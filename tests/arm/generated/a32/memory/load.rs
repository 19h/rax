//! A32 memory load tests.
//!
//! Auto-generated from ARM ASL specifications.
//! DO NOT EDIT MANUALLY.

#![allow(unused_imports)]
#![allow(dead_code)]

use crate::generated::test_helpers_32::*;

// ============================================================================
// aarch32_LDR_i_A Tests
// ============================================================================

/// Provenance: aarch32_LDR_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_ldr_i_a1_a_field_cond_0_min_0_04100000() {
    // Encoding: 0x04100000
    // Test aarch32_LDR_i_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: Rt=0, cond=0, imm12=0, W=0, P=0, Rn=0, U=0
    let encoding: u32 = 0x04100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_ldr_i_a1_a_field_cond_1_poweroftwo_0_14100000() {
    // Encoding: 0x14100000
    // Test aarch32_LDR_i_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, Rn=0, P=0, imm12=0, cond=1, U=0, W=0
    let encoding: u32 = 0x14100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_ldr_i_a1_a_field_cond_2_poweroftwo_0_24100000() {
    // Encoding: 0x24100000
    // Test aarch32_LDR_i_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, imm12=0, cond=2, U=0, W=0, Rn=0, Rt=0
    let encoding: u32 = 0x24100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_ldr_i_a1_a_field_cond_3_poweroftwo_0_34100000() {
    // Encoding: 0x34100000
    // Test aarch32_LDR_i_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, P=0, cond=3, Rn=0, Rt=0, W=0, imm12=0
    let encoding: u32 = 0x34100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_ldr_i_a1_a_field_cond_4_poweroftwo_0_44100000() {
    // Encoding: 0x44100000
    // Test aarch32_LDR_i_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, cond=4, Rn=0, W=0, Rt=0, imm12=0, P=0
    let encoding: u32 = 0x44100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_ldr_i_a1_a_field_cond_5_poweroftwo_0_54100000() {
    // Encoding: 0x54100000
    // Test aarch32_LDR_i_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, W=0, cond=5, Rt=0, U=0, imm12=0, Rn=0
    let encoding: u32 = 0x54100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_ldr_i_a1_a_field_cond_6_poweroftwo_0_64100000() {
    // Encoding: 0x64100000
    // Test aarch32_LDR_i_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, Rn=0, P=0, imm12=0, cond=6, U=0, W=0
    let encoding: u32 = 0x64100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_ldr_i_a1_a_field_cond_7_poweroftwo_0_74100000() {
    // Encoding: 0x74100000
    // Test aarch32_LDR_i_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, Rt=0, W=0, cond=7, P=0, Rn=0, imm12=0
    let encoding: u32 = 0x74100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_ldr_i_a1_a_field_cond_8_poweroftwo_0_84100000() {
    // Encoding: 0x84100000
    // Test aarch32_LDR_i_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, P=0, Rn=0, W=0, imm12=0, cond=8, U=0
    let encoding: u32 = 0x84100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_ldr_i_a1_a_field_cond_9_poweroftwo_0_94100000() {
    // Encoding: 0x94100000
    // Test aarch32_LDR_i_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, U=0, W=0, P=0, cond=9, Rt=0, imm12=0
    let encoding: u32 = 0x94100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_ldr_i_a1_a_field_cond_10_poweroftwo_0_a4100000() {
    // Encoding: 0xA4100000
    // Test aarch32_LDR_i_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=0, cond=10, Rn=0, Rt=0, U=0, W=0, P=0
    let encoding: u32 = 0xA4100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_ldr_i_a1_a_field_cond_11_poweroftwo_0_b4100000() {
    // Encoding: 0xB4100000
    // Test aarch32_LDR_i_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, Rn=0, P=0, cond=11, W=0, Rt=0, imm12=0
    let encoding: u32 = 0xB4100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_ldr_i_a1_a_field_cond_12_poweroftwo_0_c4100000() {
    // Encoding: 0xC4100000
    // Test aarch32_LDR_i_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, imm12=0, U=0, W=0, cond=12, P=0, Rn=0
    let encoding: u32 = 0xC4100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_ldr_i_a1_a_field_cond_13_poweroftwo_0_d4100000() {
    // Encoding: 0xD4100000
    // Test aarch32_LDR_i_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=0, U=0, P=0, W=0, Rn=0, Rt=0, cond=13
    let encoding: u32 = 0xD4100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_ldr_i_a1_a_field_cond_14_poweroftwo_0_e4100000() {
    // Encoding: 0xE4100000
    // Test aarch32_LDR_i_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, U=0, Rt=0, Rn=0, cond=14, imm12=0, P=0
    let encoding: u32 = 0xE4100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_ldr_i_a1_a_field_cond_15_max_0_f4100000() {
    // Encoding: 0xF4100000
    // Test aarch32_LDR_i_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: imm12=0, U=0, P=0, cond=15, W=0, Rt=0, Rn=0
    let encoding: u32 = 0xF4100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_i_A1_A
/// ASL: `field P 24 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldr_i_a1_a_field_p_0_min_0_04100000() {
    // Encoding: 0x04100000
    // Test aarch32_LDR_i_A1_A field P = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, P=0, U=0, Rt=0, W=0, imm12=0, cond=0
    let encoding: u32 = 0x04100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_i_A1_A
/// ASL: `field P 24 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldr_i_a1_a_field_p_1_max_0_05100000() {
    // Encoding: 0x05100000
    // Test aarch32_LDR_i_A1_A field P = 1 (Max)
    // ISET: A32
    // Fields: cond=0, W=0, Rn=0, P=1, U=0, Rt=0, imm12=0
    let encoding: u32 = 0x05100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_i_A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldr_i_a1_a_field_u_0_min_0_04100000() {
    // Encoding: 0x04100000
    // Test aarch32_LDR_i_A1_A field U = 0 (Min)
    // ISET: A32
    // Fields: W=0, cond=0, Rt=0, imm12=0, P=0, U=0, Rn=0
    let encoding: u32 = 0x04100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_i_A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldr_i_a1_a_field_u_1_max_0_04900000() {
    // Encoding: 0x04900000
    // Test aarch32_LDR_i_A1_A field U = 1 (Max)
    // ISET: A32
    // Fields: U=1, imm12=0, cond=0, W=0, Rn=0, P=0, Rt=0
    let encoding: u32 = 0x04900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_i_A1_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldr_i_a1_a_field_w_0_min_0_04100000() {
    // Encoding: 0x04100000
    // Test aarch32_LDR_i_A1_A field W = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=0, U=0, imm12=0, P=0, W=0
    let encoding: u32 = 0x04100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_i_A1_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldr_i_a1_a_field_w_1_max_0_04300000() {
    // Encoding: 0x04300000
    // Test aarch32_LDR_i_A1_A field W = 1 (Max)
    // ISET: A32
    // Fields: imm12=0, U=0, Rn=0, cond=0, W=1, Rt=0, P=0
    let encoding: u32 = 0x04300000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_i_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldr_i_a1_a_field_rn_0_min_0_04100000() {
    // Encoding: 0x04100000
    // Test aarch32_LDR_i_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: Rt=0, imm12=0, Rn=0, P=0, U=0, W=0, cond=0
    let encoding: u32 = 0x04100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_i_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldr_i_a1_a_field_rn_1_poweroftwo_0_04110000() {
    // Encoding: 0x04110000
    // Test aarch32_LDR_i_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, Rt=0, U=0, W=0, cond=0, Rn=1, imm12=0
    let encoding: u32 = 0x04110000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_i_A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldr_i_a1_a_field_rt_0_min_0_04100000() {
    // Encoding: 0x04100000
    // Test aarch32_LDR_i_A1_A field Rt = 0 (Min)
    // ISET: A32
    // Fields: cond=0, U=0, P=0, Rn=0, Rt=0, imm12=0, W=0
    let encoding: u32 = 0x04100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_i_A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldr_i_a1_a_field_rt_1_poweroftwo_0_04101000() {
    // Encoding: 0x04101000
    // Test aarch32_LDR_i_A1_A field Rt = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, cond=0, Rn=0, U=0, imm12=0, Rt=1, P=0
    let encoding: u32 = 0x04101000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_ldr_i_a1_a_field_imm12_0_zero_0_04100000() {
    // Encoding: 0x04100000
    // Test aarch32_LDR_i_A1_A field imm12 = 0 (Zero)
    // ISET: A32
    // Fields: Rt=0, imm12=0, P=0, U=0, W=0, cond=0, Rn=0
    let encoding: u32 = 0x04100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_ldr_i_a1_a_field_imm12_1_poweroftwo_0_04100001() {
    // Encoding: 0x04100001
    // Test aarch32_LDR_i_A1_A field imm12 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Rn=0, U=0, Rt=0, P=0, imm12=1, W=0
    let encoding: u32 = 0x04100001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_ldr_i_a1_a_field_imm12_3_poweroftwominusone_0_04100003() {
    // Encoding: 0x04100003
    // Test aarch32_LDR_i_A1_A field imm12 = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, Rt=0, W=0, imm12=3, Rn=0, P=0, U=0
    let encoding: u32 = 0x04100003;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_ldr_i_a1_a_field_imm12_4_poweroftwo_0_04100004() {
    // Encoding: 0x04100004
    // Test aarch32_LDR_i_A1_A field imm12 = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, P=0, U=0, W=0, Rt=0, imm12=4, cond=0
    let encoding: u32 = 0x04100004;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_ldr_i_a1_a_field_imm12_7_poweroftwominusone_0_04100007() {
    // Encoding: 0x04100007
    // Test aarch32_LDR_i_A1_A field imm12 = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, Rt=0, U=0, imm12=7, P=0, Rn=0, W=0
    let encoding: u32 = 0x04100007;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_ldr_i_a1_a_field_imm12_8_poweroftwo_0_04100008() {
    // Encoding: 0x04100008
    // Test aarch32_LDR_i_A1_A field imm12 = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, U=0, W=0, Rn=0, cond=0, Rt=0, imm12=8
    let encoding: u32 = 0x04100008;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_ldr_i_a1_a_field_imm12_15_poweroftwominusone_0_0410000f() {
    // Encoding: 0x0410000F
    // Test aarch32_LDR_i_A1_A field imm12 = 15 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: P=0, U=0, cond=0, W=0, Rt=0, imm12=15, Rn=0
    let encoding: u32 = 0x0410000F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_ldr_i_a1_a_field_imm12_16_poweroftwo_0_04100010() {
    // Encoding: 0x04100010
    // Test aarch32_LDR_i_A1_A field imm12 = 16 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, cond=0, W=0, U=0, Rt=0, Rn=0, imm12=16
    let encoding: u32 = 0x04100010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_ldr_i_a1_a_field_imm12_31_poweroftwominusone_0_0410001f() {
    // Encoding: 0x0410001F
    // Test aarch32_LDR_i_A1_A field imm12 = 31 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rn=0, cond=0, imm12=31, W=0, U=0, Rt=0, P=0
    let encoding: u32 = 0x0410001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_ldr_i_a1_a_field_imm12_32_poweroftwo_0_04100020() {
    // Encoding: 0x04100020
    // Test aarch32_LDR_i_A1_A field imm12 = 32 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=0, P=0, imm12=32, W=0, Rt=0, U=0
    let encoding: u32 = 0x04100020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_ldr_i_a1_a_field_imm12_63_poweroftwominusone_0_0410003f() {
    // Encoding: 0x0410003F
    // Test aarch32_LDR_i_A1_A field imm12 = 63 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: P=0, imm12=63, cond=0, W=0, Rt=0, U=0, Rn=0
    let encoding: u32 = 0x0410003F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_ldr_i_a1_a_field_imm12_64_poweroftwo_0_04100040() {
    // Encoding: 0x04100040
    // Test aarch32_LDR_i_A1_A field imm12 = 64 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=0, W=0, U=0, Rt=0, P=0, imm12=64
    let encoding: u32 = 0x04100040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 127, boundary: PowerOfTwoMinusOne }
/// 2^7 - 1 = 127
#[test]
fn test_aarch32_ldr_i_a1_a_field_imm12_127_poweroftwominusone_0_0410007f() {
    // Encoding: 0x0410007F
    // Test aarch32_LDR_i_A1_A field imm12 = 127 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: P=0, Rt=0, W=0, imm12=127, cond=0, U=0, Rn=0
    let encoding: u32 = 0x0410007F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_ldr_i_a1_a_field_imm12_128_poweroftwo_0_04100080() {
    // Encoding: 0x04100080
    // Test aarch32_LDR_i_A1_A field imm12 = 128 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=128, P=0, U=0, Rn=0, W=0, cond=0, Rt=0
    let encoding: u32 = 0x04100080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 255, boundary: PowerOfTwoMinusOne }
/// 2^8 - 1 = 255
#[test]
fn test_aarch32_ldr_i_a1_a_field_imm12_255_poweroftwominusone_0_041000ff() {
    // Encoding: 0x041000FF
    // Test aarch32_LDR_i_A1_A field imm12 = 255 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: W=0, imm12=255, Rt=0, cond=0, Rn=0, P=0, U=0
    let encoding: u32 = 0x041000FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 256, boundary: PowerOfTwo }
/// power of 2 (2^8 = 256)
#[test]
fn test_aarch32_ldr_i_a1_a_field_imm12_256_poweroftwo_0_04100100() {
    // Encoding: 0x04100100
    // Test aarch32_LDR_i_A1_A field imm12 = 256 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, imm12=256, Rn=0, U=0, W=0, Rt=0, cond=0
    let encoding: u32 = 0x04100100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 511, boundary: PowerOfTwoMinusOne }
/// 2^9 - 1 = 511
#[test]
fn test_aarch32_ldr_i_a1_a_field_imm12_511_poweroftwominusone_0_041001ff() {
    // Encoding: 0x041001FF
    // Test aarch32_LDR_i_A1_A field imm12 = 511 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: U=0, imm12=511, cond=0, W=0, P=0, Rt=0, Rn=0
    let encoding: u32 = 0x041001FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 512, boundary: PowerOfTwo }
/// power of 2 (2^9 = 512)
#[test]
fn test_aarch32_ldr_i_a1_a_field_imm12_512_poweroftwo_0_04100200() {
    // Encoding: 0x04100200
    // Test aarch32_LDR_i_A1_A field imm12 = 512 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, P=0, U=0, W=0, Rn=0, Rt=0, imm12=512
    let encoding: u32 = 0x04100200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1023, boundary: PowerOfTwoMinusOne }
/// 2^10 - 1 = 1023
#[test]
fn test_aarch32_ldr_i_a1_a_field_imm12_1023_poweroftwominusone_0_041003ff() {
    // Encoding: 0x041003FF
    // Test aarch32_LDR_i_A1_A field imm12 = 1023 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: U=0, Rn=0, cond=0, Rt=0, imm12=1023, P=0, W=0
    let encoding: u32 = 0x041003FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1024, boundary: PowerOfTwo }
/// power of 2 (2^10 = 1024)
#[test]
fn test_aarch32_ldr_i_a1_a_field_imm12_1024_poweroftwo_0_04100400() {
    // Encoding: 0x04100400
    // Test aarch32_LDR_i_A1_A field imm12 = 1024 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, P=0, Rt=0, Rn=0, U=0, imm12=1024, W=0
    let encoding: u32 = 0x04100400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2047, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (2047)
#[test]
fn test_aarch32_ldr_i_a1_a_field_imm12_2047_poweroftwominusone_0_041007ff() {
    // Encoding: 0x041007FF
    // Test aarch32_LDR_i_A1_A field imm12 = 2047 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: P=0, W=0, U=0, Rn=0, imm12=2047, Rt=0, cond=0
    let encoding: u32 = 0x041007FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2048, boundary: PowerOfTwo }
/// power of 2 (2^11 = 2048)
#[test]
fn test_aarch32_ldr_i_a1_a_field_imm12_2048_poweroftwo_0_04100800() {
    // Encoding: 0x04100800
    // Test aarch32_LDR_i_A1_A field imm12 = 2048 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, P=0, W=0, Rt=0, imm12=2048, U=0, Rn=0
    let encoding: u32 = 0x04100800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4095, boundary: Max }
/// maximum immediate (4095)
#[test]
fn test_aarch32_ldr_i_a1_a_field_imm12_4095_max_0_04100fff() {
    // Encoding: 0x04100FFF
    // Test aarch32_LDR_i_A1_A field imm12 = 4095 (Max)
    // ISET: A32
    // Fields: Rt=0, imm12=4095, P=0, Rn=0, W=0, U=0, cond=0
    let encoding: u32 = 0x04100FFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_i_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_ldr_i_a1_a_combo_0_0_04100000() {
    // Encoding: 0x04100000
    // Test aarch32_LDR_i_A1_A field combination: cond=0, P=0, U=0, W=0, Rn=0, Rt=0, imm12=0
    // ISET: A32
    // Fields: W=0, cond=0, Rt=0, U=0, Rn=0, imm12=0, P=0
    let encoding: u32 = 0x04100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_i_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_ldr_i_a1_a_special_cond_0_condition_eq_0_04100000() {
    // Encoding: 0x04100000
    // Test aarch32_LDR_i_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: P=0, U=0, Rt=0, imm12=0, W=0, cond=0, Rn=0
    let encoding: u32 = 0x04100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_i_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_ldr_i_a1_a_special_cond_1_condition_ne_0_14100000() {
    // Encoding: 0x14100000
    // Test aarch32_LDR_i_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: U=0, cond=1, Rn=0, imm12=0, W=0, P=0, Rt=0
    let encoding: u32 = 0x14100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_i_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_ldr_i_a1_a_special_cond_2_condition_cs_hs_0_24100000() {
    // Encoding: 0x24100000
    // Test aarch32_LDR_i_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: U=0, cond=2, P=0, W=0, Rt=0, imm12=0, Rn=0
    let encoding: u32 = 0x24100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_i_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_ldr_i_a1_a_special_cond_3_condition_cc_lo_0_34100000() {
    // Encoding: 0x34100000
    // Test aarch32_LDR_i_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: imm12=0, W=0, Rn=0, cond=3, U=0, Rt=0, P=0
    let encoding: u32 = 0x34100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_i_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_ldr_i_a1_a_special_cond_4_condition_mi_0_44100000() {
    // Encoding: 0x44100000
    // Test aarch32_LDR_i_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: U=0, Rn=0, Rt=0, W=0, cond=4, imm12=0, P=0
    let encoding: u32 = 0x44100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_i_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_ldr_i_a1_a_special_cond_5_condition_pl_0_54100000() {
    // Encoding: 0x54100000
    // Test aarch32_LDR_i_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: Rn=0, Rt=0, U=0, cond=5, imm12=0, W=0, P=0
    let encoding: u32 = 0x54100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_i_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_ldr_i_a1_a_special_cond_6_condition_vs_0_64100000() {
    // Encoding: 0x64100000
    // Test aarch32_LDR_i_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: imm12=0, U=0, W=0, Rn=0, Rt=0, P=0, cond=6
    let encoding: u32 = 0x64100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_i_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_ldr_i_a1_a_special_cond_7_condition_vc_0_74100000() {
    // Encoding: 0x74100000
    // Test aarch32_LDR_i_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: cond=7, Rn=0, P=0, U=0, Rt=0, imm12=0, W=0
    let encoding: u32 = 0x74100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_i_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_ldr_i_a1_a_special_cond_8_condition_hi_0_84100000() {
    // Encoding: 0x84100000
    // Test aarch32_LDR_i_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: cond=8, P=0, U=0, imm12=0, W=0, Rn=0, Rt=0
    let encoding: u32 = 0x84100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_i_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_ldr_i_a1_a_special_cond_9_condition_ls_0_94100000() {
    // Encoding: 0x94100000
    // Test aarch32_LDR_i_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: W=0, Rt=0, imm12=0, Rn=0, cond=9, P=0, U=0
    let encoding: u32 = 0x94100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_i_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_ldr_i_a1_a_special_cond_10_condition_ge_0_a4100000() {
    // Encoding: 0xA4100000
    // Test aarch32_LDR_i_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: imm12=0, U=0, cond=10, P=0, Rn=0, Rt=0, W=0
    let encoding: u32 = 0xA4100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_i_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_ldr_i_a1_a_special_cond_11_condition_lt_0_b4100000() {
    // Encoding: 0xB4100000
    // Test aarch32_LDR_i_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: Rt=0, imm12=0, W=0, cond=11, U=0, Rn=0, P=0
    let encoding: u32 = 0xB4100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_i_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_ldr_i_a1_a_special_cond_12_condition_gt_0_c4100000() {
    // Encoding: 0xC4100000
    // Test aarch32_LDR_i_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: cond=12, W=0, Rt=0, imm12=0, P=0, U=0, Rn=0
    let encoding: u32 = 0xC4100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_i_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_ldr_i_a1_a_special_cond_13_condition_le_0_d4100000() {
    // Encoding: 0xD4100000
    // Test aarch32_LDR_i_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: U=0, Rt=0, P=0, cond=13, W=0, Rn=0, imm12=0
    let encoding: u32 = 0xD4100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_i_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_ldr_i_a1_a_special_cond_14_condition_al_0_e4100000() {
    // Encoding: 0xE4100000
    // Test aarch32_LDR_i_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: cond=14, U=0, Rt=0, P=0, imm12=0, W=0, Rn=0
    let encoding: u32 = 0xE4100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_i_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_ldr_i_a1_a_special_cond_15_condition_nv_0_f4100000() {
    // Encoding: 0xF4100000
    // Test aarch32_LDR_i_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: cond=15, U=0, W=0, Rn=0, P=0, imm12=0, Rt=0
    let encoding: u32 = 0xF4100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_i_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"wback\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldr_i_a1_a_invalid_0_0_04100000() {
    // Encoding: 0x04100000
    // Test aarch32_LDR_i_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) }
    // ISET: A32
    // Fields: W=0, P=0, imm12=0, Rt=0, U=0, Rn=0, cond=0
    let encoding: u32 = 0x04100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDR_i_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldr_i_a1_a_invalid_1_0_04100000() {
    // Encoding: 0x04100000
    // Test aarch32_LDR_i_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: U=0, Rt=0, W=0, P=0, cond=0, Rn=0, imm12=0
    let encoding: u32 = 0x04100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDR_i_T1_A
/// ASL: `field imm5 22 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_ldr_i_t1_a_field_imm5_0_zero_0_68000000() {
    // Thumb encoding (32): 0x68000000
    // Test aarch32_LDR_i_T1_A field imm5 = 0 (Zero)
    // ISET: T32
    // Fields: Rn=0, imm5=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x68000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_i_T1_A
/// ASL: `field imm5 22 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_ldr_i_t1_a_field_imm5_1_poweroftwo_0_68400000() {
    // Thumb encoding (32): 0x68400000
    // Test aarch32_LDR_i_T1_A field imm5 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm5=1, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x68400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_i_T1_A
/// ASL: `field imm5 22 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_ldr_i_t1_a_field_imm5_3_poweroftwominusone_0_68c00000() {
    // Thumb encoding (32): 0x68C00000
    // Test aarch32_LDR_i_T1_A field imm5 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm5=3
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x68C00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_i_T1_A
/// ASL: `field imm5 22 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_ldr_i_t1_a_field_imm5_4_poweroftwo_0_69000000() {
    // Thumb encoding (32): 0x69000000
    // Test aarch32_LDR_i_T1_A field imm5 = 4 (PowerOfTwo)
    // ISET: T32
    // Fields: imm5=4, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x69000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_i_T1_A
/// ASL: `field imm5 22 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_ldr_i_t1_a_field_imm5_7_poweroftwominusone_0_69c00000() {
    // Thumb encoding (32): 0x69C00000
    // Test aarch32_LDR_i_T1_A field imm5 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm5=7, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x69C00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_i_T1_A
/// ASL: `field imm5 22 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_ldr_i_t1_a_field_imm5_8_poweroftwo_0_6a000000() {
    // Thumb encoding (32): 0x6A000000
    // Test aarch32_LDR_i_T1_A field imm5 = 8 (PowerOfTwo)
    // ISET: T32
    // Fields: imm5=8, Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x6A000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_i_T1_A
/// ASL: `field imm5 22 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 15, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (15)
#[test]
fn test_aarch32_ldr_i_t1_a_field_imm5_15_poweroftwominusone_0_6bc00000() {
    // Thumb encoding (32): 0x6BC00000
    // Test aarch32_LDR_i_T1_A field imm5 = 15 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, imm5=15, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x6BC00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_i_T1_A
/// ASL: `field imm5 22 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_ldr_i_t1_a_field_imm5_16_poweroftwo_0_6c000000() {
    // Thumb encoding (32): 0x6C000000
    // Test aarch32_LDR_i_T1_A field imm5 = 16 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, imm5=16, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x6C000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_i_T1_A
/// ASL: `field imm5 22 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 31, boundary: Max }
/// maximum immediate (31)
#[test]
fn test_aarch32_ldr_i_t1_a_field_imm5_31_max_0_6fc00000() {
    // Thumb encoding (32): 0x6FC00000
    // Test aarch32_LDR_i_T1_A field imm5 = 31 (Max)
    // ISET: T32
    // Fields: Rt=0, imm5=31, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x6FC00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_i_T1_A
/// ASL: `field Rn 19 +: 3`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldr_i_t1_a_field_rn_0_min_0_68000000() {
    // Thumb encoding (32): 0x68000000
    // Test aarch32_LDR_i_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rt=0, imm5=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x68000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_i_T1_A
/// ASL: `field Rn 19 +: 3`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldr_i_t1_a_field_rn_1_poweroftwo_0_68080000() {
    // Thumb encoding (32): 0x68080000
    // Test aarch32_LDR_i_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=1, Rt=0, imm5=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x68080000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_i_T1_A
/// ASL: `field Rt 16 +: 3`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldr_i_t1_a_field_rt_0_min_0_68000000() {
    // Thumb encoding (32): 0x68000000
    // Test aarch32_LDR_i_T1_A field Rt = 0 (Min)
    // ISET: T32
    // Fields: imm5=0, Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x68000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_i_T1_A
/// ASL: `field Rt 16 +: 3`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldr_i_t1_a_field_rt_1_poweroftwo_0_68010000() {
    // Thumb encoding (32): 0x68010000
    // Test aarch32_LDR_i_T1_A field Rt = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=1, Rn=0, imm5=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x68010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_i_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=0 (immediate value 0)
#[test]
fn test_aarch32_ldr_i_t1_a_combo_0_0_68000000() {
    // Thumb encoding (32): 0x68000000
    // Test aarch32_LDR_i_T1_A field combination: imm5=0, Rn=0, Rt=0
    // ISET: T32
    // Fields: imm5=0, Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x68000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_i_T2_A
/// ASL: `field Rt 24 +: 3`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldr_i_t2_a_field_rt_0_min_0_98000000() {
    // Thumb encoding (32): 0x98000000
    // Test aarch32_LDR_i_T2_A field Rt = 0 (Min)
    // ISET: T32
    // Fields: imm8=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x98000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_i_T2_A
/// ASL: `field Rt 24 +: 3`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldr_i_t2_a_field_rt_1_poweroftwo_0_99000000() {
    // Thumb encoding (32): 0x99000000
    // Test aarch32_LDR_i_T2_A field Rt = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=1, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x99000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_i_T2_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_ldr_i_t2_a_field_imm8_0_zero_0_98000000() {
    // Thumb encoding (32): 0x98000000
    // Test aarch32_LDR_i_T2_A field imm8 = 0 (Zero)
    // ISET: T32
    // Fields: Rt=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x98000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_i_T2_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_ldr_i_t2_a_field_imm8_1_poweroftwo_0_98010000() {
    // Thumb encoding (32): 0x98010000
    // Test aarch32_LDR_i_T2_A field imm8 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, imm8=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x98010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_i_T2_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_ldr_i_t2_a_field_imm8_3_poweroftwominusone_0_98030000() {
    // Thumb encoding (32): 0x98030000
    // Test aarch32_LDR_i_T2_A field imm8 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, imm8=3
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x98030000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_i_T2_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_ldr_i_t2_a_field_imm8_4_poweroftwo_0_98040000() {
    // Thumb encoding (32): 0x98040000
    // Test aarch32_LDR_i_T2_A field imm8 = 4 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=4, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x98040000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_i_T2_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_ldr_i_t2_a_field_imm8_7_poweroftwominusone_0_98070000() {
    // Thumb encoding (32): 0x98070000
    // Test aarch32_LDR_i_T2_A field imm8 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, imm8=7
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x98070000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_i_T2_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_ldr_i_t2_a_field_imm8_8_poweroftwo_0_98080000() {
    // Thumb encoding (32): 0x98080000
    // Test aarch32_LDR_i_T2_A field imm8 = 8 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, imm8=8
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x98080000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_i_T2_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_ldr_i_t2_a_field_imm8_15_poweroftwominusone_0_980f0000() {
    // Thumb encoding (32): 0x980F0000
    // Test aarch32_LDR_i_T2_A field imm8 = 15 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, imm8=15
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x980F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_i_T2_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_ldr_i_t2_a_field_imm8_16_poweroftwo_0_98100000() {
    // Thumb encoding (32): 0x98100000
    // Test aarch32_LDR_i_T2_A field imm8 = 16 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=16, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x98100000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_i_T2_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_ldr_i_t2_a_field_imm8_31_poweroftwominusone_0_981f0000() {
    // Thumb encoding (32): 0x981F0000
    // Test aarch32_LDR_i_T2_A field imm8 = 31 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, imm8=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x981F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_i_T2_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_ldr_i_t2_a_field_imm8_32_poweroftwo_0_98200000() {
    // Thumb encoding (32): 0x98200000
    // Test aarch32_LDR_i_T2_A field imm8 = 32 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, imm8=32
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x98200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_i_T2_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_ldr_i_t2_a_field_imm8_63_poweroftwominusone_0_983f0000() {
    // Thumb encoding (32): 0x983F0000
    // Test aarch32_LDR_i_T2_A field imm8 = 63 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, imm8=63
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x983F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_i_T2_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_ldr_i_t2_a_field_imm8_64_poweroftwo_0_98400000() {
    // Thumb encoding (32): 0x98400000
    // Test aarch32_LDR_i_T2_A field imm8 = 64 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=64, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x98400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_i_T2_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 127, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (127)
#[test]
fn test_aarch32_ldr_i_t2_a_field_imm8_127_poweroftwominusone_0_987f0000() {
    // Thumb encoding (32): 0x987F0000
    // Test aarch32_LDR_i_T2_A field imm8 = 127 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, imm8=127
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x987F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_i_T2_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_ldr_i_t2_a_field_imm8_128_poweroftwo_0_98800000() {
    // Thumb encoding (32): 0x98800000
    // Test aarch32_LDR_i_T2_A field imm8 = 128 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, imm8=128
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x98800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_i_T2_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 255, boundary: Max }
/// maximum immediate (255)
#[test]
fn test_aarch32_ldr_i_t2_a_field_imm8_255_max_0_98ff0000() {
    // Thumb encoding (32): 0x98FF0000
    // Test aarch32_LDR_i_T2_A field imm8 = 255 (Max)
    // ISET: T32
    // Fields: Rt=0, imm8=255
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x98FF0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_i_T2_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=0 (register index 0 (first register))
#[test]
fn test_aarch32_ldr_i_t2_a_combo_0_0_98000000() {
    // Thumb encoding (32): 0x98000000
    // Test aarch32_LDR_i_T2_A field combination: Rt=0, imm8=0
    // ISET: T32
    // Fields: imm8=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x98000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_i_T3_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldr_i_t3_a_field_rn_0_min_0_f8d00000() {
    // Thumb encoding (32): 0xF8D00000
    // Test aarch32_LDR_i_T3_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm12=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8D00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_i_T3_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldr_i_t3_a_field_rn_1_poweroftwo_0_f8d10000() {
    // Thumb encoding (32): 0xF8D10000
    // Test aarch32_LDR_i_T3_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=1, Rt=0, imm12=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8D10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_i_T3_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldr_i_t3_a_field_rt_0_min_0_f8d00000() {
    // Thumb encoding (32): 0xF8D00000
    // Test aarch32_LDR_i_T3_A field Rt = 0 (Min)
    // ISET: T32
    // Fields: Rt=0, Rn=0, imm12=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8D00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_i_T3_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldr_i_t3_a_field_rt_1_poweroftwo_0_f8d01000() {
    // Thumb encoding (32): 0xF8D01000
    // Test aarch32_LDR_i_T3_A field Rt = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Rt=1, imm12=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8D01000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_i_T3_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_ldr_i_t3_a_field_imm12_0_zero_0_f8d00000() {
    // Thumb encoding (32): 0xF8D00000
    // Test aarch32_LDR_i_T3_A field imm12 = 0 (Zero)
    // ISET: T32
    // Fields: Rt=0, imm12=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8D00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_i_T3_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_ldr_i_t3_a_field_imm12_1_poweroftwo_0_f8d00001() {
    // Thumb encoding (32): 0xF8D00001
    // Test aarch32_LDR_i_T3_A field imm12 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm12=1, Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8D00001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_i_T3_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_ldr_i_t3_a_field_imm12_3_poweroftwominusone_0_f8d00003() {
    // Thumb encoding (32): 0xF8D00003
    // Test aarch32_LDR_i_T3_A field imm12 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, imm12=3, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8D00003;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_i_T3_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_ldr_i_t3_a_field_imm12_4_poweroftwo_0_f8d00004() {
    // Thumb encoding (32): 0xF8D00004
    // Test aarch32_LDR_i_T3_A field imm12 = 4 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm12=4
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8D00004;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_i_T3_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_ldr_i_t3_a_field_imm12_7_poweroftwominusone_0_f8d00007() {
    // Thumb encoding (32): 0xF8D00007
    // Test aarch32_LDR_i_T3_A field imm12 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, imm12=7, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8D00007;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_i_T3_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_ldr_i_t3_a_field_imm12_8_poweroftwo_0_f8d00008() {
    // Thumb encoding (32): 0xF8D00008
    // Test aarch32_LDR_i_T3_A field imm12 = 8 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, imm12=8, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8D00008;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_i_T3_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_ldr_i_t3_a_field_imm12_15_poweroftwominusone_0_f8d0000f() {
    // Thumb encoding (32): 0xF8D0000F
    // Test aarch32_LDR_i_T3_A field imm12 = 15 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, imm12=15, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8D0000F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_i_T3_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_ldr_i_t3_a_field_imm12_16_poweroftwo_0_f8d00010() {
    // Thumb encoding (32): 0xF8D00010
    // Test aarch32_LDR_i_T3_A field imm12 = 16 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm12=16
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8D00010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_i_T3_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_ldr_i_t3_a_field_imm12_31_poweroftwominusone_0_f8d0001f() {
    // Thumb encoding (32): 0xF8D0001F
    // Test aarch32_LDR_i_T3_A field imm12 = 31 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm12=31, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8D0001F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_i_T3_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_ldr_i_t3_a_field_imm12_32_poweroftwo_0_f8d00020() {
    // Thumb encoding (32): 0xF8D00020
    // Test aarch32_LDR_i_T3_A field imm12 = 32 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm12=32
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8D00020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_i_T3_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_ldr_i_t3_a_field_imm12_63_poweroftwominusone_0_f8d0003f() {
    // Thumb encoding (32): 0xF8D0003F
    // Test aarch32_LDR_i_T3_A field imm12 = 63 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, Rn=0, imm12=63
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8D0003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_i_T3_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_ldr_i_t3_a_field_imm12_64_poweroftwo_0_f8d00040() {
    // Thumb encoding (32): 0xF8D00040
    // Test aarch32_LDR_i_T3_A field imm12 = 64 (PowerOfTwo)
    // ISET: T32
    // Fields: imm12=64, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8D00040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_i_T3_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 127, boundary: PowerOfTwoMinusOne }
/// 2^7 - 1 = 127
#[test]
fn test_aarch32_ldr_i_t3_a_field_imm12_127_poweroftwominusone_0_f8d0007f() {
    // Thumb encoding (32): 0xF8D0007F
    // Test aarch32_LDR_i_T3_A field imm12 = 127 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, imm12=127, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8D0007F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_i_T3_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_ldr_i_t3_a_field_imm12_128_poweroftwo_0_f8d00080() {
    // Thumb encoding (32): 0xF8D00080
    // Test aarch32_LDR_i_T3_A field imm12 = 128 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm12=128
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8D00080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_i_T3_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 255, boundary: PowerOfTwoMinusOne }
/// 2^8 - 1 = 255
#[test]
fn test_aarch32_ldr_i_t3_a_field_imm12_255_poweroftwominusone_0_f8d000ff() {
    // Thumb encoding (32): 0xF8D000FF
    // Test aarch32_LDR_i_T3_A field imm12 = 255 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, imm12=255, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8D000FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_i_T3_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 256, boundary: PowerOfTwo }
/// power of 2 (2^8 = 256)
#[test]
fn test_aarch32_ldr_i_t3_a_field_imm12_256_poweroftwo_0_f8d00100() {
    // Thumb encoding (32): 0xF8D00100
    // Test aarch32_LDR_i_T3_A field imm12 = 256 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm12=256
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8D00100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_i_T3_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 511, boundary: PowerOfTwoMinusOne }
/// 2^9 - 1 = 511
#[test]
fn test_aarch32_ldr_i_t3_a_field_imm12_511_poweroftwominusone_0_f8d001ff() {
    // Thumb encoding (32): 0xF8D001FF
    // Test aarch32_LDR_i_T3_A field imm12 = 511 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm12=511
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8D001FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_i_T3_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 512, boundary: PowerOfTwo }
/// power of 2 (2^9 = 512)
#[test]
fn test_aarch32_ldr_i_t3_a_field_imm12_512_poweroftwo_0_f8d00200() {
    // Thumb encoding (32): 0xF8D00200
    // Test aarch32_LDR_i_T3_A field imm12 = 512 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, Rn=0, imm12=512
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8D00200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_i_T3_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1023, boundary: PowerOfTwoMinusOne }
/// 2^10 - 1 = 1023
#[test]
fn test_aarch32_ldr_i_t3_a_field_imm12_1023_poweroftwominusone_0_f8d003ff() {
    // Thumb encoding (32): 0xF8D003FF
    // Test aarch32_LDR_i_T3_A field imm12 = 1023 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, imm12=1023, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8D003FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_i_T3_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1024, boundary: PowerOfTwo }
/// power of 2 (2^10 = 1024)
#[test]
fn test_aarch32_ldr_i_t3_a_field_imm12_1024_poweroftwo_0_f8d00400() {
    // Thumb encoding (32): 0xF8D00400
    // Test aarch32_LDR_i_T3_A field imm12 = 1024 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, imm12=1024, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8D00400;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_i_T3_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2047, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (2047)
#[test]
fn test_aarch32_ldr_i_t3_a_field_imm12_2047_poweroftwominusone_0_f8d007ff() {
    // Thumb encoding (32): 0xF8D007FF
    // Test aarch32_LDR_i_T3_A field imm12 = 2047 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, Rn=0, imm12=2047
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8D007FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_i_T3_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2048, boundary: PowerOfTwo }
/// power of 2 (2^11 = 2048)
#[test]
fn test_aarch32_ldr_i_t3_a_field_imm12_2048_poweroftwo_0_f8d00800() {
    // Thumb encoding (32): 0xF8D00800
    // Test aarch32_LDR_i_T3_A field imm12 = 2048 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, Rn=0, imm12=2048
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8D00800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_i_T3_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4095, boundary: Max }
/// maximum immediate (4095)
#[test]
fn test_aarch32_ldr_i_t3_a_field_imm12_4095_max_0_f8d00fff() {
    // Thumb encoding (32): 0xF8D00FFF
    // Test aarch32_LDR_i_T3_A field imm12 = 4095 (Max)
    // ISET: T32
    // Fields: Rt=0, Rn=0, imm12=4095
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8D00FFF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_i_T3_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_ldr_i_t3_a_combo_0_0_f8d00000() {
    // Thumb encoding (32): 0xF8D00000
    // Test aarch32_LDR_i_T3_A field combination: Rn=0, Rt=0, imm12=0
    // ISET: T32
    // Fields: imm12=0, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8D00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_i_T3_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: And, lhs: Binary { op: And, lhs: LitInt(15), rhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] } }, rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "LastInITBlock" }, args: [] } } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: Binary { op: And, lhs: Binary { op: And, lhs: LitInt(15), rhs: Call { name: QualifiedIdentifier { qualifier: Any, name: \"InITBlock\" }, args: [] } }, rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"LastInITBlock\" }, args: [] } } } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldr_i_t3_a_invalid_0_0_f8d00000() {
    // Thumb encoding (32): 0xF8D00000
    // Test aarch32_LDR_i_T3_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: And, lhs: Binary { op: And, lhs: LitInt(15), rhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] } }, rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "LastInITBlock" }, args: [] } } } }
    // ISET: T32
    // Fields: Rn=0, imm12=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8D00000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_LDR_i_T3_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldr_i_t3_a_invalid_1_0_f8d00000() {
    // Thumb encoding (32): 0xF8D00000
    // Test aarch32_LDR_i_T3_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rt=0, imm12=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8D00000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_LDR_i_T4_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldr_i_t4_a_field_rn_0_min_800_f8500800() {
    // Thumb encoding (32): 0xF8500800
    // Test aarch32_LDR_i_T4_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: imm8=0, U=0, Rt=0, W=0, Rn=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8500800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_i_T4_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldr_i_t4_a_field_rn_1_poweroftwo_800_f8510800() {
    // Thumb encoding (32): 0xF8510800
    // Test aarch32_LDR_i_T4_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: W=0, Rn=1, U=0, imm8=0, P=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8510800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_i_T4_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldr_i_t4_a_field_rt_0_min_800_f8500800() {
    // Thumb encoding (32): 0xF8500800
    // Test aarch32_LDR_i_T4_A field Rt = 0 (Min)
    // ISET: T32
    // Fields: imm8=0, W=0, P=0, Rn=0, Rt=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8500800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_i_T4_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldr_i_t4_a_field_rt_1_poweroftwo_800_f8501800() {
    // Thumb encoding (32): 0xF8501800
    // Test aarch32_LDR_i_T4_A field Rt = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, U=0, P=0, Rt=1, imm8=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8501800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_i_T4_A
/// ASL: `field P 10 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldr_i_t4_a_field_p_0_min_800_f8500800() {
    // Thumb encoding (32): 0xF8500800
    // Test aarch32_LDR_i_T4_A field P = 0 (Min)
    // ISET: T32
    // Fields: W=0, Rt=0, imm8=0, P=0, Rn=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8500800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_i_T4_A
/// ASL: `field P 10 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldr_i_t4_a_field_p_1_max_800_f8500c00() {
    // Thumb encoding (32): 0xF8500C00
    // Test aarch32_LDR_i_T4_A field P = 1 (Max)
    // ISET: T32
    // Fields: U=0, P=1, Rn=0, Rt=0, W=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8500C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_i_T4_A
/// ASL: `field U 9 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldr_i_t4_a_field_u_0_min_800_f8500800() {
    // Thumb encoding (32): 0xF8500800
    // Test aarch32_LDR_i_T4_A field U = 0 (Min)
    // ISET: T32
    // Fields: U=0, imm8=0, Rt=0, W=0, P=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8500800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_i_T4_A
/// ASL: `field U 9 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldr_i_t4_a_field_u_1_max_800_f8500a00() {
    // Thumb encoding (32): 0xF8500A00
    // Test aarch32_LDR_i_T4_A field U = 1 (Max)
    // ISET: T32
    // Fields: Rn=0, W=0, U=1, Rt=0, imm8=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8500A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_i_T4_A
/// ASL: `field W 8 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldr_i_t4_a_field_w_0_min_800_f8500800() {
    // Thumb encoding (32): 0xF8500800
    // Test aarch32_LDR_i_T4_A field W = 0 (Min)
    // ISET: T32
    // Fields: Rt=0, U=0, Rn=0, P=0, W=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8500800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_i_T4_A
/// ASL: `field W 8 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldr_i_t4_a_field_w_1_max_800_f8500900() {
    // Thumb encoding (32): 0xF8500900
    // Test aarch32_LDR_i_T4_A field W = 1 (Max)
    // ISET: T32
    // Fields: P=0, Rt=0, W=1, Rn=0, U=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8500900;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_i_T4_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_ldr_i_t4_a_field_imm8_0_zero_800_f8500800() {
    // Thumb encoding (32): 0xF8500800
    // Test aarch32_LDR_i_T4_A field imm8 = 0 (Zero)
    // ISET: T32
    // Fields: Rt=0, W=0, U=0, Rn=0, imm8=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8500800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_i_T4_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_ldr_i_t4_a_field_imm8_1_poweroftwo_800_f8500801() {
    // Thumb encoding (32): 0xF8500801
    // Test aarch32_LDR_i_T4_A field imm8 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, W=0, Rn=0, U=0, imm8=1, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8500801;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_i_T4_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_ldr_i_t4_a_field_imm8_3_poweroftwominusone_800_f8500803() {
    // Thumb encoding (32): 0xF8500803
    // Test aarch32_LDR_i_T4_A field imm8 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: W=0, imm8=3, P=0, Rt=0, Rn=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8500803;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_i_T4_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_ldr_i_t4_a_field_imm8_4_poweroftwo_800_f8500804() {
    // Thumb encoding (32): 0xF8500804
    // Test aarch32_LDR_i_T4_A field imm8 = 4 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=4, Rt=0, U=0, W=0, Rn=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8500804;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_i_T4_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_ldr_i_t4_a_field_imm8_7_poweroftwominusone_800_f8500807() {
    // Thumb encoding (32): 0xF8500807
    // Test aarch32_LDR_i_T4_A field imm8 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: U=0, P=0, Rn=0, imm8=7, Rt=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8500807;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_i_T4_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_ldr_i_t4_a_field_imm8_8_poweroftwo_800_f8500808() {
    // Thumb encoding (32): 0xF8500808
    // Test aarch32_LDR_i_T4_A field imm8 = 8 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=8, W=0, U=0, Rt=0, Rn=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8500808;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_i_T4_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_ldr_i_t4_a_field_imm8_15_poweroftwominusone_800_f850080f() {
    // Thumb encoding (32): 0xF850080F
    // Test aarch32_LDR_i_T4_A field imm8 = 15 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm8=15, Rn=0, U=0, P=0, Rt=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF850080F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_i_T4_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_ldr_i_t4_a_field_imm8_16_poweroftwo_800_f8500810() {
    // Thumb encoding (32): 0xF8500810
    // Test aarch32_LDR_i_T4_A field imm8 = 16 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, P=0, W=0, U=0, imm8=16, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8500810;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_i_T4_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_ldr_i_t4_a_field_imm8_31_poweroftwominusone_800_f850081f() {
    // Thumb encoding (32): 0xF850081F
    // Test aarch32_LDR_i_T4_A field imm8 = 31 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: P=0, W=0, Rt=0, imm8=31, Rn=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF850081F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_i_T4_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_ldr_i_t4_a_field_imm8_32_poweroftwo_800_f8500820() {
    // Thumb encoding (32): 0xF8500820
    // Test aarch32_LDR_i_T4_A field imm8 = 32 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=32, Rn=0, U=0, P=0, W=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8500820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_i_T4_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_ldr_i_t4_a_field_imm8_63_poweroftwominusone_800_f850083f() {
    // Thumb encoding (32): 0xF850083F
    // Test aarch32_LDR_i_T4_A field imm8 = 63 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, P=0, Rt=0, U=0, W=0, imm8=63
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF850083F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_i_T4_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_ldr_i_t4_a_field_imm8_64_poweroftwo_800_f8500840() {
    // Thumb encoding (32): 0xF8500840
    // Test aarch32_LDR_i_T4_A field imm8 = 64 (PowerOfTwo)
    // ISET: T32
    // Fields: P=0, U=0, Rn=0, W=0, Rt=0, imm8=64
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8500840;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_i_T4_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 127, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (127)
#[test]
fn test_aarch32_ldr_i_t4_a_field_imm8_127_poweroftwominusone_800_f850087f() {
    // Thumb encoding (32): 0xF850087F
    // Test aarch32_LDR_i_T4_A field imm8 = 127 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: U=0, imm8=127, W=0, Rn=0, P=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF850087F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_i_T4_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_ldr_i_t4_a_field_imm8_128_poweroftwo_800_f8500880() {
    // Thumb encoding (32): 0xF8500880
    // Test aarch32_LDR_i_T4_A field imm8 = 128 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, P=0, Rt=0, W=0, U=0, imm8=128
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8500880;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_i_T4_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 255, boundary: Max }
/// maximum immediate (255)
#[test]
fn test_aarch32_ldr_i_t4_a_field_imm8_255_max_800_f85008ff() {
    // Thumb encoding (32): 0xF85008FF
    // Test aarch32_LDR_i_T4_A field imm8 = 255 (Max)
    // ISET: T32
    // Fields: Rn=0, U=0, Rt=0, W=0, P=0, imm8=255
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF85008FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_i_T4_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_ldr_i_t4_a_combo_0_800_f8500800() {
    // Thumb encoding (32): 0xF8500800
    // Test aarch32_LDR_i_T4_A field combination: Rn=0, Rt=0, P=0, U=0, W=0, imm8=0
    // ISET: T32
    // Fields: U=0, W=0, imm8=0, Rt=0, Rn=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8500800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_i_T4_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "P" }), rhs: Binary { op: And, lhs: LitBits([false]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "W" }) } }, rhs: LitBits([false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"P\" }), rhs: Binary { op: And, lhs: LitBits([false]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"W\" }) } }, rhs: LitBits([false]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_ldr_i_t4_a_invalid_0_800_f8500800() {
    // Thumb encoding (32): 0xF8500800
    // Test aarch32_LDR_i_T4_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "P" }), rhs: Binary { op: And, lhs: LitBits([false]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "W" }) } }, rhs: LitBits([false]) }
    // ISET: T32
    // Fields: Rn=0, U=0, W=0, imm8=0, P=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8500800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_LDR_i_T4_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_ldr_i_t4_a_invalid_1_800_f8500800() {
    // Thumb encoding (32): 0xF8500800
    // Test aarch32_LDR_i_T4_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: U=0, W=0, imm8=0, Rn=0, Rt=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8500800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_LDR_i_T4_A
/// ASL: `Binary { op: Or, lhs: Binary { op: Eq, lhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) }, rhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: And, lhs: Binary { op: And, lhs: LitInt(15), rhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] } }, rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "LastInITBlock" }, args: [] } } } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Or, lhs: Binary { op: Eq, lhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"wback\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }) }, rhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: Binary { op: And, lhs: Binary { op: And, lhs: LitInt(15), rhs: Call { name: QualifiedIdentifier { qualifier: Any, name: \"InITBlock\" }, args: [] } }, rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"LastInITBlock\" }, args: [] } } } } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldr_i_t4_a_invalid_2_800_f8500800() {
    // Thumb encoding (32): 0xF8500800
    // Test aarch32_LDR_i_T4_A invalid encoding: Binary { op: Or, lhs: Binary { op: Eq, lhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) }, rhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: And, lhs: Binary { op: And, lhs: LitInt(15), rhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] } }, rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "LastInITBlock" }, args: [] } } } } }
    // ISET: T32
    // Fields: W=0, Rt=0, imm8=0, U=0, Rn=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8500800;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_LDR_i_T4_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldr_i_t4_a_invalid_3_800_f8500800() {
    // Thumb encoding (32): 0xF8500800
    // Test aarch32_LDR_i_T4_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: imm8=0, Rt=0, P=0, W=0, U=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8500800;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_LDR_i_A1_A
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldr_i_a1_a_exception_0_04100000() {
    // Test aarch32_LDR_i_A1_A exception: Unpredictable
    // Encoding: 0x04100000
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04100000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_LDR_i_A1_A
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldr_i_a1_a_exception_1_04100000() {
    // Test aarch32_LDR_i_A1_A exception: Unpredictable
    // Encoding: 0x04100000
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04100000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_LDR_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 0 (32)
#[test]
fn test_aarch32_ldr_i_t1_a_lslv_oracle_32_0_68020020() {
    // Test LSLV 32-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x12345678, "W0 should be 0x12345678");
}

/// Provenance: aarch32_LDR_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 0 (64)
#[test]
fn test_aarch32_ldr_i_t1_a_lslv_oracle_64_0_e8020020() {
    // Test LSLV 64-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x12345678,
        "X0 should be 0x0000000012345678"
    );
}

/// Provenance: aarch32_LDR_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4 (32)
#[test]
fn test_aarch32_ldr_i_t1_a_lslv_oracle_32_1_68020020() {
    // Test LSLV 32-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x4);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x23456780, "W0 should be 0x23456780");
}

/// Provenance: aarch32_LDR_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 4 (64)
#[test]
fn test_aarch32_ldr_i_t1_a_lslv_oracle_64_1_e8020020() {
    // Test LSLV 64-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x4);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x23456780,
        "X0 should be 0x0000000123456780"
    );
}

/// Provenance: aarch32_LDR_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 8 (32)
#[test]
fn test_aarch32_ldr_i_t1_a_lslv_oracle_32_2_68020020() {
    // Test LSLV 32-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x8);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x34567800, "W0 should be 0x34567800");
}

/// Provenance: aarch32_LDR_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 8 (64)
#[test]
fn test_aarch32_ldr_i_t1_a_lslv_oracle_64_2_e8020020() {
    // Test LSLV 64-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x8);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x34567800,
        "X0 should be 0x0000001234567800"
    );
}

/// Provenance: aarch32_LDR_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1 (32)
#[test]
fn test_aarch32_ldr_i_t1_a_lslv_oracle_32_3_68020020() {
    // Test LSLV 32-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_LDR_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// MSB set, shift 1 (64)
#[test]
fn test_aarch32_ldr_i_t1_a_lslv_oracle_64_3_e8020020() {
    // Test LSLV 64-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_LDR_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// LSB set, max shift (32)
#[test]
fn test_aarch32_ldr_i_t1_a_lslv_oracle_32_4_68020020() {
    // Test LSLV 32-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3F);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "W0 should be 0x80000000");
}

/// Provenance: aarch32_LDR_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// LSB set, max shift (64)
#[test]
fn test_aarch32_ldr_i_t1_a_lslv_oracle_64_4_e8020020() {
    // Test LSLV 64-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3F);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x8000000000000000");
}

/// Provenance: aarch32_LDR_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// all ones, shift 32 (32)
#[test]
fn test_aarch32_ldr_i_t1_a_lslv_oracle_32_5_68020020() {
    // Test LSLV 32-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x20);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "W0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_LDR_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// all ones, shift 32 (64)
#[test]
fn test_aarch32_ldr_i_t1_a_lslv_oracle_64_5_e8020020() {
    // Test LSLV 64-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x20);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0xFFFFFFFF00000000");
}

/// Provenance: aarch32_LDR_i_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// no shift
#[test]
fn test_aarch32_ldr_i_t1_a_t16_oracle_0_68080000() {
    // Test T16 LSLS: no shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_LDR_i_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4
#[test]
fn test_aarch32_ldr_i_t1_a_t16_oracle_1_68080000() {
    // Test T16 LSLS: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x4);
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF0, "R0 should be 0x00000FF0");
}

/// Provenance: aarch32_LDR_i_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1
#[test]
fn test_aarch32_ldr_i_t1_a_t16_oracle_2_68080000() {
    // Test T16 LSLS: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_LDR_i_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift to MSB
#[test]
fn test_aarch32_ldr_i_t1_a_t16_oracle_3_68080000() {
    // Test T16 LSLS: shift to MSB (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1F);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "R0 should be 0x80000000");
}

/// Provenance: aarch32_LDR_i_T1_A
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldr_i_t1_a_exception_0_68000000() {
    // Test aarch32_LDR_i_T1_A exception: Unpredictable
    // ISET: T16
    let mut cpu = create_test_cpu();
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_LDR_i_T1_A
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldr_i_t1_a_exception_1_68000000() {
    // Test aarch32_LDR_i_T1_A exception: Unpredictable
    // ISET: T16
    let mut cpu = create_test_cpu();
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_LDR_i_T2_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 0 (32)
#[test]
fn test_aarch32_ldr_i_t2_a_lslv_oracle_32_0_98020020() {
    // Test LSLV 32-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x12345678, "W0 should be 0x12345678");
}

/// Provenance: aarch32_LDR_i_T2_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 0 (64)
#[test]
fn test_aarch32_ldr_i_t2_a_lslv_oracle_64_0_98020020() {
    // Test LSLV 64-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x12345678,
        "X0 should be 0x0000000012345678"
    );
}

/// Provenance: aarch32_LDR_i_T2_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4 (32)
#[test]
fn test_aarch32_ldr_i_t2_a_lslv_oracle_32_1_98020020() {
    // Test LSLV 32-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x4);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x23456780, "W0 should be 0x23456780");
}

/// Provenance: aarch32_LDR_i_T2_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 4 (64)
#[test]
fn test_aarch32_ldr_i_t2_a_lslv_oracle_64_1_98020020() {
    // Test LSLV 64-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x4);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x23456780,
        "X0 should be 0x0000000123456780"
    );
}

/// Provenance: aarch32_LDR_i_T2_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 8 (32)
#[test]
fn test_aarch32_ldr_i_t2_a_lslv_oracle_32_2_98020020() {
    // Test LSLV 32-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x8);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x34567800, "W0 should be 0x34567800");
}

/// Provenance: aarch32_LDR_i_T2_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 8 (64)
#[test]
fn test_aarch32_ldr_i_t2_a_lslv_oracle_64_2_98020020() {
    // Test LSLV 64-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x8);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x34567800,
        "X0 should be 0x0000001234567800"
    );
}

/// Provenance: aarch32_LDR_i_T2_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1 (32)
#[test]
fn test_aarch32_ldr_i_t2_a_lslv_oracle_32_3_98020020() {
    // Test LSLV 32-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_LDR_i_T2_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// MSB set, shift 1 (64)
#[test]
fn test_aarch32_ldr_i_t2_a_lslv_oracle_64_3_98020020() {
    // Test LSLV 64-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_LDR_i_T2_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// LSB set, max shift (32)
#[test]
fn test_aarch32_ldr_i_t2_a_lslv_oracle_32_4_98020020() {
    // Test LSLV 32-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3F);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "W0 should be 0x80000000");
}

/// Provenance: aarch32_LDR_i_T2_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// LSB set, max shift (64)
#[test]
fn test_aarch32_ldr_i_t2_a_lslv_oracle_64_4_98020020() {
    // Test LSLV 64-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x3F);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x8000000000000000");
}

/// Provenance: aarch32_LDR_i_T2_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// all ones, shift 32 (32)
#[test]
fn test_aarch32_ldr_i_t2_a_lslv_oracle_32_5_98020020() {
    // Test LSLV 32-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x20);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "W0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_LDR_i_T2_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// all ones, shift 32 (64)
#[test]
fn test_aarch32_ldr_i_t2_a_lslv_oracle_64_5_98020020() {
    // Test LSLV 64-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x20);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0xFFFFFFFF00000000");
}

/// Provenance: aarch32_LDR_i_T2_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// no shift
#[test]
fn test_aarch32_ldr_i_t2_a_t16_oracle_0_98000000() {
    // Test T16 LSLS: no shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_LDR_i_T2_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4
#[test]
fn test_aarch32_ldr_i_t2_a_t16_oracle_1_98000000() {
    // Test T16 LSLS: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    set_w(&mut cpu, 2, 0x4);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF0, "R0 should be 0x00000FF0");
}

/// Provenance: aarch32_LDR_i_T2_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1
#[test]
fn test_aarch32_ldr_i_t2_a_t16_oracle_2_98000000() {
    // Test T16 LSLS: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_LDR_i_T2_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift to MSB
#[test]
fn test_aarch32_ldr_i_t2_a_t16_oracle_3_98000000() {
    // Test T16 LSLS: shift to MSB (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x1F);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "R0 should be 0x80000000");
}

/// Provenance: aarch32_LDR_i_T2_A
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldr_i_t2_a_exception_0_98000000() {
    // Test aarch32_LDR_i_T2_A exception: Unpredictable
    // ISET: T16
    let mut cpu = create_test_cpu();
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_LDR_i_T2_A
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldr_i_t2_a_exception_1_98000000() {
    // Test aarch32_LDR_i_T2_A exception: Unpredictable
    // ISET: T16
    let mut cpu = create_test_cpu();
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_LDR_i_T3_A
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldr_i_t3_a_exception_0_f8d00000() {
    // Test aarch32_LDR_i_T3_A exception: Unpredictable
    // ISET: T32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF8D00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_LDR_i_T3_A
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldr_i_t3_a_exception_1_f8d00000() {
    // Test aarch32_LDR_i_T3_A exception: Unpredictable
    // ISET: T32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF8D00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_LDR_i_T4_A
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldr_i_t4_a_exception_0_f8500800() {
    // Test aarch32_LDR_i_T4_A exception: Unpredictable
    // ISET: T32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF8500800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_LDR_i_T4_A
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldr_i_t4_a_exception_1_f8500800() {
    // Test aarch32_LDR_i_T4_A exception: Unpredictable
    // ISET: T32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF8500800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// aarch32_LDRSH_l_A Tests
// ============================================================================

/// Provenance: aarch32_LDRSH_l_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_ldrsh_l_a1_a_field_cond_0_min_f0_005f00f0() {
    // Encoding: 0x005F00F0
    // Test aarch32_LDRSH_l_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: U=0, Rt=0, W=0, cond=0, imm4H=0, imm4L=0, P=0
    let encoding: u32 = 0x005F00F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_l_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_ldrsh_l_a1_a_field_cond_1_poweroftwo_f0_105f00f0() {
    // Encoding: 0x105F00F0
    // Test aarch32_LDRSH_l_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4L=0, W=0, U=0, cond=1, P=0, Rt=0, imm4H=0
    let encoding: u32 = 0x105F00F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_l_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_ldrsh_l_a1_a_field_cond_2_poweroftwo_f0_205f00f0() {
    // Encoding: 0x205F00F0
    // Test aarch32_LDRSH_l_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, Rt=0, imm4H=0, imm4L=0, W=0, cond=2, U=0
    let encoding: u32 = 0x205F00F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_l_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_ldrsh_l_a1_a_field_cond_3_poweroftwo_f0_305f00f0() {
    // Encoding: 0x305F00F0
    // Test aarch32_LDRSH_l_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4L=0, imm4H=0, W=0, cond=3, P=0, U=0, Rt=0
    let encoding: u32 = 0x305F00F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_l_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_ldrsh_l_a1_a_field_cond_4_poweroftwo_f0_405f00f0() {
    // Encoding: 0x405F00F0
    // Test aarch32_LDRSH_l_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, imm4H=0, imm4L=0, P=0, cond=4, U=0, W=0
    let encoding: u32 = 0x405F00F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_l_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_ldrsh_l_a1_a_field_cond_5_poweroftwo_f0_505f00f0() {
    // Encoding: 0x505F00F0
    // Test aarch32_LDRSH_l_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, Rt=0, imm4L=0, cond=5, P=0, U=0, imm4H=0
    let encoding: u32 = 0x505F00F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_l_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_ldrsh_l_a1_a_field_cond_6_poweroftwo_f0_605f00f0() {
    // Encoding: 0x605F00F0
    // Test aarch32_LDRSH_l_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4L=0, U=0, cond=6, W=0, imm4H=0, P=0, Rt=0
    let encoding: u32 = 0x605F00F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_l_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_ldrsh_l_a1_a_field_cond_7_poweroftwo_f0_705f00f0() {
    // Encoding: 0x705F00F0
    // Test aarch32_LDRSH_l_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, P=0, cond=7, Rt=0, imm4H=0, imm4L=0, W=0
    let encoding: u32 = 0x705F00F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_l_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_ldrsh_l_a1_a_field_cond_8_poweroftwo_f0_805f00f0() {
    // Encoding: 0x805F00F0
    // Test aarch32_LDRSH_l_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, P=0, imm4L=0, Rt=0, imm4H=0, cond=8, W=0
    let encoding: u32 = 0x805F00F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_l_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_ldrsh_l_a1_a_field_cond_9_poweroftwo_f0_905f00f0() {
    // Encoding: 0x905F00F0
    // Test aarch32_LDRSH_l_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4L=0, W=0, P=0, Rt=0, imm4H=0, U=0, cond=9
    let encoding: u32 = 0x905F00F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_l_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_ldrsh_l_a1_a_field_cond_10_poweroftwo_f0_a05f00f0() {
    // Encoding: 0xA05F00F0
    // Test aarch32_LDRSH_l_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=10, U=0, W=0, imm4H=0, P=0, imm4L=0, Rt=0
    let encoding: u32 = 0xA05F00F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_l_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_ldrsh_l_a1_a_field_cond_11_poweroftwo_f0_b05f00f0() {
    // Encoding: 0xB05F00F0
    // Test aarch32_LDRSH_l_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, U=0, W=0, imm4H=0, Rt=0, cond=11, imm4L=0
    let encoding: u32 = 0xB05F00F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_l_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_ldrsh_l_a1_a_field_cond_12_poweroftwo_f0_c05f00f0() {
    // Encoding: 0xC05F00F0
    // Test aarch32_LDRSH_l_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, Rt=0, imm4H=0, imm4L=0, U=0, P=0, cond=12
    let encoding: u32 = 0xC05F00F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_l_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_ldrsh_l_a1_a_field_cond_13_poweroftwo_f0_d05f00f0() {
    // Encoding: 0xD05F00F0
    // Test aarch32_LDRSH_l_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, P=0, W=0, imm4H=0, U=0, imm4L=0, cond=13
    let encoding: u32 = 0xD05F00F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_l_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_ldrsh_l_a1_a_field_cond_14_poweroftwo_f0_e05f00f0() {
    // Encoding: 0xE05F00F0
    // Test aarch32_LDRSH_l_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=14, imm4L=0, P=0, U=0, imm4H=0, W=0, Rt=0
    let encoding: u32 = 0xE05F00F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_l_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_ldrsh_l_a1_a_field_cond_15_max_f0_f05f00f0() {
    // Encoding: 0xF05F00F0
    // Test aarch32_LDRSH_l_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: imm4H=0, imm4L=0, W=0, Rt=0, P=0, cond=15, U=0
    let encoding: u32 = 0xF05F00F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_l_A1_A
/// ASL: `field P 24 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldrsh_l_a1_a_field_p_0_min_f0_005f00f0() {
    // Encoding: 0x005F00F0
    // Test aarch32_LDRSH_l_A1_A field P = 0 (Min)
    // ISET: A32
    // Fields: W=0, Rt=0, U=0, cond=0, P=0, imm4L=0, imm4H=0
    let encoding: u32 = 0x005F00F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_l_A1_A
/// ASL: `field P 24 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldrsh_l_a1_a_field_p_1_max_f0_015f00f0() {
    // Encoding: 0x015F00F0
    // Test aarch32_LDRSH_l_A1_A field P = 1 (Max)
    // ISET: A32
    // Fields: P=1, W=0, imm4L=0, cond=0, Rt=0, U=0, imm4H=0
    let encoding: u32 = 0x015F00F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_l_A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldrsh_l_a1_a_field_u_0_min_f0_005f00f0() {
    // Encoding: 0x005F00F0
    // Test aarch32_LDRSH_l_A1_A field U = 0 (Min)
    // ISET: A32
    // Fields: W=0, cond=0, P=0, imm4H=0, U=0, imm4L=0, Rt=0
    let encoding: u32 = 0x005F00F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_l_A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldrsh_l_a1_a_field_u_1_max_f0_00df00f0() {
    // Encoding: 0x00DF00F0
    // Test aarch32_LDRSH_l_A1_A field U = 1 (Max)
    // ISET: A32
    // Fields: Rt=0, U=1, imm4H=0, imm4L=0, P=0, cond=0, W=0
    let encoding: u32 = 0x00DF00F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_l_A1_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldrsh_l_a1_a_field_w_0_min_f0_005f00f0() {
    // Encoding: 0x005F00F0
    // Test aarch32_LDRSH_l_A1_A field W = 0 (Min)
    // ISET: A32
    // Fields: cond=0, W=0, Rt=0, imm4H=0, imm4L=0, U=0, P=0
    let encoding: u32 = 0x005F00F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_l_A1_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldrsh_l_a1_a_field_w_1_max_f0_007f00f0() {
    // Encoding: 0x007F00F0
    // Test aarch32_LDRSH_l_A1_A field W = 1 (Max)
    // ISET: A32
    // Fields: imm4H=0, cond=0, P=0, imm4L=0, U=0, W=1, Rt=0
    let encoding: u32 = 0x007F00F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_l_A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrsh_l_a1_a_field_rt_0_min_f0_005f00f0() {
    // Encoding: 0x005F00F0
    // Test aarch32_LDRSH_l_A1_A field Rt = 0 (Min)
    // ISET: A32
    // Fields: imm4H=0, P=0, imm4L=0, cond=0, W=0, U=0, Rt=0
    let encoding: u32 = 0x005F00F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_l_A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrsh_l_a1_a_field_rt_1_poweroftwo_f0_005f10f0() {
    // Encoding: 0x005F10F0
    // Test aarch32_LDRSH_l_A1_A field Rt = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4H=0, imm4L=0, U=0, cond=0, Rt=1, P=0, W=0
    let encoding: u32 = 0x005F10F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_l_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_ldrsh_l_a1_a_field_imm4h_0_zero_f0_005f00f0() {
    // Encoding: 0x005F00F0
    // Test aarch32_LDRSH_l_A1_A field imm4H = 0 (Zero)
    // ISET: A32
    // Fields: imm4H=0, imm4L=0, U=0, cond=0, P=0, W=0, Rt=0
    let encoding: u32 = 0x005F00F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_l_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_ldrsh_l_a1_a_field_imm4h_1_poweroftwo_f0_005f01f0() {
    // Encoding: 0x005F01F0
    // Test aarch32_LDRSH_l_A1_A field imm4H = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, P=0, U=0, cond=0, imm4H=1, imm4L=0, Rt=0
    let encoding: u32 = 0x005F01F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_l_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_ldrsh_l_a1_a_field_imm4h_3_poweroftwominusone_f0_005f03f0() {
    // Encoding: 0x005F03F0
    // Test aarch32_LDRSH_l_A1_A field imm4H = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: U=0, cond=0, P=0, imm4L=0, W=0, Rt=0, imm4H=3
    let encoding: u32 = 0x005F03F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_l_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_ldrsh_l_a1_a_field_imm4h_4_poweroftwo_f0_005f04f0() {
    // Encoding: 0x005F04F0
    // Test aarch32_LDRSH_l_A1_A field imm4H = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4H=4, imm4L=0, U=0, cond=0, P=0, W=0, Rt=0
    let encoding: u32 = 0x005F04F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_l_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_aarch32_ldrsh_l_a1_a_field_imm4h_7_poweroftwominusone_f0_005f07f0() {
    // Encoding: 0x005F07F0
    // Test aarch32_LDRSH_l_A1_A field imm4H = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: P=0, U=0, imm4H=7, imm4L=0, cond=0, W=0, Rt=0
    let encoding: u32 = 0x005F07F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_l_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_ldrsh_l_a1_a_field_imm4h_8_poweroftwo_f0_005f08f0() {
    // Encoding: 0x005F08F0
    // Test aarch32_LDRSH_l_A1_A field imm4H = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4L=0, cond=0, U=0, W=0, Rt=0, P=0, imm4H=8
    let encoding: u32 = 0x005F08F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_l_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_aarch32_ldrsh_l_a1_a_field_imm4h_15_max_f0_005f0ff0() {
    // Encoding: 0x005F0FF0
    // Test aarch32_LDRSH_l_A1_A field imm4H = 15 (Max)
    // ISET: A32
    // Fields: cond=0, U=0, W=0, P=0, Rt=0, imm4L=0, imm4H=15
    let encoding: u32 = 0x005F0FF0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_l_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_ldrsh_l_a1_a_field_imm4l_0_zero_f0_005f00f0() {
    // Encoding: 0x005F00F0
    // Test aarch32_LDRSH_l_A1_A field imm4L = 0 (Zero)
    // ISET: A32
    // Fields: imm4L=0, U=0, P=0, cond=0, Rt=0, W=0, imm4H=0
    let encoding: u32 = 0x005F00F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_l_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_ldrsh_l_a1_a_field_imm4l_1_poweroftwo_f0_005f00f1() {
    // Encoding: 0x005F00F1
    // Test aarch32_LDRSH_l_A1_A field imm4L = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4H=0, imm4L=1, U=0, cond=0, P=0, W=0, Rt=0
    let encoding: u32 = 0x005F00F1;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_l_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_ldrsh_l_a1_a_field_imm4l_3_poweroftwominusone_f0_005f00f3() {
    // Encoding: 0x005F00F3
    // Test aarch32_LDRSH_l_A1_A field imm4L = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm4H=0, W=0, imm4L=3, P=0, U=0, Rt=0, cond=0
    let encoding: u32 = 0x005F00F3;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_l_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_ldrsh_l_a1_a_field_imm4l_4_poweroftwo_f0_005f00f4() {
    // Encoding: 0x005F00F4
    // Test aarch32_LDRSH_l_A1_A field imm4L = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4L=4, W=0, P=0, U=0, imm4H=0, cond=0, Rt=0
    let encoding: u32 = 0x005F00F4;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_l_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_aarch32_ldrsh_l_a1_a_field_imm4l_7_poweroftwominusone_f0_005f00f7() {
    // Encoding: 0x005F00F7
    // Test aarch32_LDRSH_l_A1_A field imm4L = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: W=0, P=0, U=0, imm4H=0, cond=0, imm4L=7, Rt=0
    let encoding: u32 = 0x005F00F7;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_l_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_ldrsh_l_a1_a_field_imm4l_8_poweroftwo_f0_005f00f8() {
    // Encoding: 0x005F00F8
    // Test aarch32_LDRSH_l_A1_A field imm4L = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4L=8, imm4H=0, W=0, cond=0, P=0, U=0, Rt=0
    let encoding: u32 = 0x005F00F8;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_l_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_aarch32_ldrsh_l_a1_a_field_imm4l_15_max_f0_005f00ff() {
    // Encoding: 0x005F00FF
    // Test aarch32_LDRSH_l_A1_A field imm4L = 15 (Max)
    // ISET: A32
    // Fields: cond=0, P=0, U=0, imm4H=0, imm4L=15, Rt=0, W=0
    let encoding: u32 = 0x005F00FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_l_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_ldrsh_l_a1_a_combo_0_f0_005f00f0() {
    // Encoding: 0x005F00F0
    // Test aarch32_LDRSH_l_A1_A field combination: cond=0, P=0, U=0, W=0, Rt=0, imm4H=0, imm4L=0
    // ISET: A32
    // Fields: Rt=0, cond=0, U=0, P=0, W=0, imm4H=0, imm4L=0
    let encoding: u32 = 0x005F00F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_l_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_ldrsh_l_a1_a_special_cond_0_condition_eq_240_005f00f0() {
    // Encoding: 0x005F00F0
    // Test aarch32_LDRSH_l_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: Rt=0, imm4H=0, imm4L=0, U=0, W=0, cond=0, P=0
    let encoding: u32 = 0x005F00F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_l_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_ldrsh_l_a1_a_special_cond_1_condition_ne_240_105f00f0() {
    // Encoding: 0x105F00F0
    // Test aarch32_LDRSH_l_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: imm4H=0, imm4L=0, U=0, P=0, cond=1, W=0, Rt=0
    let encoding: u32 = 0x105F00F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_l_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_ldrsh_l_a1_a_special_cond_2_condition_cs_hs_240_205f00f0() {
    // Encoding: 0x205F00F0
    // Test aarch32_LDRSH_l_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: imm4L=0, U=0, W=0, P=0, imm4H=0, Rt=0, cond=2
    let encoding: u32 = 0x205F00F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_l_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_ldrsh_l_a1_a_special_cond_3_condition_cc_lo_240_305f00f0() {
    // Encoding: 0x305F00F0
    // Test aarch32_LDRSH_l_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: W=0, imm4H=0, imm4L=0, Rt=0, cond=3, U=0, P=0
    let encoding: u32 = 0x305F00F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_l_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_ldrsh_l_a1_a_special_cond_4_condition_mi_240_405f00f0() {
    // Encoding: 0x405F00F0
    // Test aarch32_LDRSH_l_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: Rt=0, imm4L=0, imm4H=0, W=0, cond=4, P=0, U=0
    let encoding: u32 = 0x405F00F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_l_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_ldrsh_l_a1_a_special_cond_5_condition_pl_240_505f00f0() {
    // Encoding: 0x505F00F0
    // Test aarch32_LDRSH_l_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: Rt=0, U=0, imm4H=0, P=0, imm4L=0, W=0, cond=5
    let encoding: u32 = 0x505F00F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_l_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_ldrsh_l_a1_a_special_cond_6_condition_vs_240_605f00f0() {
    // Encoding: 0x605F00F0
    // Test aarch32_LDRSH_l_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: imm4H=0, W=0, U=0, cond=6, Rt=0, P=0, imm4L=0
    let encoding: u32 = 0x605F00F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_l_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_ldrsh_l_a1_a_special_cond_7_condition_vc_240_705f00f0() {
    // Encoding: 0x705F00F0
    // Test aarch32_LDRSH_l_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: imm4H=0, imm4L=0, Rt=0, U=0, cond=7, P=0, W=0
    let encoding: u32 = 0x705F00F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_l_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_ldrsh_l_a1_a_special_cond_8_condition_hi_240_805f00f0() {
    // Encoding: 0x805F00F0
    // Test aarch32_LDRSH_l_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: Rt=0, U=0, W=0, imm4H=0, cond=8, imm4L=0, P=0
    let encoding: u32 = 0x805F00F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_l_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_ldrsh_l_a1_a_special_cond_9_condition_ls_240_905f00f0() {
    // Encoding: 0x905F00F0
    // Test aarch32_LDRSH_l_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: cond=9, U=0, P=0, imm4L=0, Rt=0, imm4H=0, W=0
    let encoding: u32 = 0x905F00F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_l_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_ldrsh_l_a1_a_special_cond_10_condition_ge_240_a05f00f0() {
    // Encoding: 0xA05F00F0
    // Test aarch32_LDRSH_l_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: imm4H=0, cond=10, U=0, Rt=0, imm4L=0, P=0, W=0
    let encoding: u32 = 0xA05F00F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_l_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_ldrsh_l_a1_a_special_cond_11_condition_lt_240_b05f00f0() {
    // Encoding: 0xB05F00F0
    // Test aarch32_LDRSH_l_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: U=0, W=0, P=0, Rt=0, imm4H=0, imm4L=0, cond=11
    let encoding: u32 = 0xB05F00F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_l_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_ldrsh_l_a1_a_special_cond_12_condition_gt_240_c05f00f0() {
    // Encoding: 0xC05F00F0
    // Test aarch32_LDRSH_l_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: U=0, Rt=0, imm4H=0, cond=12, imm4L=0, W=0, P=0
    let encoding: u32 = 0xC05F00F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_l_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_ldrsh_l_a1_a_special_cond_13_condition_le_240_d05f00f0() {
    // Encoding: 0xD05F00F0
    // Test aarch32_LDRSH_l_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: U=0, W=0, Rt=0, P=0, cond=13, imm4H=0, imm4L=0
    let encoding: u32 = 0xD05F00F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_l_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_ldrsh_l_a1_a_special_cond_14_condition_al_240_e05f00f0() {
    // Encoding: 0xE05F00F0
    // Test aarch32_LDRSH_l_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: imm4L=0, W=0, Rt=0, P=0, U=0, imm4H=0, cond=14
    let encoding: u32 = 0xE05F00F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_l_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_ldrsh_l_a1_a_special_cond_15_condition_nv_240_f05f00f0() {
    // Encoding: 0xF05F00F0
    // Test aarch32_LDRSH_l_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: cond=15, U=0, P=0, W=0, imm4H=0, Rt=0, imm4L=0
    let encoding: u32 = 0xF05F00F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_l_A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }) } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"wback\" }) } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrsh_l_a1_a_invalid_0_f0_005f00f0() {
    // Encoding: 0x005F00F0
    // Test aarch32_LDRSH_l_A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }) } }
    // ISET: A32
    // Fields: U=0, P=0, cond=0, W=0, Rt=0, imm4H=0, imm4L=0
    let encoding: u32 = 0x005F00F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRSH_l_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrsh_l_a1_a_invalid_1_f0_005f00f0() {
    // Encoding: 0x005F00F0
    // Test aarch32_LDRSH_l_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: imm4H=0, imm4L=0, W=0, U=0, P=0, Rt=0, cond=0
    let encoding: u32 = 0x005F00F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRSH_l_T1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldrsh_l_t1_a_field_u_0_min_0_f93f0000() {
    // Thumb encoding (32): 0xF93F0000
    // Test aarch32_LDRSH_l_T1_A field U = 0 (Min)
    // ISET: T32
    // Fields: imm12=0, U=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF93F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_l_T1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldrsh_l_t1_a_field_u_1_max_0_f9bf0000() {
    // Thumb encoding (32): 0xF9BF0000
    // Test aarch32_LDRSH_l_T1_A field U = 1 (Max)
    // ISET: T32
    // Fields: U=1, imm12=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9BF0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_l_T1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrsh_l_t1_a_field_rt_0_min_0_f93f0000() {
    // Thumb encoding (32): 0xF93F0000
    // Test aarch32_LDRSH_l_T1_A field Rt = 0 (Min)
    // ISET: T32
    // Fields: U=0, Rt=0, imm12=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF93F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_l_T1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrsh_l_t1_a_field_rt_1_poweroftwo_0_f93f1000() {
    // Thumb encoding (32): 0xF93F1000
    // Test aarch32_LDRSH_l_T1_A field Rt = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm12=0, Rt=1, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF93F1000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_ldrsh_l_t1_a_field_imm12_0_zero_0_f93f0000() {
    // Thumb encoding (32): 0xF93F0000
    // Test aarch32_LDRSH_l_T1_A field imm12 = 0 (Zero)
    // ISET: T32
    // Fields: U=0, Rt=0, imm12=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF93F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_ldrsh_l_t1_a_field_imm12_1_poweroftwo_0_f93f0001() {
    // Thumb encoding (32): 0xF93F0001
    // Test aarch32_LDRSH_l_T1_A field imm12 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, U=0, imm12=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF93F0001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_ldrsh_l_t1_a_field_imm12_3_poweroftwominusone_0_f93f0003() {
    // Thumb encoding (32): 0xF93F0003
    // Test aarch32_LDRSH_l_T1_A field imm12 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: U=0, Rt=0, imm12=3
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF93F0003;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_ldrsh_l_t1_a_field_imm12_4_poweroftwo_0_f93f0004() {
    // Thumb encoding (32): 0xF93F0004
    // Test aarch32_LDRSH_l_T1_A field imm12 = 4 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, U=0, imm12=4
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF93F0004;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_ldrsh_l_t1_a_field_imm12_7_poweroftwominusone_0_f93f0007() {
    // Thumb encoding (32): 0xF93F0007
    // Test aarch32_LDRSH_l_T1_A field imm12 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, U=0, imm12=7
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF93F0007;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_ldrsh_l_t1_a_field_imm12_8_poweroftwo_0_f93f0008() {
    // Thumb encoding (32): 0xF93F0008
    // Test aarch32_LDRSH_l_T1_A field imm12 = 8 (PowerOfTwo)
    // ISET: T32
    // Fields: imm12=8, U=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF93F0008;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_ldrsh_l_t1_a_field_imm12_15_poweroftwominusone_0_f93f000f() {
    // Thumb encoding (32): 0xF93F000F
    // Test aarch32_LDRSH_l_T1_A field imm12 = 15 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: U=0, imm12=15, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF93F000F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_ldrsh_l_t1_a_field_imm12_16_poweroftwo_0_f93f0010() {
    // Thumb encoding (32): 0xF93F0010
    // Test aarch32_LDRSH_l_T1_A field imm12 = 16 (PowerOfTwo)
    // ISET: T32
    // Fields: imm12=16, Rt=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF93F0010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_ldrsh_l_t1_a_field_imm12_31_poweroftwominusone_0_f93f001f() {
    // Thumb encoding (32): 0xF93F001F
    // Test aarch32_LDRSH_l_T1_A field imm12 = 31 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: U=0, imm12=31, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF93F001F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_ldrsh_l_t1_a_field_imm12_32_poweroftwo_0_f93f0020() {
    // Thumb encoding (32): 0xF93F0020
    // Test aarch32_LDRSH_l_T1_A field imm12 = 32 (PowerOfTwo)
    // ISET: T32
    // Fields: imm12=32, U=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF93F0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_ldrsh_l_t1_a_field_imm12_63_poweroftwominusone_0_f93f003f() {
    // Thumb encoding (32): 0xF93F003F
    // Test aarch32_LDRSH_l_T1_A field imm12 = 63 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: U=0, Rt=0, imm12=63
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF93F003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_ldrsh_l_t1_a_field_imm12_64_poweroftwo_0_f93f0040() {
    // Thumb encoding (32): 0xF93F0040
    // Test aarch32_LDRSH_l_T1_A field imm12 = 64 (PowerOfTwo)
    // ISET: T32
    // Fields: U=0, imm12=64, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF93F0040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 127, boundary: PowerOfTwoMinusOne }
/// 2^7 - 1 = 127
#[test]
fn test_aarch32_ldrsh_l_t1_a_field_imm12_127_poweroftwominusone_0_f93f007f() {
    // Thumb encoding (32): 0xF93F007F
    // Test aarch32_LDRSH_l_T1_A field imm12 = 127 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: U=0, imm12=127, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF93F007F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_ldrsh_l_t1_a_field_imm12_128_poweroftwo_0_f93f0080() {
    // Thumb encoding (32): 0xF93F0080
    // Test aarch32_LDRSH_l_T1_A field imm12 = 128 (PowerOfTwo)
    // ISET: T32
    // Fields: U=0, imm12=128, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF93F0080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 255, boundary: PowerOfTwoMinusOne }
/// 2^8 - 1 = 255
#[test]
fn test_aarch32_ldrsh_l_t1_a_field_imm12_255_poweroftwominusone_0_f93f00ff() {
    // Thumb encoding (32): 0xF93F00FF
    // Test aarch32_LDRSH_l_T1_A field imm12 = 255 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, imm12=255, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF93F00FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 256, boundary: PowerOfTwo }
/// power of 2 (2^8 = 256)
#[test]
fn test_aarch32_ldrsh_l_t1_a_field_imm12_256_poweroftwo_0_f93f0100() {
    // Thumb encoding (32): 0xF93F0100
    // Test aarch32_LDRSH_l_T1_A field imm12 = 256 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, imm12=256, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF93F0100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 511, boundary: PowerOfTwoMinusOne }
/// 2^9 - 1 = 511
#[test]
fn test_aarch32_ldrsh_l_t1_a_field_imm12_511_poweroftwominusone_0_f93f01ff() {
    // Thumb encoding (32): 0xF93F01FF
    // Test aarch32_LDRSH_l_T1_A field imm12 = 511 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: U=0, Rt=0, imm12=511
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF93F01FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 512, boundary: PowerOfTwo }
/// power of 2 (2^9 = 512)
#[test]
fn test_aarch32_ldrsh_l_t1_a_field_imm12_512_poweroftwo_0_f93f0200() {
    // Thumb encoding (32): 0xF93F0200
    // Test aarch32_LDRSH_l_T1_A field imm12 = 512 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, imm12=512, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF93F0200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1023, boundary: PowerOfTwoMinusOne }
/// 2^10 - 1 = 1023
#[test]
fn test_aarch32_ldrsh_l_t1_a_field_imm12_1023_poweroftwominusone_0_f93f03ff() {
    // Thumb encoding (32): 0xF93F03FF
    // Test aarch32_LDRSH_l_T1_A field imm12 = 1023 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, imm12=1023, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF93F03FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1024, boundary: PowerOfTwo }
/// power of 2 (2^10 = 1024)
#[test]
fn test_aarch32_ldrsh_l_t1_a_field_imm12_1024_poweroftwo_0_f93f0400() {
    // Thumb encoding (32): 0xF93F0400
    // Test aarch32_LDRSH_l_T1_A field imm12 = 1024 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, U=0, imm12=1024
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF93F0400;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2047, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (2047)
#[test]
fn test_aarch32_ldrsh_l_t1_a_field_imm12_2047_poweroftwominusone_0_f93f07ff() {
    // Thumb encoding (32): 0xF93F07FF
    // Test aarch32_LDRSH_l_T1_A field imm12 = 2047 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm12=2047, Rt=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF93F07FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2048, boundary: PowerOfTwo }
/// power of 2 (2^11 = 2048)
#[test]
fn test_aarch32_ldrsh_l_t1_a_field_imm12_2048_poweroftwo_0_f93f0800() {
    // Thumb encoding (32): 0xF93F0800
    // Test aarch32_LDRSH_l_T1_A field imm12 = 2048 (PowerOfTwo)
    // ISET: T32
    // Fields: imm12=2048, Rt=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF93F0800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4095, boundary: Max }
/// maximum immediate (4095)
#[test]
fn test_aarch32_ldrsh_l_t1_a_field_imm12_4095_max_0_f93f0fff() {
    // Thumb encoding (32): 0xF93F0FFF
    // Test aarch32_LDRSH_l_T1_A field imm12 = 4095 (Max)
    // ISET: T32
    // Fields: U=0, Rt=0, imm12=4095
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF93F0FFF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_l_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=0 (minimum value)
#[test]
fn test_aarch32_ldrsh_l_t1_a_combo_0_0_f93f0000() {
    // Thumb encoding (32): 0xF93F0000
    // Test aarch32_LDRSH_l_T1_A field combination: U=0, Rt=0, imm12=0
    // ISET: T32
    // Fields: imm12=0, Rt=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF93F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_l_A1_A
/// ASL: `UMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple multiply
#[test]
fn test_aarch32_ldrsh_l_a1_a_umull_oracle_0_9ba27c20() {
    // Test UMULL: simple multiply (oracle)
    // Encoding: 0x9BA27C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3);
    set_w(&mut cpu, 1, 0x2);
    let encoding: u32 = 0x9BA27C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6, "X0 should be 0x0000000000000006");
}

/// Provenance: aarch32_LDRSH_l_A1_A
/// ASL: `UMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max 32-bit * 2
#[test]
fn test_aarch32_ldrsh_l_a1_a_umull_oracle_1_9ba27c20() {
    // Test UMULL: max 32-bit * 2 (oracle)
    // Encoding: 0x9BA27C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x9BA27C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0x00000001FFFFFFFE"
    );
}

/// Provenance: aarch32_LDRSH_l_A1_A
/// ASL: `UMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// large positive * large positive
#[test]
fn test_aarch32_ldrsh_l_a1_a_umull_oracle_2_9ba27c20() {
    // Test UMULL: large positive * large positive (oracle)
    // Encoding: 0x9BA27C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    set_w(&mut cpu, 2, 0x7FFFFFFF);
    let encoding: u32 = 0x9BA27C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x3FFFFFFF00000001");
}

/// Provenance: aarch32_LDRSH_l_A1_A
/// ASL: `UMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max unsigned * max unsigned
#[test]
fn test_aarch32_ldrsh_l_a1_a_umull_oracle_3_9ba27c20() {
    // Test UMULL: max unsigned * max unsigned (oracle)
    // Encoding: 0x9BA27C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x9BA27C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0xFFFFFFFE00000001");
}

/// Provenance: aarch32_LDRSH_l_A1_A
/// ASL: `UMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// medium values
#[test]
fn test_aarch32_ldrsh_l_a1_a_umull_oracle_4_9ba27c20() {
    // Test UMULL: medium values (oracle)
    // Encoding: 0x9BA27C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xC8);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x9BA27C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4E20, "X0 should be 0x0000000000004E20");
}

/// Provenance: aarch32_LDRSH_l_A1_A
/// ASL: `UMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// 16-bit values
#[test]
fn test_aarch32_ldrsh_l_a1_a_umull_oracle_5_9ba27c20() {
    // Test UMULL: 16-bit values (oracle)
    // Encoding: 0x9BA27C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1234);
    set_w(&mut cpu, 2, 0x5678);
    let encoding: u32 = 0x9BA27C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6260060, "X0 should be 0x0000000006260060");
}

// ============================================================================
// aarch32_LDRSBT_A Tests
// ============================================================================

/// Provenance: aarch32_LDRSBT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_ldrsbt_a1_a_field_cond_0_min_d0_007000d0() {
    // Encoding: 0x007000D0
    // Test aarch32_LDRSBT_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: cond=0, U=0, Rn=0, Rt=0, imm4H=0, imm4L=0
    let encoding: u32 = 0x007000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSBT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_ldrsbt_a1_a_field_cond_1_poweroftwo_d0_107000d0() {
    // Encoding: 0x107000D0
    // Test aarch32_LDRSBT_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4L=0, U=0, cond=1, Rn=0, Rt=0, imm4H=0
    let encoding: u32 = 0x107000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSBT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_ldrsbt_a1_a_field_cond_2_poweroftwo_d0_207000d0() {
    // Encoding: 0x207000D0
    // Test aarch32_LDRSBT_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, imm4H=0, imm4L=0, Rt=0, Rn=0, cond=2
    let encoding: u32 = 0x207000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSBT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_ldrsbt_a1_a_field_cond_3_poweroftwo_d0_307000d0() {
    // Encoding: 0x307000D0
    // Test aarch32_LDRSBT_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, imm4L=0, imm4H=0, cond=3, Rn=0, Rt=0
    let encoding: u32 = 0x307000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSBT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_ldrsbt_a1_a_field_cond_4_poweroftwo_d0_407000d0() {
    // Encoding: 0x407000D0
    // Test aarch32_LDRSBT_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=4, imm4H=0, imm4L=0, Rt=0, U=0, Rn=0
    let encoding: u32 = 0x407000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSBT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_ldrsbt_a1_a_field_cond_5_poweroftwo_d0_507000d0() {
    // Encoding: 0x507000D0
    // Test aarch32_LDRSBT_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, Rt=0, Rn=0, imm4H=0, imm4L=0, cond=5
    let encoding: u32 = 0x507000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSBT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_ldrsbt_a1_a_field_cond_6_poweroftwo_d0_607000d0() {
    // Encoding: 0x607000D0
    // Test aarch32_LDRSBT_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4L=0, U=0, cond=6, Rt=0, imm4H=0, Rn=0
    let encoding: u32 = 0x607000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSBT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_ldrsbt_a1_a_field_cond_7_poweroftwo_d0_707000d0() {
    // Encoding: 0x707000D0
    // Test aarch32_LDRSBT_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4L=0, U=0, imm4H=0, Rn=0, cond=7, Rt=0
    let encoding: u32 = 0x707000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSBT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_ldrsbt_a1_a_field_cond_8_poweroftwo_d0_807000d0() {
    // Encoding: 0x807000D0
    // Test aarch32_LDRSBT_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4H=0, Rt=0, Rn=0, imm4L=0, U=0, cond=8
    let encoding: u32 = 0x807000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSBT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_ldrsbt_a1_a_field_cond_9_poweroftwo_d0_907000d0() {
    // Encoding: 0x907000D0
    // Test aarch32_LDRSBT_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, imm4H=0, Rn=0, imm4L=0, cond=9, U=0
    let encoding: u32 = 0x907000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSBT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_ldrsbt_a1_a_field_cond_10_poweroftwo_d0_a07000d0() {
    // Encoding: 0xA07000D0
    // Test aarch32_LDRSBT_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=10, Rt=0, imm4H=0, imm4L=0, U=0, Rn=0
    let encoding: u32 = 0xA07000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSBT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_ldrsbt_a1_a_field_cond_11_poweroftwo_d0_b07000d0() {
    // Encoding: 0xB07000D0
    // Test aarch32_LDRSBT_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4L=0, U=0, imm4H=0, Rn=0, Rt=0, cond=11
    let encoding: u32 = 0xB07000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSBT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_ldrsbt_a1_a_field_cond_12_poweroftwo_d0_c07000d0() {
    // Encoding: 0xC07000D0
    // Test aarch32_LDRSBT_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4L=0, Rt=0, cond=12, U=0, Rn=0, imm4H=0
    let encoding: u32 = 0xC07000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSBT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_ldrsbt_a1_a_field_cond_13_poweroftwo_d0_d07000d0() {
    // Encoding: 0xD07000D0
    // Test aarch32_LDRSBT_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4H=0, U=0, Rn=0, cond=13, imm4L=0, Rt=0
    let encoding: u32 = 0xD07000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSBT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_ldrsbt_a1_a_field_cond_14_poweroftwo_d0_e07000d0() {
    // Encoding: 0xE07000D0
    // Test aarch32_LDRSBT_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, imm4H=0, imm4L=0, U=0, cond=14, Rt=0
    let encoding: u32 = 0xE07000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSBT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_ldrsbt_a1_a_field_cond_15_max_d0_f07000d0() {
    // Encoding: 0xF07000D0
    // Test aarch32_LDRSBT_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: U=0, cond=15, imm4H=0, imm4L=0, Rt=0, Rn=0
    let encoding: u32 = 0xF07000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSBT_A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldrsbt_a1_a_field_u_0_min_d0_007000d0() {
    // Encoding: 0x007000D0
    // Test aarch32_LDRSBT_A1_A field U = 0 (Min)
    // ISET: A32
    // Fields: cond=0, U=0, Rt=0, imm4H=0, imm4L=0, Rn=0
    let encoding: u32 = 0x007000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSBT_A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldrsbt_a1_a_field_u_1_max_d0_00f000d0() {
    // Encoding: 0x00F000D0
    // Test aarch32_LDRSBT_A1_A field U = 1 (Max)
    // ISET: A32
    // Fields: cond=0, imm4L=0, Rn=0, U=1, imm4H=0, Rt=0
    let encoding: u32 = 0x00F000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSBT_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrsbt_a1_a_field_rn_0_min_d0_007000d0() {
    // Encoding: 0x007000D0
    // Test aarch32_LDRSBT_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: U=0, Rt=0, imm4H=0, cond=0, Rn=0, imm4L=0
    let encoding: u32 = 0x007000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSBT_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrsbt_a1_a_field_rn_1_poweroftwo_d0_007100d0() {
    // Encoding: 0x007100D0
    // Test aarch32_LDRSBT_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4L=0, U=0, imm4H=0, Rn=1, cond=0, Rt=0
    let encoding: u32 = 0x007100D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSBT_A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrsbt_a1_a_field_rt_0_min_d0_007000d0() {
    // Encoding: 0x007000D0
    // Test aarch32_LDRSBT_A1_A field Rt = 0 (Min)
    // ISET: A32
    // Fields: Rt=0, Rn=0, cond=0, imm4H=0, imm4L=0, U=0
    let encoding: u32 = 0x007000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSBT_A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrsbt_a1_a_field_rt_1_poweroftwo_d0_007010d0() {
    // Encoding: 0x007010D0
    // Test aarch32_LDRSBT_A1_A field Rt = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4H=0, imm4L=0, U=0, cond=0, Rn=0, Rt=1
    let encoding: u32 = 0x007010D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSBT_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_ldrsbt_a1_a_field_imm4h_0_zero_d0_007000d0() {
    // Encoding: 0x007000D0
    // Test aarch32_LDRSBT_A1_A field imm4H = 0 (Zero)
    // ISET: A32
    // Fields: Rn=0, U=0, imm4H=0, imm4L=0, cond=0, Rt=0
    let encoding: u32 = 0x007000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSBT_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_ldrsbt_a1_a_field_imm4h_1_poweroftwo_d0_007001d0() {
    // Encoding: 0x007001D0
    // Test aarch32_LDRSBT_A1_A field imm4H = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, Rn=0, Rt=0, imm4H=1, cond=0, imm4L=0
    let encoding: u32 = 0x007001D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSBT_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_ldrsbt_a1_a_field_imm4h_3_poweroftwominusone_d0_007003d0() {
    // Encoding: 0x007003D0
    // Test aarch32_LDRSBT_A1_A field imm4H = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, U=0, Rn=0, Rt=0, imm4H=3, imm4L=0
    let encoding: u32 = 0x007003D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSBT_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_ldrsbt_a1_a_field_imm4h_4_poweroftwo_d0_007004d0() {
    // Encoding: 0x007004D0
    // Test aarch32_LDRSBT_A1_A field imm4H = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4L=0, Rt=0, U=0, cond=0, Rn=0, imm4H=4
    let encoding: u32 = 0x007004D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSBT_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_aarch32_ldrsbt_a1_a_field_imm4h_7_poweroftwominusone_d0_007007d0() {
    // Encoding: 0x007007D0
    // Test aarch32_LDRSBT_A1_A field imm4H = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, imm4H=7, U=0, Rt=0, Rn=0, imm4L=0
    let encoding: u32 = 0x007007D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSBT_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_ldrsbt_a1_a_field_imm4h_8_poweroftwo_d0_007008d0() {
    // Encoding: 0x007008D0
    // Test aarch32_LDRSBT_A1_A field imm4H = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4H=8, imm4L=0, U=0, cond=0, Rn=0, Rt=0
    let encoding: u32 = 0x007008D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSBT_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_aarch32_ldrsbt_a1_a_field_imm4h_15_max_d0_00700fd0() {
    // Encoding: 0x00700FD0
    // Test aarch32_LDRSBT_A1_A field imm4H = 15 (Max)
    // ISET: A32
    // Fields: Rn=0, Rt=0, U=0, imm4H=15, imm4L=0, cond=0
    let encoding: u32 = 0x00700FD0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSBT_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_ldrsbt_a1_a_field_imm4l_0_zero_d0_007000d0() {
    // Encoding: 0x007000D0
    // Test aarch32_LDRSBT_A1_A field imm4L = 0 (Zero)
    // ISET: A32
    // Fields: U=0, imm4H=0, imm4L=0, Rt=0, cond=0, Rn=0
    let encoding: u32 = 0x007000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSBT_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_ldrsbt_a1_a_field_imm4l_1_poweroftwo_d0_007000d1() {
    // Encoding: 0x007000D1
    // Test aarch32_LDRSBT_A1_A field imm4L = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4L=1, Rt=0, cond=0, U=0, imm4H=0, Rn=0
    let encoding: u32 = 0x007000D1;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSBT_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_ldrsbt_a1_a_field_imm4l_3_poweroftwominusone_d0_007000d3() {
    // Encoding: 0x007000D3
    // Test aarch32_LDRSBT_A1_A field imm4L = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, imm4L=3, Rt=0, U=0, imm4H=0, Rn=0
    let encoding: u32 = 0x007000D3;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSBT_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_ldrsbt_a1_a_field_imm4l_4_poweroftwo_d0_007000d4() {
    // Encoding: 0x007000D4
    // Test aarch32_LDRSBT_A1_A field imm4L = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4H=0, imm4L=4, U=0, cond=0, Rt=0, Rn=0
    let encoding: u32 = 0x007000D4;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSBT_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_aarch32_ldrsbt_a1_a_field_imm4l_7_poweroftwominusone_d0_007000d7() {
    // Encoding: 0x007000D7
    // Test aarch32_LDRSBT_A1_A field imm4L = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rt=0, U=0, Rn=0, imm4H=0, imm4L=7, cond=0
    let encoding: u32 = 0x007000D7;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSBT_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_ldrsbt_a1_a_field_imm4l_8_poweroftwo_d0_007000d8() {
    // Encoding: 0x007000D8
    // Test aarch32_LDRSBT_A1_A field imm4L = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4L=8, imm4H=0, Rt=0, Rn=0, cond=0, U=0
    let encoding: u32 = 0x007000D8;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSBT_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_aarch32_ldrsbt_a1_a_field_imm4l_15_max_d0_007000df() {
    // Encoding: 0x007000DF
    // Test aarch32_LDRSBT_A1_A field imm4L = 15 (Max)
    // ISET: A32
    // Fields: Rt=0, imm4H=0, imm4L=15, Rn=0, U=0, cond=0
    let encoding: u32 = 0x007000DF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSBT_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_ldrsbt_a1_a_combo_0_d0_007000d0() {
    // Encoding: 0x007000D0
    // Test aarch32_LDRSBT_A1_A field combination: cond=0, U=0, Rn=0, Rt=0, imm4H=0, imm4L=0
    // ISET: A32
    // Fields: cond=0, imm4H=0, U=0, Rt=0, imm4L=0, Rn=0
    let encoding: u32 = 0x007000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSBT_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_ldrsbt_a1_a_special_cond_0_condition_eq_208_007000d0() {
    // Encoding: 0x007000D0
    // Test aarch32_LDRSBT_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: cond=0, Rt=0, Rn=0, U=0, imm4H=0, imm4L=0
    let encoding: u32 = 0x007000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSBT_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_ldrsbt_a1_a_special_cond_1_condition_ne_208_107000d0() {
    // Encoding: 0x107000D0
    // Test aarch32_LDRSBT_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: imm4H=0, U=0, cond=1, Rt=0, Rn=0, imm4L=0
    let encoding: u32 = 0x107000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSBT_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_ldrsbt_a1_a_special_cond_2_condition_cs_hs_208_207000d0() {
    // Encoding: 0x207000D0
    // Test aarch32_LDRSBT_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: cond=2, imm4L=0, Rt=0, Rn=0, imm4H=0, U=0
    let encoding: u32 = 0x207000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSBT_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_ldrsbt_a1_a_special_cond_3_condition_cc_lo_208_307000d0() {
    // Encoding: 0x307000D0
    // Test aarch32_LDRSBT_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: cond=3, U=0, Rt=0, imm4L=0, Rn=0, imm4H=0
    let encoding: u32 = 0x307000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSBT_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_ldrsbt_a1_a_special_cond_4_condition_mi_208_407000d0() {
    // Encoding: 0x407000D0
    // Test aarch32_LDRSBT_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: cond=4, U=0, Rt=0, imm4H=0, imm4L=0, Rn=0
    let encoding: u32 = 0x407000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSBT_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_ldrsbt_a1_a_special_cond_5_condition_pl_208_507000d0() {
    // Encoding: 0x507000D0
    // Test aarch32_LDRSBT_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: cond=5, Rn=0, U=0, Rt=0, imm4H=0, imm4L=0
    let encoding: u32 = 0x507000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSBT_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_ldrsbt_a1_a_special_cond_6_condition_vs_208_607000d0() {
    // Encoding: 0x607000D0
    // Test aarch32_LDRSBT_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: imm4L=0, Rn=0, cond=6, Rt=0, U=0, imm4H=0
    let encoding: u32 = 0x607000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSBT_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_ldrsbt_a1_a_special_cond_7_condition_vc_208_707000d0() {
    // Encoding: 0x707000D0
    // Test aarch32_LDRSBT_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: U=0, Rt=0, imm4L=0, cond=7, Rn=0, imm4H=0
    let encoding: u32 = 0x707000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSBT_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_ldrsbt_a1_a_special_cond_8_condition_hi_208_807000d0() {
    // Encoding: 0x807000D0
    // Test aarch32_LDRSBT_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: cond=8, Rt=0, imm4H=0, imm4L=0, U=0, Rn=0
    let encoding: u32 = 0x807000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSBT_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_ldrsbt_a1_a_special_cond_9_condition_ls_208_907000d0() {
    // Encoding: 0x907000D0
    // Test aarch32_LDRSBT_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: imm4H=0, cond=9, Rn=0, imm4L=0, U=0, Rt=0
    let encoding: u32 = 0x907000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSBT_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_ldrsbt_a1_a_special_cond_10_condition_ge_208_a07000d0() {
    // Encoding: 0xA07000D0
    // Test aarch32_LDRSBT_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: Rt=0, cond=10, Rn=0, imm4H=0, imm4L=0, U=0
    let encoding: u32 = 0xA07000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSBT_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_ldrsbt_a1_a_special_cond_11_condition_lt_208_b07000d0() {
    // Encoding: 0xB07000D0
    // Test aarch32_LDRSBT_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: Rt=0, imm4L=0, imm4H=0, cond=11, Rn=0, U=0
    let encoding: u32 = 0xB07000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSBT_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_ldrsbt_a1_a_special_cond_12_condition_gt_208_c07000d0() {
    // Encoding: 0xC07000D0
    // Test aarch32_LDRSBT_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: cond=12, U=0, Rt=0, imm4H=0, imm4L=0, Rn=0
    let encoding: u32 = 0xC07000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSBT_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_ldrsbt_a1_a_special_cond_13_condition_le_208_d07000d0() {
    // Encoding: 0xD07000D0
    // Test aarch32_LDRSBT_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: imm4H=0, imm4L=0, U=0, Rn=0, cond=13, Rt=0
    let encoding: u32 = 0xD07000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSBT_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_ldrsbt_a1_a_special_cond_14_condition_al_208_e07000d0() {
    // Encoding: 0xE07000D0
    // Test aarch32_LDRSBT_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: imm4H=0, imm4L=0, U=0, Rn=0, cond=14, Rt=0
    let encoding: u32 = 0xE07000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSBT_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_ldrsbt_a1_a_special_cond_15_condition_nv_208_f07000d0() {
    // Encoding: 0xF07000D0
    // Test aarch32_LDRSBT_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: Rn=0, imm4H=0, imm4L=0, Rt=0, U=0, cond=15
    let encoding: u32 = 0xF07000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSBT_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrsbt_a1_a_invalid_0_d0_007000d0() {
    // Encoding: 0x007000D0
    // Test aarch32_LDRSBT_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) }
    // ISET: A32
    // Fields: Rt=0, imm4H=0, imm4L=0, cond=0, U=0, Rn=0
    let encoding: u32 = 0x007000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRSBT_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrsbt_a1_a_invalid_1_d0_007000d0() {
    // Encoding: 0x007000D0
    // Test aarch32_LDRSBT_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Rn=0, imm4H=0, Rt=0, U=0, imm4L=0, cond=0
    let encoding: u32 = 0x007000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRSBT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_ldrsbt_a2_a_field_cond_0_min_d0_003000d0() {
    // Encoding: 0x003000D0
    // Test aarch32_LDRSBT_A2_A field cond = 0 (Min)
    // ISET: A32
    // Fields: cond=0, U=0, Rm=0, Rn=0, Rt=0
    let encoding: u32 = 0x003000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSBT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_ldrsbt_a2_a_field_cond_1_poweroftwo_d0_103000d0() {
    // Encoding: 0x103000D0
    // Test aarch32_LDRSBT_A2_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=1, Rm=0, Rn=0, U=0, Rt=0
    let encoding: u32 = 0x103000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSBT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_ldrsbt_a2_a_field_cond_2_poweroftwo_d0_203000d0() {
    // Encoding: 0x203000D0
    // Test aarch32_LDRSBT_A2_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=2, U=0, Rt=0, Rm=0
    let encoding: u32 = 0x203000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSBT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_ldrsbt_a2_a_field_cond_3_poweroftwo_d0_303000d0() {
    // Encoding: 0x303000D0
    // Test aarch32_LDRSBT_A2_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, Rn=0, cond=3, Rt=0, Rm=0
    let encoding: u32 = 0x303000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSBT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_ldrsbt_a2_a_field_cond_4_poweroftwo_d0_403000d0() {
    // Encoding: 0x403000D0
    // Test aarch32_LDRSBT_A2_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, Rn=0, Rm=0, cond=4, Rt=0
    let encoding: u32 = 0x403000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSBT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_ldrsbt_a2_a_field_cond_5_poweroftwo_d0_503000d0() {
    // Encoding: 0x503000D0
    // Test aarch32_LDRSBT_A2_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, Rm=0, cond=5, Rt=0, Rn=0
    let encoding: u32 = 0x503000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSBT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_ldrsbt_a2_a_field_cond_6_poweroftwo_d0_603000d0() {
    // Encoding: 0x603000D0
    // Test aarch32_LDRSBT_A2_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=6, U=0, Rt=0, Rm=0, Rn=0
    let encoding: u32 = 0x603000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSBT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_ldrsbt_a2_a_field_cond_7_poweroftwo_d0_703000d0() {
    // Encoding: 0x703000D0
    // Test aarch32_LDRSBT_A2_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rm=0, cond=7, Rt=0, U=0
    let encoding: u32 = 0x703000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSBT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_ldrsbt_a2_a_field_cond_8_poweroftwo_d0_803000d0() {
    // Encoding: 0x803000D0
    // Test aarch32_LDRSBT_A2_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, U=0, Rm=0, cond=8, Rt=0
    let encoding: u32 = 0x803000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSBT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_ldrsbt_a2_a_field_cond_9_poweroftwo_d0_903000d0() {
    // Encoding: 0x903000D0
    // Test aarch32_LDRSBT_A2_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=9, Rn=0, U=0, Rt=0, Rm=0
    let encoding: u32 = 0x903000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSBT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_ldrsbt_a2_a_field_cond_10_poweroftwo_d0_a03000d0() {
    // Encoding: 0xA03000D0
    // Test aarch32_LDRSBT_A2_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, Rt=0, Rm=0, Rn=0, cond=10
    let encoding: u32 = 0xA03000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSBT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_ldrsbt_a2_a_field_cond_11_poweroftwo_d0_b03000d0() {
    // Encoding: 0xB03000D0
    // Test aarch32_LDRSBT_A2_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, cond=11, Rt=0, Rn=0, Rm=0
    let encoding: u32 = 0xB03000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSBT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_ldrsbt_a2_a_field_cond_12_poweroftwo_d0_c03000d0() {
    // Encoding: 0xC03000D0
    // Test aarch32_LDRSBT_A2_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=12, Rm=0, U=0, Rt=0
    let encoding: u32 = 0xC03000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSBT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_ldrsbt_a2_a_field_cond_13_poweroftwo_d0_d03000d0() {
    // Encoding: 0xD03000D0
    // Test aarch32_LDRSBT_A2_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=13, Rt=0, Rm=0, U=0
    let encoding: u32 = 0xD03000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSBT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_ldrsbt_a2_a_field_cond_14_poweroftwo_d0_e03000d0() {
    // Encoding: 0xE03000D0
    // Test aarch32_LDRSBT_A2_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, U=0, Rt=0, Rn=0, cond=14
    let encoding: u32 = 0xE03000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSBT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_ldrsbt_a2_a_field_cond_15_max_d0_f03000d0() {
    // Encoding: 0xF03000D0
    // Test aarch32_LDRSBT_A2_A field cond = 15 (Max)
    // ISET: A32
    // Fields: Rn=0, cond=15, Rm=0, Rt=0, U=0
    let encoding: u32 = 0xF03000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSBT_A2_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldrsbt_a2_a_field_u_0_min_d0_003000d0() {
    // Encoding: 0x003000D0
    // Test aarch32_LDRSBT_A2_A field U = 0 (Min)
    // ISET: A32
    // Fields: cond=0, U=0, Rn=0, Rt=0, Rm=0
    let encoding: u32 = 0x003000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSBT_A2_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldrsbt_a2_a_field_u_1_max_d0_00b000d0() {
    // Encoding: 0x00B000D0
    // Test aarch32_LDRSBT_A2_A field U = 1 (Max)
    // ISET: A32
    // Fields: Rn=0, Rt=0, U=1, cond=0, Rm=0
    let encoding: u32 = 0x00B000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSBT_A2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrsbt_a2_a_field_rn_0_min_d0_003000d0() {
    // Encoding: 0x003000D0
    // Test aarch32_LDRSBT_A2_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: U=0, Rt=0, cond=0, Rm=0, Rn=0
    let encoding: u32 = 0x003000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSBT_A2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrsbt_a2_a_field_rn_1_poweroftwo_d0_003100d0() {
    // Encoding: 0x003100D0
    // Test aarch32_LDRSBT_A2_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=1, cond=0, Rt=0, Rm=0, U=0
    let encoding: u32 = 0x003100D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSBT_A2_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrsbt_a2_a_field_rt_0_min_d0_003000d0() {
    // Encoding: 0x003000D0
    // Test aarch32_LDRSBT_A2_A field Rt = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, U=0, cond=0, Rn=0, Rt=0
    let encoding: u32 = 0x003000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSBT_A2_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrsbt_a2_a_field_rt_1_poweroftwo_d0_003010d0() {
    // Encoding: 0x003010D0
    // Test aarch32_LDRSBT_A2_A field Rt = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Rn=0, U=0, Rt=1, Rm=0
    let encoding: u32 = 0x003010D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSBT_A2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrsbt_a2_a_field_rm_0_min_d0_003000d0() {
    // Encoding: 0x003000D0
    // Test aarch32_LDRSBT_A2_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: Rt=0, Rn=0, cond=0, U=0, Rm=0
    let encoding: u32 = 0x003000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSBT_A2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrsbt_a2_a_field_rm_1_poweroftwo_d0_003000d1() {
    // Encoding: 0x003000D1
    // Test aarch32_LDRSBT_A2_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=1, Rt=0, cond=0, Rn=0, U=0
    let encoding: u32 = 0x003000D1;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSBT_A2_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_ldrsbt_a2_a_combo_0_d0_003000d0() {
    // Encoding: 0x003000D0
    // Test aarch32_LDRSBT_A2_A field combination: cond=0, U=0, Rn=0, Rt=0, Rm=0
    // ISET: A32
    // Fields: Rt=0, Rm=0, cond=0, Rn=0, U=0
    let encoding: u32 = 0x003000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSBT_A2_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_ldrsbt_a2_a_special_cond_0_condition_eq_208_003000d0() {
    // Encoding: 0x003000D0
    // Test aarch32_LDRSBT_A2_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: U=0, Rm=0, cond=0, Rt=0, Rn=0
    let encoding: u32 = 0x003000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSBT_A2_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_ldrsbt_a2_a_special_cond_1_condition_ne_208_103000d0() {
    // Encoding: 0x103000D0
    // Test aarch32_LDRSBT_A2_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: Rn=0, Rt=0, Rm=0, U=0, cond=1
    let encoding: u32 = 0x103000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSBT_A2_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_ldrsbt_a2_a_special_cond_2_condition_cs_hs_208_203000d0() {
    // Encoding: 0x203000D0
    // Test aarch32_LDRSBT_A2_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: Rn=0, Rt=0, Rm=0, cond=2, U=0
    let encoding: u32 = 0x203000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSBT_A2_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_ldrsbt_a2_a_special_cond_3_condition_cc_lo_208_303000d0() {
    // Encoding: 0x303000D0
    // Test aarch32_LDRSBT_A2_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: U=0, Rm=0, cond=3, Rn=0, Rt=0
    let encoding: u32 = 0x303000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSBT_A2_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_ldrsbt_a2_a_special_cond_4_condition_mi_208_403000d0() {
    // Encoding: 0x403000D0
    // Test aarch32_LDRSBT_A2_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: U=0, cond=4, Rn=0, Rt=0, Rm=0
    let encoding: u32 = 0x403000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSBT_A2_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_ldrsbt_a2_a_special_cond_5_condition_pl_208_503000d0() {
    // Encoding: 0x503000D0
    // Test aarch32_LDRSBT_A2_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: cond=5, U=0, Rn=0, Rt=0, Rm=0
    let encoding: u32 = 0x503000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSBT_A2_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_ldrsbt_a2_a_special_cond_6_condition_vs_208_603000d0() {
    // Encoding: 0x603000D0
    // Test aarch32_LDRSBT_A2_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: cond=6, Rt=0, Rn=0, Rm=0, U=0
    let encoding: u32 = 0x603000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSBT_A2_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_ldrsbt_a2_a_special_cond_7_condition_vc_208_703000d0() {
    // Encoding: 0x703000D0
    // Test aarch32_LDRSBT_A2_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: Rt=0, cond=7, Rn=0, U=0, Rm=0
    let encoding: u32 = 0x703000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSBT_A2_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_ldrsbt_a2_a_special_cond_8_condition_hi_208_803000d0() {
    // Encoding: 0x803000D0
    // Test aarch32_LDRSBT_A2_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: Rn=0, cond=8, U=0, Rt=0, Rm=0
    let encoding: u32 = 0x803000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSBT_A2_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_ldrsbt_a2_a_special_cond_9_condition_ls_208_903000d0() {
    // Encoding: 0x903000D0
    // Test aarch32_LDRSBT_A2_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: cond=9, Rn=0, U=0, Rt=0, Rm=0
    let encoding: u32 = 0x903000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSBT_A2_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_ldrsbt_a2_a_special_cond_10_condition_ge_208_a03000d0() {
    // Encoding: 0xA03000D0
    // Test aarch32_LDRSBT_A2_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: Rm=0, Rn=0, cond=10, Rt=0, U=0
    let encoding: u32 = 0xA03000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSBT_A2_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_ldrsbt_a2_a_special_cond_11_condition_lt_208_b03000d0() {
    // Encoding: 0xB03000D0
    // Test aarch32_LDRSBT_A2_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: U=0, cond=11, Rn=0, Rm=0, Rt=0
    let encoding: u32 = 0xB03000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSBT_A2_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_ldrsbt_a2_a_special_cond_12_condition_gt_208_c03000d0() {
    // Encoding: 0xC03000D0
    // Test aarch32_LDRSBT_A2_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: cond=12, Rm=0, U=0, Rn=0, Rt=0
    let encoding: u32 = 0xC03000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSBT_A2_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_ldrsbt_a2_a_special_cond_13_condition_le_208_d03000d0() {
    // Encoding: 0xD03000D0
    // Test aarch32_LDRSBT_A2_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: cond=13, U=0, Rt=0, Rm=0, Rn=0
    let encoding: u32 = 0xD03000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSBT_A2_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_ldrsbt_a2_a_special_cond_14_condition_al_208_e03000d0() {
    // Encoding: 0xE03000D0
    // Test aarch32_LDRSBT_A2_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: Rt=0, U=0, cond=14, Rn=0, Rm=0
    let encoding: u32 = 0xE03000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSBT_A2_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_ldrsbt_a2_a_special_cond_15_condition_nv_208_f03000d0() {
    // Encoding: 0xF03000D0
    // Test aarch32_LDRSBT_A2_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: U=0, cond=15, Rt=0, Rn=0, Rm=0
    let encoding: u32 = 0xF03000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSBT_A2_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrsbt_a2_a_invalid_0_d0_003000d0() {
    // Encoding: 0x003000D0
    // Test aarch32_LDRSBT_A2_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }
    // ISET: A32
    // Fields: Rt=0, Rm=0, Rn=0, U=0, cond=0
    let encoding: u32 = 0x003000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRSBT_A2_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrsbt_a2_a_invalid_1_d0_003000d0() {
    // Encoding: 0x003000D0
    // Test aarch32_LDRSBT_A2_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Rn=0, U=0, Rt=0, cond=0, Rm=0
    let encoding: u32 = 0x003000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRSBT_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrsbt_t1_a_field_rn_0_min_e00_f9100e00() {
    // Thumb encoding (32): 0xF9100E00
    // Test aarch32_LDRSBT_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: imm8=0, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9100E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSBT_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrsbt_t1_a_field_rn_1_poweroftwo_e00_f9110e00() {
    // Thumb encoding (32): 0xF9110E00
    // Test aarch32_LDRSBT_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=0, Rn=1, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9110E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSBT_T1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrsbt_t1_a_field_rt_0_min_e00_f9100e00() {
    // Thumb encoding (32): 0xF9100E00
    // Test aarch32_LDRSBT_T1_A field Rt = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9100E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSBT_T1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrsbt_t1_a_field_rt_1_poweroftwo_e00_f9101e00() {
    // Thumb encoding (32): 0xF9101E00
    // Test aarch32_LDRSBT_T1_A field Rt = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=0, Rn=0, Rt=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9101E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSBT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_ldrsbt_t1_a_field_imm8_0_zero_e00_f9100e00() {
    // Thumb encoding (32): 0xF9100E00
    // Test aarch32_LDRSBT_T1_A field imm8 = 0 (Zero)
    // ISET: T32
    // Fields: Rt=0, imm8=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9100E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSBT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_ldrsbt_t1_a_field_imm8_1_poweroftwo_e00_f9100e01() {
    // Thumb encoding (32): 0xF9100E01
    // Test aarch32_LDRSBT_T1_A field imm8 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=1, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9100E01;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSBT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_ldrsbt_t1_a_field_imm8_3_poweroftwominusone_e00_f9100e03() {
    // Thumb encoding (32): 0xF9100E03
    // Test aarch32_LDRSBT_T1_A field imm8 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, imm8=3, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9100E03;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSBT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_ldrsbt_t1_a_field_imm8_4_poweroftwo_e00_f9100e04() {
    // Thumb encoding (32): 0xF9100E04
    // Test aarch32_LDRSBT_T1_A field imm8 = 4 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=4, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9100E04;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSBT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_ldrsbt_t1_a_field_imm8_7_poweroftwominusone_e00_f9100e07() {
    // Thumb encoding (32): 0xF9100E07
    // Test aarch32_LDRSBT_T1_A field imm8 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm8=7, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9100E07;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSBT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_ldrsbt_t1_a_field_imm8_8_poweroftwo_e00_f9100e08() {
    // Thumb encoding (32): 0xF9100E08
    // Test aarch32_LDRSBT_T1_A field imm8 = 8 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, Rn=0, imm8=8
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9100E08;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSBT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_ldrsbt_t1_a_field_imm8_15_poweroftwominusone_e00_f9100e0f() {
    // Thumb encoding (32): 0xF9100E0F
    // Test aarch32_LDRSBT_T1_A field imm8 = 15 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm8=15
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9100E0F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSBT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_ldrsbt_t1_a_field_imm8_16_poweroftwo_e00_f9100e10() {
    // Thumb encoding (32): 0xF9100E10
    // Test aarch32_LDRSBT_T1_A field imm8 = 16 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, imm8=16, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9100E10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSBT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_ldrsbt_t1_a_field_imm8_31_poweroftwominusone_e00_f9100e1f() {
    // Thumb encoding (32): 0xF9100E1F
    // Test aarch32_LDRSBT_T1_A field imm8 = 31 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, Rn=0, imm8=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9100E1F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSBT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_ldrsbt_t1_a_field_imm8_32_poweroftwo_e00_f9100e20() {
    // Thumb encoding (32): 0xF9100E20
    // Test aarch32_LDRSBT_T1_A field imm8 = 32 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, imm8=32, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9100E20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSBT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_ldrsbt_t1_a_field_imm8_63_poweroftwominusone_e00_f9100e3f() {
    // Thumb encoding (32): 0xF9100E3F
    // Test aarch32_LDRSBT_T1_A field imm8 = 63 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, Rn=0, imm8=63
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9100E3F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSBT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_ldrsbt_t1_a_field_imm8_64_poweroftwo_e00_f9100e40() {
    // Thumb encoding (32): 0xF9100E40
    // Test aarch32_LDRSBT_T1_A field imm8 = 64 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm8=64
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9100E40;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSBT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 127, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (127)
#[test]
fn test_aarch32_ldrsbt_t1_a_field_imm8_127_poweroftwominusone_e00_f9100e7f() {
    // Thumb encoding (32): 0xF9100E7F
    // Test aarch32_LDRSBT_T1_A field imm8 = 127 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm8=127, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9100E7F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSBT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_ldrsbt_t1_a_field_imm8_128_poweroftwo_e00_f9100e80() {
    // Thumb encoding (32): 0xF9100E80
    // Test aarch32_LDRSBT_T1_A field imm8 = 128 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, Rn=0, imm8=128
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9100E80;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSBT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 255, boundary: Max }
/// maximum immediate (255)
#[test]
fn test_aarch32_ldrsbt_t1_a_field_imm8_255_max_e00_f9100eff() {
    // Thumb encoding (32): 0xF9100EFF
    // Test aarch32_LDRSBT_T1_A field imm8 = 255 (Max)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm8=255
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9100EFF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSBT_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_ldrsbt_t1_a_combo_0_e00_f9100e00() {
    // Thumb encoding (32): 0xF9100E00
    // Test aarch32_LDRSBT_T1_A field combination: Rn=0, Rt=0, imm8=0
    // ISET: T32
    // Fields: imm8=0, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9100E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSBT_T1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrsbt_t1_a_invalid_0_e00_f9100e00() {
    // Thumb encoding (32): 0xF9100E00
    // Test aarch32_LDRSBT_T1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: LitInt(15) }
    // ISET: T32
    // Fields: Rt=0, imm8=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9100E00;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRSBT_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrsbt_t1_a_invalid_1_e00_f9100e00() {
    // Thumb encoding (32): 0xF9100E00
    // Test aarch32_LDRSBT_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: imm8=0, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9100E00;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRSBT_A1_A
/// ASL: `UMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple multiply
#[test]
fn test_aarch32_ldrsbt_a1_a_umull_oracle_0_9ba27c20() {
    // Test UMULL: simple multiply (oracle)
    // Encoding: 0x9BA27C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3);
    set_w(&mut cpu, 1, 0x2);
    let encoding: u32 = 0x9BA27C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6, "X0 should be 0x0000000000000006");
}

/// Provenance: aarch32_LDRSBT_A1_A
/// ASL: `UMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max 32-bit * 2
#[test]
fn test_aarch32_ldrsbt_a1_a_umull_oracle_1_9ba27c20() {
    // Test UMULL: max 32-bit * 2 (oracle)
    // Encoding: 0x9BA27C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x9BA27C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0x00000001FFFFFFFE"
    );
}

/// Provenance: aarch32_LDRSBT_A1_A
/// ASL: `UMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// large positive * large positive
#[test]
fn test_aarch32_ldrsbt_a1_a_umull_oracle_2_9ba27c20() {
    // Test UMULL: large positive * large positive (oracle)
    // Encoding: 0x9BA27C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    set_w(&mut cpu, 2, 0x7FFFFFFF);
    let encoding: u32 = 0x9BA27C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x3FFFFFFF00000001");
}

/// Provenance: aarch32_LDRSBT_A1_A
/// ASL: `UMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max unsigned * max unsigned
#[test]
fn test_aarch32_ldrsbt_a1_a_umull_oracle_3_9ba27c20() {
    // Test UMULL: max unsigned * max unsigned (oracle)
    // Encoding: 0x9BA27C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x9BA27C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0xFFFFFFFE00000001");
}

/// Provenance: aarch32_LDRSBT_A1_A
/// ASL: `UMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// medium values
#[test]
fn test_aarch32_ldrsbt_a1_a_umull_oracle_4_9ba27c20() {
    // Test UMULL: medium values (oracle)
    // Encoding: 0x9BA27C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xC8);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x9BA27C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4E20, "X0 should be 0x0000000000004E20");
}

/// Provenance: aarch32_LDRSBT_A1_A
/// ASL: `UMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// 16-bit values
#[test]
fn test_aarch32_ldrsbt_a1_a_umull_oracle_5_9ba27c20() {
    // Test UMULL: 16-bit values (oracle)
    // Encoding: 0x9BA27C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x5678);
    set_w(&mut cpu, 1, 0x1234);
    let encoding: u32 = 0x9BA27C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6260060, "X0 should be 0x0000000006260060");
}

/// Provenance: aarch32_LDRSBT_A1_A
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrsbt_a1_a_exception_0_007000d0() {
    // Test aarch32_LDRSBT_A1_A exception: Unpredictable
    // Encoding: 0x007000D0
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x007000D0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_LDRSBT_A2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple multiply (32)
#[test]
fn test_aarch32_ldrsbt_a2_a_mul_oracle_32_0_1b027c20() {
    // Test MUL 32-bit: simple multiply (oracle)
    // Encoding: 0x1B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x2);
    set_w(&mut cpu, 2, 0x3);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6, "W0 should be 0x00000006");
}

/// Provenance: aarch32_LDRSBT_A2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple multiply (64)
#[test]
fn test_aarch32_ldrsbt_a2_a_mul_oracle_64_0_9b027c20() {
    // Test MUL 64-bit: simple multiply (oracle)
    // Encoding: 0x9B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x2);
    set_w(&mut cpu, 2, 0x3);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6, "X0 should be 0x0000000000000006");
}

/// Provenance: aarch32_LDRSBT_A2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// multiply by zero (32)
#[test]
fn test_aarch32_ldrsbt_a2_a_mul_oracle_32_1_1b027c20() {
    // Test MUL 32-bit: multiply by zero (oracle)
    // Encoding: 0x1B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x64);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_LDRSBT_A2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// multiply by zero (64)
#[test]
fn test_aarch32_ldrsbt_a2_a_mul_oracle_64_1_9b027c20() {
    // Test MUL 64-bit: multiply by zero (oracle)
    // Encoding: 0x9B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x64);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_LDRSBT_A2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// multiply by one (32)
#[test]
fn test_aarch32_ldrsbt_a2_a_mul_oracle_32_2_1b027c20() {
    // Test MUL 32-bit: multiply by one (oracle)
    // Encoding: 0x1B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_LDRSBT_A2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// multiply by one (64)
#[test]
fn test_aarch32_ldrsbt_a2_a_mul_oracle_64_2_9b027c20() {
    // Test MUL 64-bit: multiply by one (oracle)
    // Encoding: 0x9B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x0000000000000001");
}

/// Provenance: aarch32_LDRSBT_A2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// 16-bit max * 16-bit max (32)
#[test]
fn test_aarch32_ldrsbt_a2_a_mul_oracle_32_3_1b027c20() {
    // Test MUL 32-bit: 16-bit max * 16-bit max (oracle)
    // Encoding: 0x1B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFF);
    set_w(&mut cpu, 2, 0xFFFF);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFE0001, "W0 should be 0xFFFE0001");
}

/// Provenance: aarch32_LDRSBT_A2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// 16-bit max * 16-bit max (64)
#[test]
fn test_aarch32_ldrsbt_a2_a_mul_oracle_64_3_9b027c20() {
    // Test MUL 64-bit: 16-bit max * 16-bit max (oracle)
    // Encoding: 0x9B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFF);
    set_w(&mut cpu, 1, 0xFFFF);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFE0001,
        "X0 should be 0x00000000FFFE0001"
    );
}

/// Provenance: aarch32_LDRSBT_A2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift-like multiply (32)
#[test]
fn test_aarch32_ldrsbt_a2_a_mul_oracle_32_4_1b027c20() {
    // Test MUL 32-bit: shift-like multiply (oracle)
    // Encoding: 0x1B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x2468ACF0, "W0 should be 0x2468ACF0");
}

/// Provenance: aarch32_LDRSBT_A2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift-like multiply (64)
#[test]
fn test_aarch32_ldrsbt_a2_a_mul_oracle_64_4_9b027c20() {
    // Test MUL 64-bit: shift-like multiply (oracle)
    // Encoding: 0x9B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x2468ACF0,
        "X0 should be 0x000000002468ACF0"
    );
}

/// Provenance: aarch32_LDRSBT_A2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// larger values (32)
#[test]
fn test_aarch32_ldrsbt_a2_a_mul_oracle_32_5_1b027c20() {
    // Test MUL 32-bit: larger values (oracle)
    // Encoding: 0x1B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0xC8);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4E20, "W0 should be 0x00004E20");
}

/// Provenance: aarch32_LDRSBT_A2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// larger values (64)
#[test]
fn test_aarch32_ldrsbt_a2_a_mul_oracle_64_5_9b027c20() {
    // Test MUL 64-bit: larger values (oracle)
    // Encoding: 0x9B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xC8);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4E20, "X0 should be 0x0000000000004E20");
}

/// Provenance: aarch32_LDRSBT_A2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// 32-bit overflow (32)
#[test]
fn test_aarch32_ldrsbt_a2_a_mul_oracle_32_6_1b027c20() {
    // Test MUL 32-bit: 32-bit overflow (oracle)
    // Encoding: 0x1B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_LDRSBT_A2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// 32-bit overflow (64)
#[test]
fn test_aarch32_ldrsbt_a2_a_mul_oracle_64_6_9b027c20() {
    // Test MUL 64-bit: 32-bit overflow (oracle)
    // Encoding: 0x9B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0xFFFFFFFE00000001");
}

/// Provenance: aarch32_LDRSBT_A2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// prime numbers (32)
#[test]
fn test_aarch32_ldrsbt_a2_a_mul_oracle_32_7_1b027c20() {
    // Test MUL 32-bit: prime numbers (oracle)
    // Encoding: 0x1B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7);
    set_w(&mut cpu, 2, 0xB);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4D, "W0 should be 0x0000004D");
}

/// Provenance: aarch32_LDRSBT_A2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// prime numbers (64)
#[test]
fn test_aarch32_ldrsbt_a2_a_mul_oracle_64_7_9b027c20() {
    // Test MUL 64-bit: prime numbers (oracle)
    // Encoding: 0x9B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7);
    set_w(&mut cpu, 2, 0xB);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4D, "X0 should be 0x000000000000004D");
}

/// Provenance: aarch32_LDRSBT_A2_A
/// ASL: `MLA R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple values
#[test]
fn test_aarch32_ldrsbt_a2_a_a32_mul_0_0020f291() {
    // Test A32 MLA: simple values (oracle)
    // Encoding: 0x0020F291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x32);
    let encoding: u32 = 0x0020F291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1388, "R0 should be 0x00001388");
}

/// Provenance: aarch32_LDRSBT_A2_A
/// ASL: `MLA R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero values
#[test]
fn test_aarch32_ldrsbt_a2_a_a32_mul_1_0020f291() {
    // Test A32 MLA: zero values (oracle)
    // Encoding: 0x0020F291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x0020F291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_LDRSBT_A2_A
/// ASL: `MLA R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max value
#[test]
fn test_aarch32_ldrsbt_a2_a_a32_mul_2_0020f291() {
    // Test A32 MLA: max value (oracle)
    // Encoding: 0x0020F291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x0020F291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "R0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_LDRSBT_A2_A
/// ASL: `MLA R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set
#[test]
fn test_aarch32_ldrsbt_a2_a_a32_mul_3_0020f291() {
    // Test A32 MLA: MSB set (oracle)
    // Encoding: 0x0020F291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    set_w(&mut cpu, 2, 0x80000000);
    let encoding: u32 = 0x0020F291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_LDRSBT_A2_A
/// ASL: `MLA R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// mixed pattern
#[test]
fn test_aarch32_ldrsbt_a2_a_a32_mul_4_0020f291() {
    // Test A32 MLA: mixed pattern (oracle)
    // Encoding: 0x0020F291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x9ABCDEF0);
    let encoding: u32 = 0x0020F291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x242D2080, "R0 should be 0x242D2080");
}

/// Provenance: aarch32_LDRSBT_A2_A
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrsbt_a2_a_exception_0_003000d0() {
    // Test aarch32_LDRSBT_A2_A exception: Unpredictable
    // Encoding: 0x003000D0
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x003000D0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_LDRSBT_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple division (32)
#[test]
fn test_aarch32_ldrsbt_t1_a_udiv_oracle_32_0_1ac20820() {
    // Test UDIV 32-bit: simple division (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xA);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA, "W0 should be 0x0000000A");
}

/// Provenance: aarch32_LDRSBT_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple division (64)
#[test]
fn test_aarch32_ldrsbt_t1_a_udiv_oracle_64_0_9ac20820() {
    // Test UDIV 64-bit: simple division (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0xA);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA, "X0 should be 0x000000000000000A");
}

/// Provenance: aarch32_LDRSBT_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// division with remainder (32)
#[test]
fn test_aarch32_ldrsbt_t1_a_udiv_oracle_32_1_1ac20820() {
    // Test UDIV 32-bit: division with remainder (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x3);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x21, "W0 should be 0x00000021");
}

/// Provenance: aarch32_LDRSBT_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// division with remainder (64)
#[test]
fn test_aarch32_ldrsbt_t1_a_udiv_oracle_64_1_9ac20820() {
    // Test UDIV 64-bit: division with remainder (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x3);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x21, "X0 should be 0x0000000000000021");
}

/// Provenance: aarch32_LDRSBT_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero dividend (32)
#[test]
fn test_aarch32_ldrsbt_t1_a_udiv_oracle_32_2_1ac20820() {
    // Test UDIV 32-bit: zero dividend (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xA);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_LDRSBT_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero dividend (64)
#[test]
fn test_aarch32_ldrsbt_t1_a_udiv_oracle_64_2_9ac20820() {
    // Test UDIV 64-bit: zero dividend (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xA);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_LDRSBT_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// divide by zero - result is 0 (32)
#[test]
fn test_aarch32_ldrsbt_t1_a_udiv_oracle_32_3_1ac20820() {
    // Test UDIV 32-bit: divide by zero - result is 0 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xA);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_LDRSBT_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// divide by zero - result is 0 (64)
#[test]
fn test_aarch32_ldrsbt_t1_a_udiv_oracle_64_3_9ac20820() {
    // Test UDIV 64-bit: divide by zero - result is 0 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xA);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_LDRSBT_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max value / 2 (32)
#[test]
fn test_aarch32_ldrsbt_t1_a_udiv_oracle_32_4_1ac20820() {
    // Test UDIV 32-bit: max value / 2 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FFFFFFF, "W0 should be 0x7FFFFFFF");
}

/// Provenance: aarch32_LDRSBT_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max value / 2 (64)
#[test]
fn test_aarch32_ldrsbt_t1_a_udiv_oracle_64_4_9ac20820() {
    // Test UDIV 64-bit: max value / 2 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0x7FFFFFFFFFFFFFFF"
    );
}

/// Provenance: aarch32_LDRSBT_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set / 2 (32)
#[test]
fn test_aarch32_ldrsbt_t1_a_udiv_oracle_32_5_1ac20820() {
    // Test UDIV 32-bit: MSB set / 2 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_LDRSBT_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// MSB set / 2 (64)
#[test]
fn test_aarch32_ldrsbt_t1_a_udiv_oracle_64_5_9ac20820() {
    // Test UDIV 64-bit: MSB set / 2 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x4000000000000000");
}

/// Provenance: aarch32_LDRSBT_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// self-division (32)
#[test]
fn test_aarch32_ldrsbt_t1_a_udiv_oracle_32_6_1ac20820() {
    // Test UDIV 32-bit: self-division (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7);
    set_w(&mut cpu, 2, 0x7);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_LDRSBT_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// self-division (64)
#[test]
fn test_aarch32_ldrsbt_t1_a_udiv_oracle_64_6_9ac20820() {
    // Test UDIV 64-bit: self-division (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7);
    set_w(&mut cpu, 2, 0x7);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x0000000000000001");
}

/// Provenance: aarch32_LDRSBT_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// one / one (32)
#[test]
fn test_aarch32_ldrsbt_t1_a_udiv_oracle_32_7_1ac20820() {
    // Test UDIV 32-bit: one / one (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_LDRSBT_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// one / one (64)
#[test]
fn test_aarch32_ldrsbt_t1_a_udiv_oracle_64_7_9ac20820() {
    // Test UDIV 64-bit: one / one (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x0000000000000001");
}

/// Provenance: aarch32_LDRSBT_T1_A
/// ASL: `UDIV R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// exact division
#[test]
fn test_aarch32_ldrsbt_t1_a_t32_oracle_0_f9110e00() {
    // Test T32 UDIV: exact division (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0xA);
    let encoding: u32 = 0xF9110E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA, "R0 should be 0x0000000A");
}

/// Provenance: aarch32_LDRSBT_T1_A
/// ASL: `UDIV R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// with remainder
#[test]
fn test_aarch32_ldrsbt_t1_a_t32_oracle_1_f9110e00() {
    // Test T32 UDIV: with remainder (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF9110E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x21, "R0 should be 0x00000021");
}

/// Provenance: aarch32_LDRSBT_T1_A
/// ASL: `UDIV R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero dividend
#[test]
fn test_aarch32_ldrsbt_t1_a_t32_oracle_2_f9110e00() {
    // Test T32 UDIV: zero dividend (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xA);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF9110E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_LDRSBT_T1_A
/// ASL: `UDIV R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// divide by zero
#[test]
fn test_aarch32_ldrsbt_t1_a_t32_oracle_3_f9110e00() {
    // Test T32 UDIV: divide by zero (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xA);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xF9110E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_LDRSBT_T1_A
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrsbt_t1_a_exception_0_f9100e00() {
    // Test aarch32_LDRSBT_T1_A exception: Unpredictable
    // ISET: T32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF9100E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// aarch32_LDRSB_r_A Tests
// ============================================================================

/// Provenance: aarch32_LDRSB_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_ldrsb_r_a1_a_field_cond_0_min_d0_001000d0() {
    // Encoding: 0x001000D0
    // Test aarch32_LDRSB_r_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: P=0, cond=0, Rm=0, W=0, Rn=0, U=0, Rt=0
    let encoding: u32 = 0x001000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_ldrsb_r_a1_a_field_cond_1_poweroftwo_d0_101000d0() {
    // Encoding: 0x101000D0
    // Test aarch32_LDRSB_r_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=1, Rn=0, W=0, Rt=0, Rm=0, U=0, P=0
    let encoding: u32 = 0x101000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_ldrsb_r_a1_a_field_cond_2_poweroftwo_d0_201000d0() {
    // Encoding: 0x201000D0
    // Test aarch32_LDRSB_r_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=2, W=0, U=0, P=0, Rt=0, Rm=0
    let encoding: u32 = 0x201000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_ldrsb_r_a1_a_field_cond_3_poweroftwo_d0_301000d0() {
    // Encoding: 0x301000D0
    // Test aarch32_LDRSB_r_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, U=0, Rt=0, Rm=0, cond=3, P=0, W=0
    let encoding: u32 = 0x301000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_ldrsb_r_a1_a_field_cond_4_poweroftwo_d0_401000d0() {
    // Encoding: 0x401000D0
    // Test aarch32_LDRSB_r_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, cond=4, Rn=0, U=0, W=0, Rt=0, P=0
    let encoding: u32 = 0x401000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_ldrsb_r_a1_a_field_cond_5_poweroftwo_d0_501000d0() {
    // Encoding: 0x501000D0
    // Test aarch32_LDRSB_r_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, Rn=0, U=0, W=0, Rt=0, Rm=0, cond=5
    let encoding: u32 = 0x501000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_ldrsb_r_a1_a_field_cond_6_poweroftwo_d0_601000d0() {
    // Encoding: 0x601000D0
    // Test aarch32_LDRSB_r_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=6, U=0, P=0, Rn=0, Rm=0, Rt=0, W=0
    let encoding: u32 = 0x601000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_ldrsb_r_a1_a_field_cond_7_poweroftwo_d0_701000d0() {
    // Encoding: 0x701000D0
    // Test aarch32_LDRSB_r_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, Rn=0, P=0, Rm=0, cond=7, W=0, Rt=0
    let encoding: u32 = 0x701000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_ldrsb_r_a1_a_field_cond_8_poweroftwo_d0_801000d0() {
    // Encoding: 0x801000D0
    // Test aarch32_LDRSB_r_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, Rm=0, Rn=0, P=0, cond=8, U=0, W=0
    let encoding: u32 = 0x801000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_ldrsb_r_a1_a_field_cond_9_poweroftwo_d0_901000d0() {
    // Encoding: 0x901000D0
    // Test aarch32_LDRSB_r_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=9, Rt=0, U=0, P=0, W=0, Rm=0
    let encoding: u32 = 0x901000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_ldrsb_r_a1_a_field_cond_10_poweroftwo_d0_a01000d0() {
    // Encoding: 0xA01000D0
    // Test aarch32_LDRSB_r_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, Rm=0, cond=10, U=0, P=0, W=0, Rn=0
    let encoding: u32 = 0xA01000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_ldrsb_r_a1_a_field_cond_11_poweroftwo_d0_b01000d0() {
    // Encoding: 0xB01000D0
    // Test aarch32_LDRSB_r_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, U=0, W=0, cond=11, Rn=0, Rt=0, Rm=0
    let encoding: u32 = 0xB01000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_ldrsb_r_a1_a_field_cond_12_poweroftwo_d0_c01000d0() {
    // Encoding: 0xC01000D0
    // Test aarch32_LDRSB_r_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, Rt=0, Rn=0, Rm=0, cond=12, P=0, U=0
    let encoding: u32 = 0xC01000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_ldrsb_r_a1_a_field_cond_13_poweroftwo_d0_d01000d0() {
    // Encoding: 0xD01000D0
    // Test aarch32_LDRSB_r_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, W=0, cond=13, P=0, U=0, Rn=0, Rt=0
    let encoding: u32 = 0xD01000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_ldrsb_r_a1_a_field_cond_14_poweroftwo_d0_e01000d0() {
    // Encoding: 0xE01000D0
    // Test aarch32_LDRSB_r_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, cond=14, Rm=0, Rn=0, Rt=0, W=0, U=0
    let encoding: u32 = 0xE01000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_ldrsb_r_a1_a_field_cond_15_max_d0_f01000d0() {
    // Encoding: 0xF01000D0
    // Test aarch32_LDRSB_r_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: P=0, Rt=0, cond=15, Rn=0, U=0, Rm=0, W=0
    let encoding: u32 = 0xF01000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_r_A1_A
/// ASL: `field P 24 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldrsb_r_a1_a_field_p_0_min_d0_001000d0() {
    // Encoding: 0x001000D0
    // Test aarch32_LDRSB_r_A1_A field P = 0 (Min)
    // ISET: A32
    // Fields: Rt=0, Rn=0, U=0, Rm=0, W=0, cond=0, P=0
    let encoding: u32 = 0x001000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_r_A1_A
/// ASL: `field P 24 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldrsb_r_a1_a_field_p_1_max_d0_011000d0() {
    // Encoding: 0x011000D0
    // Test aarch32_LDRSB_r_A1_A field P = 1 (Max)
    // ISET: A32
    // Fields: W=0, Rt=0, Rm=0, cond=0, Rn=0, P=1, U=0
    let encoding: u32 = 0x011000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_r_A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldrsb_r_a1_a_field_u_0_min_d0_001000d0() {
    // Encoding: 0x001000D0
    // Test aarch32_LDRSB_r_A1_A field U = 0 (Min)
    // ISET: A32
    // Fields: U=0, Rn=0, Rm=0, Rt=0, cond=0, P=0, W=0
    let encoding: u32 = 0x001000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_r_A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldrsb_r_a1_a_field_u_1_max_d0_009000d0() {
    // Encoding: 0x009000D0
    // Test aarch32_LDRSB_r_A1_A field U = 1 (Max)
    // ISET: A32
    // Fields: Rt=0, U=1, Rn=0, Rm=0, cond=0, P=0, W=0
    let encoding: u32 = 0x009000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_r_A1_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldrsb_r_a1_a_field_w_0_min_d0_001000d0() {
    // Encoding: 0x001000D0
    // Test aarch32_LDRSB_r_A1_A field W = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, U=0, Rt=0, P=0, W=0, Rm=0, cond=0
    let encoding: u32 = 0x001000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_r_A1_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldrsb_r_a1_a_field_w_1_max_d0_003000d0() {
    // Encoding: 0x003000D0
    // Test aarch32_LDRSB_r_A1_A field W = 1 (Max)
    // ISET: A32
    // Fields: Rm=0, Rt=0, U=0, cond=0, P=0, W=1, Rn=0
    let encoding: u32 = 0x003000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_r_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrsb_r_a1_a_field_rn_0_min_d0_001000d0() {
    // Encoding: 0x001000D0
    // Test aarch32_LDRSB_r_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: U=0, Rt=0, P=0, W=0, Rn=0, Rm=0, cond=0
    let encoding: u32 = 0x001000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_r_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrsb_r_a1_a_field_rn_1_poweroftwo_d0_001100d0() {
    // Encoding: 0x001100D0
    // Test aarch32_LDRSB_r_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=1, cond=0, W=0, Rm=0, U=0, Rt=0, P=0
    let encoding: u32 = 0x001100D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_r_A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrsb_r_a1_a_field_rt_0_min_d0_001000d0() {
    // Encoding: 0x001000D0
    // Test aarch32_LDRSB_r_A1_A field Rt = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, P=0, cond=0, W=0, U=0, Rn=0, Rt=0
    let encoding: u32 = 0x001000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_r_A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrsb_r_a1_a_field_rt_1_poweroftwo_d0_001010d0() {
    // Encoding: 0x001010D0
    // Test aarch32_LDRSB_r_A1_A field Rt = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, cond=0, Rt=1, Rm=0, P=0, W=0, Rn=0
    let encoding: u32 = 0x001010D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_r_A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrsb_r_a1_a_field_rm_0_min_d0_001000d0() {
    // Encoding: 0x001000D0
    // Test aarch32_LDRSB_r_A1_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: cond=0, W=0, U=0, Rn=0, Rt=0, P=0, Rm=0
    let encoding: u32 = 0x001000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_r_A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrsb_r_a1_a_field_rm_1_poweroftwo_d0_001000d1() {
    // Encoding: 0x001000D1
    // Test aarch32_LDRSB_r_A1_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=0, P=0, W=0, U=0, Rm=1, Rt=0
    let encoding: u32 = 0x001000D1;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_r_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_ldrsb_r_a1_a_combo_0_d0_001000d0() {
    // Encoding: 0x001000D0
    // Test aarch32_LDRSB_r_A1_A field combination: cond=0, P=0, U=0, W=0, Rn=0, Rt=0, Rm=0
    // ISET: A32
    // Fields: P=0, cond=0, W=0, Rt=0, Rn=0, Rm=0, U=0
    let encoding: u32 = 0x001000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_r_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_ldrsb_r_a1_a_special_cond_0_condition_eq_208_001000d0() {
    // Encoding: 0x001000D0
    // Test aarch32_LDRSB_r_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: P=0, Rm=0, U=0, W=0, Rn=0, Rt=0, cond=0
    let encoding: u32 = 0x001000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_r_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_ldrsb_r_a1_a_special_cond_1_condition_ne_208_101000d0() {
    // Encoding: 0x101000D0
    // Test aarch32_LDRSB_r_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: cond=1, W=0, Rn=0, Rt=0, U=0, Rm=0, P=0
    let encoding: u32 = 0x101000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_r_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_ldrsb_r_a1_a_special_cond_2_condition_cs_hs_208_201000d0() {
    // Encoding: 0x201000D0
    // Test aarch32_LDRSB_r_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: P=0, Rt=0, U=0, cond=2, W=0, Rn=0, Rm=0
    let encoding: u32 = 0x201000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_r_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_ldrsb_r_a1_a_special_cond_3_condition_cc_lo_208_301000d0() {
    // Encoding: 0x301000D0
    // Test aarch32_LDRSB_r_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: Rn=0, cond=3, P=0, W=0, U=0, Rt=0, Rm=0
    let encoding: u32 = 0x301000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_r_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_ldrsb_r_a1_a_special_cond_4_condition_mi_208_401000d0() {
    // Encoding: 0x401000D0
    // Test aarch32_LDRSB_r_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: Rn=0, Rm=0, P=0, Rt=0, U=0, cond=4, W=0
    let encoding: u32 = 0x401000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_r_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_ldrsb_r_a1_a_special_cond_5_condition_pl_208_501000d0() {
    // Encoding: 0x501000D0
    // Test aarch32_LDRSB_r_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: P=0, Rt=0, U=0, W=0, cond=5, Rm=0, Rn=0
    let encoding: u32 = 0x501000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_r_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_ldrsb_r_a1_a_special_cond_6_condition_vs_208_601000d0() {
    // Encoding: 0x601000D0
    // Test aarch32_LDRSB_r_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: Rm=0, W=0, Rt=0, P=0, cond=6, U=0, Rn=0
    let encoding: u32 = 0x601000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_r_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_ldrsb_r_a1_a_special_cond_7_condition_vc_208_701000d0() {
    // Encoding: 0x701000D0
    // Test aarch32_LDRSB_r_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: cond=7, U=0, W=0, Rn=0, Rt=0, Rm=0, P=0
    let encoding: u32 = 0x701000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_r_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_ldrsb_r_a1_a_special_cond_8_condition_hi_208_801000d0() {
    // Encoding: 0x801000D0
    // Test aarch32_LDRSB_r_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: W=0, P=0, U=0, Rt=0, cond=8, Rn=0, Rm=0
    let encoding: u32 = 0x801000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_r_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_ldrsb_r_a1_a_special_cond_9_condition_ls_208_901000d0() {
    // Encoding: 0x901000D0
    // Test aarch32_LDRSB_r_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: cond=9, Rn=0, U=0, P=0, Rm=0, W=0, Rt=0
    let encoding: u32 = 0x901000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_r_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_ldrsb_r_a1_a_special_cond_10_condition_ge_208_a01000d0() {
    // Encoding: 0xA01000D0
    // Test aarch32_LDRSB_r_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: P=0, U=0, W=0, Rm=0, cond=10, Rn=0, Rt=0
    let encoding: u32 = 0xA01000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_r_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_ldrsb_r_a1_a_special_cond_11_condition_lt_208_b01000d0() {
    // Encoding: 0xB01000D0
    // Test aarch32_LDRSB_r_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: Rn=0, P=0, U=0, W=0, Rt=0, cond=11, Rm=0
    let encoding: u32 = 0xB01000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_r_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_ldrsb_r_a1_a_special_cond_12_condition_gt_208_c01000d0() {
    // Encoding: 0xC01000D0
    // Test aarch32_LDRSB_r_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: W=0, Rm=0, Rn=0, U=0, P=0, Rt=0, cond=12
    let encoding: u32 = 0xC01000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_r_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_ldrsb_r_a1_a_special_cond_13_condition_le_208_d01000d0() {
    // Encoding: 0xD01000D0
    // Test aarch32_LDRSB_r_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: Rt=0, Rm=0, Rn=0, cond=13, U=0, W=0, P=0
    let encoding: u32 = 0xD01000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_r_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_ldrsb_r_a1_a_special_cond_14_condition_al_208_e01000d0() {
    // Encoding: 0xE01000D0
    // Test aarch32_LDRSB_r_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: P=0, Rn=0, Rt=0, U=0, W=0, Rm=0, cond=14
    let encoding: u32 = 0xE01000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_r_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_ldrsb_r_a1_a_special_cond_15_condition_nv_208_f01000d0() {
    // Encoding: 0xF01000D0
    // Test aarch32_LDRSB_r_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: Rt=0, Rm=0, cond=15, W=0, P=0, U=0, Rn=0
    let encoding: u32 = 0xF01000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_r_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrsb_r_a1_a_invalid_0_d0_001000d0() {
    // Encoding: 0x001000D0
    // Test aarch32_LDRSB_r_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }
    // ISET: A32
    // Fields: P=0, W=0, Rm=0, U=0, Rt=0, cond=0, Rn=0
    let encoding: u32 = 0x001000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRSB_r_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrsb_r_a1_a_invalid_1_d0_001000d0() {
    // Encoding: 0x001000D0
    // Test aarch32_LDRSB_r_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: W=0, cond=0, U=0, P=0, Rn=0, Rt=0, Rm=0
    let encoding: u32 = 0x001000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRSB_r_A1_A
/// ASL: `Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"wback\" }), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }) } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrsb_r_a1_a_invalid_2_d0_001000d0() {
    // Encoding: 0x001000D0
    // Test aarch32_LDRSB_r_A1_A invalid encoding: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) } }
    // ISET: A32
    // Fields: W=0, Rn=0, Rm=0, P=0, Rt=0, U=0, cond=0
    let encoding: u32 = 0x001000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRSB_r_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrsb_r_a1_a_invalid_3_d0_001000d0() {
    // Encoding: 0x001000D0
    // Test aarch32_LDRSB_r_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: P=0, U=0, cond=0, Rn=0, Rt=0, W=0, Rm=0
    let encoding: u32 = 0x001000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRSB_r_T1_A
/// ASL: `field Rm 22 +: 3`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrsb_r_t1_a_field_rm_0_min_0_56000000() {
    // Thumb encoding (32): 0x56000000
    // Test aarch32_LDRSB_r_T1_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rm=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x56000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_r_T1_A
/// ASL: `field Rm 22 +: 3`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrsb_r_t1_a_field_rm_1_poweroftwo_0_56400000() {
    // Thumb encoding (32): 0x56400000
    // Test aarch32_LDRSB_r_T1_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=1, Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x56400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_r_T1_A
/// ASL: `field Rn 19 +: 3`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrsb_r_t1_a_field_rn_0_min_0_56000000() {
    // Thumb encoding (32): 0x56000000
    // Test aarch32_LDRSB_r_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rt=0, Rm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x56000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_r_T1_A
/// ASL: `field Rn 19 +: 3`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrsb_r_t1_a_field_rn_1_poweroftwo_0_56080000() {
    // Thumb encoding (32): 0x56080000
    // Test aarch32_LDRSB_r_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=0, Rn=1, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x56080000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_r_T1_A
/// ASL: `field Rt 16 +: 3`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrsb_r_t1_a_field_rt_0_min_0_56000000() {
    // Thumb encoding (32): 0x56000000
    // Test aarch32_LDRSB_r_T1_A field Rt = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rt=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x56000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_r_T1_A
/// ASL: `field Rt 16 +: 3`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrsb_r_t1_a_field_rt_1_poweroftwo_0_56010000() {
    // Thumb encoding (32): 0x56010000
    // Test aarch32_LDRSB_r_T1_A field Rt = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=1, Rm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x56010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_r_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch32_ldrsb_r_t1_a_combo_0_0_56000000() {
    // Thumb encoding (32): 0x56000000
    // Test aarch32_LDRSB_r_T1_A field combination: Rm=0, Rn=0, Rt=0
    // ISET: T32
    // Fields: Rt=0, Rn=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x56000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_r_T2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrsb_r_t2_a_field_rn_0_min_0_f9100000() {
    // Thumb encoding (32): 0xF9100000
    // Test aarch32_LDRSB_r_T2_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rt=0, Rm=0, imm2=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9100000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_r_T2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrsb_r_t2_a_field_rn_1_poweroftwo_0_f9110000() {
    // Thumb encoding (32): 0xF9110000
    // Test aarch32_LDRSB_r_T2_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=0, Rn=1, Rt=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9110000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_r_T2_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrsb_r_t2_a_field_rt_0_min_0_f9100000() {
    // Thumb encoding (32): 0xF9100000
    // Test aarch32_LDRSB_r_T2_A field Rt = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rm=0, Rt=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9100000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_r_T2_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrsb_r_t2_a_field_rt_1_poweroftwo_0_f9101000() {
    // Thumb encoding (32): 0xF9101000
    // Test aarch32_LDRSB_r_T2_A field Rt = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=1, imm2=0, Rm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9101000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_r_T2_A
/// ASL: `field imm2 4 +: 2`
/// Requirement: FieldBoundary { field: "imm2", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_ldrsb_r_t2_a_field_imm2_0_zero_0_f9100000() {
    // Thumb encoding (32): 0xF9100000
    // Test aarch32_LDRSB_r_T2_A field imm2 = 0 (Zero)
    // ISET: T32
    // Fields: Rm=0, imm2=0, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9100000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_r_T2_A
/// ASL: `field imm2 4 +: 2`
/// Requirement: FieldBoundary { field: "imm2", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_ldrsb_r_t2_a_field_imm2_1_poweroftwo_0_f9100010() {
    // Thumb encoding (32): 0xF9100010
    // Test aarch32_LDRSB_r_T2_A field imm2 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, Rm=0, imm2=1, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9100010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_r_T2_A
/// ASL: `field imm2 4 +: 2`
/// Requirement: FieldBoundary { field: "imm2", value: 3, boundary: Max }
/// maximum immediate (3)
#[test]
fn test_aarch32_ldrsb_r_t2_a_field_imm2_3_max_0_f9100030() {
    // Thumb encoding (32): 0xF9100030
    // Test aarch32_LDRSB_r_T2_A field imm2 = 3 (Max)
    // ISET: T32
    // Fields: Rm=0, Rn=0, Rt=0, imm2=3
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9100030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_r_T2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrsb_r_t2_a_field_rm_0_min_0_f9100000() {
    // Thumb encoding (32): 0xF9100000
    // Test aarch32_LDRSB_r_T2_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, imm2=0, Rt=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9100000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_r_T2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrsb_r_t2_a_field_rm_1_poweroftwo_0_f9100001() {
    // Thumb encoding (32): 0xF9100001
    // Test aarch32_LDRSB_r_T2_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, imm2=0, Rm=1, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9100001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_r_T2_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_ldrsb_r_t2_a_combo_0_0_f9100000() {
    // Thumb encoding (32): 0xF9100000
    // Test aarch32_LDRSB_r_T2_A field combination: Rn=0, Rt=0, imm2=0, Rm=0
    // ISET: T32
    // Fields: Rn=0, imm2=0, Rt=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9100000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_r_T2_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }), rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }), rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrsb_r_t2_a_invalid_0_0_f9100000() {
    // Thumb encoding (32): 0xF9100000
    // Test aarch32_LDRSB_r_T2_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }), rhs: LitInt(15) }
    // ISET: T32
    // Fields: Rm=0, Rn=0, Rt=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9100000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRSB_r_T2_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrsb_r_t2_a_invalid_1_0_f9100000() {
    // Thumb encoding (32): 0xF9100000
    // Test aarch32_LDRSB_r_T2_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rt=0, Rn=0, imm2=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9100000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRSB_r_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple multiply (32)
#[test]
fn test_aarch32_ldrsb_r_a1_a_mul_oracle_32_0_1b027c20() {
    // Test MUL 32-bit: simple multiply (oracle)
    // Encoding: 0x1B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3);
    set_w(&mut cpu, 1, 0x2);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6, "W0 should be 0x00000006");
}

/// Provenance: aarch32_LDRSB_r_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple multiply (64)
#[test]
fn test_aarch32_ldrsb_r_a1_a_mul_oracle_64_0_9b027c20() {
    // Test MUL 64-bit: simple multiply (oracle)
    // Encoding: 0x9B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x2);
    set_w(&mut cpu, 2, 0x3);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6, "X0 should be 0x0000000000000006");
}

/// Provenance: aarch32_LDRSB_r_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// multiply by zero (32)
#[test]
fn test_aarch32_ldrsb_r_a1_a_mul_oracle_32_1_1b027c20() {
    // Test MUL 32-bit: multiply by zero (oracle)
    // Encoding: 0x1B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x64);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_LDRSB_r_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// multiply by zero (64)
#[test]
fn test_aarch32_ldrsb_r_a1_a_mul_oracle_64_1_9b027c20() {
    // Test MUL 64-bit: multiply by zero (oracle)
    // Encoding: 0x9B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x64);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_LDRSB_r_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// multiply by one (32)
#[test]
fn test_aarch32_ldrsb_r_a1_a_mul_oracle_32_2_1b027c20() {
    // Test MUL 32-bit: multiply by one (oracle)
    // Encoding: 0x1B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_LDRSB_r_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// multiply by one (64)
#[test]
fn test_aarch32_ldrsb_r_a1_a_mul_oracle_64_2_9b027c20() {
    // Test MUL 64-bit: multiply by one (oracle)
    // Encoding: 0x9B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x0000000000000001");
}

/// Provenance: aarch32_LDRSB_r_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// 16-bit max * 16-bit max (32)
#[test]
fn test_aarch32_ldrsb_r_a1_a_mul_oracle_32_3_1b027c20() {
    // Test MUL 32-bit: 16-bit max * 16-bit max (oracle)
    // Encoding: 0x1B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFF);
    set_w(&mut cpu, 1, 0xFFFF);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFE0001, "W0 should be 0xFFFE0001");
}

/// Provenance: aarch32_LDRSB_r_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// 16-bit max * 16-bit max (64)
#[test]
fn test_aarch32_ldrsb_r_a1_a_mul_oracle_64_3_9b027c20() {
    // Test MUL 64-bit: 16-bit max * 16-bit max (oracle)
    // Encoding: 0x9B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFF);
    set_w(&mut cpu, 1, 0xFFFF);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFE0001,
        "X0 should be 0x00000000FFFE0001"
    );
}

/// Provenance: aarch32_LDRSB_r_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift-like multiply (32)
#[test]
fn test_aarch32_ldrsb_r_a1_a_mul_oracle_32_4_1b027c20() {
    // Test MUL 32-bit: shift-like multiply (oracle)
    // Encoding: 0x1B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x2468ACF0, "W0 should be 0x2468ACF0");
}

/// Provenance: aarch32_LDRSB_r_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift-like multiply (64)
#[test]
fn test_aarch32_ldrsb_r_a1_a_mul_oracle_64_4_9b027c20() {
    // Test MUL 64-bit: shift-like multiply (oracle)
    // Encoding: 0x9B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x2468ACF0,
        "X0 should be 0x000000002468ACF0"
    );
}

/// Provenance: aarch32_LDRSB_r_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// larger values (32)
#[test]
fn test_aarch32_ldrsb_r_a1_a_mul_oracle_32_5_1b027c20() {
    // Test MUL 32-bit: larger values (oracle)
    // Encoding: 0x1B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0xC8);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4E20, "W0 should be 0x00004E20");
}

/// Provenance: aarch32_LDRSB_r_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// larger values (64)
#[test]
fn test_aarch32_ldrsb_r_a1_a_mul_oracle_64_5_9b027c20() {
    // Test MUL 64-bit: larger values (oracle)
    // Encoding: 0x9B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xC8);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4E20, "X0 should be 0x0000000000004E20");
}

/// Provenance: aarch32_LDRSB_r_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// 32-bit overflow (32)
#[test]
fn test_aarch32_ldrsb_r_a1_a_mul_oracle_32_6_1b027c20() {
    // Test MUL 32-bit: 32-bit overflow (oracle)
    // Encoding: 0x1B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_LDRSB_r_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// 32-bit overflow (64)
#[test]
fn test_aarch32_ldrsb_r_a1_a_mul_oracle_64_6_9b027c20() {
    // Test MUL 64-bit: 32-bit overflow (oracle)
    // Encoding: 0x9B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0xFFFFFFFE00000001");
}

/// Provenance: aarch32_LDRSB_r_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// prime numbers (32)
#[test]
fn test_aarch32_ldrsb_r_a1_a_mul_oracle_32_7_1b027c20() {
    // Test MUL 32-bit: prime numbers (oracle)
    // Encoding: 0x1B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7);
    set_w(&mut cpu, 2, 0xB);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4D, "W0 should be 0x0000004D");
}

/// Provenance: aarch32_LDRSB_r_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// prime numbers (64)
#[test]
fn test_aarch32_ldrsb_r_a1_a_mul_oracle_64_7_9b027c20() {
    // Test MUL 64-bit: prime numbers (oracle)
    // Encoding: 0x9B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7);
    set_w(&mut cpu, 2, 0xB);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4D, "X0 should be 0x000000000000004D");
}

/// Provenance: aarch32_LDRSB_r_A1_A
/// ASL: `MUL R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple values
#[test]
fn test_aarch32_ldrsb_r_a1_a_a32_mul_0_0000f291() {
    // Test A32 MUL: simple values (oracle)
    // Encoding: 0x0000F291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x32);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x0000F291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1388, "R0 should be 0x00001388");
}

/// Provenance: aarch32_LDRSB_r_A1_A
/// ASL: `MUL R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero values
#[test]
fn test_aarch32_ldrsb_r_a1_a_a32_mul_1_0000f291() {
    // Test A32 MUL: zero values (oracle)
    // Encoding: 0x0000F291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x0000F291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_LDRSB_r_A1_A
/// ASL: `MUL R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max value
#[test]
fn test_aarch32_ldrsb_r_a1_a_a32_mul_2_0000f291() {
    // Test A32 MUL: max value (oracle)
    // Encoding: 0x0000F291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x0000F291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "R0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_LDRSB_r_A1_A
/// ASL: `MUL R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set
#[test]
fn test_aarch32_ldrsb_r_a1_a_a32_mul_3_0000f291() {
    // Test A32 MUL: MSB set (oracle)
    // Encoding: 0x0000F291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x80000000);
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0x0000F291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_LDRSB_r_A1_A
/// ASL: `MUL R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// mixed pattern
#[test]
fn test_aarch32_ldrsb_r_a1_a_a32_mul_4_0000f291() {
    // Test A32 MUL: mixed pattern (oracle)
    // Encoding: 0x0000F291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x9ABCDEF0);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u32 = 0x0000F291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x242D2080, "R0 should be 0x242D2080");
}

/// Provenance: aarch32_LDRSB_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 0 (32)
#[test]
fn test_aarch32_ldrsb_r_t1_a_lslv_oracle_32_0_56020020() {
    // Test LSLV 32-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x12345678, "W0 should be 0x12345678");
}

/// Provenance: aarch32_LDRSB_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 0 (64)
#[test]
fn test_aarch32_ldrsb_r_t1_a_lslv_oracle_64_0_d6020020() {
    // Test LSLV 64-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x12345678,
        "X0 should be 0x0000000012345678"
    );
}

/// Provenance: aarch32_LDRSB_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4 (32)
#[test]
fn test_aarch32_ldrsb_r_t1_a_lslv_oracle_32_1_56020020() {
    // Test LSLV 32-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x4);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x23456780, "W0 should be 0x23456780");
}

/// Provenance: aarch32_LDRSB_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 4 (64)
#[test]
fn test_aarch32_ldrsb_r_t1_a_lslv_oracle_64_1_d6020020() {
    // Test LSLV 64-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x4);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x23456780,
        "X0 should be 0x0000000123456780"
    );
}

/// Provenance: aarch32_LDRSB_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 8 (32)
#[test]
fn test_aarch32_ldrsb_r_t1_a_lslv_oracle_32_2_56020020() {
    // Test LSLV 32-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x8);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x34567800, "W0 should be 0x34567800");
}

/// Provenance: aarch32_LDRSB_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 8 (64)
#[test]
fn test_aarch32_ldrsb_r_t1_a_lslv_oracle_64_2_d6020020() {
    // Test LSLV 64-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x8);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x34567800,
        "X0 should be 0x0000001234567800"
    );
}

/// Provenance: aarch32_LDRSB_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1 (32)
#[test]
fn test_aarch32_ldrsb_r_t1_a_lslv_oracle_32_3_56020020() {
    // Test LSLV 32-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_LDRSB_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// MSB set, shift 1 (64)
#[test]
fn test_aarch32_ldrsb_r_t1_a_lslv_oracle_64_3_d6020020() {
    // Test LSLV 64-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_LDRSB_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// LSB set, max shift (32)
#[test]
fn test_aarch32_ldrsb_r_t1_a_lslv_oracle_32_4_56020020() {
    // Test LSLV 32-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x3F);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "W0 should be 0x80000000");
}

/// Provenance: aarch32_LDRSB_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// LSB set, max shift (64)
#[test]
fn test_aarch32_ldrsb_r_t1_a_lslv_oracle_64_4_d6020020() {
    // Test LSLV 64-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x3F);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x8000000000000000");
}

/// Provenance: aarch32_LDRSB_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// all ones, shift 32 (32)
#[test]
fn test_aarch32_ldrsb_r_t1_a_lslv_oracle_32_5_56020020() {
    // Test LSLV 32-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x20);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "W0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_LDRSB_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// all ones, shift 32 (64)
#[test]
fn test_aarch32_ldrsb_r_t1_a_lslv_oracle_64_5_d6020020() {
    // Test LSLV 64-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x20);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0xFFFFFFFF00000000");
}

/// Provenance: aarch32_LDRSB_r_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// no shift
#[test]
fn test_aarch32_ldrsb_r_t1_a_t16_oracle_0_56880000() {
    // Test T16 LSLS: no shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_LDRSB_r_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4
#[test]
fn test_aarch32_ldrsb_r_t1_a_t16_oracle_1_56880000() {
    // Test T16 LSLS: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x4);
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF0, "R0 should be 0x00000FF0");
}

/// Provenance: aarch32_LDRSB_r_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1
#[test]
fn test_aarch32_ldrsb_r_t1_a_t16_oracle_2_56880000() {
    // Test T16 LSLS: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_LDRSB_r_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift to MSB
#[test]
fn test_aarch32_ldrsb_r_t1_a_t16_oracle_3_56880000() {
    // Test T16 LSLS: shift to MSB (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1F);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "R0 should be 0x80000000");
}

/// Provenance: aarch32_LDRSB_r_T2_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple division (32)
#[test]
fn test_aarch32_ldrsb_r_t2_a_udiv_oracle_32_0_1ac20820() {
    // Test UDIV 32-bit: simple division (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xA);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA, "W0 should be 0x0000000A");
}

/// Provenance: aarch32_LDRSB_r_T2_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple division (64)
#[test]
fn test_aarch32_ldrsb_r_t2_a_udiv_oracle_64_0_9ac20820() {
    // Test UDIV 64-bit: simple division (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xA);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA, "X0 should be 0x000000000000000A");
}

/// Provenance: aarch32_LDRSB_r_T2_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// division with remainder (32)
#[test]
fn test_aarch32_ldrsb_r_t2_a_udiv_oracle_32_1_1ac20820() {
    // Test UDIV 32-bit: division with remainder (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x21, "W0 should be 0x00000021");
}

/// Provenance: aarch32_LDRSB_r_T2_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// division with remainder (64)
#[test]
fn test_aarch32_ldrsb_r_t2_a_udiv_oracle_64_1_9ac20820() {
    // Test UDIV 64-bit: division with remainder (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x3);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x21, "X0 should be 0x0000000000000021");
}

/// Provenance: aarch32_LDRSB_r_T2_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero dividend (32)
#[test]
fn test_aarch32_ldrsb_r_t2_a_udiv_oracle_32_2_1ac20820() {
    // Test UDIV 32-bit: zero dividend (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xA);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_LDRSB_r_T2_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero dividend (64)
#[test]
fn test_aarch32_ldrsb_r_t2_a_udiv_oracle_64_2_9ac20820() {
    // Test UDIV 64-bit: zero dividend (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xA);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_LDRSB_r_T2_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// divide by zero - result is 0 (32)
#[test]
fn test_aarch32_ldrsb_r_t2_a_udiv_oracle_32_3_1ac20820() {
    // Test UDIV 32-bit: divide by zero - result is 0 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xA);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_LDRSB_r_T2_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// divide by zero - result is 0 (64)
#[test]
fn test_aarch32_ldrsb_r_t2_a_udiv_oracle_64_3_9ac20820() {
    // Test UDIV 64-bit: divide by zero - result is 0 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0xA);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_LDRSB_r_T2_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max value / 2 (32)
#[test]
fn test_aarch32_ldrsb_r_t2_a_udiv_oracle_32_4_1ac20820() {
    // Test UDIV 32-bit: max value / 2 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FFFFFFF, "W0 should be 0x7FFFFFFF");
}

/// Provenance: aarch32_LDRSB_r_T2_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max value / 2 (64)
#[test]
fn test_aarch32_ldrsb_r_t2_a_udiv_oracle_64_4_9ac20820() {
    // Test UDIV 64-bit: max value / 2 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0x7FFFFFFFFFFFFFFF"
    );
}

/// Provenance: aarch32_LDRSB_r_T2_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set / 2 (32)
#[test]
fn test_aarch32_ldrsb_r_t2_a_udiv_oracle_32_5_1ac20820() {
    // Test UDIV 32-bit: MSB set / 2 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_LDRSB_r_T2_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// MSB set / 2 (64)
#[test]
fn test_aarch32_ldrsb_r_t2_a_udiv_oracle_64_5_9ac20820() {
    // Test UDIV 64-bit: MSB set / 2 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x4000000000000000");
}

/// Provenance: aarch32_LDRSB_r_T2_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// self-division (32)
#[test]
fn test_aarch32_ldrsb_r_t2_a_udiv_oracle_32_6_1ac20820() {
    // Test UDIV 32-bit: self-division (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x7);
    set_w(&mut cpu, 1, 0x7);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_LDRSB_r_T2_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// self-division (64)
#[test]
fn test_aarch32_ldrsb_r_t2_a_udiv_oracle_64_6_9ac20820() {
    // Test UDIV 64-bit: self-division (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7);
    set_w(&mut cpu, 2, 0x7);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x0000000000000001");
}

/// Provenance: aarch32_LDRSB_r_T2_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// one / one (32)
#[test]
fn test_aarch32_ldrsb_r_t2_a_udiv_oracle_32_7_1ac20820() {
    // Test UDIV 32-bit: one / one (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_LDRSB_r_T2_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// one / one (64)
#[test]
fn test_aarch32_ldrsb_r_t2_a_udiv_oracle_64_7_9ac20820() {
    // Test UDIV 64-bit: one / one (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x0000000000000001");
}

/// Provenance: aarch32_LDRSB_r_T2_A
/// ASL: `UDIV R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// exact division
#[test]
fn test_aarch32_ldrsb_r_t2_a_t32_oracle_0_f9110002() {
    // Test T32 UDIV: exact division (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0xA);
    let encoding: u32 = 0xF9110002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA, "R0 should be 0x0000000A");
}

/// Provenance: aarch32_LDRSB_r_T2_A
/// ASL: `UDIV R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// with remainder
#[test]
fn test_aarch32_ldrsb_r_t2_a_t32_oracle_1_f9110002() {
    // Test T32 UDIV: with remainder (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF9110002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x21, "R0 should be 0x00000021");
}

/// Provenance: aarch32_LDRSB_r_T2_A
/// ASL: `UDIV R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero dividend
#[test]
fn test_aarch32_ldrsb_r_t2_a_t32_oracle_2_f9110002() {
    // Test T32 UDIV: zero dividend (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xA);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF9110002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_LDRSB_r_T2_A
/// ASL: `UDIV R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// divide by zero
#[test]
fn test_aarch32_ldrsb_r_t2_a_t32_oracle_3_f9110002() {
    // Test T32 UDIV: divide by zero (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xA);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xF9110002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

// ============================================================================
// aarch32_LDREX_A Tests
// ============================================================================

/// Provenance: aarch32_LDREX_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_ldrex_a1_a_field_cond_0_min_390_01900390() {
    // Encoding: 0x01900390
    // Test aarch32_LDREX_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: Rt=0, Rn=0, cond=0
    let encoding: u32 = 0x01900390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREX_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_ldrex_a1_a_field_cond_1_poweroftwo_390_11900390() {
    // Encoding: 0x11900390
    // Test aarch32_LDREX_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, cond=1, Rn=0
    let encoding: u32 = 0x11900390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREX_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_ldrex_a1_a_field_cond_2_poweroftwo_390_21900390() {
    // Encoding: 0x21900390
    // Test aarch32_LDREX_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=2, Rt=0, Rn=0
    let encoding: u32 = 0x21900390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREX_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_ldrex_a1_a_field_cond_3_poweroftwo_390_31900390() {
    // Encoding: 0x31900390
    // Test aarch32_LDREX_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, Rn=0, cond=3
    let encoding: u32 = 0x31900390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREX_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_ldrex_a1_a_field_cond_4_poweroftwo_390_41900390() {
    // Encoding: 0x41900390
    // Test aarch32_LDREX_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=4, Rn=0, Rt=0
    let encoding: u32 = 0x41900390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREX_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_ldrex_a1_a_field_cond_5_poweroftwo_390_51900390() {
    // Encoding: 0x51900390
    // Test aarch32_LDREX_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=5, Rt=0
    let encoding: u32 = 0x51900390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREX_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_ldrex_a1_a_field_cond_6_poweroftwo_390_61900390() {
    // Encoding: 0x61900390
    // Test aarch32_LDREX_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=6, Rt=0
    let encoding: u32 = 0x61900390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREX_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_ldrex_a1_a_field_cond_7_poweroftwo_390_71900390() {
    // Encoding: 0x71900390
    // Test aarch32_LDREX_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=7, Rn=0, Rt=0
    let encoding: u32 = 0x71900390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREX_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_ldrex_a1_a_field_cond_8_poweroftwo_390_81900390() {
    // Encoding: 0x81900390
    // Test aarch32_LDREX_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=8, Rt=0, Rn=0
    let encoding: u32 = 0x81900390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREX_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_ldrex_a1_a_field_cond_9_poweroftwo_390_91900390() {
    // Encoding: 0x91900390
    // Test aarch32_LDREX_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, cond=9, Rn=0
    let encoding: u32 = 0x91900390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREX_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_ldrex_a1_a_field_cond_10_poweroftwo_390_a1900390() {
    // Encoding: 0xA1900390
    // Test aarch32_LDREX_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=10
    let encoding: u32 = 0xA1900390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREX_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_ldrex_a1_a_field_cond_11_poweroftwo_390_b1900390() {
    // Encoding: 0xB1900390
    // Test aarch32_LDREX_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, cond=11, Rn=0
    let encoding: u32 = 0xB1900390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREX_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_ldrex_a1_a_field_cond_12_poweroftwo_390_c1900390() {
    // Encoding: 0xC1900390
    // Test aarch32_LDREX_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=12, Rt=0
    let encoding: u32 = 0xC1900390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREX_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_ldrex_a1_a_field_cond_13_poweroftwo_390_d1900390() {
    // Encoding: 0xD1900390
    // Test aarch32_LDREX_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=13, Rt=0
    let encoding: u32 = 0xD1900390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREX_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_ldrex_a1_a_field_cond_14_poweroftwo_390_e1900390() {
    // Encoding: 0xE1900390
    // Test aarch32_LDREX_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=14, Rt=0
    let encoding: u32 = 0xE1900390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREX_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_ldrex_a1_a_field_cond_15_max_390_f1900390() {
    // Encoding: 0xF1900390
    // Test aarch32_LDREX_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: cond=15, Rn=0, Rt=0
    let encoding: u32 = 0xF1900390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREX_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrex_a1_a_field_rn_0_min_390_01900390() {
    // Encoding: 0x01900390
    // Test aarch32_LDREX_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, cond=0, Rt=0
    let encoding: u32 = 0x01900390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREX_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrex_a1_a_field_rn_1_poweroftwo_390_01910390() {
    // Encoding: 0x01910390
    // Test aarch32_LDREX_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=1, cond=0, Rt=0
    let encoding: u32 = 0x01910390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREX_A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrex_a1_a_field_rt_0_min_390_01900390() {
    // Encoding: 0x01900390
    // Test aarch32_LDREX_A1_A field Rt = 0 (Min)
    // ISET: A32
    // Fields: Rt=0, cond=0, Rn=0
    let encoding: u32 = 0x01900390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREX_A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrex_a1_a_field_rt_1_poweroftwo_390_01901390() {
    // Encoding: 0x01901390
    // Test aarch32_LDREX_A1_A field Rt = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Rn=0, Rt=1
    let encoding: u32 = 0x01901390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREX_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_ldrex_a1_a_combo_0_390_01900390() {
    // Encoding: 0x01900390
    // Test aarch32_LDREX_A1_A field combination: cond=0, Rn=0, Rt=0
    // ISET: A32
    // Fields: cond=0, Rt=0, Rn=0
    let encoding: u32 = 0x01900390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREX_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_ldrex_a1_a_special_cond_0_condition_eq_912_01900390() {
    // Encoding: 0x01900390
    // Test aarch32_LDREX_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: cond=0, Rn=0, Rt=0
    let encoding: u32 = 0x01900390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREX_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_ldrex_a1_a_special_cond_1_condition_ne_912_11900390() {
    // Encoding: 0x11900390
    // Test aarch32_LDREX_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: Rt=0, cond=1, Rn=0
    let encoding: u32 = 0x11900390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREX_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_ldrex_a1_a_special_cond_2_condition_cs_hs_912_21900390() {
    // Encoding: 0x21900390
    // Test aarch32_LDREX_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: cond=2, Rt=0, Rn=0
    let encoding: u32 = 0x21900390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREX_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_ldrex_a1_a_special_cond_3_condition_cc_lo_912_31900390() {
    // Encoding: 0x31900390
    // Test aarch32_LDREX_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=3
    let encoding: u32 = 0x31900390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREX_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_ldrex_a1_a_special_cond_4_condition_mi_912_41900390() {
    // Encoding: 0x41900390
    // Test aarch32_LDREX_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: cond=4, Rn=0, Rt=0
    let encoding: u32 = 0x41900390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREX_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_ldrex_a1_a_special_cond_5_condition_pl_912_51900390() {
    // Encoding: 0x51900390
    // Test aarch32_LDREX_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=5
    let encoding: u32 = 0x51900390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREX_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_ldrex_a1_a_special_cond_6_condition_vs_912_61900390() {
    // Encoding: 0x61900390
    // Test aarch32_LDREX_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: Rt=0, Rn=0, cond=6
    let encoding: u32 = 0x61900390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREX_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_ldrex_a1_a_special_cond_7_condition_vc_912_71900390() {
    // Encoding: 0x71900390
    // Test aarch32_LDREX_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: cond=7, Rt=0, Rn=0
    let encoding: u32 = 0x71900390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREX_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_ldrex_a1_a_special_cond_8_condition_hi_912_81900390() {
    // Encoding: 0x81900390
    // Test aarch32_LDREX_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: Rt=0, cond=8, Rn=0
    let encoding: u32 = 0x81900390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREX_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_ldrex_a1_a_special_cond_9_condition_ls_912_91900390() {
    // Encoding: 0x91900390
    // Test aarch32_LDREX_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: cond=9, Rn=0, Rt=0
    let encoding: u32 = 0x91900390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREX_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_ldrex_a1_a_special_cond_10_condition_ge_912_a1900390() {
    // Encoding: 0xA1900390
    // Test aarch32_LDREX_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: Rn=0, cond=10, Rt=0
    let encoding: u32 = 0xA1900390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREX_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_ldrex_a1_a_special_cond_11_condition_lt_912_b1900390() {
    // Encoding: 0xB1900390
    // Test aarch32_LDREX_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: Rt=0, cond=11, Rn=0
    let encoding: u32 = 0xB1900390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREX_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_ldrex_a1_a_special_cond_12_condition_gt_912_c1900390() {
    // Encoding: 0xC1900390
    // Test aarch32_LDREX_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: Rt=0, cond=12, Rn=0
    let encoding: u32 = 0xC1900390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREX_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_ldrex_a1_a_special_cond_13_condition_le_912_d1900390() {
    // Encoding: 0xD1900390
    // Test aarch32_LDREX_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=13
    let encoding: u32 = 0xD1900390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREX_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_ldrex_a1_a_special_cond_14_condition_al_912_e1900390() {
    // Encoding: 0xE1900390
    // Test aarch32_LDREX_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: cond=14, Rn=0, Rt=0
    let encoding: u32 = 0xE1900390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREX_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_ldrex_a1_a_special_cond_15_condition_nv_912_f1900390() {
    // Encoding: 0xF1900390
    // Test aarch32_LDREX_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: Rt=0, cond=15, Rn=0
    let encoding: u32 = 0xF1900390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREX_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrex_a1_a_invalid_0_390_01900390() {
    // Encoding: 0x01900390
    // Test aarch32_LDREX_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }
    // ISET: A32
    // Fields: cond=0, Rt=0, Rn=0
    let encoding: u32 = 0x01900390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDREX_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrex_a1_a_invalid_1_390_01900390() {
    // Encoding: 0x01900390
    // Test aarch32_LDREX_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=0
    let encoding: u32 = 0x01900390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDREX_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrex_t1_a_field_rn_0_min_0_e8500000() {
    // Thumb encoding (32): 0xE8500000
    // Test aarch32_LDREX_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rt=0, Rn=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8500000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDREX_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrex_t1_a_field_rn_1_poweroftwo_0_e8510000() {
    // Thumb encoding (32): 0xE8510000
    // Test aarch32_LDREX_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=0, Rn=1, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8510000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDREX_T1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrex_t1_a_field_rt_0_min_0_e8500000() {
    // Thumb encoding (32): 0xE8500000
    // Test aarch32_LDREX_T1_A field Rt = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8500000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDREX_T1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrex_t1_a_field_rt_1_poweroftwo_0_e8501000() {
    // Thumb encoding (32): 0xE8501000
    // Test aarch32_LDREX_T1_A field Rt = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=1, imm8=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8501000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDREX_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_ldrex_t1_a_field_imm8_0_zero_0_e8500000() {
    // Thumb encoding (32): 0xE8500000
    // Test aarch32_LDREX_T1_A field imm8 = 0 (Zero)
    // ISET: T32
    // Fields: Rt=0, Rn=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8500000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDREX_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_ldrex_t1_a_field_imm8_1_poweroftwo_0_e8500001() {
    // Thumb encoding (32): 0xE8500001
    // Test aarch32_LDREX_T1_A field imm8 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=1, Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8500001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDREX_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_ldrex_t1_a_field_imm8_3_poweroftwominusone_0_e8500003() {
    // Thumb encoding (32): 0xE8500003
    // Test aarch32_LDREX_T1_A field imm8 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm8=3
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8500003;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDREX_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_ldrex_t1_a_field_imm8_4_poweroftwo_0_e8500004() {
    // Thumb encoding (32): 0xE8500004
    // Test aarch32_LDREX_T1_A field imm8 = 4 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, imm8=4, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8500004;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDREX_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_ldrex_t1_a_field_imm8_7_poweroftwominusone_0_e8500007() {
    // Thumb encoding (32): 0xE8500007
    // Test aarch32_LDREX_T1_A field imm8 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm8=7, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8500007;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDREX_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_ldrex_t1_a_field_imm8_8_poweroftwo_0_e8500008() {
    // Thumb encoding (32): 0xE8500008
    // Test aarch32_LDREX_T1_A field imm8 = 8 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm8=8
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8500008;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDREX_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_ldrex_t1_a_field_imm8_15_poweroftwominusone_0_e850000f() {
    // Thumb encoding (32): 0xE850000F
    // Test aarch32_LDREX_T1_A field imm8 = 15 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm8=15, Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE850000F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDREX_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_ldrex_t1_a_field_imm8_16_poweroftwo_0_e8500010() {
    // Thumb encoding (32): 0xE8500010
    // Test aarch32_LDREX_T1_A field imm8 = 16 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=16, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8500010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDREX_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_ldrex_t1_a_field_imm8_31_poweroftwominusone_0_e850001f() {
    // Thumb encoding (32): 0xE850001F
    // Test aarch32_LDREX_T1_A field imm8 = 31 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm8=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE850001F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDREX_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_ldrex_t1_a_field_imm8_32_poweroftwo_0_e8500020() {
    // Thumb encoding (32): 0xE8500020
    // Test aarch32_LDREX_T1_A field imm8 = 32 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, imm8=32, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8500020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDREX_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_ldrex_t1_a_field_imm8_63_poweroftwominusone_0_e850003f() {
    // Thumb encoding (32): 0xE850003F
    // Test aarch32_LDREX_T1_A field imm8 = 63 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, imm8=63, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE850003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDREX_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_ldrex_t1_a_field_imm8_64_poweroftwo_0_e8500040() {
    // Thumb encoding (32): 0xE8500040
    // Test aarch32_LDREX_T1_A field imm8 = 64 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=64, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8500040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDREX_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 127, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (127)
#[test]
fn test_aarch32_ldrex_t1_a_field_imm8_127_poweroftwominusone_0_e850007f() {
    // Thumb encoding (32): 0xE850007F
    // Test aarch32_LDREX_T1_A field imm8 = 127 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, imm8=127, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE850007F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDREX_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_ldrex_t1_a_field_imm8_128_poweroftwo_0_e8500080() {
    // Thumb encoding (32): 0xE8500080
    // Test aarch32_LDREX_T1_A field imm8 = 128 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm8=128
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8500080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDREX_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 255, boundary: Max }
/// maximum immediate (255)
#[test]
fn test_aarch32_ldrex_t1_a_field_imm8_255_max_0_e85000ff() {
    // Thumb encoding (32): 0xE85000FF
    // Test aarch32_LDREX_T1_A field imm8 = 255 (Max)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm8=255
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE85000FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDREX_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_ldrex_t1_a_combo_0_0_e8500000() {
    // Thumb encoding (32): 0xE8500000
    // Test aarch32_LDREX_T1_A field combination: Rn=0, Rt=0, imm8=0
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8500000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDREX_T1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrex_t1_a_invalid_0_0_e8500000() {
    // Thumb encoding (32): 0xE8500000
    // Test aarch32_LDREX_T1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }
    // ISET: T32
    // Fields: imm8=0, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8500000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_LDREX_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrex_t1_a_invalid_1_0_e8500000() {
    // Thumb encoding (32): 0xE8500000
    // Test aarch32_LDREX_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: imm8=0, Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8500000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

// ============================================================================
// aarch32_LDR_l_A Tests
// ============================================================================

/// Provenance: aarch32_LDR_l_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_ldr_l_a1_a_field_cond_0_min_0_041f0000() {
    // Encoding: 0x041F0000
    // Test aarch32_LDR_l_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: Rt=0, cond=0, W=0, imm12=0, U=0, P=0
    let encoding: u32 = 0x041F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_l_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_ldr_l_a1_a_field_cond_1_poweroftwo_0_141f0000() {
    // Encoding: 0x141F0000
    // Test aarch32_LDR_l_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, P=0, U=0, cond=1, imm12=0, W=0
    let encoding: u32 = 0x141F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_l_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_ldr_l_a1_a_field_cond_2_poweroftwo_0_241f0000() {
    // Encoding: 0x241F0000
    // Test aarch32_LDR_l_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=2, W=0, P=0, Rt=0, U=0, imm12=0
    let encoding: u32 = 0x241F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_l_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_ldr_l_a1_a_field_cond_3_poweroftwo_0_341f0000() {
    // Encoding: 0x341F0000
    // Test aarch32_LDR_l_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, imm12=0, U=0, W=0, P=0, cond=3
    let encoding: u32 = 0x341F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_l_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_ldr_l_a1_a_field_cond_4_poweroftwo_0_441f0000() {
    // Encoding: 0x441F0000
    // Test aarch32_LDR_l_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, imm12=0, P=0, cond=4, U=0, W=0
    let encoding: u32 = 0x441F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_l_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_ldr_l_a1_a_field_cond_5_poweroftwo_0_541f0000() {
    // Encoding: 0x541F0000
    // Test aarch32_LDR_l_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=5, P=0, W=0, Rt=0, U=0, imm12=0
    let encoding: u32 = 0x541F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_l_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_ldr_l_a1_a_field_cond_6_poweroftwo_0_641f0000() {
    // Encoding: 0x641F0000
    // Test aarch32_LDR_l_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, P=0, imm12=0, cond=6, U=0, W=0
    let encoding: u32 = 0x641F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_l_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_ldr_l_a1_a_field_cond_7_poweroftwo_0_741f0000() {
    // Encoding: 0x741F0000
    // Test aarch32_LDR_l_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=0, P=0, W=0, cond=7, Rt=0, U=0
    let encoding: u32 = 0x741F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_l_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_ldr_l_a1_a_field_cond_8_poweroftwo_0_841f0000() {
    // Encoding: 0x841F0000
    // Test aarch32_LDR_l_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, cond=8, Rt=0, imm12=0, U=0, P=0
    let encoding: u32 = 0x841F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_l_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_ldr_l_a1_a_field_cond_9_poweroftwo_0_941f0000() {
    // Encoding: 0x941F0000
    // Test aarch32_LDR_l_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, Rt=0, P=0, W=0, imm12=0, cond=9
    let encoding: u32 = 0x941F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_l_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_ldr_l_a1_a_field_cond_10_poweroftwo_0_a41f0000() {
    // Encoding: 0xA41F0000
    // Test aarch32_LDR_l_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, imm12=0, cond=10, U=0, Rt=0, P=0
    let encoding: u32 = 0xA41F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_l_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_ldr_l_a1_a_field_cond_11_poweroftwo_0_b41f0000() {
    // Encoding: 0xB41F0000
    // Test aarch32_LDR_l_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, U=0, cond=11, W=0, P=0, imm12=0
    let encoding: u32 = 0xB41F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_l_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_ldr_l_a1_a_field_cond_12_poweroftwo_0_c41f0000() {
    // Encoding: 0xC41F0000
    // Test aarch32_LDR_l_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, U=0, cond=12, P=0, W=0, imm12=0
    let encoding: u32 = 0xC41F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_l_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_ldr_l_a1_a_field_cond_13_poweroftwo_0_d41f0000() {
    // Encoding: 0xD41F0000
    // Test aarch32_LDR_l_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=13, P=0, W=0, Rt=0, imm12=0, U=0
    let encoding: u32 = 0xD41F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_l_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_ldr_l_a1_a_field_cond_14_poweroftwo_0_e41f0000() {
    // Encoding: 0xE41F0000
    // Test aarch32_LDR_l_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=0, U=0, Rt=0, W=0, cond=14, P=0
    let encoding: u32 = 0xE41F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_l_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_ldr_l_a1_a_field_cond_15_max_0_f41f0000() {
    // Encoding: 0xF41F0000
    // Test aarch32_LDR_l_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: W=0, imm12=0, cond=15, P=0, U=0, Rt=0
    let encoding: u32 = 0xF41F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_l_A1_A
/// ASL: `field P 24 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldr_l_a1_a_field_p_0_min_0_041f0000() {
    // Encoding: 0x041F0000
    // Test aarch32_LDR_l_A1_A field P = 0 (Min)
    // ISET: A32
    // Fields: P=0, Rt=0, U=0, cond=0, W=0, imm12=0
    let encoding: u32 = 0x041F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_l_A1_A
/// ASL: `field P 24 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldr_l_a1_a_field_p_1_max_0_051f0000() {
    // Encoding: 0x051F0000
    // Test aarch32_LDR_l_A1_A field P = 1 (Max)
    // ISET: A32
    // Fields: Rt=0, imm12=0, P=1, cond=0, U=0, W=0
    let encoding: u32 = 0x051F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_l_A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldr_l_a1_a_field_u_0_min_0_041f0000() {
    // Encoding: 0x041F0000
    // Test aarch32_LDR_l_A1_A field U = 0 (Min)
    // ISET: A32
    // Fields: U=0, Rt=0, W=0, cond=0, P=0, imm12=0
    let encoding: u32 = 0x041F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_l_A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldr_l_a1_a_field_u_1_max_0_049f0000() {
    // Encoding: 0x049F0000
    // Test aarch32_LDR_l_A1_A field U = 1 (Max)
    // ISET: A32
    // Fields: U=1, imm12=0, P=0, cond=0, W=0, Rt=0
    let encoding: u32 = 0x049F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_l_A1_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldr_l_a1_a_field_w_0_min_0_041f0000() {
    // Encoding: 0x041F0000
    // Test aarch32_LDR_l_A1_A field W = 0 (Min)
    // ISET: A32
    // Fields: Rt=0, imm12=0, W=0, cond=0, P=0, U=0
    let encoding: u32 = 0x041F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_l_A1_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldr_l_a1_a_field_w_1_max_0_043f0000() {
    // Encoding: 0x043F0000
    // Test aarch32_LDR_l_A1_A field W = 1 (Max)
    // ISET: A32
    // Fields: imm12=0, P=0, cond=0, U=0, W=1, Rt=0
    let encoding: u32 = 0x043F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_l_A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldr_l_a1_a_field_rt_0_min_0_041f0000() {
    // Encoding: 0x041F0000
    // Test aarch32_LDR_l_A1_A field Rt = 0 (Min)
    // ISET: A32
    // Fields: P=0, cond=0, Rt=0, W=0, imm12=0, U=0
    let encoding: u32 = 0x041F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_l_A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldr_l_a1_a_field_rt_1_poweroftwo_0_041f1000() {
    // Encoding: 0x041F1000
    // Test aarch32_LDR_l_A1_A field Rt = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, Rt=1, imm12=0, cond=0, W=0, U=0
    let encoding: u32 = 0x041F1000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_l_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_ldr_l_a1_a_field_imm12_0_zero_0_041f0000() {
    // Encoding: 0x041F0000
    // Test aarch32_LDR_l_A1_A field imm12 = 0 (Zero)
    // ISET: A32
    // Fields: W=0, imm12=0, Rt=0, cond=0, P=0, U=0
    let encoding: u32 = 0x041F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_l_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_ldr_l_a1_a_field_imm12_1_poweroftwo_0_041f0001() {
    // Encoding: 0x041F0001
    // Test aarch32_LDR_l_A1_A field imm12 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, U=0, W=0, Rt=0, cond=0, imm12=1
    let encoding: u32 = 0x041F0001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_l_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_ldr_l_a1_a_field_imm12_3_poweroftwominusone_0_041f0003() {
    // Encoding: 0x041F0003
    // Test aarch32_LDR_l_A1_A field imm12 = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: P=0, cond=0, U=0, Rt=0, W=0, imm12=3
    let encoding: u32 = 0x041F0003;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_l_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_ldr_l_a1_a_field_imm12_4_poweroftwo_0_041f0004() {
    // Encoding: 0x041F0004
    // Test aarch32_LDR_l_A1_A field imm12 = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, Rt=0, cond=0, W=0, imm12=4, U=0
    let encoding: u32 = 0x041F0004;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_l_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_ldr_l_a1_a_field_imm12_7_poweroftwominusone_0_041f0007() {
    // Encoding: 0x041F0007
    // Test aarch32_LDR_l_A1_A field imm12 = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: W=0, P=0, Rt=0, imm12=7, U=0, cond=0
    let encoding: u32 = 0x041F0007;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_l_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_ldr_l_a1_a_field_imm12_8_poweroftwo_0_041f0008() {
    // Encoding: 0x041F0008
    // Test aarch32_LDR_l_A1_A field imm12 = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, Rt=0, imm12=8, P=0, cond=0, U=0
    let encoding: u32 = 0x041F0008;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_l_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_ldr_l_a1_a_field_imm12_15_poweroftwominusone_0_041f000f() {
    // Encoding: 0x041F000F
    // Test aarch32_LDR_l_A1_A field imm12 = 15 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm12=15, W=0, Rt=0, P=0, cond=0, U=0
    let encoding: u32 = 0x041F000F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_l_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_ldr_l_a1_a_field_imm12_16_poweroftwo_0_041f0010() {
    // Encoding: 0x041F0010
    // Test aarch32_LDR_l_A1_A field imm12 = 16 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, U=0, P=0, W=0, imm12=16, cond=0
    let encoding: u32 = 0x041F0010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_l_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_ldr_l_a1_a_field_imm12_31_poweroftwominusone_0_041f001f() {
    // Encoding: 0x041F001F
    // Test aarch32_LDR_l_A1_A field imm12 = 31 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm12=31, W=0, Rt=0, U=0, P=0, cond=0
    let encoding: u32 = 0x041F001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_l_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_ldr_l_a1_a_field_imm12_32_poweroftwo_0_041f0020() {
    // Encoding: 0x041F0020
    // Test aarch32_LDR_l_A1_A field imm12 = 32 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, U=0, P=0, W=0, Rt=0, imm12=32
    let encoding: u32 = 0x041F0020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_l_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_ldr_l_a1_a_field_imm12_63_poweroftwominusone_0_041f003f() {
    // Encoding: 0x041F003F
    // Test aarch32_LDR_l_A1_A field imm12 = 63 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: P=0, imm12=63, cond=0, W=0, U=0, Rt=0
    let encoding: u32 = 0x041F003F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_l_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_ldr_l_a1_a_field_imm12_64_poweroftwo_0_041f0040() {
    // Encoding: 0x041F0040
    // Test aarch32_LDR_l_A1_A field imm12 = 64 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, P=0, W=0, Rt=0, imm12=64, U=0
    let encoding: u32 = 0x041F0040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_l_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 127, boundary: PowerOfTwoMinusOne }
/// 2^7 - 1 = 127
#[test]
fn test_aarch32_ldr_l_a1_a_field_imm12_127_poweroftwominusone_0_041f007f() {
    // Encoding: 0x041F007F
    // Test aarch32_LDR_l_A1_A field imm12 = 127 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: W=0, cond=0, U=0, Rt=0, P=0, imm12=127
    let encoding: u32 = 0x041F007F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_l_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_ldr_l_a1_a_field_imm12_128_poweroftwo_0_041f0080() {
    // Encoding: 0x041F0080
    // Test aarch32_LDR_l_A1_A field imm12 = 128 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, cond=0, W=0, imm12=128, U=0, P=0
    let encoding: u32 = 0x041F0080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_l_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 255, boundary: PowerOfTwoMinusOne }
/// 2^8 - 1 = 255
#[test]
fn test_aarch32_ldr_l_a1_a_field_imm12_255_poweroftwominusone_0_041f00ff() {
    // Encoding: 0x041F00FF
    // Test aarch32_LDR_l_A1_A field imm12 = 255 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, P=0, W=0, Rt=0, imm12=255, U=0
    let encoding: u32 = 0x041F00FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_l_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 256, boundary: PowerOfTwo }
/// power of 2 (2^8 = 256)
#[test]
fn test_aarch32_ldr_l_a1_a_field_imm12_256_poweroftwo_0_041f0100() {
    // Encoding: 0x041F0100
    // Test aarch32_LDR_l_A1_A field imm12 = 256 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, P=0, U=0, imm12=256, cond=0, W=0
    let encoding: u32 = 0x041F0100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_l_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 511, boundary: PowerOfTwoMinusOne }
/// 2^9 - 1 = 511
#[test]
fn test_aarch32_ldr_l_a1_a_field_imm12_511_poweroftwominusone_0_041f01ff() {
    // Encoding: 0x041F01FF
    // Test aarch32_LDR_l_A1_A field imm12 = 511 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: U=0, Rt=0, P=0, cond=0, imm12=511, W=0
    let encoding: u32 = 0x041F01FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_l_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 512, boundary: PowerOfTwo }
/// power of 2 (2^9 = 512)
#[test]
fn test_aarch32_ldr_l_a1_a_field_imm12_512_poweroftwo_0_041f0200() {
    // Encoding: 0x041F0200
    // Test aarch32_LDR_l_A1_A field imm12 = 512 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, U=0, imm12=512, P=0, W=0, Rt=0
    let encoding: u32 = 0x041F0200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_l_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1023, boundary: PowerOfTwoMinusOne }
/// 2^10 - 1 = 1023
#[test]
fn test_aarch32_ldr_l_a1_a_field_imm12_1023_poweroftwominusone_0_041f03ff() {
    // Encoding: 0x041F03FF
    // Test aarch32_LDR_l_A1_A field imm12 = 1023 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: P=0, W=0, U=0, cond=0, Rt=0, imm12=1023
    let encoding: u32 = 0x041F03FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_l_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1024, boundary: PowerOfTwo }
/// power of 2 (2^10 = 1024)
#[test]
fn test_aarch32_ldr_l_a1_a_field_imm12_1024_poweroftwo_0_041f0400() {
    // Encoding: 0x041F0400
    // Test aarch32_LDR_l_A1_A field imm12 = 1024 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, imm12=1024, U=0, cond=0, Rt=0, P=0
    let encoding: u32 = 0x041F0400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_l_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2047, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (2047)
#[test]
fn test_aarch32_ldr_l_a1_a_field_imm12_2047_poweroftwominusone_0_041f07ff() {
    // Encoding: 0x041F07FF
    // Test aarch32_LDR_l_A1_A field imm12 = 2047 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: U=0, P=0, imm12=2047, cond=0, W=0, Rt=0
    let encoding: u32 = 0x041F07FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_l_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2048, boundary: PowerOfTwo }
/// power of 2 (2^11 = 2048)
#[test]
fn test_aarch32_ldr_l_a1_a_field_imm12_2048_poweroftwo_0_041f0800() {
    // Encoding: 0x041F0800
    // Test aarch32_LDR_l_A1_A field imm12 = 2048 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=2048, W=0, U=0, P=0, Rt=0, cond=0
    let encoding: u32 = 0x041F0800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_l_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4095, boundary: Max }
/// maximum immediate (4095)
#[test]
fn test_aarch32_ldr_l_a1_a_field_imm12_4095_max_0_041f0fff() {
    // Encoding: 0x041F0FFF
    // Test aarch32_LDR_l_A1_A field imm12 = 4095 (Max)
    // ISET: A32
    // Fields: cond=0, imm12=4095, P=0, U=0, Rt=0, W=0
    let encoding: u32 = 0x041F0FFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_l_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_ldr_l_a1_a_combo_0_0_041f0000() {
    // Encoding: 0x041F0000
    // Test aarch32_LDR_l_A1_A field combination: cond=0, P=0, U=0, W=0, Rt=0, imm12=0
    // ISET: A32
    // Fields: U=0, W=0, cond=0, P=0, imm12=0, Rt=0
    let encoding: u32 = 0x041F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_l_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_ldr_l_a1_a_special_cond_0_condition_eq_0_041f0000() {
    // Encoding: 0x041F0000
    // Test aarch32_LDR_l_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: U=0, cond=0, W=0, P=0, Rt=0, imm12=0
    let encoding: u32 = 0x041F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_l_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_ldr_l_a1_a_special_cond_1_condition_ne_0_141f0000() {
    // Encoding: 0x141F0000
    // Test aarch32_LDR_l_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: imm12=0, W=0, P=0, U=0, cond=1, Rt=0
    let encoding: u32 = 0x141F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_l_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_ldr_l_a1_a_special_cond_2_condition_cs_hs_0_241f0000() {
    // Encoding: 0x241F0000
    // Test aarch32_LDR_l_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: Rt=0, imm12=0, P=0, W=0, cond=2, U=0
    let encoding: u32 = 0x241F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_l_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_ldr_l_a1_a_special_cond_3_condition_cc_lo_0_341f0000() {
    // Encoding: 0x341F0000
    // Test aarch32_LDR_l_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: P=0, imm12=0, U=0, Rt=0, W=0, cond=3
    let encoding: u32 = 0x341F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_l_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_ldr_l_a1_a_special_cond_4_condition_mi_0_441f0000() {
    // Encoding: 0x441F0000
    // Test aarch32_LDR_l_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: cond=4, W=0, P=0, U=0, Rt=0, imm12=0
    let encoding: u32 = 0x441F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_l_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_ldr_l_a1_a_special_cond_5_condition_pl_0_541f0000() {
    // Encoding: 0x541F0000
    // Test aarch32_LDR_l_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: W=0, Rt=0, U=0, cond=5, P=0, imm12=0
    let encoding: u32 = 0x541F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_l_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_ldr_l_a1_a_special_cond_6_condition_vs_0_641f0000() {
    // Encoding: 0x641F0000
    // Test aarch32_LDR_l_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: cond=6, Rt=0, imm12=0, U=0, P=0, W=0
    let encoding: u32 = 0x641F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_l_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_ldr_l_a1_a_special_cond_7_condition_vc_0_741f0000() {
    // Encoding: 0x741F0000
    // Test aarch32_LDR_l_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: imm12=0, U=0, cond=7, W=0, Rt=0, P=0
    let encoding: u32 = 0x741F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_l_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_ldr_l_a1_a_special_cond_8_condition_hi_0_841f0000() {
    // Encoding: 0x841F0000
    // Test aarch32_LDR_l_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: Rt=0, imm12=0, W=0, cond=8, P=0, U=0
    let encoding: u32 = 0x841F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_l_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_ldr_l_a1_a_special_cond_9_condition_ls_0_941f0000() {
    // Encoding: 0x941F0000
    // Test aarch32_LDR_l_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: P=0, imm12=0, cond=9, U=0, Rt=0, W=0
    let encoding: u32 = 0x941F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_l_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_ldr_l_a1_a_special_cond_10_condition_ge_0_a41f0000() {
    // Encoding: 0xA41F0000
    // Test aarch32_LDR_l_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: W=0, Rt=0, U=0, P=0, imm12=0, cond=10
    let encoding: u32 = 0xA41F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_l_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_ldr_l_a1_a_special_cond_11_condition_lt_0_b41f0000() {
    // Encoding: 0xB41F0000
    // Test aarch32_LDR_l_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: W=0, U=0, Rt=0, cond=11, imm12=0, P=0
    let encoding: u32 = 0xB41F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_l_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_ldr_l_a1_a_special_cond_12_condition_gt_0_c41f0000() {
    // Encoding: 0xC41F0000
    // Test aarch32_LDR_l_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: Rt=0, U=0, P=0, imm12=0, cond=12, W=0
    let encoding: u32 = 0xC41F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_l_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_ldr_l_a1_a_special_cond_13_condition_le_0_d41f0000() {
    // Encoding: 0xD41F0000
    // Test aarch32_LDR_l_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: cond=13, imm12=0, P=0, U=0, W=0, Rt=0
    let encoding: u32 = 0xD41F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_l_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_ldr_l_a1_a_special_cond_14_condition_al_0_e41f0000() {
    // Encoding: 0xE41F0000
    // Test aarch32_LDR_l_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: P=0, W=0, Rt=0, U=0, imm12=0, cond=14
    let encoding: u32 = 0xE41F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_l_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_ldr_l_a1_a_special_cond_15_condition_nv_0_f41f0000() {
    // Encoding: 0xF41F0000
    // Test aarch32_LDR_l_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: imm12=0, P=0, Rt=0, U=0, W=0, cond=15
    let encoding: u32 = 0xF41F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_l_A1_A
/// ASL: `Var(QualifiedIdentifier { qualifier: Any, name: "wback" })`
/// Requirement: UndefinedEncoding { condition: "Var(QualifiedIdentifier { qualifier: Any, name: \"wback\" })" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldr_l_a1_a_invalid_0_0_041f0000() {
    // Encoding: 0x041F0000
    // Test aarch32_LDR_l_A1_A invalid encoding: Var(QualifiedIdentifier { qualifier: Any, name: "wback" })
    // ISET: A32
    // Fields: cond=0, U=0, P=0, W=0, Rt=0, imm12=0
    let encoding: u32 = 0x041F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDR_l_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldr_l_a1_a_invalid_1_0_041f0000() {
    // Encoding: 0x041F0000
    // Test aarch32_LDR_l_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: P=0, cond=0, imm12=0, W=0, Rt=0, U=0
    let encoding: u32 = 0x041F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDR_l_T1_A
/// ASL: `field Rt 24 +: 3`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldr_l_t1_a_field_rt_0_min_0_48000000() {
    // Thumb encoding (32): 0x48000000
    // Test aarch32_LDR_l_T1_A field Rt = 0 (Min)
    // ISET: T32
    // Fields: imm8=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x48000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_l_T1_A
/// ASL: `field Rt 24 +: 3`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldr_l_t1_a_field_rt_1_poweroftwo_0_49000000() {
    // Thumb encoding (32): 0x49000000
    // Test aarch32_LDR_l_T1_A field Rt = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=1, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x49000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_l_T1_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_ldr_l_t1_a_field_imm8_0_zero_0_48000000() {
    // Thumb encoding (32): 0x48000000
    // Test aarch32_LDR_l_T1_A field imm8 = 0 (Zero)
    // ISET: T32
    // Fields: Rt=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x48000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_l_T1_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_ldr_l_t1_a_field_imm8_1_poweroftwo_0_48010000() {
    // Thumb encoding (32): 0x48010000
    // Test aarch32_LDR_l_T1_A field imm8 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, imm8=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x48010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_l_T1_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_ldr_l_t1_a_field_imm8_3_poweroftwominusone_0_48030000() {
    // Thumb encoding (32): 0x48030000
    // Test aarch32_LDR_l_T1_A field imm8 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, imm8=3
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x48030000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_l_T1_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_ldr_l_t1_a_field_imm8_4_poweroftwo_0_48040000() {
    // Thumb encoding (32): 0x48040000
    // Test aarch32_LDR_l_T1_A field imm8 = 4 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, imm8=4
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x48040000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_l_T1_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_ldr_l_t1_a_field_imm8_7_poweroftwominusone_0_48070000() {
    // Thumb encoding (32): 0x48070000
    // Test aarch32_LDR_l_T1_A field imm8 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, imm8=7
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x48070000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_l_T1_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_ldr_l_t1_a_field_imm8_8_poweroftwo_0_48080000() {
    // Thumb encoding (32): 0x48080000
    // Test aarch32_LDR_l_T1_A field imm8 = 8 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, imm8=8
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x48080000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_l_T1_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_ldr_l_t1_a_field_imm8_15_poweroftwominusone_0_480f0000() {
    // Thumb encoding (32): 0x480F0000
    // Test aarch32_LDR_l_T1_A field imm8 = 15 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, imm8=15
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x480F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_l_T1_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_ldr_l_t1_a_field_imm8_16_poweroftwo_0_48100000() {
    // Thumb encoding (32): 0x48100000
    // Test aarch32_LDR_l_T1_A field imm8 = 16 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=16, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x48100000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_l_T1_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_ldr_l_t1_a_field_imm8_31_poweroftwominusone_0_481f0000() {
    // Thumb encoding (32): 0x481F0000
    // Test aarch32_LDR_l_T1_A field imm8 = 31 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, imm8=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x481F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_l_T1_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_ldr_l_t1_a_field_imm8_32_poweroftwo_0_48200000() {
    // Thumb encoding (32): 0x48200000
    // Test aarch32_LDR_l_T1_A field imm8 = 32 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, imm8=32
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x48200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_l_T1_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_ldr_l_t1_a_field_imm8_63_poweroftwominusone_0_483f0000() {
    // Thumb encoding (32): 0x483F0000
    // Test aarch32_LDR_l_T1_A field imm8 = 63 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, imm8=63
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x483F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_l_T1_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_ldr_l_t1_a_field_imm8_64_poweroftwo_0_48400000() {
    // Thumb encoding (32): 0x48400000
    // Test aarch32_LDR_l_T1_A field imm8 = 64 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, imm8=64
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x48400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_l_T1_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 127, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (127)
#[test]
fn test_aarch32_ldr_l_t1_a_field_imm8_127_poweroftwominusone_0_487f0000() {
    // Thumb encoding (32): 0x487F0000
    // Test aarch32_LDR_l_T1_A field imm8 = 127 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm8=127, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x487F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_l_T1_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_ldr_l_t1_a_field_imm8_128_poweroftwo_0_48800000() {
    // Thumb encoding (32): 0x48800000
    // Test aarch32_LDR_l_T1_A field imm8 = 128 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=128, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x48800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_l_T1_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 255, boundary: Max }
/// maximum immediate (255)
#[test]
fn test_aarch32_ldr_l_t1_a_field_imm8_255_max_0_48ff0000() {
    // Thumb encoding (32): 0x48FF0000
    // Test aarch32_LDR_l_T1_A field imm8 = 255 (Max)
    // ISET: T32
    // Fields: imm8=255, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x48FF0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_l_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=0 (register index 0 (first register))
#[test]
fn test_aarch32_ldr_l_t1_a_combo_0_0_48000000() {
    // Thumb encoding (32): 0x48000000
    // Test aarch32_LDR_l_T1_A field combination: Rt=0, imm8=0
    // ISET: T32
    // Fields: Rt=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x48000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_l_T2_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldr_l_t2_a_field_u_0_min_0_f85f0000() {
    // Thumb encoding (32): 0xF85F0000
    // Test aarch32_LDR_l_T2_A field U = 0 (Min)
    // ISET: T32
    // Fields: Rt=0, imm12=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF85F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_l_T2_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldr_l_t2_a_field_u_1_max_0_f8df0000() {
    // Thumb encoding (32): 0xF8DF0000
    // Test aarch32_LDR_l_T2_A field U = 1 (Max)
    // ISET: T32
    // Fields: Rt=0, U=1, imm12=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8DF0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_l_T2_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldr_l_t2_a_field_rt_0_min_0_f85f0000() {
    // Thumb encoding (32): 0xF85F0000
    // Test aarch32_LDR_l_T2_A field Rt = 0 (Min)
    // ISET: T32
    // Fields: U=0, Rt=0, imm12=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF85F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_l_T2_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldr_l_t2_a_field_rt_1_poweroftwo_0_f85f1000() {
    // Thumb encoding (32): 0xF85F1000
    // Test aarch32_LDR_l_T2_A field Rt = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm12=0, Rt=1, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF85F1000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_l_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_ldr_l_t2_a_field_imm12_0_zero_0_f85f0000() {
    // Thumb encoding (32): 0xF85F0000
    // Test aarch32_LDR_l_T2_A field imm12 = 0 (Zero)
    // ISET: T32
    // Fields: U=0, Rt=0, imm12=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF85F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_l_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_ldr_l_t2_a_field_imm12_1_poweroftwo_0_f85f0001() {
    // Thumb encoding (32): 0xF85F0001
    // Test aarch32_LDR_l_T2_A field imm12 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, imm12=1, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF85F0001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_l_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_ldr_l_t2_a_field_imm12_3_poweroftwominusone_0_f85f0003() {
    // Thumb encoding (32): 0xF85F0003
    // Test aarch32_LDR_l_T2_A field imm12 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, U=0, imm12=3
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF85F0003;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_l_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_ldr_l_t2_a_field_imm12_4_poweroftwo_0_f85f0004() {
    // Thumb encoding (32): 0xF85F0004
    // Test aarch32_LDR_l_T2_A field imm12 = 4 (PowerOfTwo)
    // ISET: T32
    // Fields: U=0, Rt=0, imm12=4
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF85F0004;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_l_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_ldr_l_t2_a_field_imm12_7_poweroftwominusone_0_f85f0007() {
    // Thumb encoding (32): 0xF85F0007
    // Test aarch32_LDR_l_T2_A field imm12 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: U=0, imm12=7, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF85F0007;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_l_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_ldr_l_t2_a_field_imm12_8_poweroftwo_0_f85f0008() {
    // Thumb encoding (32): 0xF85F0008
    // Test aarch32_LDR_l_T2_A field imm12 = 8 (PowerOfTwo)
    // ISET: T32
    // Fields: imm12=8, Rt=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF85F0008;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_l_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_ldr_l_t2_a_field_imm12_15_poweroftwominusone_0_f85f000f() {
    // Thumb encoding (32): 0xF85F000F
    // Test aarch32_LDR_l_T2_A field imm12 = 15 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm12=15, U=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF85F000F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_l_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_ldr_l_t2_a_field_imm12_16_poweroftwo_0_f85f0010() {
    // Thumb encoding (32): 0xF85F0010
    // Test aarch32_LDR_l_T2_A field imm12 = 16 (PowerOfTwo)
    // ISET: T32
    // Fields: U=0, imm12=16, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF85F0010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_l_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_ldr_l_t2_a_field_imm12_31_poweroftwominusone_0_f85f001f() {
    // Thumb encoding (32): 0xF85F001F
    // Test aarch32_LDR_l_T2_A field imm12 = 31 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm12=31, Rt=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF85F001F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_l_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_ldr_l_t2_a_field_imm12_32_poweroftwo_0_f85f0020() {
    // Thumb encoding (32): 0xF85F0020
    // Test aarch32_LDR_l_T2_A field imm12 = 32 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, U=0, imm12=32
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF85F0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_l_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_ldr_l_t2_a_field_imm12_63_poweroftwominusone_0_f85f003f() {
    // Thumb encoding (32): 0xF85F003F
    // Test aarch32_LDR_l_T2_A field imm12 = 63 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: U=0, imm12=63, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF85F003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_l_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_ldr_l_t2_a_field_imm12_64_poweroftwo_0_f85f0040() {
    // Thumb encoding (32): 0xF85F0040
    // Test aarch32_LDR_l_T2_A field imm12 = 64 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, U=0, imm12=64
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF85F0040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_l_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 127, boundary: PowerOfTwoMinusOne }
/// 2^7 - 1 = 127
#[test]
fn test_aarch32_ldr_l_t2_a_field_imm12_127_poweroftwominusone_0_f85f007f() {
    // Thumb encoding (32): 0xF85F007F
    // Test aarch32_LDR_l_T2_A field imm12 = 127 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: U=0, Rt=0, imm12=127
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF85F007F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_l_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_ldr_l_t2_a_field_imm12_128_poweroftwo_0_f85f0080() {
    // Thumb encoding (32): 0xF85F0080
    // Test aarch32_LDR_l_T2_A field imm12 = 128 (PowerOfTwo)
    // ISET: T32
    // Fields: U=0, imm12=128, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF85F0080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_l_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 255, boundary: PowerOfTwoMinusOne }
/// 2^8 - 1 = 255
#[test]
fn test_aarch32_ldr_l_t2_a_field_imm12_255_poweroftwominusone_0_f85f00ff() {
    // Thumb encoding (32): 0xF85F00FF
    // Test aarch32_LDR_l_T2_A field imm12 = 255 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: U=0, imm12=255, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF85F00FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_l_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 256, boundary: PowerOfTwo }
/// power of 2 (2^8 = 256)
#[test]
fn test_aarch32_ldr_l_t2_a_field_imm12_256_poweroftwo_0_f85f0100() {
    // Thumb encoding (32): 0xF85F0100
    // Test aarch32_LDR_l_T2_A field imm12 = 256 (PowerOfTwo)
    // ISET: T32
    // Fields: imm12=256, Rt=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF85F0100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_l_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 511, boundary: PowerOfTwoMinusOne }
/// 2^9 - 1 = 511
#[test]
fn test_aarch32_ldr_l_t2_a_field_imm12_511_poweroftwominusone_0_f85f01ff() {
    // Thumb encoding (32): 0xF85F01FF
    // Test aarch32_LDR_l_T2_A field imm12 = 511 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, imm12=511, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF85F01FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_l_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 512, boundary: PowerOfTwo }
/// power of 2 (2^9 = 512)
#[test]
fn test_aarch32_ldr_l_t2_a_field_imm12_512_poweroftwo_0_f85f0200() {
    // Thumb encoding (32): 0xF85F0200
    // Test aarch32_LDR_l_T2_A field imm12 = 512 (PowerOfTwo)
    // ISET: T32
    // Fields: imm12=512, U=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF85F0200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_l_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1023, boundary: PowerOfTwoMinusOne }
/// 2^10 - 1 = 1023
#[test]
fn test_aarch32_ldr_l_t2_a_field_imm12_1023_poweroftwominusone_0_f85f03ff() {
    // Thumb encoding (32): 0xF85F03FF
    // Test aarch32_LDR_l_T2_A field imm12 = 1023 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm12=1023, U=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF85F03FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_l_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1024, boundary: PowerOfTwo }
/// power of 2 (2^10 = 1024)
#[test]
fn test_aarch32_ldr_l_t2_a_field_imm12_1024_poweroftwo_0_f85f0400() {
    // Thumb encoding (32): 0xF85F0400
    // Test aarch32_LDR_l_T2_A field imm12 = 1024 (PowerOfTwo)
    // ISET: T32
    // Fields: U=0, Rt=0, imm12=1024
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF85F0400;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_l_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2047, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (2047)
#[test]
fn test_aarch32_ldr_l_t2_a_field_imm12_2047_poweroftwominusone_0_f85f07ff() {
    // Thumb encoding (32): 0xF85F07FF
    // Test aarch32_LDR_l_T2_A field imm12 = 2047 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: U=0, Rt=0, imm12=2047
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF85F07FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_l_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2048, boundary: PowerOfTwo }
/// power of 2 (2^11 = 2048)
#[test]
fn test_aarch32_ldr_l_t2_a_field_imm12_2048_poweroftwo_0_f85f0800() {
    // Thumb encoding (32): 0xF85F0800
    // Test aarch32_LDR_l_T2_A field imm12 = 2048 (PowerOfTwo)
    // ISET: T32
    // Fields: U=0, Rt=0, imm12=2048
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF85F0800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_l_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4095, boundary: Max }
/// maximum immediate (4095)
#[test]
fn test_aarch32_ldr_l_t2_a_field_imm12_4095_max_0_f85f0fff() {
    // Thumb encoding (32): 0xF85F0FFF
    // Test aarch32_LDR_l_T2_A field imm12 = 4095 (Max)
    // ISET: T32
    // Fields: imm12=4095, Rt=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF85F0FFF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_l_T2_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=0 (minimum value)
#[test]
fn test_aarch32_ldr_l_t2_a_combo_0_0_f85f0000() {
    // Thumb encoding (32): 0xF85F0000
    // Test aarch32_LDR_l_T2_A field combination: U=0, Rt=0, imm12=0
    // ISET: T32
    // Fields: Rt=0, U=0, imm12=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF85F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_l_T2_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: And, lhs: Binary { op: And, lhs: LitInt(15), rhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] } }, rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "LastInITBlock" }, args: [] } } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: Binary { op: And, lhs: Binary { op: And, lhs: LitInt(15), rhs: Call { name: QualifiedIdentifier { qualifier: Any, name: \"InITBlock\" }, args: [] } }, rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"LastInITBlock\" }, args: [] } } } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldr_l_t2_a_invalid_0_0_f85f0000() {
    // Thumb encoding (32): 0xF85F0000
    // Test aarch32_LDR_l_T2_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: And, lhs: Binary { op: And, lhs: LitInt(15), rhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] } }, rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "LastInITBlock" }, args: [] } } } }
    // ISET: T32
    // Fields: imm12=0, U=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF85F0000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_LDR_l_T2_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldr_l_t2_a_invalid_1_0_f85f0000() {
    // Thumb encoding (32): 0xF85F0000
    // Test aarch32_LDR_l_T2_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rt=0, imm12=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF85F0000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_LDR_l_A1_A
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldr_l_a1_a_exception_0_041f0000() {
    // Test aarch32_LDR_l_A1_A exception: Unpredictable
    // Encoding: 0x041F0000
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x041F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_LDR_l_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 0 (32)
#[test]
fn test_aarch32_ldr_l_t1_a_lslv_oracle_32_0_48020020() {
    // Test LSLV 32-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x12345678, "W0 should be 0x12345678");
}

/// Provenance: aarch32_LDR_l_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 0 (64)
#[test]
fn test_aarch32_ldr_l_t1_a_lslv_oracle_64_0_c8020020() {
    // Test LSLV 64-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x12345678,
        "X0 should be 0x0000000012345678"
    );
}

/// Provenance: aarch32_LDR_l_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4 (32)
#[test]
fn test_aarch32_ldr_l_t1_a_lslv_oracle_32_1_48020020() {
    // Test LSLV 32-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x4);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x23456780, "W0 should be 0x23456780");
}

/// Provenance: aarch32_LDR_l_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 4 (64)
#[test]
fn test_aarch32_ldr_l_t1_a_lslv_oracle_64_1_c8020020() {
    // Test LSLV 64-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x4);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x23456780,
        "X0 should be 0x0000000123456780"
    );
}

/// Provenance: aarch32_LDR_l_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 8 (32)
#[test]
fn test_aarch32_ldr_l_t1_a_lslv_oracle_32_2_48020020() {
    // Test LSLV 32-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x8);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x34567800, "W0 should be 0x34567800");
}

/// Provenance: aarch32_LDR_l_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 8 (64)
#[test]
fn test_aarch32_ldr_l_t1_a_lslv_oracle_64_2_c8020020() {
    // Test LSLV 64-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x8);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x34567800,
        "X0 should be 0x0000001234567800"
    );
}

/// Provenance: aarch32_LDR_l_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1 (32)
#[test]
fn test_aarch32_ldr_l_t1_a_lslv_oracle_32_3_48020020() {
    // Test LSLV 32-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_LDR_l_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// MSB set, shift 1 (64)
#[test]
fn test_aarch32_ldr_l_t1_a_lslv_oracle_64_3_c8020020() {
    // Test LSLV 64-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_LDR_l_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// LSB set, max shift (32)
#[test]
fn test_aarch32_ldr_l_t1_a_lslv_oracle_32_4_48020020() {
    // Test LSLV 32-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x3F);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "W0 should be 0x80000000");
}

/// Provenance: aarch32_LDR_l_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// LSB set, max shift (64)
#[test]
fn test_aarch32_ldr_l_t1_a_lslv_oracle_64_4_c8020020() {
    // Test LSLV 64-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3F);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x8000000000000000");
}

/// Provenance: aarch32_LDR_l_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// all ones, shift 32 (32)
#[test]
fn test_aarch32_ldr_l_t1_a_lslv_oracle_32_5_48020020() {
    // Test LSLV 32-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x20);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "W0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_LDR_l_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// all ones, shift 32 (64)
#[test]
fn test_aarch32_ldr_l_t1_a_lslv_oracle_64_5_c8020020() {
    // Test LSLV 64-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x20);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0xFFFFFFFF00000000");
}

/// Provenance: aarch32_LDR_l_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// no shift
#[test]
fn test_aarch32_ldr_l_t1_a_t16_oracle_0_48000000() {
    // Test T16 LSLS: no shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_LDR_l_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4
#[test]
fn test_aarch32_ldr_l_t1_a_t16_oracle_1_48000000() {
    // Test T16 LSLS: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    set_w(&mut cpu, 2, 0x4);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF0, "R0 should be 0x00000FF0");
}

/// Provenance: aarch32_LDR_l_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1
#[test]
fn test_aarch32_ldr_l_t1_a_t16_oracle_2_48000000() {
    // Test T16 LSLS: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_LDR_l_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift to MSB
#[test]
fn test_aarch32_ldr_l_t1_a_t16_oracle_3_48000000() {
    // Test T16 LSLS: shift to MSB (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x1F);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "R0 should be 0x80000000");
}

/// Provenance: aarch32_LDR_l_T1_A
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldr_l_t1_a_exception_0_48000000() {
    // Test aarch32_LDR_l_T1_A exception: Unpredictable
    // ISET: T16
    let mut cpu = create_test_cpu();
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_LDR_l_T2_A
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldr_l_t2_a_exception_0_f85f0000() {
    // Test aarch32_LDR_l_T2_A exception: Unpredictable
    // ISET: T32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF85F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// aarch32_LDRSH_i_A Tests
// ============================================================================

/// Provenance: aarch32_LDRSH_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_ldrsh_i_a1_a_field_cond_0_min_f0_005000f0() {
    // Encoding: 0x005000F0
    // Test aarch32_LDRSH_i_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rn=0, W=0, P=0, imm4L=0, imm4H=0, U=0, Rt=0
    let encoding: u32 = 0x005000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_ldrsh_i_a1_a_field_cond_1_poweroftwo_f0_105000f0() {
    // Encoding: 0x105000F0
    // Test aarch32_LDRSH_i_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4H=0, U=0, P=0, W=0, Rt=0, Rn=0, cond=1, imm4L=0
    let encoding: u32 = 0x105000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_ldrsh_i_a1_a_field_cond_2_poweroftwo_f0_205000f0() {
    // Encoding: 0x205000F0
    // Test aarch32_LDRSH_i_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, cond=2, P=0, imm4H=0, Rt=0, W=0, Rn=0, imm4L=0
    let encoding: u32 = 0x205000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_ldrsh_i_a1_a_field_cond_3_poweroftwo_f0_305000f0() {
    // Encoding: 0x305000F0
    // Test aarch32_LDRSH_i_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=3, W=0, imm4L=0, U=0, Rn=0, imm4H=0, P=0, Rt=0
    let encoding: u32 = 0x305000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_ldrsh_i_a1_a_field_cond_4_poweroftwo_f0_405000f0() {
    // Encoding: 0x405000F0
    // Test aarch32_LDRSH_i_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, imm4L=0, cond=4, W=0, Rt=0, imm4H=0, U=0, P=0
    let encoding: u32 = 0x405000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_ldrsh_i_a1_a_field_cond_5_poweroftwo_f0_505000f0() {
    // Encoding: 0x505000F0
    // Test aarch32_LDRSH_i_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4L=0, W=0, imm4H=0, P=0, U=0, Rn=0, Rt=0, cond=5
    let encoding: u32 = 0x505000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_ldrsh_i_a1_a_field_cond_6_poweroftwo_f0_605000f0() {
    // Encoding: 0x605000F0
    // Test aarch32_LDRSH_i_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=6, W=0, Rn=0, imm4H=0, imm4L=0, P=0, U=0, Rt=0
    let encoding: u32 = 0x605000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_ldrsh_i_a1_a_field_cond_7_poweroftwo_f0_705000f0() {
    // Encoding: 0x705000F0
    // Test aarch32_LDRSH_i_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, P=0, Rt=0, W=0, cond=7, imm4H=0, Rn=0, imm4L=0
    let encoding: u32 = 0x705000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_ldrsh_i_a1_a_field_cond_8_poweroftwo_f0_805000f0() {
    // Encoding: 0x805000F0
    // Test aarch32_LDRSH_i_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4H=0, cond=8, P=0, W=0, Rn=0, imm4L=0, Rt=0, U=0
    let encoding: u32 = 0x805000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_ldrsh_i_a1_a_field_cond_9_poweroftwo_f0_905000f0() {
    // Encoding: 0x905000F0
    // Test aarch32_LDRSH_i_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4H=0, U=0, cond=9, W=0, P=0, Rt=0, Rn=0, imm4L=0
    let encoding: u32 = 0x905000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_ldrsh_i_a1_a_field_cond_10_poweroftwo_f0_a05000f0() {
    // Encoding: 0xA05000F0
    // Test aarch32_LDRSH_i_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, Rn=0, U=0, cond=10, imm4H=0, imm4L=0, Rt=0, P=0
    let encoding: u32 = 0xA05000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_ldrsh_i_a1_a_field_cond_11_poweroftwo_f0_b05000f0() {
    // Encoding: 0xB05000F0
    // Test aarch32_LDRSH_i_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, U=0, P=0, cond=11, Rn=0, imm4L=0, Rt=0, imm4H=0
    let encoding: u32 = 0xB05000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_ldrsh_i_a1_a_field_cond_12_poweroftwo_f0_c05000f0() {
    // Encoding: 0xC05000F0
    // Test aarch32_LDRSH_i_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, U=0, W=0, imm4L=0, Rt=0, imm4H=0, Rn=0, cond=12
    let encoding: u32 = 0xC05000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_ldrsh_i_a1_a_field_cond_13_poweroftwo_f0_d05000f0() {
    // Encoding: 0xD05000F0
    // Test aarch32_LDRSH_i_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, imm4H=0, Rn=0, imm4L=0, P=0, cond=13, Rt=0, U=0
    let encoding: u32 = 0xD05000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_ldrsh_i_a1_a_field_cond_14_poweroftwo_f0_e05000f0() {
    // Encoding: 0xE05000F0
    // Test aarch32_LDRSH_i_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, imm4H=0, imm4L=0, cond=14, P=0, U=0, Rt=0, W=0
    let encoding: u32 = 0xE05000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_ldrsh_i_a1_a_field_cond_15_max_f0_f05000f0() {
    // Encoding: 0xF05000F0
    // Test aarch32_LDRSH_i_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: W=0, P=0, imm4H=0, Rt=0, U=0, cond=15, imm4L=0, Rn=0
    let encoding: u32 = 0xF05000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_i_A1_A
/// ASL: `field P 24 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldrsh_i_a1_a_field_p_0_min_f0_005000f0() {
    // Encoding: 0x005000F0
    // Test aarch32_LDRSH_i_A1_A field P = 0 (Min)
    // ISET: A32
    // Fields: U=0, imm4L=0, cond=0, Rt=0, imm4H=0, P=0, W=0, Rn=0
    let encoding: u32 = 0x005000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_i_A1_A
/// ASL: `field P 24 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldrsh_i_a1_a_field_p_1_max_f0_015000f0() {
    // Encoding: 0x015000F0
    // Test aarch32_LDRSH_i_A1_A field P = 1 (Max)
    // ISET: A32
    // Fields: Rt=0, cond=0, U=0, Rn=0, imm4L=0, W=0, P=1, imm4H=0
    let encoding: u32 = 0x015000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_i_A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldrsh_i_a1_a_field_u_0_min_f0_005000f0() {
    // Encoding: 0x005000F0
    // Test aarch32_LDRSH_i_A1_A field U = 0 (Min)
    // ISET: A32
    // Fields: W=0, cond=0, imm4H=0, P=0, Rn=0, Rt=0, U=0, imm4L=0
    let encoding: u32 = 0x005000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_i_A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldrsh_i_a1_a_field_u_1_max_f0_00d000f0() {
    // Encoding: 0x00D000F0
    // Test aarch32_LDRSH_i_A1_A field U = 1 (Max)
    // ISET: A32
    // Fields: Rt=0, U=1, imm4H=0, W=0, cond=0, P=0, Rn=0, imm4L=0
    let encoding: u32 = 0x00D000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_i_A1_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldrsh_i_a1_a_field_w_0_min_f0_005000f0() {
    // Encoding: 0x005000F0
    // Test aarch32_LDRSH_i_A1_A field W = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, cond=0, imm4L=0, P=0, U=0, W=0, Rt=0, imm4H=0
    let encoding: u32 = 0x005000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_i_A1_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldrsh_i_a1_a_field_w_1_max_f0_007000f0() {
    // Encoding: 0x007000F0
    // Test aarch32_LDRSH_i_A1_A field W = 1 (Max)
    // ISET: A32
    // Fields: cond=0, W=1, P=0, imm4L=0, U=0, Rn=0, imm4H=0, Rt=0
    let encoding: u32 = 0x007000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_i_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrsh_i_a1_a_field_rn_0_min_f0_005000f0() {
    // Encoding: 0x005000F0
    // Test aarch32_LDRSH_i_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, P=0, Rt=0, imm4L=0, imm4H=0, U=0, W=0, cond=0
    let encoding: u32 = 0x005000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_i_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrsh_i_a1_a_field_rn_1_poweroftwo_f0_005100f0() {
    // Encoding: 0x005100F0
    // Test aarch32_LDRSH_i_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, P=0, Rn=1, imm4H=0, U=0, W=0, cond=0, imm4L=0
    let encoding: u32 = 0x005100F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_i_A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrsh_i_a1_a_field_rt_0_min_f0_005000f0() {
    // Encoding: 0x005000F0
    // Test aarch32_LDRSH_i_A1_A field Rt = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, P=0, Rt=0, W=0, cond=0, imm4L=0, imm4H=0, U=0
    let encoding: u32 = 0x005000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_i_A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrsh_i_a1_a_field_rt_1_poweroftwo_f0_005010f0() {
    // Encoding: 0x005010F0
    // Test aarch32_LDRSH_i_A1_A field Rt = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4H=0, imm4L=0, Rt=1, Rn=0, U=0, W=0, P=0, cond=0
    let encoding: u32 = 0x005010F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_i_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_ldrsh_i_a1_a_field_imm4h_0_zero_f0_005000f0() {
    // Encoding: 0x005000F0
    // Test aarch32_LDRSH_i_A1_A field imm4H = 0 (Zero)
    // ISET: A32
    // Fields: W=0, imm4L=0, Rt=0, Rn=0, imm4H=0, P=0, cond=0, U=0
    let encoding: u32 = 0x005000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_i_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_ldrsh_i_a1_a_field_imm4h_1_poweroftwo_f0_005001f0() {
    // Encoding: 0x005001F0
    // Test aarch32_LDRSH_i_A1_A field imm4H = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, imm4H=1, imm4L=0, U=0, Rn=0, cond=0, P=0, W=0
    let encoding: u32 = 0x005001F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_i_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_ldrsh_i_a1_a_field_imm4h_3_poweroftwominusone_f0_005003f0() {
    // Encoding: 0x005003F0
    // Test aarch32_LDRSH_i_A1_A field imm4H = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rn=0, Rt=0, P=0, W=0, U=0, cond=0, imm4L=0, imm4H=3
    let encoding: u32 = 0x005003F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_i_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_ldrsh_i_a1_a_field_imm4h_4_poweroftwo_f0_005004f0() {
    // Encoding: 0x005004F0
    // Test aarch32_LDRSH_i_A1_A field imm4H = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, Rt=0, Rn=0, imm4H=4, W=0, imm4L=0, cond=0, P=0
    let encoding: u32 = 0x005004F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_i_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_aarch32_ldrsh_i_a1_a_field_imm4h_7_poweroftwominusone_f0_005007f0() {
    // Encoding: 0x005007F0
    // Test aarch32_LDRSH_i_A1_A field imm4H = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, W=0, imm4H=7, U=0, P=0, Rt=0, Rn=0, imm4L=0
    let encoding: u32 = 0x005007F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_i_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_ldrsh_i_a1_a_field_imm4h_8_poweroftwo_f0_005008f0() {
    // Encoding: 0x005008F0
    // Test aarch32_LDRSH_i_A1_A field imm4H = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4L=0, Rt=0, U=0, P=0, cond=0, imm4H=8, W=0, Rn=0
    let encoding: u32 = 0x005008F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_i_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_aarch32_ldrsh_i_a1_a_field_imm4h_15_max_f0_00500ff0() {
    // Encoding: 0x00500FF0
    // Test aarch32_LDRSH_i_A1_A field imm4H = 15 (Max)
    // ISET: A32
    // Fields: U=0, imm4L=0, imm4H=15, W=0, P=0, Rn=0, cond=0, Rt=0
    let encoding: u32 = 0x00500FF0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_i_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_ldrsh_i_a1_a_field_imm4l_0_zero_f0_005000f0() {
    // Encoding: 0x005000F0
    // Test aarch32_LDRSH_i_A1_A field imm4L = 0 (Zero)
    // ISET: A32
    // Fields: Rn=0, Rt=0, P=0, W=0, imm4L=0, cond=0, U=0, imm4H=0
    let encoding: u32 = 0x005000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_i_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_ldrsh_i_a1_a_field_imm4l_1_poweroftwo_f0_005000f1() {
    // Encoding: 0x005000F1
    // Test aarch32_LDRSH_i_A1_A field imm4L = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, U=0, W=0, P=0, Rn=0, Rt=0, imm4L=1, imm4H=0
    let encoding: u32 = 0x005000F1;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_i_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_ldrsh_i_a1_a_field_imm4l_3_poweroftwominusone_f0_005000f3() {
    // Encoding: 0x005000F3
    // Test aarch32_LDRSH_i_A1_A field imm4L = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rn=0, P=0, W=0, cond=0, Rt=0, U=0, imm4H=0, imm4L=3
    let encoding: u32 = 0x005000F3;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_i_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_ldrsh_i_a1_a_field_imm4l_4_poweroftwo_f0_005000f4() {
    // Encoding: 0x005000F4
    // Test aarch32_LDRSH_i_A1_A field imm4L = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Rn=0, P=0, imm4L=4, Rt=0, W=0, imm4H=0, U=0
    let encoding: u32 = 0x005000F4;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_i_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_aarch32_ldrsh_i_a1_a_field_imm4l_7_poweroftwominusone_f0_005000f7() {
    // Encoding: 0x005000F7
    // Test aarch32_LDRSH_i_A1_A field imm4L = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rt=0, imm4H=0, P=0, cond=0, imm4L=7, W=0, U=0, Rn=0
    let encoding: u32 = 0x005000F7;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_i_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_ldrsh_i_a1_a_field_imm4l_8_poweroftwo_f0_005000f8() {
    // Encoding: 0x005000F8
    // Test aarch32_LDRSH_i_A1_A field imm4L = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, imm4L=8, cond=0, P=0, Rt=0, U=0, imm4H=0, Rn=0
    let encoding: u32 = 0x005000F8;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_i_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_aarch32_ldrsh_i_a1_a_field_imm4l_15_max_f0_005000ff() {
    // Encoding: 0x005000FF
    // Test aarch32_LDRSH_i_A1_A field imm4L = 15 (Max)
    // ISET: A32
    // Fields: U=0, Rt=0, cond=0, P=0, imm4H=0, imm4L=15, Rn=0, W=0
    let encoding: u32 = 0x005000FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_i_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_ldrsh_i_a1_a_combo_0_f0_005000f0() {
    // Encoding: 0x005000F0
    // Test aarch32_LDRSH_i_A1_A field combination: cond=0, P=0, U=0, W=0, Rn=0, Rt=0, imm4H=0, imm4L=0
    // ISET: A32
    // Fields: U=0, cond=0, W=0, P=0, imm4H=0, imm4L=0, Rn=0, Rt=0
    let encoding: u32 = 0x005000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_i_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_ldrsh_i_a1_a_special_cond_0_condition_eq_240_005000f0() {
    // Encoding: 0x005000F0
    // Test aarch32_LDRSH_i_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: Rn=0, W=0, imm4H=0, P=0, U=0, imm4L=0, cond=0, Rt=0
    let encoding: u32 = 0x005000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_i_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_ldrsh_i_a1_a_special_cond_1_condition_ne_240_105000f0() {
    // Encoding: 0x105000F0
    // Test aarch32_LDRSH_i_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: imm4L=0, W=0, cond=1, imm4H=0, P=0, Rt=0, Rn=0, U=0
    let encoding: u32 = 0x105000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_i_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_ldrsh_i_a1_a_special_cond_2_condition_cs_hs_240_205000f0() {
    // Encoding: 0x205000F0
    // Test aarch32_LDRSH_i_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: P=0, W=0, U=0, Rt=0, cond=2, Rn=0, imm4L=0, imm4H=0
    let encoding: u32 = 0x205000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_i_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_ldrsh_i_a1_a_special_cond_3_condition_cc_lo_240_305000f0() {
    // Encoding: 0x305000F0
    // Test aarch32_LDRSH_i_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: cond=3, Rt=0, imm4L=0, W=0, U=0, P=0, imm4H=0, Rn=0
    let encoding: u32 = 0x305000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_i_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_ldrsh_i_a1_a_special_cond_4_condition_mi_240_405000f0() {
    // Encoding: 0x405000F0
    // Test aarch32_LDRSH_i_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: Rn=0, U=0, W=0, Rt=0, imm4L=0, cond=4, P=0, imm4H=0
    let encoding: u32 = 0x405000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_i_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_ldrsh_i_a1_a_special_cond_5_condition_pl_240_505000f0() {
    // Encoding: 0x505000F0
    // Test aarch32_LDRSH_i_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: U=0, imm4L=0, W=0, cond=5, P=0, Rn=0, imm4H=0, Rt=0
    let encoding: u32 = 0x505000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_i_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_ldrsh_i_a1_a_special_cond_6_condition_vs_240_605000f0() {
    // Encoding: 0x605000F0
    // Test aarch32_LDRSH_i_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: Rt=0, cond=6, U=0, W=0, P=0, imm4H=0, Rn=0, imm4L=0
    let encoding: u32 = 0x605000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_i_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_ldrsh_i_a1_a_special_cond_7_condition_vc_240_705000f0() {
    // Encoding: 0x705000F0
    // Test aarch32_LDRSH_i_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: cond=7, imm4L=0, P=0, U=0, Rn=0, imm4H=0, Rt=0, W=0
    let encoding: u32 = 0x705000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_i_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_ldrsh_i_a1_a_special_cond_8_condition_hi_240_805000f0() {
    // Encoding: 0x805000F0
    // Test aarch32_LDRSH_i_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: cond=8, W=0, U=0, Rn=0, Rt=0, imm4H=0, imm4L=0, P=0
    let encoding: u32 = 0x805000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_i_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_ldrsh_i_a1_a_special_cond_9_condition_ls_240_905000f0() {
    // Encoding: 0x905000F0
    // Test aarch32_LDRSH_i_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: Rn=0, Rt=0, imm4H=0, cond=9, U=0, imm4L=0, P=0, W=0
    let encoding: u32 = 0x905000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_i_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_ldrsh_i_a1_a_special_cond_10_condition_ge_240_a05000f0() {
    // Encoding: 0xA05000F0
    // Test aarch32_LDRSH_i_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: W=0, imm4H=0, Rn=0, U=0, P=0, cond=10, Rt=0, imm4L=0
    let encoding: u32 = 0xA05000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_i_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_ldrsh_i_a1_a_special_cond_11_condition_lt_240_b05000f0() {
    // Encoding: 0xB05000F0
    // Test aarch32_LDRSH_i_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: Rt=0, imm4L=0, cond=11, Rn=0, P=0, W=0, imm4H=0, U=0
    let encoding: u32 = 0xB05000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_i_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_ldrsh_i_a1_a_special_cond_12_condition_gt_240_c05000f0() {
    // Encoding: 0xC05000F0
    // Test aarch32_LDRSH_i_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: U=0, cond=12, Rn=0, P=0, imm4L=0, W=0, Rt=0, imm4H=0
    let encoding: u32 = 0xC05000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_i_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_ldrsh_i_a1_a_special_cond_13_condition_le_240_d05000f0() {
    // Encoding: 0xD05000F0
    // Test aarch32_LDRSH_i_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: imm4H=0, cond=13, Rn=0, U=0, P=0, W=0, imm4L=0, Rt=0
    let encoding: u32 = 0xD05000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_i_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_ldrsh_i_a1_a_special_cond_14_condition_al_240_e05000f0() {
    // Encoding: 0xE05000F0
    // Test aarch32_LDRSH_i_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: imm4L=0, imm4H=0, U=0, P=0, W=0, Rn=0, cond=14, Rt=0
    let encoding: u32 = 0xE05000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_i_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_ldrsh_i_a1_a_special_cond_15_condition_nv_240_f05000f0() {
    // Encoding: 0xF05000F0
    // Test aarch32_LDRSH_i_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: imm4L=0, U=0, imm4H=0, Rt=0, P=0, W=0, Rn=0, cond=15
    let encoding: u32 = 0xF05000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_i_A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Binary { op: Eq, lhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Binary { op: Eq, lhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"wback\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }) } } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrsh_i_a1_a_invalid_0_f0_005000f0() {
    // Encoding: 0x005000F0
    // Test aarch32_LDRSH_i_A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Binary { op: Eq, lhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) } } }
    // ISET: A32
    // Fields: P=0, imm4L=0, imm4H=0, cond=0, Rt=0, U=0, Rn=0, W=0
    let encoding: u32 = 0x005000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRSH_i_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrsh_i_a1_a_invalid_1_f0_005000f0() {
    // Encoding: 0x005000F0
    // Test aarch32_LDRSH_i_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Rn=0, Rt=0, P=0, imm4H=0, W=0, imm4L=0, U=0, cond=0
    let encoding: u32 = 0x005000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRSH_i_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrsh_i_t1_a_field_rn_0_min_0_f9b00000() {
    // Thumb encoding (32): 0xF9B00000
    // Test aarch32_LDRSH_i_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: imm12=0, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9B00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_i_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrsh_i_t1_a_field_rn_1_poweroftwo_0_f9b10000() {
    // Thumb encoding (32): 0xF9B10000
    // Test aarch32_LDRSH_i_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, imm12=0, Rn=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9B10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_i_T1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrsh_i_t1_a_field_rt_0_min_0_f9b00000() {
    // Thumb encoding (32): 0xF9B00000
    // Test aarch32_LDRSH_i_T1_A field Rt = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, imm12=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9B00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_i_T1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrsh_i_t1_a_field_rt_1_poweroftwo_0_f9b01000() {
    // Thumb encoding (32): 0xF9B01000
    // Test aarch32_LDRSH_i_T1_A field Rt = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=1, imm12=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9B01000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_i_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_ldrsh_i_t1_a_field_imm12_0_zero_0_f9b00000() {
    // Thumb encoding (32): 0xF9B00000
    // Test aarch32_LDRSH_i_T1_A field imm12 = 0 (Zero)
    // ISET: T32
    // Fields: Rt=0, Rn=0, imm12=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9B00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_i_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_ldrsh_i_t1_a_field_imm12_1_poweroftwo_0_f9b00001() {
    // Thumb encoding (32): 0xF9B00001
    // Test aarch32_LDRSH_i_T1_A field imm12 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm12=1, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9B00001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_i_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_ldrsh_i_t1_a_field_imm12_3_poweroftwominusone_0_f9b00003() {
    // Thumb encoding (32): 0xF9B00003
    // Test aarch32_LDRSH_i_T1_A field imm12 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, Rn=0, imm12=3
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9B00003;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_i_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_ldrsh_i_t1_a_field_imm12_4_poweroftwo_0_f9b00004() {
    // Thumb encoding (32): 0xF9B00004
    // Test aarch32_LDRSH_i_T1_A field imm12 = 4 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm12=4
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9B00004;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_i_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_ldrsh_i_t1_a_field_imm12_7_poweroftwominusone_0_f9b00007() {
    // Thumb encoding (32): 0xF9B00007
    // Test aarch32_LDRSH_i_T1_A field imm12 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm12=7
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9B00007;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_i_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_ldrsh_i_t1_a_field_imm12_8_poweroftwo_0_f9b00008() {
    // Thumb encoding (32): 0xF9B00008
    // Test aarch32_LDRSH_i_T1_A field imm12 = 8 (PowerOfTwo)
    // ISET: T32
    // Fields: imm12=8, Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9B00008;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_i_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_ldrsh_i_t1_a_field_imm12_15_poweroftwominusone_0_f9b0000f() {
    // Thumb encoding (32): 0xF9B0000F
    // Test aarch32_LDRSH_i_T1_A field imm12 = 15 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm12=15, Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9B0000F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_i_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_ldrsh_i_t1_a_field_imm12_16_poweroftwo_0_f9b00010() {
    // Thumb encoding (32): 0xF9B00010
    // Test aarch32_LDRSH_i_T1_A field imm12 = 16 (PowerOfTwo)
    // ISET: T32
    // Fields: imm12=16, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9B00010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_i_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_ldrsh_i_t1_a_field_imm12_31_poweroftwominusone_0_f9b0001f() {
    // Thumb encoding (32): 0xF9B0001F
    // Test aarch32_LDRSH_i_T1_A field imm12 = 31 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, imm12=31, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9B0001F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_i_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_ldrsh_i_t1_a_field_imm12_32_poweroftwo_0_f9b00020() {
    // Thumb encoding (32): 0xF9B00020
    // Test aarch32_LDRSH_i_T1_A field imm12 = 32 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, Rn=0, imm12=32
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9B00020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_i_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_ldrsh_i_t1_a_field_imm12_63_poweroftwominusone_0_f9b0003f() {
    // Thumb encoding (32): 0xF9B0003F
    // Test aarch32_LDRSH_i_T1_A field imm12 = 63 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm12=63, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9B0003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_i_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_ldrsh_i_t1_a_field_imm12_64_poweroftwo_0_f9b00040() {
    // Thumb encoding (32): 0xF9B00040
    // Test aarch32_LDRSH_i_T1_A field imm12 = 64 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, imm12=64, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9B00040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_i_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 127, boundary: PowerOfTwoMinusOne }
/// 2^7 - 1 = 127
#[test]
fn test_aarch32_ldrsh_i_t1_a_field_imm12_127_poweroftwominusone_0_f9b0007f() {
    // Thumb encoding (32): 0xF9B0007F
    // Test aarch32_LDRSH_i_T1_A field imm12 = 127 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm12=127
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9B0007F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_i_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_ldrsh_i_t1_a_field_imm12_128_poweroftwo_0_f9b00080() {
    // Thumb encoding (32): 0xF9B00080
    // Test aarch32_LDRSH_i_T1_A field imm12 = 128 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, imm12=128, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9B00080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_i_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 255, boundary: PowerOfTwoMinusOne }
/// 2^8 - 1 = 255
#[test]
fn test_aarch32_ldrsh_i_t1_a_field_imm12_255_poweroftwominusone_0_f9b000ff() {
    // Thumb encoding (32): 0xF9B000FF
    // Test aarch32_LDRSH_i_T1_A field imm12 = 255 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, imm12=255, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9B000FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_i_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 256, boundary: PowerOfTwo }
/// power of 2 (2^8 = 256)
#[test]
fn test_aarch32_ldrsh_i_t1_a_field_imm12_256_poweroftwo_0_f9b00100() {
    // Thumb encoding (32): 0xF9B00100
    // Test aarch32_LDRSH_i_T1_A field imm12 = 256 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, imm12=256, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9B00100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_i_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 511, boundary: PowerOfTwoMinusOne }
/// 2^9 - 1 = 511
#[test]
fn test_aarch32_ldrsh_i_t1_a_field_imm12_511_poweroftwominusone_0_f9b001ff() {
    // Thumb encoding (32): 0xF9B001FF
    // Test aarch32_LDRSH_i_T1_A field imm12 = 511 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, imm12=511, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9B001FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_i_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 512, boundary: PowerOfTwo }
/// power of 2 (2^9 = 512)
#[test]
fn test_aarch32_ldrsh_i_t1_a_field_imm12_512_poweroftwo_0_f9b00200() {
    // Thumb encoding (32): 0xF9B00200
    // Test aarch32_LDRSH_i_T1_A field imm12 = 512 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm12=512
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9B00200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_i_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1023, boundary: PowerOfTwoMinusOne }
/// 2^10 - 1 = 1023
#[test]
fn test_aarch32_ldrsh_i_t1_a_field_imm12_1023_poweroftwominusone_0_f9b003ff() {
    // Thumb encoding (32): 0xF9B003FF
    // Test aarch32_LDRSH_i_T1_A field imm12 = 1023 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, imm12=1023, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9B003FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_i_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1024, boundary: PowerOfTwo }
/// power of 2 (2^10 = 1024)
#[test]
fn test_aarch32_ldrsh_i_t1_a_field_imm12_1024_poweroftwo_0_f9b00400() {
    // Thumb encoding (32): 0xF9B00400
    // Test aarch32_LDRSH_i_T1_A field imm12 = 1024 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm12=1024
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9B00400;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_i_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2047, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (2047)
#[test]
fn test_aarch32_ldrsh_i_t1_a_field_imm12_2047_poweroftwominusone_0_f9b007ff() {
    // Thumb encoding (32): 0xF9B007FF
    // Test aarch32_LDRSH_i_T1_A field imm12 = 2047 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm12=2047
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9B007FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_i_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2048, boundary: PowerOfTwo }
/// power of 2 (2^11 = 2048)
#[test]
fn test_aarch32_ldrsh_i_t1_a_field_imm12_2048_poweroftwo_0_f9b00800() {
    // Thumb encoding (32): 0xF9B00800
    // Test aarch32_LDRSH_i_T1_A field imm12 = 2048 (PowerOfTwo)
    // ISET: T32
    // Fields: imm12=2048, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9B00800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_i_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4095, boundary: Max }
/// maximum immediate (4095)
#[test]
fn test_aarch32_ldrsh_i_t1_a_field_imm12_4095_max_0_f9b00fff() {
    // Thumb encoding (32): 0xF9B00FFF
    // Test aarch32_LDRSH_i_T1_A field imm12 = 4095 (Max)
    // ISET: T32
    // Fields: Rn=0, imm12=4095, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9B00FFF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_i_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_ldrsh_i_t1_a_combo_0_0_f9b00000() {
    // Thumb encoding (32): 0xF9B00000
    // Test aarch32_LDRSH_i_T1_A field combination: Rn=0, Rt=0, imm12=0
    // ISET: T32
    // Fields: Rt=0, imm12=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9B00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_i_T2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrsh_i_t2_a_field_rn_0_min_800_f9300800() {
    // Thumb encoding (32): 0xF9300800
    // Test aarch32_LDRSH_i_T2_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rt=0, W=0, imm8=0, U=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9300800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_i_T2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrsh_i_t2_a_field_rn_1_poweroftwo_800_f9310800() {
    // Thumb encoding (32): 0xF9310800
    // Test aarch32_LDRSH_i_T2_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: W=0, U=0, Rn=1, imm8=0, P=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9310800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_i_T2_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrsh_i_t2_a_field_rt_0_min_800_f9300800() {
    // Thumb encoding (32): 0xF9300800
    // Test aarch32_LDRSH_i_T2_A field Rt = 0 (Min)
    // ISET: T32
    // Fields: Rt=0, U=0, W=0, imm8=0, Rn=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9300800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_i_T2_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrsh_i_t2_a_field_rt_1_poweroftwo_800_f9301800() {
    // Thumb encoding (32): 0xF9301800
    // Test aarch32_LDRSH_i_T2_A field Rt = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, U=0, W=0, imm8=0, Rt=1, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9301800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_i_T2_A
/// ASL: `field P 10 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldrsh_i_t2_a_field_p_0_min_800_f9300800() {
    // Thumb encoding (32): 0xF9300800
    // Test aarch32_LDRSH_i_T2_A field P = 0 (Min)
    // ISET: T32
    // Fields: P=0, W=0, imm8=0, Rn=0, Rt=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9300800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_i_T2_A
/// ASL: `field P 10 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldrsh_i_t2_a_field_p_1_max_800_f9300c00() {
    // Thumb encoding (32): 0xF9300C00
    // Test aarch32_LDRSH_i_T2_A field P = 1 (Max)
    // ISET: T32
    // Fields: Rn=0, imm8=0, W=0, U=0, P=1, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9300C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_i_T2_A
/// ASL: `field U 9 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldrsh_i_t2_a_field_u_0_min_800_f9300800() {
    // Thumb encoding (32): 0xF9300800
    // Test aarch32_LDRSH_i_T2_A field U = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, P=0, imm8=0, Rt=0, U=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9300800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_i_T2_A
/// ASL: `field U 9 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldrsh_i_t2_a_field_u_1_max_800_f9300a00() {
    // Thumb encoding (32): 0xF9300A00
    // Test aarch32_LDRSH_i_T2_A field U = 1 (Max)
    // ISET: T32
    // Fields: Rt=0, P=0, U=1, W=0, imm8=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9300A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_i_T2_A
/// ASL: `field W 8 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldrsh_i_t2_a_field_w_0_min_800_f9300800() {
    // Thumb encoding (32): 0xF9300800
    // Test aarch32_LDRSH_i_T2_A field W = 0 (Min)
    // ISET: T32
    // Fields: U=0, P=0, Rn=0, Rt=0, imm8=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9300800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_i_T2_A
/// ASL: `field W 8 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldrsh_i_t2_a_field_w_1_max_800_f9300900() {
    // Thumb encoding (32): 0xF9300900
    // Test aarch32_LDRSH_i_T2_A field W = 1 (Max)
    // ISET: T32
    // Fields: Rn=0, W=1, U=0, imm8=0, P=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9300900;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_i_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_ldrsh_i_t2_a_field_imm8_0_zero_800_f9300800() {
    // Thumb encoding (32): 0xF9300800
    // Test aarch32_LDRSH_i_T2_A field imm8 = 0 (Zero)
    // ISET: T32
    // Fields: Rt=0, W=0, P=0, imm8=0, Rn=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9300800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_i_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_ldrsh_i_t2_a_field_imm8_1_poweroftwo_800_f9300801() {
    // Thumb encoding (32): 0xF9300801
    // Test aarch32_LDRSH_i_T2_A field imm8 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, P=0, Rt=0, W=0, imm8=1, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9300801;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_i_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_ldrsh_i_t2_a_field_imm8_3_poweroftwominusone_800_f9300803() {
    // Thumb encoding (32): 0xF9300803
    // Test aarch32_LDRSH_i_T2_A field imm8 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: U=0, imm8=3, P=0, W=0, Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9300803;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_i_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_ldrsh_i_t2_a_field_imm8_4_poweroftwo_800_f9300804() {
    // Thumb encoding (32): 0xF9300804
    // Test aarch32_LDRSH_i_T2_A field imm8 = 4 (PowerOfTwo)
    // ISET: T32
    // Fields: P=0, U=0, W=0, imm8=4, Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9300804;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_i_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_ldrsh_i_t2_a_field_imm8_7_poweroftwominusone_800_f9300807() {
    // Thumb encoding (32): 0xF9300807
    // Test aarch32_LDRSH_i_T2_A field imm8 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, U=0, P=0, Rn=0, W=0, imm8=7
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9300807;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_i_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_ldrsh_i_t2_a_field_imm8_8_poweroftwo_800_f9300808() {
    // Thumb encoding (32): 0xF9300808
    // Test aarch32_LDRSH_i_T2_A field imm8 = 8 (PowerOfTwo)
    // ISET: T32
    // Fields: W=0, imm8=8, U=0, Rt=0, P=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9300808;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_i_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_ldrsh_i_t2_a_field_imm8_15_poweroftwominusone_800_f930080f() {
    // Thumb encoding (32): 0xF930080F
    // Test aarch32_LDRSH_i_T2_A field imm8 = 15 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm8=15, P=0, Rt=0, Rn=0, U=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF930080F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_i_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_ldrsh_i_t2_a_field_imm8_16_poweroftwo_800_f9300810() {
    // Thumb encoding (32): 0xF9300810
    // Test aarch32_LDRSH_i_T2_A field imm8 = 16 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, W=0, imm8=16, Rt=0, U=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9300810;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_i_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_ldrsh_i_t2_a_field_imm8_31_poweroftwominusone_800_f930081f() {
    // Thumb encoding (32): 0xF930081F
    // Test aarch32_LDRSH_i_T2_A field imm8 = 31 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, imm8=31, P=0, W=0, Rn=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF930081F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_i_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_ldrsh_i_t2_a_field_imm8_32_poweroftwo_800_f9300820() {
    // Thumb encoding (32): 0xF9300820
    // Test aarch32_LDRSH_i_T2_A field imm8 = 32 (PowerOfTwo)
    // ISET: T32
    // Fields: P=0, U=0, Rt=0, W=0, Rn=0, imm8=32
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9300820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_i_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_ldrsh_i_t2_a_field_imm8_63_poweroftwominusone_800_f930083f() {
    // Thumb encoding (32): 0xF930083F
    // Test aarch32_LDRSH_i_T2_A field imm8 = 63 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, imm8=63, U=0, Rt=0, W=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF930083F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_i_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_ldrsh_i_t2_a_field_imm8_64_poweroftwo_800_f9300840() {
    // Thumb encoding (32): 0xF9300840
    // Test aarch32_LDRSH_i_T2_A field imm8 = 64 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, Rn=0, P=0, imm8=64, W=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9300840;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_i_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 127, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (127)
#[test]
fn test_aarch32_ldrsh_i_t2_a_field_imm8_127_poweroftwominusone_800_f930087f() {
    // Thumb encoding (32): 0xF930087F
    // Test aarch32_LDRSH_i_T2_A field imm8 = 127 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, P=0, U=0, W=0, imm8=127, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF930087F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_i_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_ldrsh_i_t2_a_field_imm8_128_poweroftwo_800_f9300880() {
    // Thumb encoding (32): 0xF9300880
    // Test aarch32_LDRSH_i_T2_A field imm8 = 128 (PowerOfTwo)
    // ISET: T32
    // Fields: W=0, imm8=128, Rn=0, Rt=0, P=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9300880;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_i_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 255, boundary: Max }
/// maximum immediate (255)
#[test]
fn test_aarch32_ldrsh_i_t2_a_field_imm8_255_max_800_f93008ff() {
    // Thumb encoding (32): 0xF93008FF
    // Test aarch32_LDRSH_i_T2_A field imm8 = 255 (Max)
    // ISET: T32
    // Fields: P=0, U=0, imm8=255, W=0, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF93008FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_i_T2_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_ldrsh_i_t2_a_combo_0_800_f9300800() {
    // Thumb encoding (32): 0xF9300800
    // Test aarch32_LDRSH_i_T2_A field combination: Rn=0, Rt=0, P=0, U=0, W=0, imm8=0
    // ISET: T32
    // Fields: W=0, P=0, U=0, Rt=0, imm8=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9300800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_i_T2_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "P" }), rhs: Binary { op: And, lhs: LitBits([false]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "W" }) } }, rhs: LitBits([false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"P\" }), rhs: Binary { op: And, lhs: LitBits([false]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"W\" }) } }, rhs: LitBits([false]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_ldrsh_i_t2_a_invalid_0_800_f9300800() {
    // Thumb encoding (32): 0xF9300800
    // Test aarch32_LDRSH_i_T2_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "P" }), rhs: Binary { op: And, lhs: LitBits([false]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "W" }) } }, rhs: LitBits([false]) }
    // ISET: T32
    // Fields: imm8=0, Rt=0, U=0, P=0, W=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9300800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_LDRSH_i_T2_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_ldrsh_i_t2_a_invalid_1_800_f9300800() {
    // Thumb encoding (32): 0xF9300800
    // Test aarch32_LDRSH_i_T2_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: Rt=0, U=0, P=0, W=0, Rn=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9300800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_LDRSH_i_T2_A
/// ASL: `Binary { op: Or, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: And, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "W" }) } }, rhs: LitBits([true]) }, rhs: Binary { op: Eq, lhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Or, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: Binary { op: And, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"W\" }) } }, rhs: LitBits([true]) }, rhs: Binary { op: Eq, lhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"wback\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }) } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrsh_i_t2_a_invalid_2_800_f9300800() {
    // Thumb encoding (32): 0xF9300800
    // Test aarch32_LDRSH_i_T2_A invalid encoding: Binary { op: Or, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: And, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "W" }) } }, rhs: LitBits([true]) }, rhs: Binary { op: Eq, lhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) } }
    // ISET: T32
    // Fields: W=0, imm8=0, Rt=0, Rn=0, P=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9300800;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRSH_i_T2_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrsh_i_t2_a_invalid_3_800_f9300800() {
    // Thumb encoding (32): 0xF9300800
    // Test aarch32_LDRSH_i_T2_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rt=0, imm8=0, U=0, W=0, Rn=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9300800;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRSH_i_A1_A
/// ASL: `UMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple multiply
#[test]
fn test_aarch32_ldrsh_i_a1_a_umull_oracle_0_9ba27c20() {
    // Test UMULL: simple multiply (oracle)
    // Encoding: 0x9BA27C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x2);
    set_w(&mut cpu, 2, 0x3);
    let encoding: u32 = 0x9BA27C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6, "X0 should be 0x0000000000000006");
}

/// Provenance: aarch32_LDRSH_i_A1_A
/// ASL: `UMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max 32-bit * 2
#[test]
fn test_aarch32_ldrsh_i_a1_a_umull_oracle_1_9ba27c20() {
    // Test UMULL: max 32-bit * 2 (oracle)
    // Encoding: 0x9BA27C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x9BA27C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0x00000001FFFFFFFE"
    );
}

/// Provenance: aarch32_LDRSH_i_A1_A
/// ASL: `UMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// large positive * large positive
#[test]
fn test_aarch32_ldrsh_i_a1_a_umull_oracle_2_9ba27c20() {
    // Test UMULL: large positive * large positive (oracle)
    // Encoding: 0x9BA27C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x7FFFFFFF);
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x9BA27C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x3FFFFFFF00000001");
}

/// Provenance: aarch32_LDRSH_i_A1_A
/// ASL: `UMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max unsigned * max unsigned
#[test]
fn test_aarch32_ldrsh_i_a1_a_umull_oracle_3_9ba27c20() {
    // Test UMULL: max unsigned * max unsigned (oracle)
    // Encoding: 0x9BA27C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x9BA27C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0xFFFFFFFE00000001");
}

/// Provenance: aarch32_LDRSH_i_A1_A
/// ASL: `UMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// medium values
#[test]
fn test_aarch32_ldrsh_i_a1_a_umull_oracle_4_9ba27c20() {
    // Test UMULL: medium values (oracle)
    // Encoding: 0x9BA27C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xC8);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x9BA27C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4E20, "X0 should be 0x0000000000004E20");
}

/// Provenance: aarch32_LDRSH_i_A1_A
/// ASL: `UMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// 16-bit values
#[test]
fn test_aarch32_ldrsh_i_a1_a_umull_oracle_5_9ba27c20() {
    // Test UMULL: 16-bit values (oracle)
    // Encoding: 0x9BA27C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x5678);
    set_w(&mut cpu, 1, 0x1234);
    let encoding: u32 = 0x9BA27C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6260060, "X0 should be 0x0000000006260060");
}

// ============================================================================
// aarch32_LDREXB_A Tests
// ============================================================================

/// Provenance: aarch32_LDREXB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_ldrexb_a1_a_field_cond_0_min_390_01d00390() {
    // Encoding: 0x01D00390
    // Test aarch32_LDREXB_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rn=0, Rt=0
    let encoding: u32 = 0x01D00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_ldrexb_a1_a_field_cond_1_poweroftwo_390_11d00390() {
    // Encoding: 0x11D00390
    // Test aarch32_LDREXB_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=1, Rt=0
    let encoding: u32 = 0x11D00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_ldrexb_a1_a_field_cond_2_poweroftwo_390_21d00390() {
    // Encoding: 0x21D00390
    // Test aarch32_LDREXB_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=2, Rn=0, Rt=0
    let encoding: u32 = 0x21D00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_ldrexb_a1_a_field_cond_3_poweroftwo_390_31d00390() {
    // Encoding: 0x31D00390
    // Test aarch32_LDREXB_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=3
    let encoding: u32 = 0x31D00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_ldrexb_a1_a_field_cond_4_poweroftwo_390_41d00390() {
    // Encoding: 0x41D00390
    // Test aarch32_LDREXB_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, Rn=0, cond=4
    let encoding: u32 = 0x41D00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_ldrexb_a1_a_field_cond_5_poweroftwo_390_51d00390() {
    // Encoding: 0x51D00390
    // Test aarch32_LDREXB_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, cond=5, Rn=0
    let encoding: u32 = 0x51D00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_ldrexb_a1_a_field_cond_6_poweroftwo_390_61d00390() {
    // Encoding: 0x61D00390
    // Test aarch32_LDREXB_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=6, Rt=0, Rn=0
    let encoding: u32 = 0x61D00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_ldrexb_a1_a_field_cond_7_poweroftwo_390_71d00390() {
    // Encoding: 0x71D00390
    // Test aarch32_LDREXB_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=7, Rt=0, Rn=0
    let encoding: u32 = 0x71D00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_ldrexb_a1_a_field_cond_8_poweroftwo_390_81d00390() {
    // Encoding: 0x81D00390
    // Test aarch32_LDREXB_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=8
    let encoding: u32 = 0x81D00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_ldrexb_a1_a_field_cond_9_poweroftwo_390_91d00390() {
    // Encoding: 0x91D00390
    // Test aarch32_LDREXB_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, cond=9, Rn=0
    let encoding: u32 = 0x91D00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_ldrexb_a1_a_field_cond_10_poweroftwo_390_a1d00390() {
    // Encoding: 0xA1D00390
    // Test aarch32_LDREXB_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=10, Rn=0, Rt=0
    let encoding: u32 = 0xA1D00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_ldrexb_a1_a_field_cond_11_poweroftwo_390_b1d00390() {
    // Encoding: 0xB1D00390
    // Test aarch32_LDREXB_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=11, Rn=0, Rt=0
    let encoding: u32 = 0xB1D00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_ldrexb_a1_a_field_cond_12_poweroftwo_390_c1d00390() {
    // Encoding: 0xC1D00390
    // Test aarch32_LDREXB_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=12
    let encoding: u32 = 0xC1D00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_ldrexb_a1_a_field_cond_13_poweroftwo_390_d1d00390() {
    // Encoding: 0xD1D00390
    // Test aarch32_LDREXB_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=13, Rt=0
    let encoding: u32 = 0xD1D00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_ldrexb_a1_a_field_cond_14_poweroftwo_390_e1d00390() {
    // Encoding: 0xE1D00390
    // Test aarch32_LDREXB_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=14, Rn=0, Rt=0
    let encoding: u32 = 0xE1D00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_ldrexb_a1_a_field_cond_15_max_390_f1d00390() {
    // Encoding: 0xF1D00390
    // Test aarch32_LDREXB_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: Rt=0, Rn=0, cond=15
    let encoding: u32 = 0xF1D00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXB_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrexb_a1_a_field_rn_0_min_390_01d00390() {
    // Encoding: 0x01D00390
    // Test aarch32_LDREXB_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: Rt=0, Rn=0, cond=0
    let encoding: u32 = 0x01D00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXB_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrexb_a1_a_field_rn_1_poweroftwo_390_01d10390() {
    // Encoding: 0x01D10390
    // Test aarch32_LDREXB_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, Rn=1, cond=0
    let encoding: u32 = 0x01D10390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXB_A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrexb_a1_a_field_rt_0_min_390_01d00390() {
    // Encoding: 0x01D00390
    // Test aarch32_LDREXB_A1_A field Rt = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, cond=0, Rt=0
    let encoding: u32 = 0x01D00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXB_A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrexb_a1_a_field_rt_1_poweroftwo_390_01d01390() {
    // Encoding: 0x01D01390
    // Test aarch32_LDREXB_A1_A field Rt = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=1, cond=0, Rn=0
    let encoding: u32 = 0x01D01390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXB_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_ldrexb_a1_a_combo_0_390_01d00390() {
    // Encoding: 0x01D00390
    // Test aarch32_LDREXB_A1_A field combination: cond=0, Rn=0, Rt=0
    // ISET: A32
    // Fields: cond=0, Rn=0, Rt=0
    let encoding: u32 = 0x01D00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXB_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_ldrexb_a1_a_special_cond_0_condition_eq_912_01d00390() {
    // Encoding: 0x01D00390
    // Test aarch32_LDREXB_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: cond=0, Rt=0, Rn=0
    let encoding: u32 = 0x01D00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXB_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_ldrexb_a1_a_special_cond_1_condition_ne_912_11d00390() {
    // Encoding: 0x11D00390
    // Test aarch32_LDREXB_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: cond=1, Rn=0, Rt=0
    let encoding: u32 = 0x11D00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXB_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_ldrexb_a1_a_special_cond_2_condition_cs_hs_912_21d00390() {
    // Encoding: 0x21D00390
    // Test aarch32_LDREXB_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: Rt=0, cond=2, Rn=0
    let encoding: u32 = 0x21D00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXB_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_ldrexb_a1_a_special_cond_3_condition_cc_lo_912_31d00390() {
    // Encoding: 0x31D00390
    // Test aarch32_LDREXB_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=3
    let encoding: u32 = 0x31D00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXB_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_ldrexb_a1_a_special_cond_4_condition_mi_912_41d00390() {
    // Encoding: 0x41D00390
    // Test aarch32_LDREXB_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: Rt=0, cond=4, Rn=0
    let encoding: u32 = 0x41D00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXB_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_ldrexb_a1_a_special_cond_5_condition_pl_912_51d00390() {
    // Encoding: 0x51D00390
    // Test aarch32_LDREXB_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: cond=5, Rt=0, Rn=0
    let encoding: u32 = 0x51D00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXB_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_ldrexb_a1_a_special_cond_6_condition_vs_912_61d00390() {
    // Encoding: 0x61D00390
    // Test aarch32_LDREXB_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: cond=6, Rn=0, Rt=0
    let encoding: u32 = 0x61D00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXB_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_ldrexb_a1_a_special_cond_7_condition_vc_912_71d00390() {
    // Encoding: 0x71D00390
    // Test aarch32_LDREXB_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: cond=7, Rn=0, Rt=0
    let encoding: u32 = 0x71D00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXB_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_ldrexb_a1_a_special_cond_8_condition_hi_912_81d00390() {
    // Encoding: 0x81D00390
    // Test aarch32_LDREXB_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: Rt=0, Rn=0, cond=8
    let encoding: u32 = 0x81D00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXB_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_ldrexb_a1_a_special_cond_9_condition_ls_912_91d00390() {
    // Encoding: 0x91D00390
    // Test aarch32_LDREXB_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: Rt=0, cond=9, Rn=0
    let encoding: u32 = 0x91D00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXB_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_ldrexb_a1_a_special_cond_10_condition_ge_912_a1d00390() {
    // Encoding: 0xA1D00390
    // Test aarch32_LDREXB_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: Rt=0, cond=10, Rn=0
    let encoding: u32 = 0xA1D00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXB_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_ldrexb_a1_a_special_cond_11_condition_lt_912_b1d00390() {
    // Encoding: 0xB1D00390
    // Test aarch32_LDREXB_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: Rt=0, Rn=0, cond=11
    let encoding: u32 = 0xB1D00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXB_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_ldrexb_a1_a_special_cond_12_condition_gt_912_c1d00390() {
    // Encoding: 0xC1D00390
    // Test aarch32_LDREXB_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: cond=12, Rn=0, Rt=0
    let encoding: u32 = 0xC1D00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXB_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_ldrexb_a1_a_special_cond_13_condition_le_912_d1d00390() {
    // Encoding: 0xD1D00390
    // Test aarch32_LDREXB_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: Rt=0, Rn=0, cond=13
    let encoding: u32 = 0xD1D00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXB_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_ldrexb_a1_a_special_cond_14_condition_al_912_e1d00390() {
    // Encoding: 0xE1D00390
    // Test aarch32_LDREXB_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=14
    let encoding: u32 = 0xE1D00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXB_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_ldrexb_a1_a_special_cond_15_condition_nv_912_f1d00390() {
    // Encoding: 0xF1D00390
    // Test aarch32_LDREXB_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: Rt=0, Rn=0, cond=15
    let encoding: u32 = 0xF1D00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXB_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrexb_a1_a_invalid_0_390_01d00390() {
    // Encoding: 0x01D00390
    // Test aarch32_LDREXB_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }
    // ISET: A32
    // Fields: Rn=0, cond=0, Rt=0
    let encoding: u32 = 0x01D00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDREXB_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrexb_a1_a_invalid_1_390_01d00390() {
    // Encoding: 0x01D00390
    // Test aarch32_LDREXB_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: cond=0, Rn=0, Rt=0
    let encoding: u32 = 0x01D00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDREXB_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrexb_t1_a_field_rn_0_min_40_e8d00040() {
    // Thumb encoding (32): 0xE8D00040
    // Test aarch32_LDREXB_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8D00040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDREXB_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrexb_t1_a_field_rn_1_poweroftwo_40_e8d10040() {
    // Thumb encoding (32): 0xE8D10040
    // Test aarch32_LDREXB_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=1, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8D10040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDREXB_T1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrexb_t1_a_field_rt_0_min_40_e8d00040() {
    // Thumb encoding (32): 0xE8D00040
    // Test aarch32_LDREXB_T1_A field Rt = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8D00040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDREXB_T1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrexb_t1_a_field_rt_1_poweroftwo_40_e8d01040() {
    // Thumb encoding (32): 0xE8D01040
    // Test aarch32_LDREXB_T1_A field Rt = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Rt=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8D01040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDREXB_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_ldrexb_t1_a_combo_0_40_e8d00040() {
    // Thumb encoding (32): 0xE8D00040
    // Test aarch32_LDREXB_T1_A field combination: Rn=0, Rt=0
    // ISET: T32
    // Fields: Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8D00040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDREXB_T1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrexb_t1_a_invalid_0_40_e8d00040() {
    // Thumb encoding (32): 0xE8D00040
    // Test aarch32_LDREXB_T1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }
    // ISET: T32
    // Fields: Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8D00040;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_LDREXB_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrexb_t1_a_invalid_1_40_e8d00040() {
    // Thumb encoding (32): 0xE8D00040
    // Test aarch32_LDREXB_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8D00040;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_LDREXB_A1_A
/// ASL: `SMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple multiply
#[test]
fn test_aarch32_ldrexb_a1_a_smull_oracle_0_9b227c20() {
    // Test SMULL: simple multiply (oracle)
    // Encoding: 0x9B227C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3);
    set_w(&mut cpu, 1, 0x2);
    let encoding: u32 = 0x9B227C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6, "X0 should be 0x0000000000000006");
}

/// Provenance: aarch32_LDREXB_A1_A
/// ASL: `SMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max 32-bit * 2
#[test]
fn test_aarch32_ldrexb_a1_a_smull_oracle_1_9b227c20() {
    // Test SMULL: max 32-bit * 2 (oracle)
    // Encoding: 0x9B227C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x9B227C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0xFFFFFFFFFFFFFFFE"
    );
}

/// Provenance: aarch32_LDREXB_A1_A
/// ASL: `SMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// large positive * large positive
#[test]
fn test_aarch32_ldrexb_a1_a_smull_oracle_2_9b227c20() {
    // Test SMULL: large positive * large positive (oracle)
    // Encoding: 0x9B227C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    set_w(&mut cpu, 2, 0x7FFFFFFF);
    let encoding: u32 = 0x9B227C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x3FFFFFFF00000001");
}

/// Provenance: aarch32_LDREXB_A1_A
/// ASL: `SMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max unsigned * max unsigned
#[test]
fn test_aarch32_ldrexb_a1_a_smull_oracle_3_9b227c20() {
    // Test SMULL: max unsigned * max unsigned (oracle)
    // Encoding: 0x9B227C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x9B227C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x0000000000000001");
}

/// Provenance: aarch32_LDREXB_A1_A
/// ASL: `SMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// medium values
#[test]
fn test_aarch32_ldrexb_a1_a_smull_oracle_4_9b227c20() {
    // Test SMULL: medium values (oracle)
    // Encoding: 0x9B227C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xC8);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x9B227C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4E20, "X0 should be 0x0000000000004E20");
}

/// Provenance: aarch32_LDREXB_A1_A
/// ASL: `SMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// 16-bit values
#[test]
fn test_aarch32_ldrexb_a1_a_smull_oracle_5_9b227c20() {
    // Test SMULL: 16-bit values (oracle)
    // Encoding: 0x9B227C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1234);
    set_w(&mut cpu, 2, 0x5678);
    let encoding: u32 = 0x9B227C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6260060, "X0 should be 0x0000000006260060");
}

// ============================================================================
// aarch32_LDRH_r_A Tests
// ============================================================================

/// Provenance: aarch32_LDRH_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_ldrh_r_a1_a_field_cond_0_min_b0_001000b0() {
    // Encoding: 0x001000B0
    // Test aarch32_LDRH_r_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: cond=0, P=0, U=0, Rn=0, Rt=0, W=0, Rm=0
    let encoding: u32 = 0x001000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_ldrh_r_a1_a_field_cond_1_poweroftwo_b0_101000b0() {
    // Encoding: 0x101000B0
    // Test aarch32_LDRH_r_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=1, Rt=0, Rm=0, U=0, P=0, W=0, Rn=0
    let encoding: u32 = 0x101000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_ldrh_r_a1_a_field_cond_2_poweroftwo_b0_201000b0() {
    // Encoding: 0x201000B0
    // Test aarch32_LDRH_r_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rt=0, P=0, Rm=0, W=0, cond=2, U=0
    let encoding: u32 = 0x201000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_ldrh_r_a1_a_field_cond_3_poweroftwo_b0_301000b0() {
    // Encoding: 0x301000B0
    // Test aarch32_LDRH_r_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, cond=3, U=0, W=0, Rn=0, Rt=0, Rm=0
    let encoding: u32 = 0x301000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_ldrh_r_a1_a_field_cond_4_poweroftwo_b0_401000b0() {
    // Encoding: 0x401000B0
    // Test aarch32_LDRH_r_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, U=0, Rt=0, Rm=0, cond=4, P=0, Rn=0
    let encoding: u32 = 0x401000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_ldrh_r_a1_a_field_cond_5_poweroftwo_b0_501000b0() {
    // Encoding: 0x501000B0
    // Test aarch32_LDRH_r_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rt=0, Rm=0, P=0, W=0, cond=5, U=0
    let encoding: u32 = 0x501000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_ldrh_r_a1_a_field_cond_6_poweroftwo_b0_601000b0() {
    // Encoding: 0x601000B0
    // Test aarch32_LDRH_r_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, P=0, Rm=0, U=0, W=0, Rn=0, cond=6
    let encoding: u32 = 0x601000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_ldrh_r_a1_a_field_cond_7_poweroftwo_b0_701000b0() {
    // Encoding: 0x701000B0
    // Test aarch32_LDRH_r_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, Rt=0, Rn=0, Rm=0, cond=7, P=0, U=0
    let encoding: u32 = 0x701000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_ldrh_r_a1_a_field_cond_8_poweroftwo_b0_801000b0() {
    // Encoding: 0x801000B0
    // Test aarch32_LDRH_r_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, Rn=0, Rt=0, Rm=0, cond=8, W=0, U=0
    let encoding: u32 = 0x801000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_ldrh_r_a1_a_field_cond_9_poweroftwo_b0_901000b0() {
    // Encoding: 0x901000B0
    // Test aarch32_LDRH_r_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, W=0, Rn=0, Rt=0, Rm=0, P=0, cond=9
    let encoding: u32 = 0x901000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_ldrh_r_a1_a_field_cond_10_poweroftwo_b0_a01000b0() {
    // Encoding: 0xA01000B0
    // Test aarch32_LDRH_r_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=10, Rn=0, W=0, U=0, Rt=0, Rm=0, P=0
    let encoding: u32 = 0xA01000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_ldrh_r_a1_a_field_cond_11_poweroftwo_b0_b01000b0() {
    // Encoding: 0xB01000B0
    // Test aarch32_LDRH_r_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, P=0, Rn=0, cond=11, Rt=0, W=0, Rm=0
    let encoding: u32 = 0xB01000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_ldrh_r_a1_a_field_cond_12_poweroftwo_b0_c01000b0() {
    // Encoding: 0xC01000B0
    // Test aarch32_LDRH_r_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Rn=0, P=0, cond=12, W=0, Rt=0, U=0
    let encoding: u32 = 0xC01000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_ldrh_r_a1_a_field_cond_13_poweroftwo_b0_d01000b0() {
    // Encoding: 0xD01000B0
    // Test aarch32_LDRH_r_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=13, Rm=0, Rt=0, P=0, Rn=0, W=0, U=0
    let encoding: u32 = 0xD01000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_ldrh_r_a1_a_field_cond_14_poweroftwo_b0_e01000b0() {
    // Encoding: 0xE01000B0
    // Test aarch32_LDRH_r_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, Rn=0, Rt=0, cond=14, P=0, W=0, Rm=0
    let encoding: u32 = 0xE01000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_ldrh_r_a1_a_field_cond_15_max_b0_f01000b0() {
    // Encoding: 0xF01000B0
    // Test aarch32_LDRH_r_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: P=0, U=0, W=0, Rm=0, Rn=0, cond=15, Rt=0
    let encoding: u32 = 0xF01000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_r_A1_A
/// ASL: `field P 24 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldrh_r_a1_a_field_p_0_min_b0_001000b0() {
    // Encoding: 0x001000B0
    // Test aarch32_LDRH_r_A1_A field P = 0 (Min)
    // ISET: A32
    // Fields: P=0, Rn=0, Rt=0, U=0, cond=0, Rm=0, W=0
    let encoding: u32 = 0x001000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_r_A1_A
/// ASL: `field P 24 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldrh_r_a1_a_field_p_1_max_b0_011000b0() {
    // Encoding: 0x011000B0
    // Test aarch32_LDRH_r_A1_A field P = 1 (Max)
    // ISET: A32
    // Fields: Rn=0, W=0, U=0, cond=0, Rm=0, P=1, Rt=0
    let encoding: u32 = 0x011000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_r_A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldrh_r_a1_a_field_u_0_min_b0_001000b0() {
    // Encoding: 0x001000B0
    // Test aarch32_LDRH_r_A1_A field U = 0 (Min)
    // ISET: A32
    // Fields: Rt=0, Rm=0, W=0, cond=0, U=0, P=0, Rn=0
    let encoding: u32 = 0x001000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_r_A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldrh_r_a1_a_field_u_1_max_b0_009000b0() {
    // Encoding: 0x009000B0
    // Test aarch32_LDRH_r_A1_A field U = 1 (Max)
    // ISET: A32
    // Fields: W=0, Rn=0, U=1, Rt=0, P=0, Rm=0, cond=0
    let encoding: u32 = 0x009000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_r_A1_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldrh_r_a1_a_field_w_0_min_b0_001000b0() {
    // Encoding: 0x001000B0
    // Test aarch32_LDRH_r_A1_A field W = 0 (Min)
    // ISET: A32
    // Fields: P=0, Rm=0, U=0, cond=0, W=0, Rn=0, Rt=0
    let encoding: u32 = 0x001000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_r_A1_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldrh_r_a1_a_field_w_1_max_b0_003000b0() {
    // Encoding: 0x003000B0
    // Test aarch32_LDRH_r_A1_A field W = 1 (Max)
    // ISET: A32
    // Fields: U=0, cond=0, Rt=0, W=1, Rn=0, Rm=0, P=0
    let encoding: u32 = 0x003000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_r_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrh_r_a1_a_field_rn_0_min_b0_001000b0() {
    // Encoding: 0x001000B0
    // Test aarch32_LDRH_r_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: P=0, W=0, Rn=0, Rt=0, Rm=0, cond=0, U=0
    let encoding: u32 = 0x001000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_r_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrh_r_a1_a_field_rn_1_poweroftwo_b0_001100b0() {
    // Encoding: 0x001100B0
    // Test aarch32_LDRH_r_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, cond=0, Rm=0, P=0, W=0, Rn=1, Rt=0
    let encoding: u32 = 0x001100B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_r_A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrh_r_a1_a_field_rt_0_min_b0_001000b0() {
    // Encoding: 0x001000B0
    // Test aarch32_LDRH_r_A1_A field Rt = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, Rm=0, cond=0, U=0, P=0, W=0, Rt=0
    let encoding: u32 = 0x001000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_r_A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrh_r_a1_a_field_rt_1_poweroftwo_b0_001010b0() {
    // Encoding: 0x001010B0
    // Test aarch32_LDRH_r_A1_A field Rt = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, cond=0, Rt=1, Rm=0, W=0, Rn=0, U=0
    let encoding: u32 = 0x001010B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_r_A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrh_r_a1_a_field_rm_0_min_b0_001000b0() {
    // Encoding: 0x001000B0
    // Test aarch32_LDRH_r_A1_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, U=0, P=0, cond=0, W=0, Rn=0, Rt=0
    let encoding: u32 = 0x001000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_r_A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrh_r_a1_a_field_rm_1_poweroftwo_b0_001000b1() {
    // Encoding: 0x001000B1
    // Test aarch32_LDRH_r_A1_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, Rm=1, Rn=0, cond=0, W=0, U=0, P=0
    let encoding: u32 = 0x001000B1;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_r_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_ldrh_r_a1_a_combo_0_b0_001000b0() {
    // Encoding: 0x001000B0
    // Test aarch32_LDRH_r_A1_A field combination: cond=0, P=0, U=0, W=0, Rn=0, Rt=0, Rm=0
    // ISET: A32
    // Fields: Rm=0, Rt=0, U=0, P=0, W=0, cond=0, Rn=0
    let encoding: u32 = 0x001000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_r_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_ldrh_r_a1_a_special_cond_0_condition_eq_176_001000b0() {
    // Encoding: 0x001000B0
    // Test aarch32_LDRH_r_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: cond=0, U=0, Rn=0, Rm=0, Rt=0, P=0, W=0
    let encoding: u32 = 0x001000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_r_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_ldrh_r_a1_a_special_cond_1_condition_ne_176_101000b0() {
    // Encoding: 0x101000B0
    // Test aarch32_LDRH_r_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: Rm=0, cond=1, Rn=0, U=0, P=0, Rt=0, W=0
    let encoding: u32 = 0x101000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_r_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_ldrh_r_a1_a_special_cond_2_condition_cs_hs_176_201000b0() {
    // Encoding: 0x201000B0
    // Test aarch32_LDRH_r_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: U=0, W=0, cond=2, P=0, Rn=0, Rm=0, Rt=0
    let encoding: u32 = 0x201000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_r_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_ldrh_r_a1_a_special_cond_3_condition_cc_lo_176_301000b0() {
    // Encoding: 0x301000B0
    // Test aarch32_LDRH_r_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: cond=3, W=0, P=0, Rn=0, Rt=0, Rm=0, U=0
    let encoding: u32 = 0x301000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_r_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_ldrh_r_a1_a_special_cond_4_condition_mi_176_401000b0() {
    // Encoding: 0x401000B0
    // Test aarch32_LDRH_r_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: U=0, Rn=0, cond=4, Rm=0, W=0, P=0, Rt=0
    let encoding: u32 = 0x401000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_r_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_ldrh_r_a1_a_special_cond_5_condition_pl_176_501000b0() {
    // Encoding: 0x501000B0
    // Test aarch32_LDRH_r_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: Rm=0, P=0, U=0, W=0, Rn=0, cond=5, Rt=0
    let encoding: u32 = 0x501000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_r_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_ldrh_r_a1_a_special_cond_6_condition_vs_176_601000b0() {
    // Encoding: 0x601000B0
    // Test aarch32_LDRH_r_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: W=0, Rn=0, Rt=0, Rm=0, U=0, P=0, cond=6
    let encoding: u32 = 0x601000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_r_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_ldrh_r_a1_a_special_cond_7_condition_vc_176_701000b0() {
    // Encoding: 0x701000B0
    // Test aarch32_LDRH_r_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: Rt=0, cond=7, U=0, W=0, P=0, Rn=0, Rm=0
    let encoding: u32 = 0x701000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_r_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_ldrh_r_a1_a_special_cond_8_condition_hi_176_801000b0() {
    // Encoding: 0x801000B0
    // Test aarch32_LDRH_r_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: Rn=0, Rt=0, Rm=0, cond=8, P=0, U=0, W=0
    let encoding: u32 = 0x801000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_r_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_ldrh_r_a1_a_special_cond_9_condition_ls_176_901000b0() {
    // Encoding: 0x901000B0
    // Test aarch32_LDRH_r_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: Rt=0, W=0, Rn=0, Rm=0, cond=9, P=0, U=0
    let encoding: u32 = 0x901000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_r_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_ldrh_r_a1_a_special_cond_10_condition_ge_176_a01000b0() {
    // Encoding: 0xA01000B0
    // Test aarch32_LDRH_r_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: P=0, U=0, Rn=0, Rt=0, Rm=0, cond=10, W=0
    let encoding: u32 = 0xA01000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_r_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_ldrh_r_a1_a_special_cond_11_condition_lt_176_b01000b0() {
    // Encoding: 0xB01000B0
    // Test aarch32_LDRH_r_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: Rt=0, Rm=0, cond=11, P=0, W=0, Rn=0, U=0
    let encoding: u32 = 0xB01000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_r_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_ldrh_r_a1_a_special_cond_12_condition_gt_176_c01000b0() {
    // Encoding: 0xC01000B0
    // Test aarch32_LDRH_r_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: Rt=0, P=0, U=0, cond=12, W=0, Rm=0, Rn=0
    let encoding: u32 = 0xC01000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_r_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_ldrh_r_a1_a_special_cond_13_condition_le_176_d01000b0() {
    // Encoding: 0xD01000B0
    // Test aarch32_LDRH_r_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: Rt=0, Rm=0, U=0, cond=13, W=0, P=0, Rn=0
    let encoding: u32 = 0xD01000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_r_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_ldrh_r_a1_a_special_cond_14_condition_al_176_e01000b0() {
    // Encoding: 0xE01000B0
    // Test aarch32_LDRH_r_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: Rn=0, P=0, Rt=0, Rm=0, cond=14, U=0, W=0
    let encoding: u32 = 0xE01000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_r_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_ldrh_r_a1_a_special_cond_15_condition_nv_176_f01000b0() {
    // Encoding: 0xF01000B0
    // Test aarch32_LDRH_r_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: P=0, U=0, cond=15, Rn=0, Rt=0, W=0, Rm=0
    let encoding: u32 = 0xF01000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_r_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrh_r_a1_a_invalid_0_b0_001000b0() {
    // Encoding: 0x001000B0
    // Test aarch32_LDRH_r_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }
    // ISET: A32
    // Fields: P=0, Rt=0, Rm=0, U=0, Rn=0, cond=0, W=0
    let encoding: u32 = 0x001000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRH_r_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrh_r_a1_a_invalid_1_b0_001000b0() {
    // Encoding: 0x001000B0
    // Test aarch32_LDRH_r_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: cond=0, U=0, W=0, P=0, Rn=0, Rt=0, Rm=0
    let encoding: u32 = 0x001000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRH_r_A1_A
/// ASL: `Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"wback\" }), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }) } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrh_r_a1_a_invalid_2_b0_001000b0() {
    // Encoding: 0x001000B0
    // Test aarch32_LDRH_r_A1_A invalid encoding: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) } }
    // ISET: A32
    // Fields: U=0, Rn=0, Rt=0, P=0, Rm=0, W=0, cond=0
    let encoding: u32 = 0x001000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRH_r_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrh_r_a1_a_invalid_3_b0_001000b0() {
    // Encoding: 0x001000B0
    // Test aarch32_LDRH_r_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Rm=0, W=0, Rn=0, P=0, cond=0, U=0, Rt=0
    let encoding: u32 = 0x001000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRH_r_T1_A
/// ASL: `field Rm 22 +: 3`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrh_r_t1_a_field_rm_0_min_0_5a000000() {
    // Thumb encoding (32): 0x5A000000
    // Test aarch32_LDRH_r_T1_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rt=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x5A000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_r_T1_A
/// ASL: `field Rm 22 +: 3`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrh_r_t1_a_field_rm_1_poweroftwo_0_5a400000() {
    // Thumb encoding (32): 0x5A400000
    // Test aarch32_LDRH_r_T1_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Rm=1, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x5A400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_r_T1_A
/// ASL: `field Rn 19 +: 3`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrh_r_t1_a_field_rn_0_min_0_5a000000() {
    // Thumb encoding (32): 0x5A000000
    // Test aarch32_LDRH_r_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rm=0, Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x5A000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_r_T1_A
/// ASL: `field Rn 19 +: 3`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrh_r_t1_a_field_rn_1_poweroftwo_0_5a080000() {
    // Thumb encoding (32): 0x5A080000
    // Test aarch32_LDRH_r_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, Rn=1, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x5A080000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_r_T1_A
/// ASL: `field Rt 16 +: 3`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrh_r_t1_a_field_rt_0_min_0_5a000000() {
    // Thumb encoding (32): 0x5A000000
    // Test aarch32_LDRH_r_T1_A field Rt = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rm=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x5A000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_r_T1_A
/// ASL: `field Rt 16 +: 3`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrh_r_t1_a_field_rt_1_poweroftwo_0_5a010000() {
    // Thumb encoding (32): 0x5A010000
    // Test aarch32_LDRH_r_T1_A field Rt = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=0, Rn=0, Rt=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x5A010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_r_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch32_ldrh_r_t1_a_combo_0_0_5a000000() {
    // Thumb encoding (32): 0x5A000000
    // Test aarch32_LDRH_r_T1_A field combination: Rm=0, Rn=0, Rt=0
    // ISET: T32
    // Fields: Rt=0, Rm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x5A000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_r_T2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrh_r_t2_a_field_rn_0_min_0_f8300000() {
    // Thumb encoding (32): 0xF8300000
    // Test aarch32_LDRH_r_T2_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rt=0, Rm=0, Rn=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8300000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_r_T2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrh_r_t2_a_field_rn_1_poweroftwo_0_f8310000() {
    // Thumb encoding (32): 0xF8310000
    // Test aarch32_LDRH_r_T2_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=0, imm2=0, Rn=1, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8310000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_r_T2_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrh_r_t2_a_field_rt_0_min_0_f8300000() {
    // Thumb encoding (32): 0xF8300000
    // Test aarch32_LDRH_r_T2_A field Rt = 0 (Min)
    // ISET: T32
    // Fields: Rm=0, Rn=0, imm2=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8300000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_r_T2_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrh_r_t2_a_field_rt_1_poweroftwo_0_f8301000() {
    // Thumb encoding (32): 0xF8301000
    // Test aarch32_LDRH_r_T2_A field Rt = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, imm2=0, Rt=1, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8301000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_r_T2_A
/// ASL: `field imm2 4 +: 2`
/// Requirement: FieldBoundary { field: "imm2", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_ldrh_r_t2_a_field_imm2_0_zero_0_f8300000() {
    // Thumb encoding (32): 0xF8300000
    // Test aarch32_LDRH_r_T2_A field imm2 = 0 (Zero)
    // ISET: T32
    // Fields: Rn=0, Rm=0, Rt=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8300000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_r_T2_A
/// ASL: `field imm2 4 +: 2`
/// Requirement: FieldBoundary { field: "imm2", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_ldrh_r_t2_a_field_imm2_1_poweroftwo_0_f8300010() {
    // Thumb encoding (32): 0xF8300010
    // Test aarch32_LDRH_r_T2_A field imm2 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, imm2=1, Rm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8300010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_r_T2_A
/// ASL: `field imm2 4 +: 2`
/// Requirement: FieldBoundary { field: "imm2", value: 3, boundary: Max }
/// maximum immediate (3)
#[test]
fn test_aarch32_ldrh_r_t2_a_field_imm2_3_max_0_f8300030() {
    // Thumb encoding (32): 0xF8300030
    // Test aarch32_LDRH_r_T2_A field imm2 = 3 (Max)
    // ISET: T32
    // Fields: Rn=0, imm2=3, Rm=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8300030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_r_T2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrh_r_t2_a_field_rm_0_min_0_f8300000() {
    // Thumb encoding (32): 0xF8300000
    // Test aarch32_LDRH_r_T2_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: imm2=0, Rt=0, Rn=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8300000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_r_T2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrh_r_t2_a_field_rm_1_poweroftwo_0_f8300001() {
    // Thumb encoding (32): 0xF8300001
    // Test aarch32_LDRH_r_T2_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, Rn=0, Rm=1, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8300001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_r_T2_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_ldrh_r_t2_a_combo_0_0_f8300000() {
    // Thumb encoding (32): 0xF8300000
    // Test aarch32_LDRH_r_T2_A field combination: Rn=0, Rt=0, imm2=0, Rm=0
    // ISET: T32
    // Fields: Rm=0, Rn=0, Rt=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8300000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_r_T2_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }), rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }), rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrh_r_t2_a_invalid_0_0_f8300000() {
    // Thumb encoding (32): 0xF8300000
    // Test aarch32_LDRH_r_T2_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }), rhs: LitInt(15) }
    // ISET: T32
    // Fields: Rm=0, Rn=0, Rt=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8300000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRH_r_T2_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrh_r_t2_a_invalid_1_0_f8300000() {
    // Thumb encoding (32): 0xF8300000
    // Test aarch32_LDRH_r_T2_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rm=0, Rn=0, imm2=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8300000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRH_r_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple multiply (32)
#[test]
fn test_aarch32_ldrh_r_a1_a_mul_oracle_32_0_1b027c20() {
    // Test MUL 32-bit: simple multiply (oracle)
    // Encoding: 0x1B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3);
    set_w(&mut cpu, 1, 0x2);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6, "W0 should be 0x00000006");
}

/// Provenance: aarch32_LDRH_r_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple multiply (64)
#[test]
fn test_aarch32_ldrh_r_a1_a_mul_oracle_64_0_9b027c20() {
    // Test MUL 64-bit: simple multiply (oracle)
    // Encoding: 0x9B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x2);
    set_w(&mut cpu, 2, 0x3);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6, "X0 should be 0x0000000000000006");
}

/// Provenance: aarch32_LDRH_r_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// multiply by zero (32)
#[test]
fn test_aarch32_ldrh_r_a1_a_mul_oracle_32_1_1b027c20() {
    // Test MUL 32-bit: multiply by zero (oracle)
    // Encoding: 0x1B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x64);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_LDRH_r_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// multiply by zero (64)
#[test]
fn test_aarch32_ldrh_r_a1_a_mul_oracle_64_1_9b027c20() {
    // Test MUL 64-bit: multiply by zero (oracle)
    // Encoding: 0x9B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x64);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_LDRH_r_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// multiply by one (32)
#[test]
fn test_aarch32_ldrh_r_a1_a_mul_oracle_32_2_1b027c20() {
    // Test MUL 32-bit: multiply by one (oracle)
    // Encoding: 0x1B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_LDRH_r_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// multiply by one (64)
#[test]
fn test_aarch32_ldrh_r_a1_a_mul_oracle_64_2_9b027c20() {
    // Test MUL 64-bit: multiply by one (oracle)
    // Encoding: 0x9B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x0000000000000001");
}

/// Provenance: aarch32_LDRH_r_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// 16-bit max * 16-bit max (32)
#[test]
fn test_aarch32_ldrh_r_a1_a_mul_oracle_32_3_1b027c20() {
    // Test MUL 32-bit: 16-bit max * 16-bit max (oracle)
    // Encoding: 0x1B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFF);
    set_w(&mut cpu, 1, 0xFFFF);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFE0001, "W0 should be 0xFFFE0001");
}

/// Provenance: aarch32_LDRH_r_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// 16-bit max * 16-bit max (64)
#[test]
fn test_aarch32_ldrh_r_a1_a_mul_oracle_64_3_9b027c20() {
    // Test MUL 64-bit: 16-bit max * 16-bit max (oracle)
    // Encoding: 0x9B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFF);
    set_w(&mut cpu, 2, 0xFFFF);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFE0001,
        "X0 should be 0x00000000FFFE0001"
    );
}

/// Provenance: aarch32_LDRH_r_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift-like multiply (32)
#[test]
fn test_aarch32_ldrh_r_a1_a_mul_oracle_32_4_1b027c20() {
    // Test MUL 32-bit: shift-like multiply (oracle)
    // Encoding: 0x1B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x2468ACF0, "W0 should be 0x2468ACF0");
}

/// Provenance: aarch32_LDRH_r_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift-like multiply (64)
#[test]
fn test_aarch32_ldrh_r_a1_a_mul_oracle_64_4_9b027c20() {
    // Test MUL 64-bit: shift-like multiply (oracle)
    // Encoding: 0x9B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x2468ACF0,
        "X0 should be 0x000000002468ACF0"
    );
}

/// Provenance: aarch32_LDRH_r_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// larger values (32)
#[test]
fn test_aarch32_ldrh_r_a1_a_mul_oracle_32_5_1b027c20() {
    // Test MUL 32-bit: larger values (oracle)
    // Encoding: 0x1B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0xC8);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4E20, "W0 should be 0x00004E20");
}

/// Provenance: aarch32_LDRH_r_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// larger values (64)
#[test]
fn test_aarch32_ldrh_r_a1_a_mul_oracle_64_5_9b027c20() {
    // Test MUL 64-bit: larger values (oracle)
    // Encoding: 0x9B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xC8);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4E20, "X0 should be 0x0000000000004E20");
}

/// Provenance: aarch32_LDRH_r_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// 32-bit overflow (32)
#[test]
fn test_aarch32_ldrh_r_a1_a_mul_oracle_32_6_1b027c20() {
    // Test MUL 32-bit: 32-bit overflow (oracle)
    // Encoding: 0x1B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_LDRH_r_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// 32-bit overflow (64)
#[test]
fn test_aarch32_ldrh_r_a1_a_mul_oracle_64_6_9b027c20() {
    // Test MUL 64-bit: 32-bit overflow (oracle)
    // Encoding: 0x9B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0xFFFFFFFE00000001");
}

/// Provenance: aarch32_LDRH_r_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// prime numbers (32)
#[test]
fn test_aarch32_ldrh_r_a1_a_mul_oracle_32_7_1b027c20() {
    // Test MUL 32-bit: prime numbers (oracle)
    // Encoding: 0x1B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7);
    set_w(&mut cpu, 2, 0xB);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4D, "W0 should be 0x0000004D");
}

/// Provenance: aarch32_LDRH_r_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// prime numbers (64)
#[test]
fn test_aarch32_ldrh_r_a1_a_mul_oracle_64_7_9b027c20() {
    // Test MUL 64-bit: prime numbers (oracle)
    // Encoding: 0x9B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7);
    set_w(&mut cpu, 2, 0xB);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4D, "X0 should be 0x000000000000004D");
}

/// Provenance: aarch32_LDRH_r_A1_A
/// ASL: `MUL R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple values
#[test]
fn test_aarch32_ldrh_r_a1_a_a32_mul_0_0000f291() {
    // Test A32 MUL: simple values (oracle)
    // Encoding: 0x0000F291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x32);
    let encoding: u32 = 0x0000F291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1388, "R0 should be 0x00001388");
}

/// Provenance: aarch32_LDRH_r_A1_A
/// ASL: `MUL R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero values
#[test]
fn test_aarch32_ldrh_r_a1_a_a32_mul_1_0000f291() {
    // Test A32 MUL: zero values (oracle)
    // Encoding: 0x0000F291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x0000F291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_LDRH_r_A1_A
/// ASL: `MUL R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max value
#[test]
fn test_aarch32_ldrh_r_a1_a_a32_mul_2_0000f291() {
    // Test A32 MUL: max value (oracle)
    // Encoding: 0x0000F291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x0000F291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "R0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_LDRH_r_A1_A
/// ASL: `MUL R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set
#[test]
fn test_aarch32_ldrh_r_a1_a_a32_mul_3_0000f291() {
    // Test A32 MUL: MSB set (oracle)
    // Encoding: 0x0000F291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    set_w(&mut cpu, 2, 0x80000000);
    let encoding: u32 = 0x0000F291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_LDRH_r_A1_A
/// ASL: `MUL R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// mixed pattern
#[test]
fn test_aarch32_ldrh_r_a1_a_a32_mul_4_0000f291() {
    // Test A32 MUL: mixed pattern (oracle)
    // Encoding: 0x0000F291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x9ABCDEF0);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u32 = 0x0000F291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x242D2080, "R0 should be 0x242D2080");
}

/// Provenance: aarch32_LDRH_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 0 (32)
#[test]
fn test_aarch32_ldrh_r_t1_a_lslv_oracle_32_0_5a020020() {
    // Test LSLV 32-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x12345678, "W0 should be 0x12345678");
}

/// Provenance: aarch32_LDRH_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 0 (64)
#[test]
fn test_aarch32_ldrh_r_t1_a_lslv_oracle_64_0_da020020() {
    // Test LSLV 64-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x12345678,
        "X0 should be 0x0000000012345678"
    );
}

/// Provenance: aarch32_LDRH_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4 (32)
#[test]
fn test_aarch32_ldrh_r_t1_a_lslv_oracle_32_1_5a020020() {
    // Test LSLV 32-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x4);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x23456780, "W0 should be 0x23456780");
}

/// Provenance: aarch32_LDRH_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 4 (64)
#[test]
fn test_aarch32_ldrh_r_t1_a_lslv_oracle_64_1_da020020() {
    // Test LSLV 64-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x4);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x23456780,
        "X0 should be 0x0000000123456780"
    );
}

/// Provenance: aarch32_LDRH_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 8 (32)
#[test]
fn test_aarch32_ldrh_r_t1_a_lslv_oracle_32_2_5a020020() {
    // Test LSLV 32-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x8);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x34567800, "W0 should be 0x34567800");
}

/// Provenance: aarch32_LDRH_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 8 (64)
#[test]
fn test_aarch32_ldrh_r_t1_a_lslv_oracle_64_2_da020020() {
    // Test LSLV 64-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x8);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x34567800,
        "X0 should be 0x0000001234567800"
    );
}

/// Provenance: aarch32_LDRH_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1 (32)
#[test]
fn test_aarch32_ldrh_r_t1_a_lslv_oracle_32_3_5a020020() {
    // Test LSLV 32-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_LDRH_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// MSB set, shift 1 (64)
#[test]
fn test_aarch32_ldrh_r_t1_a_lslv_oracle_64_3_da020020() {
    // Test LSLV 64-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_LDRH_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// LSB set, max shift (32)
#[test]
fn test_aarch32_ldrh_r_t1_a_lslv_oracle_32_4_5a020020() {
    // Test LSLV 32-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3F);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "W0 should be 0x80000000");
}

/// Provenance: aarch32_LDRH_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// LSB set, max shift (64)
#[test]
fn test_aarch32_ldrh_r_t1_a_lslv_oracle_64_4_da020020() {
    // Test LSLV 64-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x3F);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x8000000000000000");
}

/// Provenance: aarch32_LDRH_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// all ones, shift 32 (32)
#[test]
fn test_aarch32_ldrh_r_t1_a_lslv_oracle_32_5_5a020020() {
    // Test LSLV 32-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x20);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "W0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_LDRH_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// all ones, shift 32 (64)
#[test]
fn test_aarch32_ldrh_r_t1_a_lslv_oracle_64_5_da020020() {
    // Test LSLV 64-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x20);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0xFFFFFFFF00000000");
}

/// Provenance: aarch32_LDRH_r_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// no shift
#[test]
fn test_aarch32_ldrh_r_t1_a_t16_oracle_0_5a880000() {
    // Test T16 LSLS: no shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_LDRH_r_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4
#[test]
fn test_aarch32_ldrh_r_t1_a_t16_oracle_1_5a880000() {
    // Test T16 LSLS: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    set_w(&mut cpu, 2, 0x4);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF0, "R0 should be 0x00000FF0");
}

/// Provenance: aarch32_LDRH_r_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1
#[test]
fn test_aarch32_ldrh_r_t1_a_t16_oracle_2_5a880000() {
    // Test T16 LSLS: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_LDRH_r_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift to MSB
#[test]
fn test_aarch32_ldrh_r_t1_a_t16_oracle_3_5a880000() {
    // Test T16 LSLS: shift to MSB (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x1F);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "R0 should be 0x80000000");
}

// ============================================================================
// aarch32_LDRSHT_A Tests
// ============================================================================

/// Provenance: aarch32_LDRSHT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_ldrsht_a1_a_field_cond_0_min_f0_007000f0() {
    // Encoding: 0x007000F0
    // Test aarch32_LDRSHT_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: U=0, Rn=0, cond=0, Rt=0, imm4L=0, imm4H=0
    let encoding: u32 = 0x007000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSHT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_ldrsht_a1_a_field_cond_1_poweroftwo_f0_107000f0() {
    // Encoding: 0x107000F0
    // Test aarch32_LDRSHT_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=1, U=0, Rt=0, imm4H=0, imm4L=0, Rn=0
    let encoding: u32 = 0x107000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSHT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_ldrsht_a1_a_field_cond_2_poweroftwo_f0_207000f0() {
    // Encoding: 0x207000F0
    // Test aarch32_LDRSHT_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, imm4H=0, Rt=0, cond=2, U=0, imm4L=0
    let encoding: u32 = 0x207000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSHT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_ldrsht_a1_a_field_cond_3_poweroftwo_f0_307000f0() {
    // Encoding: 0x307000F0
    // Test aarch32_LDRSHT_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, imm4L=0, cond=3, Rn=0, imm4H=0, Rt=0
    let encoding: u32 = 0x307000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSHT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_ldrsht_a1_a_field_cond_4_poweroftwo_f0_407000f0() {
    // Encoding: 0x407000F0
    // Test aarch32_LDRSHT_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rt=0, U=0, imm4L=0, imm4H=0, cond=4
    let encoding: u32 = 0x407000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSHT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_ldrsht_a1_a_field_cond_5_poweroftwo_f0_507000f0() {
    // Encoding: 0x507000F0
    // Test aarch32_LDRSHT_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=5, U=0, Rt=0, imm4H=0, Rn=0, imm4L=0
    let encoding: u32 = 0x507000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSHT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_ldrsht_a1_a_field_cond_6_poweroftwo_f0_607000f0() {
    // Encoding: 0x607000F0
    // Test aarch32_LDRSHT_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=6, Rt=0, imm4H=0, Rn=0, U=0, imm4L=0
    let encoding: u32 = 0x607000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSHT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_ldrsht_a1_a_field_cond_7_poweroftwo_f0_707000f0() {
    // Encoding: 0x707000F0
    // Test aarch32_LDRSHT_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4L=0, cond=7, U=0, Rt=0, Rn=0, imm4H=0
    let encoding: u32 = 0x707000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSHT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_ldrsht_a1_a_field_cond_8_poweroftwo_f0_807000f0() {
    // Encoding: 0x807000F0
    // Test aarch32_LDRSHT_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, U=0, imm4L=0, cond=8, imm4H=0, Rn=0
    let encoding: u32 = 0x807000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSHT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_ldrsht_a1_a_field_cond_9_poweroftwo_f0_907000f0() {
    // Encoding: 0x907000F0
    // Test aarch32_LDRSHT_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, imm4L=0, imm4H=0, U=0, cond=9, Rt=0
    let encoding: u32 = 0x907000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSHT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_ldrsht_a1_a_field_cond_10_poweroftwo_f0_a07000f0() {
    // Encoding: 0xA07000F0
    // Test aarch32_LDRSHT_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, Rt=0, cond=10, imm4L=0, Rn=0, imm4H=0
    let encoding: u32 = 0xA07000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSHT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_ldrsht_a1_a_field_cond_11_poweroftwo_f0_b07000f0() {
    // Encoding: 0xB07000F0
    // Test aarch32_LDRSHT_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4L=0, Rn=0, Rt=0, imm4H=0, U=0, cond=11
    let encoding: u32 = 0xB07000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSHT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_ldrsht_a1_a_field_cond_12_poweroftwo_f0_c07000f0() {
    // Encoding: 0xC07000F0
    // Test aarch32_LDRSHT_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4L=0, cond=12, Rt=0, imm4H=0, U=0, Rn=0
    let encoding: u32 = 0xC07000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSHT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_ldrsht_a1_a_field_cond_13_poweroftwo_f0_d07000f0() {
    // Encoding: 0xD07000F0
    // Test aarch32_LDRSHT_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=13, Rt=0, imm4H=0, U=0, imm4L=0
    let encoding: u32 = 0xD07000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSHT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_ldrsht_a1_a_field_cond_14_poweroftwo_f0_e07000f0() {
    // Encoding: 0xE07000F0
    // Test aarch32_LDRSHT_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=14, Rt=0, imm4L=0, imm4H=0, U=0, Rn=0
    let encoding: u32 = 0xE07000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSHT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_ldrsht_a1_a_field_cond_15_max_f0_f07000f0() {
    // Encoding: 0xF07000F0
    // Test aarch32_LDRSHT_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: U=0, cond=15, Rn=0, Rt=0, imm4L=0, imm4H=0
    let encoding: u32 = 0xF07000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSHT_A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldrsht_a1_a_field_u_0_min_f0_007000f0() {
    // Encoding: 0x007000F0
    // Test aarch32_LDRSHT_A1_A field U = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rt=0, imm4H=0, Rn=0, imm4L=0, U=0
    let encoding: u32 = 0x007000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSHT_A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldrsht_a1_a_field_u_1_max_f0_00f000f0() {
    // Encoding: 0x00F000F0
    // Test aarch32_LDRSHT_A1_A field U = 1 (Max)
    // ISET: A32
    // Fields: Rt=0, Rn=0, imm4L=0, imm4H=0, cond=0, U=1
    let encoding: u32 = 0x00F000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSHT_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrsht_a1_a_field_rn_0_min_f0_007000f0() {
    // Encoding: 0x007000F0
    // Test aarch32_LDRSHT_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: imm4H=0, imm4L=0, Rn=0, cond=0, U=0, Rt=0
    let encoding: u32 = 0x007000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSHT_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrsht_a1_a_field_rn_1_poweroftwo_f0_007100f0() {
    // Encoding: 0x007100F0
    // Test aarch32_LDRSHT_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, imm4L=0, imm4H=0, U=0, cond=0, Rn=1
    let encoding: u32 = 0x007100F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSHT_A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrsht_a1_a_field_rt_0_min_f0_007000f0() {
    // Encoding: 0x007000F0
    // Test aarch32_LDRSHT_A1_A field Rt = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rn=0, U=0, imm4H=0, Rt=0, imm4L=0
    let encoding: u32 = 0x007000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSHT_A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrsht_a1_a_field_rt_1_poweroftwo_f0_007010f0() {
    // Encoding: 0x007010F0
    // Test aarch32_LDRSHT_A1_A field Rt = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4H=0, Rt=1, U=0, cond=0, Rn=0, imm4L=0
    let encoding: u32 = 0x007010F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSHT_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_ldrsht_a1_a_field_imm4h_0_zero_f0_007000f0() {
    // Encoding: 0x007000F0
    // Test aarch32_LDRSHT_A1_A field imm4H = 0 (Zero)
    // ISET: A32
    // Fields: cond=0, Rt=0, Rn=0, imm4H=0, U=0, imm4L=0
    let encoding: u32 = 0x007000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSHT_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_ldrsht_a1_a_field_imm4h_1_poweroftwo_f0_007001f0() {
    // Encoding: 0x007001F0
    // Test aarch32_LDRSHT_A1_A field imm4H = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4H=1, Rn=0, cond=0, Rt=0, imm4L=0, U=0
    let encoding: u32 = 0x007001F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSHT_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_ldrsht_a1_a_field_imm4h_3_poweroftwominusone_f0_007003f0() {
    // Encoding: 0x007003F0
    // Test aarch32_LDRSHT_A1_A field imm4H = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm4H=3, Rt=0, U=0, Rn=0, imm4L=0, cond=0
    let encoding: u32 = 0x007003F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSHT_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_ldrsht_a1_a_field_imm4h_4_poweroftwo_f0_007004f0() {
    // Encoding: 0x007004F0
    // Test aarch32_LDRSHT_A1_A field imm4H = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4H=4, imm4L=0, cond=0, Rt=0, Rn=0, U=0
    let encoding: u32 = 0x007004F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSHT_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_aarch32_ldrsht_a1_a_field_imm4h_7_poweroftwominusone_f0_007007f0() {
    // Encoding: 0x007007F0
    // Test aarch32_LDRSHT_A1_A field imm4H = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: U=0, cond=0, Rn=0, imm4H=7, Rt=0, imm4L=0
    let encoding: u32 = 0x007007F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSHT_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_ldrsht_a1_a_field_imm4h_8_poweroftwo_f0_007008f0() {
    // Encoding: 0x007008F0
    // Test aarch32_LDRSHT_A1_A field imm4H = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4L=0, Rn=0, cond=0, U=0, Rt=0, imm4H=8
    let encoding: u32 = 0x007008F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSHT_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_aarch32_ldrsht_a1_a_field_imm4h_15_max_f0_00700ff0() {
    // Encoding: 0x00700FF0
    // Test aarch32_LDRSHT_A1_A field imm4H = 15 (Max)
    // ISET: A32
    // Fields: imm4H=15, Rn=0, U=0, cond=0, Rt=0, imm4L=0
    let encoding: u32 = 0x00700FF0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSHT_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_ldrsht_a1_a_field_imm4l_0_zero_f0_007000f0() {
    // Encoding: 0x007000F0
    // Test aarch32_LDRSHT_A1_A field imm4L = 0 (Zero)
    // ISET: A32
    // Fields: Rn=0, imm4H=0, cond=0, imm4L=0, Rt=0, U=0
    let encoding: u32 = 0x007000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSHT_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_ldrsht_a1_a_field_imm4l_1_poweroftwo_f0_007000f1() {
    // Encoding: 0x007000F1
    // Test aarch32_LDRSHT_A1_A field imm4L = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4L=1, Rt=0, imm4H=0, cond=0, U=0, Rn=0
    let encoding: u32 = 0x007000F1;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSHT_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_ldrsht_a1_a_field_imm4l_3_poweroftwominusone_f0_007000f3() {
    // Encoding: 0x007000F3
    // Test aarch32_LDRSHT_A1_A field imm4L = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: U=0, Rt=0, Rn=0, cond=0, imm4H=0, imm4L=3
    let encoding: u32 = 0x007000F3;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSHT_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_ldrsht_a1_a_field_imm4l_4_poweroftwo_f0_007000f4() {
    // Encoding: 0x007000F4
    // Test aarch32_LDRSHT_A1_A field imm4L = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, imm4H=0, Rn=0, imm4L=4, cond=0, Rt=0
    let encoding: u32 = 0x007000F4;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSHT_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_aarch32_ldrsht_a1_a_field_imm4l_7_poweroftwominusone_f0_007000f7() {
    // Encoding: 0x007000F7
    // Test aarch32_LDRSHT_A1_A field imm4L = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: U=0, Rt=0, cond=0, Rn=0, imm4H=0, imm4L=7
    let encoding: u32 = 0x007000F7;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSHT_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_ldrsht_a1_a_field_imm4l_8_poweroftwo_f0_007000f8() {
    // Encoding: 0x007000F8
    // Test aarch32_LDRSHT_A1_A field imm4L = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Rn=0, Rt=0, imm4H=0, imm4L=8, U=0
    let encoding: u32 = 0x007000F8;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSHT_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_aarch32_ldrsht_a1_a_field_imm4l_15_max_f0_007000ff() {
    // Encoding: 0x007000FF
    // Test aarch32_LDRSHT_A1_A field imm4L = 15 (Max)
    // ISET: A32
    // Fields: imm4H=0, Rn=0, Rt=0, U=0, imm4L=15, cond=0
    let encoding: u32 = 0x007000FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSHT_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_ldrsht_a1_a_combo_0_f0_007000f0() {
    // Encoding: 0x007000F0
    // Test aarch32_LDRSHT_A1_A field combination: cond=0, U=0, Rn=0, Rt=0, imm4H=0, imm4L=0
    // ISET: A32
    // Fields: Rt=0, U=0, cond=0, Rn=0, imm4H=0, imm4L=0
    let encoding: u32 = 0x007000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSHT_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_ldrsht_a1_a_special_cond_0_condition_eq_240_007000f0() {
    // Encoding: 0x007000F0
    // Test aarch32_LDRSHT_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: cond=0, imm4L=0, imm4H=0, Rn=0, Rt=0, U=0
    let encoding: u32 = 0x007000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSHT_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_ldrsht_a1_a_special_cond_1_condition_ne_240_107000f0() {
    // Encoding: 0x107000F0
    // Test aarch32_LDRSHT_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: Rt=0, imm4H=0, U=0, Rn=0, imm4L=0, cond=1
    let encoding: u32 = 0x107000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSHT_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_ldrsht_a1_a_special_cond_2_condition_cs_hs_240_207000f0() {
    // Encoding: 0x207000F0
    // Test aarch32_LDRSHT_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: imm4L=0, Rn=0, U=0, cond=2, imm4H=0, Rt=0
    let encoding: u32 = 0x207000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSHT_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_ldrsht_a1_a_special_cond_3_condition_cc_lo_240_307000f0() {
    // Encoding: 0x307000F0
    // Test aarch32_LDRSHT_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: Rt=0, imm4L=0, Rn=0, cond=3, imm4H=0, U=0
    let encoding: u32 = 0x307000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSHT_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_ldrsht_a1_a_special_cond_4_condition_mi_240_407000f0() {
    // Encoding: 0x407000F0
    // Test aarch32_LDRSHT_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: imm4H=0, Rn=0, cond=4, Rt=0, imm4L=0, U=0
    let encoding: u32 = 0x407000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSHT_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_ldrsht_a1_a_special_cond_5_condition_pl_240_507000f0() {
    // Encoding: 0x507000F0
    // Test aarch32_LDRSHT_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: U=0, imm4H=0, cond=5, Rt=0, Rn=0, imm4L=0
    let encoding: u32 = 0x507000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSHT_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_ldrsht_a1_a_special_cond_6_condition_vs_240_607000f0() {
    // Encoding: 0x607000F0
    // Test aarch32_LDRSHT_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: cond=6, U=0, Rn=0, imm4L=0, Rt=0, imm4H=0
    let encoding: u32 = 0x607000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSHT_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_ldrsht_a1_a_special_cond_7_condition_vc_240_707000f0() {
    // Encoding: 0x707000F0
    // Test aarch32_LDRSHT_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: cond=7, Rt=0, imm4L=0, imm4H=0, U=0, Rn=0
    let encoding: u32 = 0x707000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSHT_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_ldrsht_a1_a_special_cond_8_condition_hi_240_807000f0() {
    // Encoding: 0x807000F0
    // Test aarch32_LDRSHT_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: U=0, imm4H=0, imm4L=0, Rn=0, Rt=0, cond=8
    let encoding: u32 = 0x807000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSHT_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_ldrsht_a1_a_special_cond_9_condition_ls_240_907000f0() {
    // Encoding: 0x907000F0
    // Test aarch32_LDRSHT_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: U=0, Rn=0, imm4H=0, cond=9, imm4L=0, Rt=0
    let encoding: u32 = 0x907000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSHT_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_ldrsht_a1_a_special_cond_10_condition_ge_240_a07000f0() {
    // Encoding: 0xA07000F0
    // Test aarch32_LDRSHT_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: cond=10, Rt=0, imm4H=0, U=0, imm4L=0, Rn=0
    let encoding: u32 = 0xA07000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSHT_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_ldrsht_a1_a_special_cond_11_condition_lt_240_b07000f0() {
    // Encoding: 0xB07000F0
    // Test aarch32_LDRSHT_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: Rn=0, U=0, Rt=0, imm4H=0, imm4L=0, cond=11
    let encoding: u32 = 0xB07000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSHT_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_ldrsht_a1_a_special_cond_12_condition_gt_240_c07000f0() {
    // Encoding: 0xC07000F0
    // Test aarch32_LDRSHT_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: Rt=0, imm4H=0, imm4L=0, U=0, cond=12, Rn=0
    let encoding: u32 = 0xC07000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSHT_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_ldrsht_a1_a_special_cond_13_condition_le_240_d07000f0() {
    // Encoding: 0xD07000F0
    // Test aarch32_LDRSHT_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: Rn=0, U=0, imm4H=0, Rt=0, cond=13, imm4L=0
    let encoding: u32 = 0xD07000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSHT_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_ldrsht_a1_a_special_cond_14_condition_al_240_e07000f0() {
    // Encoding: 0xE07000F0
    // Test aarch32_LDRSHT_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: imm4H=0, imm4L=0, Rn=0, cond=14, U=0, Rt=0
    let encoding: u32 = 0xE07000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSHT_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_ldrsht_a1_a_special_cond_15_condition_nv_240_f07000f0() {
    // Encoding: 0xF07000F0
    // Test aarch32_LDRSHT_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: Rn=0, imm4H=0, cond=15, U=0, imm4L=0, Rt=0
    let encoding: u32 = 0xF07000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSHT_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrsht_a1_a_invalid_0_f0_007000f0() {
    // Encoding: 0x007000F0
    // Test aarch32_LDRSHT_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) }
    // ISET: A32
    // Fields: imm4L=0, imm4H=0, cond=0, U=0, Rn=0, Rt=0
    let encoding: u32 = 0x007000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRSHT_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrsht_a1_a_invalid_1_f0_007000f0() {
    // Encoding: 0x007000F0
    // Test aarch32_LDRSHT_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: U=0, cond=0, Rn=0, Rt=0, imm4H=0, imm4L=0
    let encoding: u32 = 0x007000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRSHT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_ldrsht_a2_a_field_cond_0_min_f0_003000f0() {
    // Encoding: 0x003000F0
    // Test aarch32_LDRSHT_A2_A field cond = 0 (Min)
    // ISET: A32
    // Fields: U=0, Rm=0, cond=0, Rt=0, Rn=0
    let encoding: u32 = 0x003000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSHT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_ldrsht_a2_a_field_cond_1_poweroftwo_f0_103000f0() {
    // Encoding: 0x103000F0
    // Test aarch32_LDRSHT_A2_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, cond=1, Rt=0, Rn=0, Rm=0
    let encoding: u32 = 0x103000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSHT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_ldrsht_a2_a_field_cond_2_poweroftwo_f0_203000f0() {
    // Encoding: 0x203000F0
    // Test aarch32_LDRSHT_A2_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, Rm=0, cond=2, U=0, Rn=0
    let encoding: u32 = 0x203000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSHT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_ldrsht_a2_a_field_cond_3_poweroftwo_f0_303000f0() {
    // Encoding: 0x303000F0
    // Test aarch32_LDRSHT_A2_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, cond=3, Rt=0, Rn=0, Rm=0
    let encoding: u32 = 0x303000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSHT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_ldrsht_a2_a_field_cond_4_poweroftwo_f0_403000f0() {
    // Encoding: 0x403000F0
    // Test aarch32_LDRSHT_A2_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, cond=4, Rn=0, Rt=0, Rm=0
    let encoding: u32 = 0x403000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSHT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_ldrsht_a2_a_field_cond_5_poweroftwo_f0_503000f0() {
    // Encoding: 0x503000F0
    // Test aarch32_LDRSHT_A2_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, Rm=0, cond=5, Rn=0, Rt=0
    let encoding: u32 = 0x503000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSHT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_ldrsht_a2_a_field_cond_6_poweroftwo_f0_603000f0() {
    // Encoding: 0x603000F0
    // Test aarch32_LDRSHT_A2_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, Rm=0, cond=6, U=0, Rn=0
    let encoding: u32 = 0x603000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSHT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_ldrsht_a2_a_field_cond_7_poweroftwo_f0_703000f0() {
    // Encoding: 0x703000F0
    // Test aarch32_LDRSHT_A2_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, cond=7, Rm=0, Rn=0, U=0
    let encoding: u32 = 0x703000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSHT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_ldrsht_a2_a_field_cond_8_poweroftwo_f0_803000f0() {
    // Encoding: 0x803000F0
    // Test aarch32_LDRSHT_A2_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=8, Rm=0, U=0, Rt=0, Rn=0
    let encoding: u32 = 0x803000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSHT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_ldrsht_a2_a_field_cond_9_poweroftwo_f0_903000f0() {
    // Encoding: 0x903000F0
    // Test aarch32_LDRSHT_A2_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=9, Rm=0, U=0, Rn=0, Rt=0
    let encoding: u32 = 0x903000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSHT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_ldrsht_a2_a_field_cond_10_poweroftwo_f0_a03000f0() {
    // Encoding: 0xA03000F0
    // Test aarch32_LDRSHT_A2_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, cond=10, Rt=0, Rm=0, Rn=0
    let encoding: u32 = 0xA03000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSHT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_ldrsht_a2_a_field_cond_11_poweroftwo_f0_b03000f0() {
    // Encoding: 0xB03000F0
    // Test aarch32_LDRSHT_A2_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rm=0, Rt=0, cond=11, U=0
    let encoding: u32 = 0xB03000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSHT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_ldrsht_a2_a_field_cond_12_poweroftwo_f0_c03000f0() {
    // Encoding: 0xC03000F0
    // Test aarch32_LDRSHT_A2_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Rn=0, cond=12, U=0, Rt=0
    let encoding: u32 = 0xC03000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSHT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_ldrsht_a2_a_field_cond_13_poweroftwo_f0_d03000f0() {
    // Encoding: 0xD03000F0
    // Test aarch32_LDRSHT_A2_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=13, Rn=0, Rm=0, U=0, Rt=0
    let encoding: u32 = 0xD03000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSHT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_ldrsht_a2_a_field_cond_14_poweroftwo_f0_e03000f0() {
    // Encoding: 0xE03000F0
    // Test aarch32_LDRSHT_A2_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, Rm=0, U=0, Rn=0, cond=14
    let encoding: u32 = 0xE03000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSHT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_ldrsht_a2_a_field_cond_15_max_f0_f03000f0() {
    // Encoding: 0xF03000F0
    // Test aarch32_LDRSHT_A2_A field cond = 15 (Max)
    // ISET: A32
    // Fields: Rn=0, Rm=0, Rt=0, U=0, cond=15
    let encoding: u32 = 0xF03000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSHT_A2_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldrsht_a2_a_field_u_0_min_f0_003000f0() {
    // Encoding: 0x003000F0
    // Test aarch32_LDRSHT_A2_A field U = 0 (Min)
    // ISET: A32
    // Fields: Rt=0, Rn=0, U=0, cond=0, Rm=0
    let encoding: u32 = 0x003000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSHT_A2_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldrsht_a2_a_field_u_1_max_f0_00b000f0() {
    // Encoding: 0x00B000F0
    // Test aarch32_LDRSHT_A2_A field U = 1 (Max)
    // ISET: A32
    // Fields: U=1, Rt=0, Rm=0, Rn=0, cond=0
    let encoding: u32 = 0x00B000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSHT_A2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrsht_a2_a_field_rn_0_min_f0_003000f0() {
    // Encoding: 0x003000F0
    // Test aarch32_LDRSHT_A2_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: Rt=0, U=0, Rm=0, cond=0, Rn=0
    let encoding: u32 = 0x003000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSHT_A2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrsht_a2_a_field_rn_1_poweroftwo_f0_003100f0() {
    // Encoding: 0x003100F0
    // Test aarch32_LDRSHT_A2_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, Rt=0, cond=0, Rn=1, Rm=0
    let encoding: u32 = 0x003100F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSHT_A2_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrsht_a2_a_field_rt_0_min_f0_003000f0() {
    // Encoding: 0x003000F0
    // Test aarch32_LDRSHT_A2_A field Rt = 0 (Min)
    // ISET: A32
    // Fields: Rt=0, Rm=0, U=0, cond=0, Rn=0
    let encoding: u32 = 0x003000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSHT_A2_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrsht_a2_a_field_rt_1_poweroftwo_f0_003010f0() {
    // Encoding: 0x003010F0
    // Test aarch32_LDRSHT_A2_A field Rt = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rt=1, cond=0, Rm=0, U=0
    let encoding: u32 = 0x003010F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSHT_A2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrsht_a2_a_field_rm_0_min_f0_003000f0() {
    // Encoding: 0x003000F0
    // Test aarch32_LDRSHT_A2_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, cond=0, Rn=0, U=0, Rt=0
    let encoding: u32 = 0x003000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSHT_A2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrsht_a2_a_field_rm_1_poweroftwo_f0_003000f1() {
    // Encoding: 0x003000F1
    // Test aarch32_LDRSHT_A2_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, Rn=0, Rm=1, cond=0, U=0
    let encoding: u32 = 0x003000F1;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSHT_A2_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_ldrsht_a2_a_combo_0_f0_003000f0() {
    // Encoding: 0x003000F0
    // Test aarch32_LDRSHT_A2_A field combination: cond=0, U=0, Rn=0, Rt=0, Rm=0
    // ISET: A32
    // Fields: Rn=0, Rm=0, Rt=0, cond=0, U=0
    let encoding: u32 = 0x003000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSHT_A2_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_ldrsht_a2_a_special_cond_0_condition_eq_240_003000f0() {
    // Encoding: 0x003000F0
    // Test aarch32_LDRSHT_A2_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: Rt=0, Rm=0, cond=0, U=0, Rn=0
    let encoding: u32 = 0x003000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSHT_A2_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_ldrsht_a2_a_special_cond_1_condition_ne_240_103000f0() {
    // Encoding: 0x103000F0
    // Test aarch32_LDRSHT_A2_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: cond=1, U=0, Rt=0, Rn=0, Rm=0
    let encoding: u32 = 0x103000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSHT_A2_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_ldrsht_a2_a_special_cond_2_condition_cs_hs_240_203000f0() {
    // Encoding: 0x203000F0
    // Test aarch32_LDRSHT_A2_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: U=0, Rt=0, Rm=0, Rn=0, cond=2
    let encoding: u32 = 0x203000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSHT_A2_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_ldrsht_a2_a_special_cond_3_condition_cc_lo_240_303000f0() {
    // Encoding: 0x303000F0
    // Test aarch32_LDRSHT_A2_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: Rt=0, Rm=0, U=0, Rn=0, cond=3
    let encoding: u32 = 0x303000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSHT_A2_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_ldrsht_a2_a_special_cond_4_condition_mi_240_403000f0() {
    // Encoding: 0x403000F0
    // Test aarch32_LDRSHT_A2_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: U=0, Rm=0, Rn=0, cond=4, Rt=0
    let encoding: u32 = 0x403000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSHT_A2_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_ldrsht_a2_a_special_cond_5_condition_pl_240_503000f0() {
    // Encoding: 0x503000F0
    // Test aarch32_LDRSHT_A2_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: Rn=0, Rm=0, U=0, cond=5, Rt=0
    let encoding: u32 = 0x503000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSHT_A2_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_ldrsht_a2_a_special_cond_6_condition_vs_240_603000f0() {
    // Encoding: 0x603000F0
    // Test aarch32_LDRSHT_A2_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: Rm=0, U=0, cond=6, Rt=0, Rn=0
    let encoding: u32 = 0x603000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSHT_A2_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_ldrsht_a2_a_special_cond_7_condition_vc_240_703000f0() {
    // Encoding: 0x703000F0
    // Test aarch32_LDRSHT_A2_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: U=0, cond=7, Rm=0, Rn=0, Rt=0
    let encoding: u32 = 0x703000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSHT_A2_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_ldrsht_a2_a_special_cond_8_condition_hi_240_803000f0() {
    // Encoding: 0x803000F0
    // Test aarch32_LDRSHT_A2_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: Rt=0, Rm=0, Rn=0, cond=8, U=0
    let encoding: u32 = 0x803000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSHT_A2_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_ldrsht_a2_a_special_cond_9_condition_ls_240_903000f0() {
    // Encoding: 0x903000F0
    // Test aarch32_LDRSHT_A2_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: cond=9, U=0, Rt=0, Rm=0, Rn=0
    let encoding: u32 = 0x903000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSHT_A2_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_ldrsht_a2_a_special_cond_10_condition_ge_240_a03000f0() {
    // Encoding: 0xA03000F0
    // Test aarch32_LDRSHT_A2_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: Rm=0, Rt=0, cond=10, U=0, Rn=0
    let encoding: u32 = 0xA03000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSHT_A2_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_ldrsht_a2_a_special_cond_11_condition_lt_240_b03000f0() {
    // Encoding: 0xB03000F0
    // Test aarch32_LDRSHT_A2_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: U=0, Rn=0, Rt=0, Rm=0, cond=11
    let encoding: u32 = 0xB03000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSHT_A2_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_ldrsht_a2_a_special_cond_12_condition_gt_240_c03000f0() {
    // Encoding: 0xC03000F0
    // Test aarch32_LDRSHT_A2_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: cond=12, U=0, Rn=0, Rt=0, Rm=0
    let encoding: u32 = 0xC03000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSHT_A2_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_ldrsht_a2_a_special_cond_13_condition_le_240_d03000f0() {
    // Encoding: 0xD03000F0
    // Test aarch32_LDRSHT_A2_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: U=0, Rn=0, cond=13, Rt=0, Rm=0
    let encoding: u32 = 0xD03000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSHT_A2_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_ldrsht_a2_a_special_cond_14_condition_al_240_e03000f0() {
    // Encoding: 0xE03000F0
    // Test aarch32_LDRSHT_A2_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: Rn=0, U=0, cond=14, Rt=0, Rm=0
    let encoding: u32 = 0xE03000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSHT_A2_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_ldrsht_a2_a_special_cond_15_condition_nv_240_f03000f0() {
    // Encoding: 0xF03000F0
    // Test aarch32_LDRSHT_A2_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: Rn=0, Rt=0, U=0, Rm=0, cond=15
    let encoding: u32 = 0xF03000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSHT_A2_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrsht_a2_a_invalid_0_f0_003000f0() {
    // Encoding: 0x003000F0
    // Test aarch32_LDRSHT_A2_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }
    // ISET: A32
    // Fields: cond=0, U=0, Rm=0, Rt=0, Rn=0
    let encoding: u32 = 0x003000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRSHT_A2_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrsht_a2_a_invalid_1_f0_003000f0() {
    // Encoding: 0x003000F0
    // Test aarch32_LDRSHT_A2_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: cond=0, Rt=0, Rm=0, U=0, Rn=0
    let encoding: u32 = 0x003000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRSHT_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrsht_t1_a_field_rn_0_min_e00_f9300e00() {
    // Thumb encoding (32): 0xF9300E00
    // Test aarch32_LDRSHT_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rt=0, imm8=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9300E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSHT_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrsht_t1_a_field_rn_1_poweroftwo_e00_f9310e00() {
    // Thumb encoding (32): 0xF9310E00
    // Test aarch32_LDRSHT_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, imm8=0, Rn=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9310E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSHT_T1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrsht_t1_a_field_rt_0_min_e00_f9300e00() {
    // Thumb encoding (32): 0xF9300E00
    // Test aarch32_LDRSHT_T1_A field Rt = 0 (Min)
    // ISET: T32
    // Fields: Rt=0, imm8=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9300E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSHT_T1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrsht_t1_a_field_rt_1_poweroftwo_e00_f9301e00() {
    // Thumb encoding (32): 0xF9301E00
    // Test aarch32_LDRSHT_T1_A field Rt = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Rt=1, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9301E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSHT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_ldrsht_t1_a_field_imm8_0_zero_e00_f9300e00() {
    // Thumb encoding (32): 0xF9300E00
    // Test aarch32_LDRSHT_T1_A field imm8 = 0 (Zero)
    // ISET: T32
    // Fields: Rt=0, Rn=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9300E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSHT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_ldrsht_t1_a_field_imm8_1_poweroftwo_e00_f9300e01() {
    // Thumb encoding (32): 0xF9300E01
    // Test aarch32_LDRSHT_T1_A field imm8 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, Rn=0, imm8=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9300E01;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSHT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_ldrsht_t1_a_field_imm8_3_poweroftwominusone_e00_f9300e03() {
    // Thumb encoding (32): 0xF9300E03
    // Test aarch32_LDRSHT_T1_A field imm8 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm8=3
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9300E03;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSHT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_ldrsht_t1_a_field_imm8_4_poweroftwo_e00_f9300e04() {
    // Thumb encoding (32): 0xF9300E04
    // Test aarch32_LDRSHT_T1_A field imm8 = 4 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm8=4
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9300E04;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSHT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_ldrsht_t1_a_field_imm8_7_poweroftwominusone_e00_f9300e07() {
    // Thumb encoding (32): 0xF9300E07
    // Test aarch32_LDRSHT_T1_A field imm8 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm8=7, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9300E07;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSHT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_ldrsht_t1_a_field_imm8_8_poweroftwo_e00_f9300e08() {
    // Thumb encoding (32): 0xF9300E08
    // Test aarch32_LDRSHT_T1_A field imm8 = 8 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm8=8
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9300E08;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSHT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_ldrsht_t1_a_field_imm8_15_poweroftwominusone_e00_f9300e0f() {
    // Thumb encoding (32): 0xF9300E0F
    // Test aarch32_LDRSHT_T1_A field imm8 = 15 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm8=15, Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9300E0F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSHT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_ldrsht_t1_a_field_imm8_16_poweroftwo_e00_f9300e10() {
    // Thumb encoding (32): 0xF9300E10
    // Test aarch32_LDRSHT_T1_A field imm8 = 16 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=16, Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9300E10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSHT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_ldrsht_t1_a_field_imm8_31_poweroftwominusone_e00_f9300e1f() {
    // Thumb encoding (32): 0xF9300E1F
    // Test aarch32_LDRSHT_T1_A field imm8 = 31 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm8=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9300E1F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSHT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_ldrsht_t1_a_field_imm8_32_poweroftwo_e00_f9300e20() {
    // Thumb encoding (32): 0xF9300E20
    // Test aarch32_LDRSHT_T1_A field imm8 = 32 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, Rn=0, imm8=32
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9300E20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSHT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_ldrsht_t1_a_field_imm8_63_poweroftwominusone_e00_f9300e3f() {
    // Thumb encoding (32): 0xF9300E3F
    // Test aarch32_LDRSHT_T1_A field imm8 = 63 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, imm8=63, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9300E3F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSHT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_ldrsht_t1_a_field_imm8_64_poweroftwo_e00_f9300e40() {
    // Thumb encoding (32): 0xF9300E40
    // Test aarch32_LDRSHT_T1_A field imm8 = 64 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, Rn=0, imm8=64
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9300E40;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSHT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 127, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (127)
#[test]
fn test_aarch32_ldrsht_t1_a_field_imm8_127_poweroftwominusone_e00_f9300e7f() {
    // Thumb encoding (32): 0xF9300E7F
    // Test aarch32_LDRSHT_T1_A field imm8 = 127 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, imm8=127, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9300E7F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSHT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_ldrsht_t1_a_field_imm8_128_poweroftwo_e00_f9300e80() {
    // Thumb encoding (32): 0xF9300E80
    // Test aarch32_LDRSHT_T1_A field imm8 = 128 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, Rn=0, imm8=128
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9300E80;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSHT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 255, boundary: Max }
/// maximum immediate (255)
#[test]
fn test_aarch32_ldrsht_t1_a_field_imm8_255_max_e00_f9300eff() {
    // Thumb encoding (32): 0xF9300EFF
    // Test aarch32_LDRSHT_T1_A field imm8 = 255 (Max)
    // ISET: T32
    // Fields: imm8=255, Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9300EFF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSHT_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_ldrsht_t1_a_combo_0_e00_f9300e00() {
    // Thumb encoding (32): 0xF9300E00
    // Test aarch32_LDRSHT_T1_A field combination: Rn=0, Rt=0, imm8=0
    // ISET: T32
    // Fields: Rt=0, Rn=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9300E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSHT_T1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrsht_t1_a_invalid_0_e00_f9300e00() {
    // Thumb encoding (32): 0xF9300E00
    // Test aarch32_LDRSHT_T1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: LitInt(15) }
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9300E00;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRSHT_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrsht_t1_a_invalid_1_e00_f9300e00() {
    // Thumb encoding (32): 0xF9300E00
    // Test aarch32_LDRSHT_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9300E00;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRSHT_A1_A
/// ASL: `UMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple multiply
#[test]
fn test_aarch32_ldrsht_a1_a_umull_oracle_0_9ba27c20() {
    // Test UMULL: simple multiply (oracle)
    // Encoding: 0x9BA27C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3);
    set_w(&mut cpu, 1, 0x2);
    let encoding: u32 = 0x9BA27C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6, "X0 should be 0x0000000000000006");
}

/// Provenance: aarch32_LDRSHT_A1_A
/// ASL: `UMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max 32-bit * 2
#[test]
fn test_aarch32_ldrsht_a1_a_umull_oracle_1_9ba27c20() {
    // Test UMULL: max 32-bit * 2 (oracle)
    // Encoding: 0x9BA27C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x9BA27C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0x00000001FFFFFFFE"
    );
}

/// Provenance: aarch32_LDRSHT_A1_A
/// ASL: `UMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// large positive * large positive
#[test]
fn test_aarch32_ldrsht_a1_a_umull_oracle_2_9ba27c20() {
    // Test UMULL: large positive * large positive (oracle)
    // Encoding: 0x9BA27C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    set_w(&mut cpu, 2, 0x7FFFFFFF);
    let encoding: u32 = 0x9BA27C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x3FFFFFFF00000001");
}

/// Provenance: aarch32_LDRSHT_A1_A
/// ASL: `UMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max unsigned * max unsigned
#[test]
fn test_aarch32_ldrsht_a1_a_umull_oracle_3_9ba27c20() {
    // Test UMULL: max unsigned * max unsigned (oracle)
    // Encoding: 0x9BA27C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x9BA27C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0xFFFFFFFE00000001");
}

/// Provenance: aarch32_LDRSHT_A1_A
/// ASL: `UMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// medium values
#[test]
fn test_aarch32_ldrsht_a1_a_umull_oracle_4_9ba27c20() {
    // Test UMULL: medium values (oracle)
    // Encoding: 0x9BA27C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xC8);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x9BA27C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4E20, "X0 should be 0x0000000000004E20");
}

/// Provenance: aarch32_LDRSHT_A1_A
/// ASL: `UMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// 16-bit values
#[test]
fn test_aarch32_ldrsht_a1_a_umull_oracle_5_9ba27c20() {
    // Test UMULL: 16-bit values (oracle)
    // Encoding: 0x9BA27C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x5678);
    set_w(&mut cpu, 1, 0x1234);
    let encoding: u32 = 0x9BA27C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6260060, "X0 should be 0x0000000006260060");
}

/// Provenance: aarch32_LDRSHT_A1_A
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrsht_a1_a_exception_0_007000f0() {
    // Test aarch32_LDRSHT_A1_A exception: Unpredictable
    // Encoding: 0x007000F0
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x007000F0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_LDRSHT_A2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple multiply (32)
#[test]
fn test_aarch32_ldrsht_a2_a_mul_oracle_32_0_1b027c20() {
    // Test MUL 32-bit: simple multiply (oracle)
    // Encoding: 0x1B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x2);
    set_w(&mut cpu, 2, 0x3);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6, "W0 should be 0x00000006");
}

/// Provenance: aarch32_LDRSHT_A2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple multiply (64)
#[test]
fn test_aarch32_ldrsht_a2_a_mul_oracle_64_0_9b027c20() {
    // Test MUL 64-bit: simple multiply (oracle)
    // Encoding: 0x9B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3);
    set_w(&mut cpu, 1, 0x2);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6, "X0 should be 0x0000000000000006");
}

/// Provenance: aarch32_LDRSHT_A2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// multiply by zero (32)
#[test]
fn test_aarch32_ldrsht_a2_a_mul_oracle_32_1_1b027c20() {
    // Test MUL 32-bit: multiply by zero (oracle)
    // Encoding: 0x1B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x64);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_LDRSHT_A2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// multiply by zero (64)
#[test]
fn test_aarch32_ldrsht_a2_a_mul_oracle_64_1_9b027c20() {
    // Test MUL 64-bit: multiply by zero (oracle)
    // Encoding: 0x9B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x64);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_LDRSHT_A2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// multiply by one (32)
#[test]
fn test_aarch32_ldrsht_a2_a_mul_oracle_32_2_1b027c20() {
    // Test MUL 32-bit: multiply by one (oracle)
    // Encoding: 0x1B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_LDRSHT_A2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// multiply by one (64)
#[test]
fn test_aarch32_ldrsht_a2_a_mul_oracle_64_2_9b027c20() {
    // Test MUL 64-bit: multiply by one (oracle)
    // Encoding: 0x9B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x0000000000000001");
}

/// Provenance: aarch32_LDRSHT_A2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// 16-bit max * 16-bit max (32)
#[test]
fn test_aarch32_ldrsht_a2_a_mul_oracle_32_3_1b027c20() {
    // Test MUL 32-bit: 16-bit max * 16-bit max (oracle)
    // Encoding: 0x1B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFF);
    set_w(&mut cpu, 2, 0xFFFF);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFE0001, "W0 should be 0xFFFE0001");
}

/// Provenance: aarch32_LDRSHT_A2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// 16-bit max * 16-bit max (64)
#[test]
fn test_aarch32_ldrsht_a2_a_mul_oracle_64_3_9b027c20() {
    // Test MUL 64-bit: 16-bit max * 16-bit max (oracle)
    // Encoding: 0x9B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFF);
    set_w(&mut cpu, 2, 0xFFFF);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFE0001,
        "X0 should be 0x00000000FFFE0001"
    );
}

/// Provenance: aarch32_LDRSHT_A2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift-like multiply (32)
#[test]
fn test_aarch32_ldrsht_a2_a_mul_oracle_32_4_1b027c20() {
    // Test MUL 32-bit: shift-like multiply (oracle)
    // Encoding: 0x1B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x2468ACF0, "W0 should be 0x2468ACF0");
}

/// Provenance: aarch32_LDRSHT_A2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift-like multiply (64)
#[test]
fn test_aarch32_ldrsht_a2_a_mul_oracle_64_4_9b027c20() {
    // Test MUL 64-bit: shift-like multiply (oracle)
    // Encoding: 0x9B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x2468ACF0,
        "X0 should be 0x000000002468ACF0"
    );
}

/// Provenance: aarch32_LDRSHT_A2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// larger values (32)
#[test]
fn test_aarch32_ldrsht_a2_a_mul_oracle_32_5_1b027c20() {
    // Test MUL 32-bit: larger values (oracle)
    // Encoding: 0x1B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0xC8);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4E20, "W0 should be 0x00004E20");
}

/// Provenance: aarch32_LDRSHT_A2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// larger values (64)
#[test]
fn test_aarch32_ldrsht_a2_a_mul_oracle_64_5_9b027c20() {
    // Test MUL 64-bit: larger values (oracle)
    // Encoding: 0x9B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0xC8);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4E20, "X0 should be 0x0000000000004E20");
}

/// Provenance: aarch32_LDRSHT_A2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// 32-bit overflow (32)
#[test]
fn test_aarch32_ldrsht_a2_a_mul_oracle_32_6_1b027c20() {
    // Test MUL 32-bit: 32-bit overflow (oracle)
    // Encoding: 0x1B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_LDRSHT_A2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// 32-bit overflow (64)
#[test]
fn test_aarch32_ldrsht_a2_a_mul_oracle_64_6_9b027c20() {
    // Test MUL 64-bit: 32-bit overflow (oracle)
    // Encoding: 0x9B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0xFFFFFFFE00000001");
}

/// Provenance: aarch32_LDRSHT_A2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// prime numbers (32)
#[test]
fn test_aarch32_ldrsht_a2_a_mul_oracle_32_7_1b027c20() {
    // Test MUL 32-bit: prime numbers (oracle)
    // Encoding: 0x1B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7);
    set_w(&mut cpu, 2, 0xB);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4D, "W0 should be 0x0000004D");
}

/// Provenance: aarch32_LDRSHT_A2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// prime numbers (64)
#[test]
fn test_aarch32_ldrsht_a2_a_mul_oracle_64_7_9b027c20() {
    // Test MUL 64-bit: prime numbers (oracle)
    // Encoding: 0x9B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7);
    set_w(&mut cpu, 2, 0xB);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4D, "X0 should be 0x000000000000004D");
}

/// Provenance: aarch32_LDRSHT_A2_A
/// ASL: `MLA R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple values
#[test]
fn test_aarch32_ldrsht_a2_a_a32_mul_0_0020f291() {
    // Test A32 MLA: simple values (oracle)
    // Encoding: 0x0020F291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x32);
    let encoding: u32 = 0x0020F291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1388, "R0 should be 0x00001388");
}

/// Provenance: aarch32_LDRSHT_A2_A
/// ASL: `MLA R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero values
#[test]
fn test_aarch32_ldrsht_a2_a_a32_mul_1_0020f291() {
    // Test A32 MLA: zero values (oracle)
    // Encoding: 0x0020F291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x0020F291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_LDRSHT_A2_A
/// ASL: `MLA R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max value
#[test]
fn test_aarch32_ldrsht_a2_a_a32_mul_2_0020f291() {
    // Test A32 MLA: max value (oracle)
    // Encoding: 0x0020F291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x0020F291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "R0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_LDRSHT_A2_A
/// ASL: `MLA R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set
#[test]
fn test_aarch32_ldrsht_a2_a_a32_mul_3_0020f291() {
    // Test A32 MLA: MSB set (oracle)
    // Encoding: 0x0020F291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    set_w(&mut cpu, 2, 0x80000000);
    let encoding: u32 = 0x0020F291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_LDRSHT_A2_A
/// ASL: `MLA R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// mixed pattern
#[test]
fn test_aarch32_ldrsht_a2_a_a32_mul_4_0020f291() {
    // Test A32 MLA: mixed pattern (oracle)
    // Encoding: 0x0020F291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x9ABCDEF0);
    let encoding: u32 = 0x0020F291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x242D2080, "R0 should be 0x242D2080");
}

/// Provenance: aarch32_LDRSHT_A2_A
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrsht_a2_a_exception_0_003000f0() {
    // Test aarch32_LDRSHT_A2_A exception: Unpredictable
    // Encoding: 0x003000F0
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x003000F0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_LDRSHT_T1_A
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrsht_t1_a_exception_0_f9300e00() {
    // Test aarch32_LDRSHT_T1_A exception: Unpredictable
    // ISET: T32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF9300E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// aarch32_LDRD_i_A Tests
// ============================================================================

/// Provenance: aarch32_LDRD_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_ldrd_i_a1_a_field_cond_0_min_d0_004000d0() {
    // Encoding: 0x004000D0
    // Test aarch32_LDRD_i_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: P=0, Rn=0, cond=0, Rt=0, imm4H=0, imm4L=0, W=0, U=0
    let encoding: u32 = 0x004000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_ldrd_i_a1_a_field_cond_1_poweroftwo_d0_104000d0() {
    // Encoding: 0x104000D0
    // Test aarch32_LDRD_i_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, imm4L=0, W=0, cond=1, imm4H=0, P=0, Rt=0, U=0
    let encoding: u32 = 0x104000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_ldrd_i_a1_a_field_cond_2_poweroftwo_d0_204000d0() {
    // Encoding: 0x204000D0
    // Test aarch32_LDRD_i_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4L=0, Rt=0, W=0, P=0, cond=2, imm4H=0, Rn=0, U=0
    let encoding: u32 = 0x204000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_ldrd_i_a1_a_field_cond_3_poweroftwo_d0_304000d0() {
    // Encoding: 0x304000D0
    // Test aarch32_LDRD_i_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=3, Rn=0, P=0, Rt=0, imm4L=0, imm4H=0, W=0, U=0
    let encoding: u32 = 0x304000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_ldrd_i_a1_a_field_cond_4_poweroftwo_d0_404000d0() {
    // Encoding: 0x404000D0
    // Test aarch32_LDRD_i_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, W=0, U=0, imm4H=0, P=0, cond=4, imm4L=0, Rt=0
    let encoding: u32 = 0x404000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_ldrd_i_a1_a_field_cond_5_poweroftwo_d0_504000d0() {
    // Encoding: 0x504000D0
    // Test aarch32_LDRD_i_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, Rn=0, imm4H=0, W=0, Rt=0, cond=5, U=0, imm4L=0
    let encoding: u32 = 0x504000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_ldrd_i_a1_a_field_cond_6_poweroftwo_d0_604000d0() {
    // Encoding: 0x604000D0
    // Test aarch32_LDRD_i_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4H=0, P=0, Rn=0, Rt=0, imm4L=0, U=0, cond=6, W=0
    let encoding: u32 = 0x604000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_ldrd_i_a1_a_field_cond_7_poweroftwo_d0_704000d0() {
    // Encoding: 0x704000D0
    // Test aarch32_LDRD_i_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=7, Rn=0, imm4L=0, Rt=0, imm4H=0, P=0, W=0, U=0
    let encoding: u32 = 0x704000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_ldrd_i_a1_a_field_cond_8_poweroftwo_d0_804000d0() {
    // Encoding: 0x804000D0
    // Test aarch32_LDRD_i_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=8, imm4L=0, imm4H=0, W=0, P=0, U=0, Rn=0, Rt=0
    let encoding: u32 = 0x804000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_ldrd_i_a1_a_field_cond_9_poweroftwo_d0_904000d0() {
    // Encoding: 0x904000D0
    // Test aarch32_LDRD_i_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, imm4L=0, P=0, imm4H=0, Rn=0, Rt=0, cond=9, U=0
    let encoding: u32 = 0x904000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_ldrd_i_a1_a_field_cond_10_poweroftwo_d0_a04000d0() {
    // Encoding: 0xA04000D0
    // Test aarch32_LDRD_i_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, P=0, imm4H=0, imm4L=0, cond=10, W=0, Rn=0, Rt=0
    let encoding: u32 = 0xA04000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_ldrd_i_a1_a_field_cond_11_poweroftwo_d0_b04000d0() {
    // Encoding: 0xB04000D0
    // Test aarch32_LDRD_i_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4H=0, imm4L=0, cond=11, P=0, W=0, Rt=0, U=0, Rn=0
    let encoding: u32 = 0xB04000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_ldrd_i_a1_a_field_cond_12_poweroftwo_d0_c04000d0() {
    // Encoding: 0xC04000D0
    // Test aarch32_LDRD_i_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, imm4H=0, cond=12, imm4L=0, Rt=0, Rn=0, W=0, U=0
    let encoding: u32 = 0xC04000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_ldrd_i_a1_a_field_cond_13_poweroftwo_d0_d04000d0() {
    // Encoding: 0xD04000D0
    // Test aarch32_LDRD_i_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, cond=13, U=0, Rn=0, W=0, P=0, imm4L=0, imm4H=0
    let encoding: u32 = 0xD04000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_ldrd_i_a1_a_field_cond_14_poweroftwo_d0_e04000d0() {
    // Encoding: 0xE04000D0
    // Test aarch32_LDRD_i_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, W=0, U=0, P=0, imm4H=0, cond=14, Rt=0, imm4L=0
    let encoding: u32 = 0xE04000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_ldrd_i_a1_a_field_cond_15_max_d0_f04000d0() {
    // Encoding: 0xF04000D0
    // Test aarch32_LDRD_i_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: cond=15, P=0, Rn=0, imm4H=0, U=0, Rt=0, W=0, imm4L=0
    let encoding: u32 = 0xF04000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_i_A1_A
/// ASL: `field P 24 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldrd_i_a1_a_field_p_0_min_d0_004000d0() {
    // Encoding: 0x004000D0
    // Test aarch32_LDRD_i_A1_A field P = 0 (Min)
    // ISET: A32
    // Fields: imm4L=0, Rn=0, cond=0, P=0, U=0, W=0, imm4H=0, Rt=0
    let encoding: u32 = 0x004000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_i_A1_A
/// ASL: `field P 24 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldrd_i_a1_a_field_p_1_max_d0_014000d0() {
    // Encoding: 0x014000D0
    // Test aarch32_LDRD_i_A1_A field P = 1 (Max)
    // ISET: A32
    // Fields: P=1, imm4H=0, cond=0, W=0, Rt=0, U=0, imm4L=0, Rn=0
    let encoding: u32 = 0x014000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_i_A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldrd_i_a1_a_field_u_0_min_d0_004000d0() {
    // Encoding: 0x004000D0
    // Test aarch32_LDRD_i_A1_A field U = 0 (Min)
    // ISET: A32
    // Fields: P=0, Rn=0, U=0, W=0, Rt=0, cond=0, imm4L=0, imm4H=0
    let encoding: u32 = 0x004000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_i_A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldrd_i_a1_a_field_u_1_max_d0_00c000d0() {
    // Encoding: 0x00C000D0
    // Test aarch32_LDRD_i_A1_A field U = 1 (Max)
    // ISET: A32
    // Fields: Rt=0, W=0, P=0, cond=0, Rn=0, imm4L=0, imm4H=0, U=1
    let encoding: u32 = 0x00C000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_i_A1_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldrd_i_a1_a_field_w_0_min_d0_004000d0() {
    // Encoding: 0x004000D0
    // Test aarch32_LDRD_i_A1_A field W = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rt=0, U=0, P=0, imm4L=0, imm4H=0, Rn=0, W=0
    let encoding: u32 = 0x004000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_i_A1_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldrd_i_a1_a_field_w_1_max_d0_006000d0() {
    // Encoding: 0x006000D0
    // Test aarch32_LDRD_i_A1_A field W = 1 (Max)
    // ISET: A32
    // Fields: imm4L=0, P=0, cond=0, W=1, Rn=0, U=0, imm4H=0, Rt=0
    let encoding: u32 = 0x006000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_i_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrd_i_a1_a_field_rn_0_min_d0_004000d0() {
    // Encoding: 0x004000D0
    // Test aarch32_LDRD_i_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: U=0, imm4L=0, cond=0, P=0, Rt=0, Rn=0, W=0, imm4H=0
    let encoding: u32 = 0x004000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_i_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrd_i_a1_a_field_rn_1_poweroftwo_d0_004100d0() {
    // Encoding: 0x004100D0
    // Test aarch32_LDRD_i_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, Rn=1, imm4H=0, W=0, imm4L=0, cond=0, P=0, U=0
    let encoding: u32 = 0x004100D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_i_A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrd_i_a1_a_field_rt_0_min_d0_004000d0() {
    // Encoding: 0x004000D0
    // Test aarch32_LDRD_i_A1_A field Rt = 0 (Min)
    // ISET: A32
    // Fields: imm4L=0, W=0, imm4H=0, P=0, U=0, Rt=0, Rn=0, cond=0
    let encoding: u32 = 0x004000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_i_A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrd_i_a1_a_field_rt_1_poweroftwo_d0_004010d0() {
    // Encoding: 0x004010D0
    // Test aarch32_LDRD_i_A1_A field Rt = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, imm4H=0, cond=0, Rt=1, imm4L=0, U=0, W=0, P=0
    let encoding: u32 = 0x004010D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_i_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_ldrd_i_a1_a_field_imm4h_0_zero_d0_004000d0() {
    // Encoding: 0x004000D0
    // Test aarch32_LDRD_i_A1_A field imm4H = 0 (Zero)
    // ISET: A32
    // Fields: P=0, Rn=0, imm4L=0, cond=0, imm4H=0, W=0, U=0, Rt=0
    let encoding: u32 = 0x004000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_i_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_ldrd_i_a1_a_field_imm4h_1_poweroftwo_d0_004001d0() {
    // Encoding: 0x004001D0
    // Test aarch32_LDRD_i_A1_A field imm4H = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4H=1, Rt=0, cond=0, P=0, U=0, Rn=0, imm4L=0, W=0
    let encoding: u32 = 0x004001D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_i_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_ldrd_i_a1_a_field_imm4h_3_poweroftwominusone_d0_004003d0() {
    // Encoding: 0x004003D0
    // Test aarch32_LDRD_i_A1_A field imm4H = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm4L=0, cond=0, W=0, Rn=0, U=0, imm4H=3, Rt=0, P=0
    let encoding: u32 = 0x004003D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_i_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_ldrd_i_a1_a_field_imm4h_4_poweroftwo_d0_004004d0() {
    // Encoding: 0x004004D0
    // Test aarch32_LDRD_i_A1_A field imm4H = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4L=0, Rt=0, W=0, cond=0, U=0, P=0, Rn=0, imm4H=4
    let encoding: u32 = 0x004004D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_i_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_aarch32_ldrd_i_a1_a_field_imm4h_7_poweroftwominusone_d0_004007d0() {
    // Encoding: 0x004007D0
    // Test aarch32_LDRD_i_A1_A field imm4H = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm4H=7, P=0, Rt=0, U=0, W=0, Rn=0, imm4L=0, cond=0
    let encoding: u32 = 0x004007D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_i_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_ldrd_i_a1_a_field_imm4h_8_poweroftwo_d0_004008d0() {
    // Encoding: 0x004008D0
    // Test aarch32_LDRD_i_A1_A field imm4H = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, U=0, Rn=0, P=0, imm4H=8, W=0, imm4L=0, cond=0
    let encoding: u32 = 0x004008D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_i_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_aarch32_ldrd_i_a1_a_field_imm4h_15_max_d0_00400fd0() {
    // Encoding: 0x00400FD0
    // Test aarch32_LDRD_i_A1_A field imm4H = 15 (Max)
    // ISET: A32
    // Fields: P=0, cond=0, imm4L=0, Rn=0, U=0, Rt=0, imm4H=15, W=0
    let encoding: u32 = 0x00400FD0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_i_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_ldrd_i_a1_a_field_imm4l_0_zero_d0_004000d0() {
    // Encoding: 0x004000D0
    // Test aarch32_LDRD_i_A1_A field imm4L = 0 (Zero)
    // ISET: A32
    // Fields: W=0, Rt=0, imm4L=0, imm4H=0, cond=0, P=0, U=0, Rn=0
    let encoding: u32 = 0x004000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_i_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_ldrd_i_a1_a_field_imm4l_1_poweroftwo_d0_004000d1() {
    // Encoding: 0x004000D1
    // Test aarch32_LDRD_i_A1_A field imm4L = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, imm4L=1, imm4H=0, U=0, W=0, P=0, Rn=0, Rt=0
    let encoding: u32 = 0x004000D1;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_i_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_ldrd_i_a1_a_field_imm4l_3_poweroftwominusone_d0_004000d3() {
    // Encoding: 0x004000D3
    // Test aarch32_LDRD_i_A1_A field imm4L = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rn=0, U=0, W=0, Rt=0, P=0, imm4H=0, imm4L=3, cond=0
    let encoding: u32 = 0x004000D3;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_i_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_ldrd_i_a1_a_field_imm4l_4_poweroftwo_d0_004000d4() {
    // Encoding: 0x004000D4
    // Test aarch32_LDRD_i_A1_A field imm4L = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, Rt=0, imm4H=0, imm4L=4, Rn=0, U=0, cond=0, P=0
    let encoding: u32 = 0x004000D4;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_i_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_aarch32_ldrd_i_a1_a_field_imm4l_7_poweroftwominusone_d0_004000d7() {
    // Encoding: 0x004000D7
    // Test aarch32_LDRD_i_A1_A field imm4L = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm4L=7, P=0, cond=0, U=0, Rt=0, W=0, imm4H=0, Rn=0
    let encoding: u32 = 0x004000D7;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_i_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_ldrd_i_a1_a_field_imm4l_8_poweroftwo_d0_004000d8() {
    // Encoding: 0x004000D8
    // Test aarch32_LDRD_i_A1_A field imm4L = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, U=0, imm4L=8, Rn=0, imm4H=0, W=0, P=0, cond=0
    let encoding: u32 = 0x004000D8;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_i_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_aarch32_ldrd_i_a1_a_field_imm4l_15_max_d0_004000df() {
    // Encoding: 0x004000DF
    // Test aarch32_LDRD_i_A1_A field imm4L = 15 (Max)
    // ISET: A32
    // Fields: cond=0, P=0, Rt=0, U=0, W=0, Rn=0, imm4L=15, imm4H=0
    let encoding: u32 = 0x004000DF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_i_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_ldrd_i_a1_a_combo_0_d0_004000d0() {
    // Encoding: 0x004000D0
    // Test aarch32_LDRD_i_A1_A field combination: cond=0, P=0, U=0, W=0, Rn=0, Rt=0, imm4H=0, imm4L=0
    // ISET: A32
    // Fields: P=0, Rt=0, Rn=0, W=0, cond=0, U=0, imm4L=0, imm4H=0
    let encoding: u32 = 0x004000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_i_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_ldrd_i_a1_a_special_cond_0_condition_eq_208_004000d0() {
    // Encoding: 0x004000D0
    // Test aarch32_LDRD_i_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: U=0, cond=0, W=0, Rt=0, imm4L=0, P=0, Rn=0, imm4H=0
    let encoding: u32 = 0x004000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_i_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_ldrd_i_a1_a_special_cond_1_condition_ne_208_104000d0() {
    // Encoding: 0x104000D0
    // Test aarch32_LDRD_i_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: P=0, Rn=0, W=0, imm4L=0, imm4H=0, U=0, cond=1, Rt=0
    let encoding: u32 = 0x104000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_i_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_ldrd_i_a1_a_special_cond_2_condition_cs_hs_208_204000d0() {
    // Encoding: 0x204000D0
    // Test aarch32_LDRD_i_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: Rt=0, U=0, Rn=0, P=0, imm4H=0, cond=2, imm4L=0, W=0
    let encoding: u32 = 0x204000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_i_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_ldrd_i_a1_a_special_cond_3_condition_cc_lo_208_304000d0() {
    // Encoding: 0x304000D0
    // Test aarch32_LDRD_i_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: Rn=0, cond=3, P=0, imm4L=0, W=0, Rt=0, imm4H=0, U=0
    let encoding: u32 = 0x304000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_i_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_ldrd_i_a1_a_special_cond_4_condition_mi_208_404000d0() {
    // Encoding: 0x404000D0
    // Test aarch32_LDRD_i_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: U=0, imm4L=0, cond=4, Rt=0, P=0, imm4H=0, W=0, Rn=0
    let encoding: u32 = 0x404000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_i_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_ldrd_i_a1_a_special_cond_5_condition_pl_208_504000d0() {
    // Encoding: 0x504000D0
    // Test aarch32_LDRD_i_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: cond=5, W=0, P=0, U=0, Rt=0, imm4H=0, imm4L=0, Rn=0
    let encoding: u32 = 0x504000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_i_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_ldrd_i_a1_a_special_cond_6_condition_vs_208_604000d0() {
    // Encoding: 0x604000D0
    // Test aarch32_LDRD_i_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: cond=6, P=0, Rt=0, imm4L=0, Rn=0, W=0, U=0, imm4H=0
    let encoding: u32 = 0x604000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_i_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_ldrd_i_a1_a_special_cond_7_condition_vc_208_704000d0() {
    // Encoding: 0x704000D0
    // Test aarch32_LDRD_i_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: W=0, cond=7, U=0, Rn=0, imm4L=0, Rt=0, imm4H=0, P=0
    let encoding: u32 = 0x704000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_i_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_ldrd_i_a1_a_special_cond_8_condition_hi_208_804000d0() {
    // Encoding: 0x804000D0
    // Test aarch32_LDRD_i_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: P=0, U=0, Rn=0, Rt=0, cond=8, imm4L=0, W=0, imm4H=0
    let encoding: u32 = 0x804000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_i_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_ldrd_i_a1_a_special_cond_9_condition_ls_208_904000d0() {
    // Encoding: 0x904000D0
    // Test aarch32_LDRD_i_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: cond=9, Rt=0, imm4L=0, Rn=0, U=0, P=0, W=0, imm4H=0
    let encoding: u32 = 0x904000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_i_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_ldrd_i_a1_a_special_cond_10_condition_ge_208_a04000d0() {
    // Encoding: 0xA04000D0
    // Test aarch32_LDRD_i_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: U=0, cond=10, Rt=0, P=0, Rn=0, W=0, imm4H=0, imm4L=0
    let encoding: u32 = 0xA04000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_i_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_ldrd_i_a1_a_special_cond_11_condition_lt_208_b04000d0() {
    // Encoding: 0xB04000D0
    // Test aarch32_LDRD_i_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: U=0, imm4L=0, W=0, Rn=0, Rt=0, cond=11, imm4H=0, P=0
    let encoding: u32 = 0xB04000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_i_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_ldrd_i_a1_a_special_cond_12_condition_gt_208_c04000d0() {
    // Encoding: 0xC04000D0
    // Test aarch32_LDRD_i_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: cond=12, P=0, Rt=0, imm4H=0, Rn=0, U=0, W=0, imm4L=0
    let encoding: u32 = 0xC04000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_i_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_ldrd_i_a1_a_special_cond_13_condition_le_208_d04000d0() {
    // Encoding: 0xD04000D0
    // Test aarch32_LDRD_i_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: P=0, cond=13, W=0, imm4H=0, imm4L=0, Rt=0, U=0, Rn=0
    let encoding: u32 = 0xD04000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_i_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_ldrd_i_a1_a_special_cond_14_condition_al_208_e04000d0() {
    // Encoding: 0xE04000D0
    // Test aarch32_LDRD_i_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: imm4H=0, cond=14, Rn=0, Rt=0, imm4L=0, W=0, P=0, U=0
    let encoding: u32 = 0xE04000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_i_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_ldrd_i_a1_a_special_cond_15_condition_nv_208_f04000d0() {
    // Encoding: 0xF04000D0
    // Test aarch32_LDRD_i_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: imm4L=0, U=0, Rt=0, P=0, imm4H=0, cond=15, W=0, Rn=0
    let encoding: u32 = 0xF04000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_i_A1_A
/// ASL: `Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Rt" }), indices: [Single(LitInt(0))] }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Rt\" }), indices: [Single(LitInt(0))] }, rhs: LitBits([true]) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrd_i_a1_a_invalid_0_d0_004000d0() {
    // Encoding: 0x004000D0
    // Test aarch32_LDRD_i_A1_A invalid encoding: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Rt" }), indices: [Single(LitInt(0))] }, rhs: LitBits([true]) }
    // ISET: A32
    // Fields: imm4L=0, cond=0, P=0, imm4H=0, Rt=0, U=0, Rn=0, W=0
    let encoding: u32 = 0x004000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRD_i_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrd_i_a1_a_invalid_1_d0_004000d0() {
    // Encoding: 0x004000D0
    // Test aarch32_LDRD_i_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: cond=0, Rn=0, U=0, P=0, Rt=0, imm4H=0, W=0, imm4L=0
    let encoding: u32 = 0x004000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRD_i_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "P" }), rhs: Binary { op: And, lhs: LitBits([false]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "W" }) } }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"P\" }), rhs: Binary { op: And, lhs: LitBits([false]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"W\" }) } }, rhs: LitBits([true]) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrd_i_a1_a_invalid_2_d0_004000d0() {
    // Encoding: 0x004000D0
    // Test aarch32_LDRD_i_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "P" }), rhs: Binary { op: And, lhs: LitBits([false]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "W" }) } }, rhs: LitBits([true]) }
    // ISET: A32
    // Fields: cond=0, imm4L=0, Rn=0, P=0, W=0, U=0, Rt=0, imm4H=0
    let encoding: u32 = 0x004000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRD_i_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrd_i_a1_a_invalid_3_d0_004000d0() {
    // Encoding: 0x004000D0
    // Test aarch32_LDRD_i_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Rn=0, U=0, Rt=0, imm4L=0, P=0, imm4H=0, cond=0, W=0
    let encoding: u32 = 0x004000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRD_i_A1_A
/// ASL: `Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t2" }) } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"wback\" }), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t2\" }) } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrd_i_a1_a_invalid_4_d0_004000d0() {
    // Encoding: 0x004000D0
    // Test aarch32_LDRD_i_A1_A invalid encoding: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t2" }) } }
    // ISET: A32
    // Fields: imm4H=0, cond=0, W=0, Rn=0, P=0, imm4L=0, Rt=0, U=0
    let encoding: u32 = 0x004000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRD_i_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrd_i_a1_a_invalid_5_d0_004000d0() {
    // Encoding: 0x004000D0
    // Test aarch32_LDRD_i_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: U=0, Rt=0, W=0, imm4L=0, P=0, cond=0, Rn=0, imm4H=0
    let encoding: u32 = 0x004000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRD_i_A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t2" }), rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t2\" }), rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrd_i_a1_a_invalid_6_d0_004000d0() {
    // Encoding: 0x004000D0
    // Test aarch32_LDRD_i_A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t2" }), rhs: LitInt(15) }
    // ISET: A32
    // Fields: U=0, imm4H=0, cond=0, W=0, Rn=0, P=0, Rt=0, imm4L=0
    let encoding: u32 = 0x004000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRD_i_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrd_i_a1_a_invalid_7_d0_004000d0() {
    // Encoding: 0x004000D0
    // Test aarch32_LDRD_i_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: imm4L=0, W=0, Rn=0, U=0, cond=0, P=0, imm4H=0, Rt=0
    let encoding: u32 = 0x004000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRD_i_T1_A
/// ASL: `field P 24 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldrd_i_t1_a_field_p_0_min_0_e8500000() {
    // Thumb encoding (32): 0xE8500000
    // Test aarch32_LDRD_i_T1_A field P = 0 (Min)
    // ISET: T32
    // Fields: imm8=0, Rt=0, P=0, Rn=0, W=0, U=0, Rt2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8500000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRD_i_T1_A
/// ASL: `field P 24 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldrd_i_t1_a_field_p_1_max_0_e9500000() {
    // Thumb encoding (32): 0xE9500000
    // Test aarch32_LDRD_i_T1_A field P = 1 (Max)
    // ISET: T32
    // Fields: W=0, Rn=0, Rt2=0, P=1, Rt=0, U=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE9500000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRD_i_T1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldrd_i_t1_a_field_u_0_min_0_e8500000() {
    // Thumb encoding (32): 0xE8500000
    // Test aarch32_LDRD_i_T1_A field U = 0 (Min)
    // ISET: T32
    // Fields: imm8=0, Rt=0, U=0, P=0, Rn=0, W=0, Rt2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8500000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRD_i_T1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldrd_i_t1_a_field_u_1_max_0_e8d00000() {
    // Thumb encoding (32): 0xE8D00000
    // Test aarch32_LDRD_i_T1_A field U = 1 (Max)
    // ISET: T32
    // Fields: U=1, imm8=0, P=0, W=0, Rn=0, Rt2=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8D00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRD_i_T1_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldrd_i_t1_a_field_w_0_min_0_e8500000() {
    // Thumb encoding (32): 0xE8500000
    // Test aarch32_LDRD_i_T1_A field W = 0 (Min)
    // ISET: T32
    // Fields: U=0, W=0, Rn=0, Rt=0, P=0, imm8=0, Rt2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8500000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRD_i_T1_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldrd_i_t1_a_field_w_1_max_0_e8700000() {
    // Thumb encoding (32): 0xE8700000
    // Test aarch32_LDRD_i_T1_A field W = 1 (Max)
    // ISET: T32
    // Fields: P=0, Rn=0, imm8=0, U=0, W=1, Rt=0, Rt2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8700000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRD_i_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrd_i_t1_a_field_rn_0_min_0_e8500000() {
    // Thumb encoding (32): 0xE8500000
    // Test aarch32_LDRD_i_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: imm8=0, Rt=0, Rt2=0, P=0, W=0, U=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8500000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRD_i_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrd_i_t1_a_field_rn_1_poweroftwo_0_e8510000() {
    // Thumb encoding (32): 0xE8510000
    // Test aarch32_LDRD_i_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt2=0, imm8=0, U=0, P=0, W=0, Rn=1, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8510000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRD_i_T1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrd_i_t1_a_field_rt_0_min_0_e8500000() {
    // Thumb encoding (32): 0xE8500000
    // Test aarch32_LDRD_i_T1_A field Rt = 0 (Min)
    // ISET: T32
    // Fields: P=0, W=0, U=0, Rt=0, Rt2=0, Rn=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8500000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRD_i_T1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrd_i_t1_a_field_rt_1_poweroftwo_0_e8501000() {
    // Thumb encoding (32): 0xE8501000
    // Test aarch32_LDRD_i_T1_A field Rt = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: P=0, U=0, Rn=0, W=0, Rt=1, Rt2=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8501000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRD_i_T1_A
/// ASL: `field Rt2 8 +: 4`
/// Requirement: FieldBoundary { field: "Rt2", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrd_i_t1_a_field_rt2_0_min_0_e8500000() {
    // Thumb encoding (32): 0xE8500000
    // Test aarch32_LDRD_i_T1_A field Rt2 = 0 (Min)
    // ISET: T32
    // Fields: Rt2=0, imm8=0, Rn=0, U=0, W=0, P=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8500000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRD_i_T1_A
/// ASL: `field Rt2 8 +: 4`
/// Requirement: FieldBoundary { field: "Rt2", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrd_i_t1_a_field_rt2_1_poweroftwo_0_e8500100() {
    // Thumb encoding (32): 0xE8500100
    // Test aarch32_LDRD_i_T1_A field Rt2 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: P=0, U=0, W=0, Rn=0, imm8=0, Rt2=1, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8500100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRD_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_ldrd_i_t1_a_field_imm8_0_zero_0_e8500000() {
    // Thumb encoding (32): 0xE8500000
    // Test aarch32_LDRD_i_T1_A field imm8 = 0 (Zero)
    // ISET: T32
    // Fields: Rt=0, imm8=0, P=0, Rt2=0, U=0, W=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8500000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRD_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_ldrd_i_t1_a_field_imm8_1_poweroftwo_0_e8500001() {
    // Thumb encoding (32): 0xE8500001
    // Test aarch32_LDRD_i_T1_A field imm8 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, W=0, Rt2=0, imm8=1, U=0, Rn=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8500001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRD_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_ldrd_i_t1_a_field_imm8_3_poweroftwominusone_0_e8500003() {
    // Thumb encoding (32): 0xE8500003
    // Test aarch32_LDRD_i_T1_A field imm8 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, imm8=3, W=0, Rn=0, P=0, U=0, Rt2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8500003;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRD_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_ldrd_i_t1_a_field_imm8_4_poweroftwo_0_e8500004() {
    // Thumb encoding (32): 0xE8500004
    // Test aarch32_LDRD_i_T1_A field imm8 = 4 (PowerOfTwo)
    // ISET: T32
    // Fields: P=0, U=0, Rn=0, W=0, Rt=0, Rt2=0, imm8=4
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8500004;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRD_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_ldrd_i_t1_a_field_imm8_7_poweroftwominusone_0_e8500007() {
    // Thumb encoding (32): 0xE8500007
    // Test aarch32_LDRD_i_T1_A field imm8 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, imm8=7, Rt2=0, U=0, P=0, W=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8500007;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRD_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_ldrd_i_t1_a_field_imm8_8_poweroftwo_0_e8500008() {
    // Thumb encoding (32): 0xE8500008
    // Test aarch32_LDRD_i_T1_A field imm8 = 8 (PowerOfTwo)
    // ISET: T32
    // Fields: U=0, Rn=0, Rt=0, imm8=8, P=0, W=0, Rt2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8500008;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRD_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_ldrd_i_t1_a_field_imm8_15_poweroftwominusone_0_e850000f() {
    // Thumb encoding (32): 0xE850000F
    // Test aarch32_LDRD_i_T1_A field imm8 = 15 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: U=0, W=0, Rt=0, P=0, Rt2=0, Rn=0, imm8=15
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE850000F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRD_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_ldrd_i_t1_a_field_imm8_16_poweroftwo_0_e8500010() {
    // Thumb encoding (32): 0xE8500010
    // Test aarch32_LDRD_i_T1_A field imm8 = 16 (PowerOfTwo)
    // ISET: T32
    // Fields: W=0, Rt=0, Rn=0, Rt2=0, U=0, imm8=16, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8500010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRD_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_ldrd_i_t1_a_field_imm8_31_poweroftwominusone_0_e850001f() {
    // Thumb encoding (32): 0xE850001F
    // Test aarch32_LDRD_i_T1_A field imm8 = 31 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt2=0, imm8=31, P=0, U=0, Rt=0, W=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE850001F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRD_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_ldrd_i_t1_a_field_imm8_32_poweroftwo_0_e8500020() {
    // Thumb encoding (32): 0xE8500020
    // Test aarch32_LDRD_i_T1_A field imm8 = 32 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, P=0, imm8=32, Rt2=0, U=0, Rn=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8500020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRD_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_ldrd_i_t1_a_field_imm8_63_poweroftwominusone_0_e850003f() {
    // Thumb encoding (32): 0xE850003F
    // Test aarch32_LDRD_i_T1_A field imm8 = 63 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, W=0, Rn=0, Rt2=0, U=0, imm8=63, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE850003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRD_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_ldrd_i_t1_a_field_imm8_64_poweroftwo_0_e8500040() {
    // Thumb encoding (32): 0xE8500040
    // Test aarch32_LDRD_i_T1_A field imm8 = 64 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, Rt2=0, U=0, P=0, imm8=64, W=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8500040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRD_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 127, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (127)
#[test]
fn test_aarch32_ldrd_i_t1_a_field_imm8_127_poweroftwominusone_0_e850007f() {
    // Thumb encoding (32): 0xE850007F
    // Test aarch32_LDRD_i_T1_A field imm8 = 127 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm8=127, P=0, U=0, Rt2=0, W=0, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE850007F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRD_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_ldrd_i_t1_a_field_imm8_128_poweroftwo_0_e8500080() {
    // Thumb encoding (32): 0xE8500080
    // Test aarch32_LDRD_i_T1_A field imm8 = 128 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt2=0, W=0, imm8=128, U=0, P=0, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8500080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRD_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 255, boundary: Max }
/// maximum immediate (255)
#[test]
fn test_aarch32_ldrd_i_t1_a_field_imm8_255_max_0_e85000ff() {
    // Thumb encoding (32): 0xE85000FF
    // Test aarch32_LDRD_i_T1_A field imm8 = 255 (Max)
    // ISET: T32
    // Fields: imm8=255, Rt2=0, W=0, U=0, P=0, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE85000FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRD_i_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// P=0 (minimum value)
#[test]
fn test_aarch32_ldrd_i_t1_a_combo_0_0_e8500000() {
    // Thumb encoding (32): 0xE8500000
    // Test aarch32_LDRD_i_T1_A field combination: P=0, U=0, W=0, Rn=0, Rt=0, Rt2=0, imm8=0
    // ISET: T32
    // Fields: P=0, Rt=0, Rt2=0, imm8=0, U=0, Rn=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8500000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRD_i_T1_A
/// ASL: `Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t2" }) } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"wback\" }), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t2\" }) } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrd_i_t1_a_invalid_0_0_e8500000() {
    // Thumb encoding (32): 0xE8500000
    // Test aarch32_LDRD_i_T1_A invalid encoding: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t2" }) } }
    // ISET: T32
    // Fields: imm8=0, Rn=0, P=0, Rt=0, U=0, W=0, Rt2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8500000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRD_i_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrd_i_t1_a_invalid_1_0_e8500000() {
    // Thumb encoding (32): 0xE8500000
    // Test aarch32_LDRD_i_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rt=0, W=0, P=0, U=0, imm8=0, Rt2=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8500000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRD_i_T1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t2" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t2" }) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t2\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t2\" }) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrd_i_t1_a_invalid_2_0_e8500000() {
    // Thumb encoding (32): 0xE8500000
    // Test aarch32_LDRD_i_T1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t2" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t2" }) }
    // ISET: T32
    // Fields: W=0, Rt=0, P=0, Rn=0, Rt2=0, imm8=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8500000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRD_i_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrd_i_t1_a_invalid_3_0_e8500000() {
    // Thumb encoding (32): 0xE8500000
    // Test aarch32_LDRD_i_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: W=0, Rt=0, imm8=0, P=0, Rn=0, Rt2=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8500000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRD_i_A1_A
/// ASL: `UMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple multiply
#[test]
fn test_aarch32_ldrd_i_a1_a_umull_oracle_0_9ba27c20() {
    // Test UMULL: simple multiply (oracle)
    // Encoding: 0x9BA27C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3);
    set_w(&mut cpu, 1, 0x2);
    let encoding: u32 = 0x9BA27C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6, "X0 should be 0x0000000000000006");
}

/// Provenance: aarch32_LDRD_i_A1_A
/// ASL: `UMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max 32-bit * 2
#[test]
fn test_aarch32_ldrd_i_a1_a_umull_oracle_1_9ba27c20() {
    // Test UMULL: max 32-bit * 2 (oracle)
    // Encoding: 0x9BA27C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x9BA27C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0x00000001FFFFFFFE"
    );
}

/// Provenance: aarch32_LDRD_i_A1_A
/// ASL: `UMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// large positive * large positive
#[test]
fn test_aarch32_ldrd_i_a1_a_umull_oracle_2_9ba27c20() {
    // Test UMULL: large positive * large positive (oracle)
    // Encoding: 0x9BA27C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    set_w(&mut cpu, 2, 0x7FFFFFFF);
    let encoding: u32 = 0x9BA27C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x3FFFFFFF00000001");
}

/// Provenance: aarch32_LDRD_i_A1_A
/// ASL: `UMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max unsigned * max unsigned
#[test]
fn test_aarch32_ldrd_i_a1_a_umull_oracle_3_9ba27c20() {
    // Test UMULL: max unsigned * max unsigned (oracle)
    // Encoding: 0x9BA27C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x9BA27C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0xFFFFFFFE00000001");
}

/// Provenance: aarch32_LDRD_i_A1_A
/// ASL: `UMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// medium values
#[test]
fn test_aarch32_ldrd_i_a1_a_umull_oracle_4_9ba27c20() {
    // Test UMULL: medium values (oracle)
    // Encoding: 0x9BA27C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xC8);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x9BA27C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4E20, "X0 should be 0x0000000000004E20");
}

/// Provenance: aarch32_LDRD_i_A1_A
/// ASL: `UMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// 16-bit values
#[test]
fn test_aarch32_ldrd_i_a1_a_umull_oracle_5_9ba27c20() {
    // Test UMULL: 16-bit values (oracle)
    // Encoding: 0x9BA27C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x5678);
    set_w(&mut cpu, 1, 0x1234);
    let encoding: u32 = 0x9BA27C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6260060, "X0 should be 0x0000000006260060");
}

// ============================================================================
// aarch32_LDRB_l_A Tests
// ============================================================================

/// Provenance: aarch32_LDRB_l_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_ldrb_l_a1_a_field_cond_0_min_0_045f0000() {
    // Encoding: 0x045F0000
    // Test aarch32_LDRB_l_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: Rt=0, imm12=0, W=0, P=0, U=0, cond=0
    let encoding: u32 = 0x045F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_l_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_ldrb_l_a1_a_field_cond_1_poweroftwo_0_145f0000() {
    // Encoding: 0x145F0000
    // Test aarch32_LDRB_l_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, Rt=0, cond=1, U=0, imm12=0, W=0
    let encoding: u32 = 0x145F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_l_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_ldrb_l_a1_a_field_cond_2_poweroftwo_0_245f0000() {
    // Encoding: 0x245F0000
    // Test aarch32_LDRB_l_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=2, U=0, W=0, imm12=0, Rt=0, P=0
    let encoding: u32 = 0x245F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_l_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_ldrb_l_a1_a_field_cond_3_poweroftwo_0_345f0000() {
    // Encoding: 0x345F0000
    // Test aarch32_LDRB_l_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=3, U=0, imm12=0, Rt=0, W=0, P=0
    let encoding: u32 = 0x345F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_l_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_ldrb_l_a1_a_field_cond_4_poweroftwo_0_445f0000() {
    // Encoding: 0x445F0000
    // Test aarch32_LDRB_l_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=0, P=0, cond=4, W=0, Rt=0, U=0
    let encoding: u32 = 0x445F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_l_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_ldrb_l_a1_a_field_cond_5_poweroftwo_0_545f0000() {
    // Encoding: 0x545F0000
    // Test aarch32_LDRB_l_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, P=0, U=0, cond=5, imm12=0, W=0
    let encoding: u32 = 0x545F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_l_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_ldrb_l_a1_a_field_cond_6_poweroftwo_0_645f0000() {
    // Encoding: 0x645F0000
    // Test aarch32_LDRB_l_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, P=0, cond=6, W=0, Rt=0, imm12=0
    let encoding: u32 = 0x645F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_l_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_ldrb_l_a1_a_field_cond_7_poweroftwo_0_745f0000() {
    // Encoding: 0x745F0000
    // Test aarch32_LDRB_l_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, P=0, cond=7, W=0, Rt=0, imm12=0
    let encoding: u32 = 0x745F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_l_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_ldrb_l_a1_a_field_cond_8_poweroftwo_0_845f0000() {
    // Encoding: 0x845F0000
    // Test aarch32_LDRB_l_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, Rt=0, P=0, imm12=0, U=0, cond=8
    let encoding: u32 = 0x845F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_l_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_ldrb_l_a1_a_field_cond_9_poweroftwo_0_945f0000() {
    // Encoding: 0x945F0000
    // Test aarch32_LDRB_l_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, P=0, Rt=0, cond=9, U=0, imm12=0
    let encoding: u32 = 0x945F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_l_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_ldrb_l_a1_a_field_cond_10_poweroftwo_0_a45f0000() {
    // Encoding: 0xA45F0000
    // Test aarch32_LDRB_l_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, Rt=0, imm12=0, cond=10, U=0, W=0
    let encoding: u32 = 0xA45F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_l_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_ldrb_l_a1_a_field_cond_11_poweroftwo_0_b45f0000() {
    // Encoding: 0xB45F0000
    // Test aarch32_LDRB_l_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=11, imm12=0, Rt=0, W=0, P=0, U=0
    let encoding: u32 = 0xB45F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_l_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_ldrb_l_a1_a_field_cond_12_poweroftwo_0_c45f0000() {
    // Encoding: 0xC45F0000
    // Test aarch32_LDRB_l_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=0, Rt=0, cond=12, P=0, U=0, W=0
    let encoding: u32 = 0xC45F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_l_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_ldrb_l_a1_a_field_cond_13_poweroftwo_0_d45f0000() {
    // Encoding: 0xD45F0000
    // Test aarch32_LDRB_l_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=13, P=0, W=0, imm12=0, U=0, Rt=0
    let encoding: u32 = 0xD45F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_l_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_ldrb_l_a1_a_field_cond_14_poweroftwo_0_e45f0000() {
    // Encoding: 0xE45F0000
    // Test aarch32_LDRB_l_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, W=0, Rt=0, cond=14, imm12=0, U=0
    let encoding: u32 = 0xE45F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_l_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_ldrb_l_a1_a_field_cond_15_max_0_f45f0000() {
    // Encoding: 0xF45F0000
    // Test aarch32_LDRB_l_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: cond=15, imm12=0, Rt=0, P=0, U=0, W=0
    let encoding: u32 = 0xF45F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_l_A1_A
/// ASL: `field P 24 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldrb_l_a1_a_field_p_0_min_0_045f0000() {
    // Encoding: 0x045F0000
    // Test aarch32_LDRB_l_A1_A field P = 0 (Min)
    // ISET: A32
    // Fields: U=0, P=0, cond=0, W=0, Rt=0, imm12=0
    let encoding: u32 = 0x045F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_l_A1_A
/// ASL: `field P 24 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldrb_l_a1_a_field_p_1_max_0_055f0000() {
    // Encoding: 0x055F0000
    // Test aarch32_LDRB_l_A1_A field P = 1 (Max)
    // ISET: A32
    // Fields: P=1, U=0, W=0, imm12=0, cond=0, Rt=0
    let encoding: u32 = 0x055F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_l_A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldrb_l_a1_a_field_u_0_min_0_045f0000() {
    // Encoding: 0x045F0000
    // Test aarch32_LDRB_l_A1_A field U = 0 (Min)
    // ISET: A32
    // Fields: imm12=0, Rt=0, U=0, P=0, cond=0, W=0
    let encoding: u32 = 0x045F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_l_A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldrb_l_a1_a_field_u_1_max_0_04df0000() {
    // Encoding: 0x04DF0000
    // Test aarch32_LDRB_l_A1_A field U = 1 (Max)
    // ISET: A32
    // Fields: cond=0, imm12=0, U=1, W=0, Rt=0, P=0
    let encoding: u32 = 0x04DF0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_l_A1_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldrb_l_a1_a_field_w_0_min_0_045f0000() {
    // Encoding: 0x045F0000
    // Test aarch32_LDRB_l_A1_A field W = 0 (Min)
    // ISET: A32
    // Fields: U=0, P=0, cond=0, W=0, Rt=0, imm12=0
    let encoding: u32 = 0x045F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_l_A1_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldrb_l_a1_a_field_w_1_max_0_047f0000() {
    // Encoding: 0x047F0000
    // Test aarch32_LDRB_l_A1_A field W = 1 (Max)
    // ISET: A32
    // Fields: W=1, U=0, P=0, cond=0, Rt=0, imm12=0
    let encoding: u32 = 0x047F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_l_A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrb_l_a1_a_field_rt_0_min_0_045f0000() {
    // Encoding: 0x045F0000
    // Test aarch32_LDRB_l_A1_A field Rt = 0 (Min)
    // ISET: A32
    // Fields: P=0, W=0, Rt=0, imm12=0, cond=0, U=0
    let encoding: u32 = 0x045F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_l_A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrb_l_a1_a_field_rt_1_poweroftwo_0_045f1000() {
    // Encoding: 0x045F1000
    // Test aarch32_LDRB_l_A1_A field Rt = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, U=0, W=0, Rt=1, P=0, imm12=0
    let encoding: u32 = 0x045F1000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_l_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_ldrb_l_a1_a_field_imm12_0_zero_0_045f0000() {
    // Encoding: 0x045F0000
    // Test aarch32_LDRB_l_A1_A field imm12 = 0 (Zero)
    // ISET: A32
    // Fields: U=0, Rt=0, cond=0, imm12=0, P=0, W=0
    let encoding: u32 = 0x045F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_l_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_ldrb_l_a1_a_field_imm12_1_poweroftwo_0_045f0001() {
    // Encoding: 0x045F0001
    // Test aarch32_LDRB_l_A1_A field imm12 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=1, Rt=0, cond=0, P=0, U=0, W=0
    let encoding: u32 = 0x045F0001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_l_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_ldrb_l_a1_a_field_imm12_3_poweroftwominusone_0_045f0003() {
    // Encoding: 0x045F0003
    // Test aarch32_LDRB_l_A1_A field imm12 = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: W=0, imm12=3, Rt=0, cond=0, P=0, U=0
    let encoding: u32 = 0x045F0003;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_l_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_ldrb_l_a1_a_field_imm12_4_poweroftwo_0_045f0004() {
    // Encoding: 0x045F0004
    // Test aarch32_LDRB_l_A1_A field imm12 = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, imm12=4, W=0, cond=0, P=0, Rt=0
    let encoding: u32 = 0x045F0004;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_l_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_ldrb_l_a1_a_field_imm12_7_poweroftwominusone_0_045f0007() {
    // Encoding: 0x045F0007
    // Test aarch32_LDRB_l_A1_A field imm12 = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, Rt=0, U=0, imm12=7, P=0, W=0
    let encoding: u32 = 0x045F0007;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_l_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_ldrb_l_a1_a_field_imm12_8_poweroftwo_0_045f0008() {
    // Encoding: 0x045F0008
    // Test aarch32_LDRB_l_A1_A field imm12 = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, Rt=0, P=0, imm12=8, cond=0, U=0
    let encoding: u32 = 0x045F0008;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_l_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_ldrb_l_a1_a_field_imm12_15_poweroftwominusone_0_045f000f() {
    // Encoding: 0x045F000F
    // Test aarch32_LDRB_l_A1_A field imm12 = 15 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, P=0, U=0, W=0, Rt=0, imm12=15
    let encoding: u32 = 0x045F000F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_l_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_ldrb_l_a1_a_field_imm12_16_poweroftwo_0_045f0010() {
    // Encoding: 0x045F0010
    // Test aarch32_LDRB_l_A1_A field imm12 = 16 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, imm12=16, W=0, Rt=0, cond=0, U=0
    let encoding: u32 = 0x045F0010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_l_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_ldrb_l_a1_a_field_imm12_31_poweroftwominusone_0_045f001f() {
    // Encoding: 0x045F001F
    // Test aarch32_LDRB_l_A1_A field imm12 = 31 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, P=0, Rt=0, U=0, imm12=31, W=0
    let encoding: u32 = 0x045F001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_l_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_ldrb_l_a1_a_field_imm12_32_poweroftwo_0_045f0020() {
    // Encoding: 0x045F0020
    // Test aarch32_LDRB_l_A1_A field imm12 = 32 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, cond=0, W=0, Rt=0, imm12=32, U=0
    let encoding: u32 = 0x045F0020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_l_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_ldrb_l_a1_a_field_imm12_63_poweroftwominusone_0_045f003f() {
    // Encoding: 0x045F003F
    // Test aarch32_LDRB_l_A1_A field imm12 = 63 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: W=0, Rt=0, U=0, cond=0, P=0, imm12=63
    let encoding: u32 = 0x045F003F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_l_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_ldrb_l_a1_a_field_imm12_64_poweroftwo_0_045f0040() {
    // Encoding: 0x045F0040
    // Test aarch32_LDRB_l_A1_A field imm12 = 64 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, U=0, Rt=0, imm12=64, W=0, P=0
    let encoding: u32 = 0x045F0040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_l_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 127, boundary: PowerOfTwoMinusOne }
/// 2^7 - 1 = 127
#[test]
fn test_aarch32_ldrb_l_a1_a_field_imm12_127_poweroftwominusone_0_045f007f() {
    // Encoding: 0x045F007F
    // Test aarch32_LDRB_l_A1_A field imm12 = 127 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm12=127, P=0, U=0, cond=0, Rt=0, W=0
    let encoding: u32 = 0x045F007F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_l_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_ldrb_l_a1_a_field_imm12_128_poweroftwo_0_045f0080() {
    // Encoding: 0x045F0080
    // Test aarch32_LDRB_l_A1_A field imm12 = 128 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, imm12=128, P=0, cond=0, U=0, Rt=0
    let encoding: u32 = 0x045F0080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_l_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 255, boundary: PowerOfTwoMinusOne }
/// 2^8 - 1 = 255
#[test]
fn test_aarch32_ldrb_l_a1_a_field_imm12_255_poweroftwominusone_0_045f00ff() {
    // Encoding: 0x045F00FF
    // Test aarch32_LDRB_l_A1_A field imm12 = 255 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm12=255, cond=0, P=0, U=0, W=0, Rt=0
    let encoding: u32 = 0x045F00FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_l_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 256, boundary: PowerOfTwo }
/// power of 2 (2^8 = 256)
#[test]
fn test_aarch32_ldrb_l_a1_a_field_imm12_256_poweroftwo_0_045f0100() {
    // Encoding: 0x045F0100
    // Test aarch32_LDRB_l_A1_A field imm12 = 256 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, P=0, imm12=256, U=0, W=0, cond=0
    let encoding: u32 = 0x045F0100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_l_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 511, boundary: PowerOfTwoMinusOne }
/// 2^9 - 1 = 511
#[test]
fn test_aarch32_ldrb_l_a1_a_field_imm12_511_poweroftwominusone_0_045f01ff() {
    // Encoding: 0x045F01FF
    // Test aarch32_LDRB_l_A1_A field imm12 = 511 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: P=0, U=0, cond=0, Rt=0, W=0, imm12=511
    let encoding: u32 = 0x045F01FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_l_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 512, boundary: PowerOfTwo }
/// power of 2 (2^9 = 512)
#[test]
fn test_aarch32_ldrb_l_a1_a_field_imm12_512_poweroftwo_0_045f0200() {
    // Encoding: 0x045F0200
    // Test aarch32_LDRB_l_A1_A field imm12 = 512 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=512, P=0, cond=0, W=0, Rt=0, U=0
    let encoding: u32 = 0x045F0200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_l_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1023, boundary: PowerOfTwoMinusOne }
/// 2^10 - 1 = 1023
#[test]
fn test_aarch32_ldrb_l_a1_a_field_imm12_1023_poweroftwominusone_0_045f03ff() {
    // Encoding: 0x045F03FF
    // Test aarch32_LDRB_l_A1_A field imm12 = 1023 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rt=0, imm12=1023, U=0, P=0, cond=0, W=0
    let encoding: u32 = 0x045F03FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_l_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1024, boundary: PowerOfTwo }
/// power of 2 (2^10 = 1024)
#[test]
fn test_aarch32_ldrb_l_a1_a_field_imm12_1024_poweroftwo_0_045f0400() {
    // Encoding: 0x045F0400
    // Test aarch32_LDRB_l_A1_A field imm12 = 1024 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, W=0, imm12=1024, U=0, Rt=0, P=0
    let encoding: u32 = 0x045F0400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_l_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2047, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (2047)
#[test]
fn test_aarch32_ldrb_l_a1_a_field_imm12_2047_poweroftwominusone_0_045f07ff() {
    // Encoding: 0x045F07FF
    // Test aarch32_LDRB_l_A1_A field imm12 = 2047 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: U=0, P=0, imm12=2047, W=0, Rt=0, cond=0
    let encoding: u32 = 0x045F07FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_l_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2048, boundary: PowerOfTwo }
/// power of 2 (2^11 = 2048)
#[test]
fn test_aarch32_ldrb_l_a1_a_field_imm12_2048_poweroftwo_0_045f0800() {
    // Encoding: 0x045F0800
    // Test aarch32_LDRB_l_A1_A field imm12 = 2048 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=2048, P=0, U=0, cond=0, W=0, Rt=0
    let encoding: u32 = 0x045F0800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_l_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4095, boundary: Max }
/// maximum immediate (4095)
#[test]
fn test_aarch32_ldrb_l_a1_a_field_imm12_4095_max_0_045f0fff() {
    // Encoding: 0x045F0FFF
    // Test aarch32_LDRB_l_A1_A field imm12 = 4095 (Max)
    // ISET: A32
    // Fields: Rt=0, cond=0, imm12=4095, P=0, U=0, W=0
    let encoding: u32 = 0x045F0FFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_l_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_ldrb_l_a1_a_combo_0_0_045f0000() {
    // Encoding: 0x045F0000
    // Test aarch32_LDRB_l_A1_A field combination: cond=0, P=0, U=0, W=0, Rt=0, imm12=0
    // ISET: A32
    // Fields: U=0, W=0, Rt=0, imm12=0, cond=0, P=0
    let encoding: u32 = 0x045F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_l_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_ldrb_l_a1_a_special_cond_0_condition_eq_0_045f0000() {
    // Encoding: 0x045F0000
    // Test aarch32_LDRB_l_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: P=0, Rt=0, imm12=0, W=0, cond=0, U=0
    let encoding: u32 = 0x045F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_l_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_ldrb_l_a1_a_special_cond_1_condition_ne_0_145f0000() {
    // Encoding: 0x145F0000
    // Test aarch32_LDRB_l_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: cond=1, P=0, U=0, W=0, Rt=0, imm12=0
    let encoding: u32 = 0x145F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_l_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_ldrb_l_a1_a_special_cond_2_condition_cs_hs_0_245f0000() {
    // Encoding: 0x245F0000
    // Test aarch32_LDRB_l_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: cond=2, U=0, P=0, W=0, Rt=0, imm12=0
    let encoding: u32 = 0x245F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_l_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_ldrb_l_a1_a_special_cond_3_condition_cc_lo_0_345f0000() {
    // Encoding: 0x345F0000
    // Test aarch32_LDRB_l_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: cond=3, imm12=0, Rt=0, W=0, P=0, U=0
    let encoding: u32 = 0x345F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_l_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_ldrb_l_a1_a_special_cond_4_condition_mi_0_445f0000() {
    // Encoding: 0x445F0000
    // Test aarch32_LDRB_l_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: W=0, P=0, cond=4, U=0, Rt=0, imm12=0
    let encoding: u32 = 0x445F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_l_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_ldrb_l_a1_a_special_cond_5_condition_pl_0_545f0000() {
    // Encoding: 0x545F0000
    // Test aarch32_LDRB_l_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: P=0, U=0, W=0, Rt=0, imm12=0, cond=5
    let encoding: u32 = 0x545F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_l_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_ldrb_l_a1_a_special_cond_6_condition_vs_0_645f0000() {
    // Encoding: 0x645F0000
    // Test aarch32_LDRB_l_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: U=0, W=0, Rt=0, cond=6, P=0, imm12=0
    let encoding: u32 = 0x645F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_l_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_ldrb_l_a1_a_special_cond_7_condition_vc_0_745f0000() {
    // Encoding: 0x745F0000
    // Test aarch32_LDRB_l_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: Rt=0, P=0, cond=7, U=0, imm12=0, W=0
    let encoding: u32 = 0x745F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_l_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_ldrb_l_a1_a_special_cond_8_condition_hi_0_845f0000() {
    // Encoding: 0x845F0000
    // Test aarch32_LDRB_l_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: Rt=0, P=0, imm12=0, cond=8, U=0, W=0
    let encoding: u32 = 0x845F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_l_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_ldrb_l_a1_a_special_cond_9_condition_ls_0_945f0000() {
    // Encoding: 0x945F0000
    // Test aarch32_LDRB_l_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: P=0, cond=9, U=0, Rt=0, imm12=0, W=0
    let encoding: u32 = 0x945F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_l_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_ldrb_l_a1_a_special_cond_10_condition_ge_0_a45f0000() {
    // Encoding: 0xA45F0000
    // Test aarch32_LDRB_l_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: U=0, P=0, cond=10, W=0, imm12=0, Rt=0
    let encoding: u32 = 0xA45F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_l_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_ldrb_l_a1_a_special_cond_11_condition_lt_0_b45f0000() {
    // Encoding: 0xB45F0000
    // Test aarch32_LDRB_l_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: cond=11, Rt=0, U=0, imm12=0, W=0, P=0
    let encoding: u32 = 0xB45F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_l_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_ldrb_l_a1_a_special_cond_12_condition_gt_0_c45f0000() {
    // Encoding: 0xC45F0000
    // Test aarch32_LDRB_l_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: Rt=0, W=0, P=0, imm12=0, cond=12, U=0
    let encoding: u32 = 0xC45F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_l_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_ldrb_l_a1_a_special_cond_13_condition_le_0_d45f0000() {
    // Encoding: 0xD45F0000
    // Test aarch32_LDRB_l_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: U=0, W=0, P=0, cond=13, Rt=0, imm12=0
    let encoding: u32 = 0xD45F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_l_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_ldrb_l_a1_a_special_cond_14_condition_al_0_e45f0000() {
    // Encoding: 0xE45F0000
    // Test aarch32_LDRB_l_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: imm12=0, U=0, Rt=0, W=0, P=0, cond=14
    let encoding: u32 = 0xE45F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_l_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_ldrb_l_a1_a_special_cond_15_condition_nv_0_f45f0000() {
    // Encoding: 0xF45F0000
    // Test aarch32_LDRB_l_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: W=0, P=0, U=0, cond=15, Rt=0, imm12=0
    let encoding: u32 = 0xF45F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_l_A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }) } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"wback\" }) } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrb_l_a1_a_invalid_0_0_045f0000() {
    // Encoding: 0x045F0000
    // Test aarch32_LDRB_l_A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }) } }
    // ISET: A32
    // Fields: U=0, P=0, W=0, imm12=0, cond=0, Rt=0
    let encoding: u32 = 0x045F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRB_l_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrb_l_a1_a_invalid_1_0_045f0000() {
    // Encoding: 0x045F0000
    // Test aarch32_LDRB_l_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: cond=0, P=0, Rt=0, imm12=0, W=0, U=0
    let encoding: u32 = 0x045F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRB_l_T1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldrb_l_t1_a_field_u_0_min_0_f81f0000() {
    // Thumb encoding (32): 0xF81F0000
    // Test aarch32_LDRB_l_T1_A field U = 0 (Min)
    // ISET: T32
    // Fields: imm12=0, U=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF81F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_l_T1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldrb_l_t1_a_field_u_1_max_0_f89f0000() {
    // Thumb encoding (32): 0xF89F0000
    // Test aarch32_LDRB_l_T1_A field U = 1 (Max)
    // ISET: T32
    // Fields: imm12=0, U=1, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF89F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_l_T1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrb_l_t1_a_field_rt_0_min_0_f81f0000() {
    // Thumb encoding (32): 0xF81F0000
    // Test aarch32_LDRB_l_T1_A field Rt = 0 (Min)
    // ISET: T32
    // Fields: U=0, Rt=0, imm12=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF81F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_l_T1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrb_l_t1_a_field_rt_1_poweroftwo_0_f81f1000() {
    // Thumb encoding (32): 0xF81F1000
    // Test aarch32_LDRB_l_T1_A field Rt = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm12=0, U=0, Rt=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF81F1000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_ldrb_l_t1_a_field_imm12_0_zero_0_f81f0000() {
    // Thumb encoding (32): 0xF81F0000
    // Test aarch32_LDRB_l_T1_A field imm12 = 0 (Zero)
    // ISET: T32
    // Fields: U=0, Rt=0, imm12=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF81F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_ldrb_l_t1_a_field_imm12_1_poweroftwo_0_f81f0001() {
    // Thumb encoding (32): 0xF81F0001
    // Test aarch32_LDRB_l_T1_A field imm12 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, imm12=1, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF81F0001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_ldrb_l_t1_a_field_imm12_3_poweroftwominusone_0_f81f0003() {
    // Thumb encoding (32): 0xF81F0003
    // Test aarch32_LDRB_l_T1_A field imm12 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: U=0, Rt=0, imm12=3
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF81F0003;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_ldrb_l_t1_a_field_imm12_4_poweroftwo_0_f81f0004() {
    // Thumb encoding (32): 0xF81F0004
    // Test aarch32_LDRB_l_T1_A field imm12 = 4 (PowerOfTwo)
    // ISET: T32
    // Fields: imm12=4, Rt=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF81F0004;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_ldrb_l_t1_a_field_imm12_7_poweroftwominusone_0_f81f0007() {
    // Thumb encoding (32): 0xF81F0007
    // Test aarch32_LDRB_l_T1_A field imm12 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: U=0, Rt=0, imm12=7
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF81F0007;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_ldrb_l_t1_a_field_imm12_8_poweroftwo_0_f81f0008() {
    // Thumb encoding (32): 0xF81F0008
    // Test aarch32_LDRB_l_T1_A field imm12 = 8 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, imm12=8, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF81F0008;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_ldrb_l_t1_a_field_imm12_15_poweroftwominusone_0_f81f000f() {
    // Thumb encoding (32): 0xF81F000F
    // Test aarch32_LDRB_l_T1_A field imm12 = 15 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: U=0, Rt=0, imm12=15
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF81F000F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_ldrb_l_t1_a_field_imm12_16_poweroftwo_0_f81f0010() {
    // Thumb encoding (32): 0xF81F0010
    // Test aarch32_LDRB_l_T1_A field imm12 = 16 (PowerOfTwo)
    // ISET: T32
    // Fields: imm12=16, Rt=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF81F0010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_ldrb_l_t1_a_field_imm12_31_poweroftwominusone_0_f81f001f() {
    // Thumb encoding (32): 0xF81F001F
    // Test aarch32_LDRB_l_T1_A field imm12 = 31 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: U=0, imm12=31, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF81F001F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_ldrb_l_t1_a_field_imm12_32_poweroftwo_0_f81f0020() {
    // Thumb encoding (32): 0xF81F0020
    // Test aarch32_LDRB_l_T1_A field imm12 = 32 (PowerOfTwo)
    // ISET: T32
    // Fields: imm12=32, U=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF81F0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_ldrb_l_t1_a_field_imm12_63_poweroftwominusone_0_f81f003f() {
    // Thumb encoding (32): 0xF81F003F
    // Test aarch32_LDRB_l_T1_A field imm12 = 63 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: U=0, Rt=0, imm12=63
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF81F003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_ldrb_l_t1_a_field_imm12_64_poweroftwo_0_f81f0040() {
    // Thumb encoding (32): 0xF81F0040
    // Test aarch32_LDRB_l_T1_A field imm12 = 64 (PowerOfTwo)
    // ISET: T32
    // Fields: U=0, Rt=0, imm12=64
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF81F0040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 127, boundary: PowerOfTwoMinusOne }
/// 2^7 - 1 = 127
#[test]
fn test_aarch32_ldrb_l_t1_a_field_imm12_127_poweroftwominusone_0_f81f007f() {
    // Thumb encoding (32): 0xF81F007F
    // Test aarch32_LDRB_l_T1_A field imm12 = 127 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm12=127, U=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF81F007F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_ldrb_l_t1_a_field_imm12_128_poweroftwo_0_f81f0080() {
    // Thumb encoding (32): 0xF81F0080
    // Test aarch32_LDRB_l_T1_A field imm12 = 128 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, imm12=128, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF81F0080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 255, boundary: PowerOfTwoMinusOne }
/// 2^8 - 1 = 255
#[test]
fn test_aarch32_ldrb_l_t1_a_field_imm12_255_poweroftwominusone_0_f81f00ff() {
    // Thumb encoding (32): 0xF81F00FF
    // Test aarch32_LDRB_l_T1_A field imm12 = 255 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: U=0, imm12=255, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF81F00FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 256, boundary: PowerOfTwo }
/// power of 2 (2^8 = 256)
#[test]
fn test_aarch32_ldrb_l_t1_a_field_imm12_256_poweroftwo_0_f81f0100() {
    // Thumb encoding (32): 0xF81F0100
    // Test aarch32_LDRB_l_T1_A field imm12 = 256 (PowerOfTwo)
    // ISET: T32
    // Fields: U=0, Rt=0, imm12=256
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF81F0100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 511, boundary: PowerOfTwoMinusOne }
/// 2^9 - 1 = 511
#[test]
fn test_aarch32_ldrb_l_t1_a_field_imm12_511_poweroftwominusone_0_f81f01ff() {
    // Thumb encoding (32): 0xF81F01FF
    // Test aarch32_LDRB_l_T1_A field imm12 = 511 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm12=511, U=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF81F01FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 512, boundary: PowerOfTwo }
/// power of 2 (2^9 = 512)
#[test]
fn test_aarch32_ldrb_l_t1_a_field_imm12_512_poweroftwo_0_f81f0200() {
    // Thumb encoding (32): 0xF81F0200
    // Test aarch32_LDRB_l_T1_A field imm12 = 512 (PowerOfTwo)
    // ISET: T32
    // Fields: imm12=512, Rt=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF81F0200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1023, boundary: PowerOfTwoMinusOne }
/// 2^10 - 1 = 1023
#[test]
fn test_aarch32_ldrb_l_t1_a_field_imm12_1023_poweroftwominusone_0_f81f03ff() {
    // Thumb encoding (32): 0xF81F03FF
    // Test aarch32_LDRB_l_T1_A field imm12 = 1023 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm12=1023, U=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF81F03FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1024, boundary: PowerOfTwo }
/// power of 2 (2^10 = 1024)
#[test]
fn test_aarch32_ldrb_l_t1_a_field_imm12_1024_poweroftwo_0_f81f0400() {
    // Thumb encoding (32): 0xF81F0400
    // Test aarch32_LDRB_l_T1_A field imm12 = 1024 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, U=0, imm12=1024
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF81F0400;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2047, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (2047)
#[test]
fn test_aarch32_ldrb_l_t1_a_field_imm12_2047_poweroftwominusone_0_f81f07ff() {
    // Thumb encoding (32): 0xF81F07FF
    // Test aarch32_LDRB_l_T1_A field imm12 = 2047 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, imm12=2047, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF81F07FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2048, boundary: PowerOfTwo }
/// power of 2 (2^11 = 2048)
#[test]
fn test_aarch32_ldrb_l_t1_a_field_imm12_2048_poweroftwo_0_f81f0800() {
    // Thumb encoding (32): 0xF81F0800
    // Test aarch32_LDRB_l_T1_A field imm12 = 2048 (PowerOfTwo)
    // ISET: T32
    // Fields: U=0, Rt=0, imm12=2048
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF81F0800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4095, boundary: Max }
/// maximum immediate (4095)
#[test]
fn test_aarch32_ldrb_l_t1_a_field_imm12_4095_max_0_f81f0fff() {
    // Thumb encoding (32): 0xF81F0FFF
    // Test aarch32_LDRB_l_T1_A field imm12 = 4095 (Max)
    // ISET: T32
    // Fields: U=0, Rt=0, imm12=4095
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF81F0FFF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_l_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=0 (minimum value)
#[test]
fn test_aarch32_ldrb_l_t1_a_combo_0_0_f81f0000() {
    // Thumb encoding (32): 0xF81F0000
    // Test aarch32_LDRB_l_T1_A field combination: U=0, Rt=0, imm12=0
    // ISET: T32
    // Fields: Rt=0, imm12=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF81F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_l_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple division (32)
#[test]
fn test_aarch32_ldrb_l_t1_a_udiv_oracle_32_0_1ac20820() {
    // Test UDIV 32-bit: simple division (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0xA);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA, "W0 should be 0x0000000A");
}

/// Provenance: aarch32_LDRB_l_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple division (64)
#[test]
fn test_aarch32_ldrb_l_t1_a_udiv_oracle_64_0_9ac20820() {
    // Test UDIV 64-bit: simple division (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xA);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA, "X0 should be 0x000000000000000A");
}

/// Provenance: aarch32_LDRB_l_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// division with remainder (32)
#[test]
fn test_aarch32_ldrb_l_t1_a_udiv_oracle_32_1_1ac20820() {
    // Test UDIV 32-bit: division with remainder (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x3);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x21, "W0 should be 0x00000021");
}

/// Provenance: aarch32_LDRB_l_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// division with remainder (64)
#[test]
fn test_aarch32_ldrb_l_t1_a_udiv_oracle_64_1_9ac20820() {
    // Test UDIV 64-bit: division with remainder (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x21, "X0 should be 0x0000000000000021");
}

/// Provenance: aarch32_LDRB_l_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero dividend (32)
#[test]
fn test_aarch32_ldrb_l_t1_a_udiv_oracle_32_2_1ac20820() {
    // Test UDIV 32-bit: zero dividend (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xA);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_LDRB_l_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero dividend (64)
#[test]
fn test_aarch32_ldrb_l_t1_a_udiv_oracle_64_2_9ac20820() {
    // Test UDIV 64-bit: zero dividend (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xA);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_LDRB_l_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// divide by zero - result is 0 (32)
#[test]
fn test_aarch32_ldrb_l_t1_a_udiv_oracle_32_3_1ac20820() {
    // Test UDIV 32-bit: divide by zero - result is 0 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xA);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_LDRB_l_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// divide by zero - result is 0 (64)
#[test]
fn test_aarch32_ldrb_l_t1_a_udiv_oracle_64_3_9ac20820() {
    // Test UDIV 64-bit: divide by zero - result is 0 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0xA);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_LDRB_l_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max value / 2 (32)
#[test]
fn test_aarch32_ldrb_l_t1_a_udiv_oracle_32_4_1ac20820() {
    // Test UDIV 32-bit: max value / 2 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FFFFFFF, "W0 should be 0x7FFFFFFF");
}

/// Provenance: aarch32_LDRB_l_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max value / 2 (64)
#[test]
fn test_aarch32_ldrb_l_t1_a_udiv_oracle_64_4_9ac20820() {
    // Test UDIV 64-bit: max value / 2 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0x7FFFFFFFFFFFFFFF"
    );
}

/// Provenance: aarch32_LDRB_l_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set / 2 (32)
#[test]
fn test_aarch32_ldrb_l_t1_a_udiv_oracle_32_5_1ac20820() {
    // Test UDIV 32-bit: MSB set / 2 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_LDRB_l_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// MSB set / 2 (64)
#[test]
fn test_aarch32_ldrb_l_t1_a_udiv_oracle_64_5_9ac20820() {
    // Test UDIV 64-bit: MSB set / 2 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x4000000000000000");
}

/// Provenance: aarch32_LDRB_l_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// self-division (32)
#[test]
fn test_aarch32_ldrb_l_t1_a_udiv_oracle_32_6_1ac20820() {
    // Test UDIV 32-bit: self-division (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x7);
    set_w(&mut cpu, 1, 0x7);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_LDRB_l_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// self-division (64)
#[test]
fn test_aarch32_ldrb_l_t1_a_udiv_oracle_64_6_9ac20820() {
    // Test UDIV 64-bit: self-division (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7);
    set_w(&mut cpu, 2, 0x7);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x0000000000000001");
}

/// Provenance: aarch32_LDRB_l_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// one / one (32)
#[test]
fn test_aarch32_ldrb_l_t1_a_udiv_oracle_32_7_1ac20820() {
    // Test UDIV 32-bit: one / one (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_LDRB_l_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// one / one (64)
#[test]
fn test_aarch32_ldrb_l_t1_a_udiv_oracle_64_7_9ac20820() {
    // Test UDIV 64-bit: one / one (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x0000000000000001");
}

/// Provenance: aarch32_LDRB_l_T1_A
/// ASL: `UDIV R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// exact division
#[test]
fn test_aarch32_ldrb_l_t1_a_t32_oracle_0_f81f0000() {
    // Test T32 UDIV: exact division (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xA);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF81F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA, "R0 should be 0x0000000A");
}

/// Provenance: aarch32_LDRB_l_T1_A
/// ASL: `UDIV R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// with remainder
#[test]
fn test_aarch32_ldrb_l_t1_a_t32_oracle_1_f81f0000() {
    // Test T32 UDIV: with remainder (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x3);
    let encoding: u32 = 0xF81F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x21, "R0 should be 0x00000021");
}

/// Provenance: aarch32_LDRB_l_T1_A
/// ASL: `UDIV R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero dividend
#[test]
fn test_aarch32_ldrb_l_t1_a_t32_oracle_2_f81f0000() {
    // Test T32 UDIV: zero dividend (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xA);
    let encoding: u32 = 0xF81F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_LDRB_l_T1_A
/// ASL: `UDIV R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// divide by zero
#[test]
fn test_aarch32_ldrb_l_t1_a_t32_oracle_3_f81f0000() {
    // Test T32 UDIV: divide by zero (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0xA);
    let encoding: u32 = 0xF81F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

// ============================================================================
// aarch32_LDAEXH_A Tests
// ============================================================================

/// Provenance: aarch32_LDAEXH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_ldaexh_a1_a_field_cond_0_min_290_01f00290() {
    // Encoding: 0x01F00290
    // Test aarch32_LDAEXH_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: Rt=0, cond=0, Rn=0
    let encoding: u32 = 0x01F00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_ldaexh_a1_a_field_cond_1_poweroftwo_290_11f00290() {
    // Encoding: 0x11F00290
    // Test aarch32_LDAEXH_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=1, Rt=0
    let encoding: u32 = 0x11F00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_ldaexh_a1_a_field_cond_2_poweroftwo_290_21f00290() {
    // Encoding: 0x21F00290
    // Test aarch32_LDAEXH_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, cond=2, Rn=0
    let encoding: u32 = 0x21F00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_ldaexh_a1_a_field_cond_3_poweroftwo_290_31f00290() {
    // Encoding: 0x31F00290
    // Test aarch32_LDAEXH_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=3, Rt=0
    let encoding: u32 = 0x31F00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_ldaexh_a1_a_field_cond_4_poweroftwo_290_41f00290() {
    // Encoding: 0x41F00290
    // Test aarch32_LDAEXH_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, cond=4, Rn=0
    let encoding: u32 = 0x41F00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_ldaexh_a1_a_field_cond_5_poweroftwo_290_51f00290() {
    // Encoding: 0x51F00290
    // Test aarch32_LDAEXH_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=5
    let encoding: u32 = 0x51F00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_ldaexh_a1_a_field_cond_6_poweroftwo_290_61f00290() {
    // Encoding: 0x61F00290
    // Test aarch32_LDAEXH_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=6
    let encoding: u32 = 0x61F00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_ldaexh_a1_a_field_cond_7_poweroftwo_290_71f00290() {
    // Encoding: 0x71F00290
    // Test aarch32_LDAEXH_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=7
    let encoding: u32 = 0x71F00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_ldaexh_a1_a_field_cond_8_poweroftwo_290_81f00290() {
    // Encoding: 0x81F00290
    // Test aarch32_LDAEXH_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, Rn=0, cond=8
    let encoding: u32 = 0x81F00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_ldaexh_a1_a_field_cond_9_poweroftwo_290_91f00290() {
    // Encoding: 0x91F00290
    // Test aarch32_LDAEXH_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=9
    let encoding: u32 = 0x91F00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_ldaexh_a1_a_field_cond_10_poweroftwo_290_a1f00290() {
    // Encoding: 0xA1F00290
    // Test aarch32_LDAEXH_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=10, Rn=0, Rt=0
    let encoding: u32 = 0xA1F00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_ldaexh_a1_a_field_cond_11_poweroftwo_290_b1f00290() {
    // Encoding: 0xB1F00290
    // Test aarch32_LDAEXH_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, cond=11, Rn=0
    let encoding: u32 = 0xB1F00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_ldaexh_a1_a_field_cond_12_poweroftwo_290_c1f00290() {
    // Encoding: 0xC1F00290
    // Test aarch32_LDAEXH_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=12
    let encoding: u32 = 0xC1F00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_ldaexh_a1_a_field_cond_13_poweroftwo_290_d1f00290() {
    // Encoding: 0xD1F00290
    // Test aarch32_LDAEXH_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, Rn=0, cond=13
    let encoding: u32 = 0xD1F00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_ldaexh_a1_a_field_cond_14_poweroftwo_290_e1f00290() {
    // Encoding: 0xE1F00290
    // Test aarch32_LDAEXH_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, Rn=0, cond=14
    let encoding: u32 = 0xE1F00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_ldaexh_a1_a_field_cond_15_max_290_f1f00290() {
    // Encoding: 0xF1F00290
    // Test aarch32_LDAEXH_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: Rt=0, cond=15, Rn=0
    let encoding: u32 = 0xF1F00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXH_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldaexh_a1_a_field_rn_0_min_290_01f00290() {
    // Encoding: 0x01F00290
    // Test aarch32_LDAEXH_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rn=0, Rt=0
    let encoding: u32 = 0x01F00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXH_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldaexh_a1_a_field_rn_1_poweroftwo_290_01f10290() {
    // Encoding: 0x01F10290
    // Test aarch32_LDAEXH_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, cond=0, Rn=1
    let encoding: u32 = 0x01F10290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXH_A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldaexh_a1_a_field_rt_0_min_290_01f00290() {
    // Encoding: 0x01F00290
    // Test aarch32_LDAEXH_A1_A field Rt = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rt=0, Rn=0
    let encoding: u32 = 0x01F00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXH_A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldaexh_a1_a_field_rt_1_poweroftwo_290_01f01290() {
    // Encoding: 0x01F01290
    // Test aarch32_LDAEXH_A1_A field Rt = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=1, cond=0, Rn=0
    let encoding: u32 = 0x01F01290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXH_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_ldaexh_a1_a_combo_0_290_01f00290() {
    // Encoding: 0x01F00290
    // Test aarch32_LDAEXH_A1_A field combination: cond=0, Rn=0, Rt=0
    // ISET: A32
    // Fields: Rt=0, Rn=0, cond=0
    let encoding: u32 = 0x01F00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXH_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_ldaexh_a1_a_special_cond_0_condition_eq_656_01f00290() {
    // Encoding: 0x01F00290
    // Test aarch32_LDAEXH_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: cond=0, Rt=0, Rn=0
    let encoding: u32 = 0x01F00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXH_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_ldaexh_a1_a_special_cond_1_condition_ne_656_11f00290() {
    // Encoding: 0x11F00290
    // Test aarch32_LDAEXH_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: cond=1, Rt=0, Rn=0
    let encoding: u32 = 0x11F00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXH_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_ldaexh_a1_a_special_cond_2_condition_cs_hs_656_21f00290() {
    // Encoding: 0x21F00290
    // Test aarch32_LDAEXH_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: Rn=0, cond=2, Rt=0
    let encoding: u32 = 0x21F00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXH_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_ldaexh_a1_a_special_cond_3_condition_cc_lo_656_31f00290() {
    // Encoding: 0x31F00290
    // Test aarch32_LDAEXH_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: cond=3, Rt=0, Rn=0
    let encoding: u32 = 0x31F00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXH_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_ldaexh_a1_a_special_cond_4_condition_mi_656_41f00290() {
    // Encoding: 0x41F00290
    // Test aarch32_LDAEXH_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: cond=4, Rt=0, Rn=0
    let encoding: u32 = 0x41F00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXH_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_ldaexh_a1_a_special_cond_5_condition_pl_656_51f00290() {
    // Encoding: 0x51F00290
    // Test aarch32_LDAEXH_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: Rt=0, cond=5, Rn=0
    let encoding: u32 = 0x51F00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXH_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_ldaexh_a1_a_special_cond_6_condition_vs_656_61f00290() {
    // Encoding: 0x61F00290
    // Test aarch32_LDAEXH_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: Rt=0, cond=6, Rn=0
    let encoding: u32 = 0x61F00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXH_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_ldaexh_a1_a_special_cond_7_condition_vc_656_71f00290() {
    // Encoding: 0x71F00290
    // Test aarch32_LDAEXH_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: Rt=0, Rn=0, cond=7
    let encoding: u32 = 0x71F00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXH_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_ldaexh_a1_a_special_cond_8_condition_hi_656_81f00290() {
    // Encoding: 0x81F00290
    // Test aarch32_LDAEXH_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: cond=8, Rt=0, Rn=0
    let encoding: u32 = 0x81F00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXH_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_ldaexh_a1_a_special_cond_9_condition_ls_656_91f00290() {
    // Encoding: 0x91F00290
    // Test aarch32_LDAEXH_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=9
    let encoding: u32 = 0x91F00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXH_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_ldaexh_a1_a_special_cond_10_condition_ge_656_a1f00290() {
    // Encoding: 0xA1F00290
    // Test aarch32_LDAEXH_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: Rt=0, Rn=0, cond=10
    let encoding: u32 = 0xA1F00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXH_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_ldaexh_a1_a_special_cond_11_condition_lt_656_b1f00290() {
    // Encoding: 0xB1F00290
    // Test aarch32_LDAEXH_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: Rt=0, cond=11, Rn=0
    let encoding: u32 = 0xB1F00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXH_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_ldaexh_a1_a_special_cond_12_condition_gt_656_c1f00290() {
    // Encoding: 0xC1F00290
    // Test aarch32_LDAEXH_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: Rt=0, cond=12, Rn=0
    let encoding: u32 = 0xC1F00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXH_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_ldaexh_a1_a_special_cond_13_condition_le_656_d1f00290() {
    // Encoding: 0xD1F00290
    // Test aarch32_LDAEXH_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=13
    let encoding: u32 = 0xD1F00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXH_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_ldaexh_a1_a_special_cond_14_condition_al_656_e1f00290() {
    // Encoding: 0xE1F00290
    // Test aarch32_LDAEXH_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: cond=14, Rn=0, Rt=0
    let encoding: u32 = 0xE1F00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXH_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_ldaexh_a1_a_special_cond_15_condition_nv_656_f1f00290() {
    // Encoding: 0xF1F00290
    // Test aarch32_LDAEXH_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: Rt=0, cond=15, Rn=0
    let encoding: u32 = 0xF1F00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXH_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldaexh_a1_a_invalid_0_290_01f00290() {
    // Encoding: 0x01F00290
    // Test aarch32_LDAEXH_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }
    // ISET: A32
    // Fields: Rt=0, cond=0, Rn=0
    let encoding: u32 = 0x01F00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDAEXH_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldaexh_a1_a_invalid_1_290_01f00290() {
    // Encoding: 0x01F00290
    // Test aarch32_LDAEXH_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Rt=0, cond=0, Rn=0
    let encoding: u32 = 0x01F00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDAEXH_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldaexh_t1_a_field_rn_0_min_d0_e8d000d0() {
    // Thumb encoding (32): 0xE8D000D0
    // Test aarch32_LDAEXH_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8D000D0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDAEXH_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldaexh_t1_a_field_rn_1_poweroftwo_d0_e8d100d0() {
    // Thumb encoding (32): 0xE8D100D0
    // Test aarch32_LDAEXH_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=1, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8D100D0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDAEXH_T1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldaexh_t1_a_field_rt_0_min_d0_e8d000d0() {
    // Thumb encoding (32): 0xE8D000D0
    // Test aarch32_LDAEXH_T1_A field Rt = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8D000D0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDAEXH_T1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldaexh_t1_a_field_rt_1_poweroftwo_d0_e8d010d0() {
    // Thumb encoding (32): 0xE8D010D0
    // Test aarch32_LDAEXH_T1_A field Rt = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=1, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8D010D0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDAEXH_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_ldaexh_t1_a_combo_0_d0_e8d000d0() {
    // Thumb encoding (32): 0xE8D000D0
    // Test aarch32_LDAEXH_T1_A field combination: Rn=0, Rt=0
    // ISET: T32
    // Fields: Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8D000D0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDAEXH_T1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldaexh_t1_a_invalid_0_d0_e8d000d0() {
    // Thumb encoding (32): 0xE8D000D0
    // Test aarch32_LDAEXH_T1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }
    // ISET: T32
    // Fields: Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8D000D0;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_LDAEXH_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldaexh_t1_a_invalid_1_d0_e8d000d0() {
    // Thumb encoding (32): 0xE8D000D0
    // Test aarch32_LDAEXH_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8D000D0;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_LDAEXH_A1_A
/// ASL: `SMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple multiply
#[test]
fn test_aarch32_ldaexh_a1_a_smull_oracle_0_9b227c20() {
    // Test SMULL: simple multiply (oracle)
    // Encoding: 0x9B227C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x2);
    set_w(&mut cpu, 2, 0x3);
    let encoding: u32 = 0x9B227C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6, "X0 should be 0x0000000000000006");
}

/// Provenance: aarch32_LDAEXH_A1_A
/// ASL: `SMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max 32-bit * 2
#[test]
fn test_aarch32_ldaexh_a1_a_smull_oracle_1_9b227c20() {
    // Test SMULL: max 32-bit * 2 (oracle)
    // Encoding: 0x9B227C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x9B227C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0xFFFFFFFFFFFFFFFE"
    );
}

/// Provenance: aarch32_LDAEXH_A1_A
/// ASL: `SMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// large positive * large positive
#[test]
fn test_aarch32_ldaexh_a1_a_smull_oracle_2_9b227c20() {
    // Test SMULL: large positive * large positive (oracle)
    // Encoding: 0x9B227C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    set_w(&mut cpu, 2, 0x7FFFFFFF);
    let encoding: u32 = 0x9B227C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x3FFFFFFF00000001");
}

/// Provenance: aarch32_LDAEXH_A1_A
/// ASL: `SMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max unsigned * max unsigned
#[test]
fn test_aarch32_ldaexh_a1_a_smull_oracle_3_9b227c20() {
    // Test SMULL: max unsigned * max unsigned (oracle)
    // Encoding: 0x9B227C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x9B227C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x0000000000000001");
}

/// Provenance: aarch32_LDAEXH_A1_A
/// ASL: `SMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// medium values
#[test]
fn test_aarch32_ldaexh_a1_a_smull_oracle_4_9b227c20() {
    // Test SMULL: medium values (oracle)
    // Encoding: 0x9B227C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0xC8);
    let encoding: u32 = 0x9B227C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4E20, "X0 should be 0x0000000000004E20");
}

/// Provenance: aarch32_LDAEXH_A1_A
/// ASL: `SMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// 16-bit values
#[test]
fn test_aarch32_ldaexh_a1_a_smull_oracle_5_9b227c20() {
    // Test SMULL: 16-bit values (oracle)
    // Encoding: 0x9B227C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x5678);
    set_w(&mut cpu, 1, 0x1234);
    let encoding: u32 = 0x9B227C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6260060, "X0 should be 0x0000000006260060");
}

// ============================================================================
// aarch32_LDREXD_A Tests
// ============================================================================

/// Provenance: aarch32_LDREXD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_ldrexd_a1_a_field_cond_0_min_390_01b00390() {
    // Encoding: 0x01B00390
    // Test aarch32_LDREXD_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=0
    let encoding: u32 = 0x01B00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_ldrexd_a1_a_field_cond_1_poweroftwo_390_11b00390() {
    // Encoding: 0x11B00390
    // Test aarch32_LDREXD_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, Rn=0, cond=1
    let encoding: u32 = 0x11B00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_ldrexd_a1_a_field_cond_2_poweroftwo_390_21b00390() {
    // Encoding: 0x21B00390
    // Test aarch32_LDREXD_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, Rn=0, cond=2
    let encoding: u32 = 0x21B00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_ldrexd_a1_a_field_cond_3_poweroftwo_390_31b00390() {
    // Encoding: 0x31B00390
    // Test aarch32_LDREXD_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=3
    let encoding: u32 = 0x31B00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_ldrexd_a1_a_field_cond_4_poweroftwo_390_41b00390() {
    // Encoding: 0x41B00390
    // Test aarch32_LDREXD_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=4
    let encoding: u32 = 0x41B00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_ldrexd_a1_a_field_cond_5_poweroftwo_390_51b00390() {
    // Encoding: 0x51B00390
    // Test aarch32_LDREXD_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, Rn=0, cond=5
    let encoding: u32 = 0x51B00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_ldrexd_a1_a_field_cond_6_poweroftwo_390_61b00390() {
    // Encoding: 0x61B00390
    // Test aarch32_LDREXD_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=6, Rn=0, Rt=0
    let encoding: u32 = 0x61B00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_ldrexd_a1_a_field_cond_7_poweroftwo_390_71b00390() {
    // Encoding: 0x71B00390
    // Test aarch32_LDREXD_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=7
    let encoding: u32 = 0x71B00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_ldrexd_a1_a_field_cond_8_poweroftwo_390_81b00390() {
    // Encoding: 0x81B00390
    // Test aarch32_LDREXD_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=8, Rt=0
    let encoding: u32 = 0x81B00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_ldrexd_a1_a_field_cond_9_poweroftwo_390_91b00390() {
    // Encoding: 0x91B00390
    // Test aarch32_LDREXD_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=9
    let encoding: u32 = 0x91B00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_ldrexd_a1_a_field_cond_10_poweroftwo_390_a1b00390() {
    // Encoding: 0xA1B00390
    // Test aarch32_LDREXD_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=10, Rn=0, Rt=0
    let encoding: u32 = 0xA1B00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_ldrexd_a1_a_field_cond_11_poweroftwo_390_b1b00390() {
    // Encoding: 0xB1B00390
    // Test aarch32_LDREXD_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, Rn=0, cond=11
    let encoding: u32 = 0xB1B00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_ldrexd_a1_a_field_cond_12_poweroftwo_390_c1b00390() {
    // Encoding: 0xC1B00390
    // Test aarch32_LDREXD_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, cond=12, Rn=0
    let encoding: u32 = 0xC1B00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_ldrexd_a1_a_field_cond_13_poweroftwo_390_d1b00390() {
    // Encoding: 0xD1B00390
    // Test aarch32_LDREXD_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, cond=13, Rn=0
    let encoding: u32 = 0xD1B00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_ldrexd_a1_a_field_cond_14_poweroftwo_390_e1b00390() {
    // Encoding: 0xE1B00390
    // Test aarch32_LDREXD_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=14, Rn=0, Rt=0
    let encoding: u32 = 0xE1B00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_ldrexd_a1_a_field_cond_15_max_390_f1b00390() {
    // Encoding: 0xF1B00390
    // Test aarch32_LDREXD_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: Rn=0, cond=15, Rt=0
    let encoding: u32 = 0xF1B00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXD_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrexd_a1_a_field_rn_0_min_390_01b00390() {
    // Encoding: 0x01B00390
    // Test aarch32_LDREXD_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, cond=0, Rt=0
    let encoding: u32 = 0x01B00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXD_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrexd_a1_a_field_rn_1_poweroftwo_390_01b10390() {
    // Encoding: 0x01B10390
    // Test aarch32_LDREXD_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Rt=0, Rn=1
    let encoding: u32 = 0x01B10390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXD_A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrexd_a1_a_field_rt_0_min_390_01b00390() {
    // Encoding: 0x01B00390
    // Test aarch32_LDREXD_A1_A field Rt = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, cond=0, Rt=0
    let encoding: u32 = 0x01B00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXD_A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrexd_a1_a_field_rt_1_poweroftwo_390_01b01390() {
    // Encoding: 0x01B01390
    // Test aarch32_LDREXD_A1_A field Rt = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rt=1, cond=0
    let encoding: u32 = 0x01B01390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXD_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_ldrexd_a1_a_combo_0_390_01b00390() {
    // Encoding: 0x01B00390
    // Test aarch32_LDREXD_A1_A field combination: cond=0, Rn=0, Rt=0
    // ISET: A32
    // Fields: cond=0, Rt=0, Rn=0
    let encoding: u32 = 0x01B00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXD_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_ldrexd_a1_a_special_cond_0_condition_eq_912_01b00390() {
    // Encoding: 0x01B00390
    // Test aarch32_LDREXD_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: cond=0, Rn=0, Rt=0
    let encoding: u32 = 0x01B00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXD_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_ldrexd_a1_a_special_cond_1_condition_ne_912_11b00390() {
    // Encoding: 0x11B00390
    // Test aarch32_LDREXD_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=1
    let encoding: u32 = 0x11B00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXD_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_ldrexd_a1_a_special_cond_2_condition_cs_hs_912_21b00390() {
    // Encoding: 0x21B00390
    // Test aarch32_LDREXD_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: Rt=0, cond=2, Rn=0
    let encoding: u32 = 0x21B00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXD_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_ldrexd_a1_a_special_cond_3_condition_cc_lo_912_31b00390() {
    // Encoding: 0x31B00390
    // Test aarch32_LDREXD_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=3
    let encoding: u32 = 0x31B00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXD_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_ldrexd_a1_a_special_cond_4_condition_mi_912_41b00390() {
    // Encoding: 0x41B00390
    // Test aarch32_LDREXD_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=4
    let encoding: u32 = 0x41B00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXD_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_ldrexd_a1_a_special_cond_5_condition_pl_912_51b00390() {
    // Encoding: 0x51B00390
    // Test aarch32_LDREXD_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: cond=5, Rn=0, Rt=0
    let encoding: u32 = 0x51B00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXD_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_ldrexd_a1_a_special_cond_6_condition_vs_912_61b00390() {
    // Encoding: 0x61B00390
    // Test aarch32_LDREXD_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: Rt=0, Rn=0, cond=6
    let encoding: u32 = 0x61B00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXD_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_ldrexd_a1_a_special_cond_7_condition_vc_912_71b00390() {
    // Encoding: 0x71B00390
    // Test aarch32_LDREXD_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=7
    let encoding: u32 = 0x71B00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXD_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_ldrexd_a1_a_special_cond_8_condition_hi_912_81b00390() {
    // Encoding: 0x81B00390
    // Test aarch32_LDREXD_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: cond=8, Rn=0, Rt=0
    let encoding: u32 = 0x81B00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXD_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_ldrexd_a1_a_special_cond_9_condition_ls_912_91b00390() {
    // Encoding: 0x91B00390
    // Test aarch32_LDREXD_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: Rt=0, cond=9, Rn=0
    let encoding: u32 = 0x91B00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXD_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_ldrexd_a1_a_special_cond_10_condition_ge_912_a1b00390() {
    // Encoding: 0xA1B00390
    // Test aarch32_LDREXD_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: cond=10, Rn=0, Rt=0
    let encoding: u32 = 0xA1B00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXD_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_ldrexd_a1_a_special_cond_11_condition_lt_912_b1b00390() {
    // Encoding: 0xB1B00390
    // Test aarch32_LDREXD_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=11
    let encoding: u32 = 0xB1B00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXD_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_ldrexd_a1_a_special_cond_12_condition_gt_912_c1b00390() {
    // Encoding: 0xC1B00390
    // Test aarch32_LDREXD_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=12
    let encoding: u32 = 0xC1B00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXD_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_ldrexd_a1_a_special_cond_13_condition_le_912_d1b00390() {
    // Encoding: 0xD1B00390
    // Test aarch32_LDREXD_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: Rt=0, cond=13, Rn=0
    let encoding: u32 = 0xD1B00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXD_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_ldrexd_a1_a_special_cond_14_condition_al_912_e1b00390() {
    // Encoding: 0xE1B00390
    // Test aarch32_LDREXD_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: Rt=0, Rn=0, cond=14
    let encoding: u32 = 0xE1B00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXD_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_ldrexd_a1_a_special_cond_15_condition_nv_912_f1b00390() {
    // Encoding: 0xF1B00390
    // Test aarch32_LDREXD_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: Rt=0, cond=15, Rn=0
    let encoding: u32 = 0xF1B00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXD_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Rt" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t2" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Rt\" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t2\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrexd_a1_a_invalid_0_390_01b00390() {
    // Encoding: 0x01B00390
    // Test aarch32_LDREXD_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Rt" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t2" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }
    // ISET: A32
    // Fields: cond=0, Rn=0, Rt=0
    let encoding: u32 = 0x01B00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDREXD_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrexd_a1_a_invalid_1_390_01b00390() {
    // Encoding: 0x01B00390
    // Test aarch32_LDREXD_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: cond=0, Rt=0, Rn=0
    let encoding: u32 = 0x01B00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDREXD_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrexd_t1_a_field_rn_0_min_70_e8d00070() {
    // Thumb encoding (32): 0xE8D00070
    // Test aarch32_LDREXD_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rt2=0, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8D00070;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDREXD_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrexd_t1_a_field_rn_1_poweroftwo_70_e8d10070() {
    // Thumb encoding (32): 0xE8D10070
    // Test aarch32_LDREXD_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=1, Rt=0, Rt2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8D10070;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDREXD_T1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrexd_t1_a_field_rt_0_min_70_e8d00070() {
    // Thumb encoding (32): 0xE8D00070
    // Test aarch32_LDREXD_T1_A field Rt = 0 (Min)
    // ISET: T32
    // Fields: Rt2=0, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8D00070;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDREXD_T1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrexd_t1_a_field_rt_1_poweroftwo_70_e8d01070() {
    // Thumb encoding (32): 0xE8D01070
    // Test aarch32_LDREXD_T1_A field Rt = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Rt=1, Rt2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8D01070;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDREXD_T1_A
/// ASL: `field Rt2 8 +: 4`
/// Requirement: FieldBoundary { field: "Rt2", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrexd_t1_a_field_rt2_0_min_70_e8d00070() {
    // Thumb encoding (32): 0xE8D00070
    // Test aarch32_LDREXD_T1_A field Rt2 = 0 (Min)
    // ISET: T32
    // Fields: Rt=0, Rn=0, Rt2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8D00070;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDREXD_T1_A
/// ASL: `field Rt2 8 +: 4`
/// Requirement: FieldBoundary { field: "Rt2", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrexd_t1_a_field_rt2_1_poweroftwo_70_e8d00170() {
    // Thumb encoding (32): 0xE8D00170
    // Test aarch32_LDREXD_T1_A field Rt2 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, Rt2=1, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8D00170;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDREXD_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_ldrexd_t1_a_combo_0_70_e8d00070() {
    // Thumb encoding (32): 0xE8D00070
    // Test aarch32_LDREXD_T1_A field combination: Rn=0, Rt=0, Rt2=0
    // ISET: T32
    // Fields: Rn=0, Rt=0, Rt2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8D00070;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDREXD_T1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t2" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) } }, rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t2" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t2\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }) } }, rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t2\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrexd_t1_a_invalid_0_70_e8d00070() {
    // Thumb encoding (32): 0xE8D00070
    // Test aarch32_LDREXD_T1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t2" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) } }, rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t2" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }
    // ISET: T32
    // Fields: Rt2=0, Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8D00070;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_LDREXD_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrexd_t1_a_invalid_1_70_e8d00070() {
    // Thumb encoding (32): 0xE8D00070
    // Test aarch32_LDREXD_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rt2=0, Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8D00070;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

// ============================================================================
// aarch32_LDRB_i_A Tests
// ============================================================================

/// Provenance: aarch32_LDRB_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_ldrb_i_a1_a_field_cond_0_min_0_04500000() {
    // Encoding: 0x04500000
    // Test aarch32_LDRB_i_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: U=0, W=0, Rn=0, cond=0, imm12=0, P=0, Rt=0
    let encoding: u32 = 0x04500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_ldrb_i_a1_a_field_cond_1_poweroftwo_0_14500000() {
    // Encoding: 0x14500000
    // Test aarch32_LDRB_i_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, imm12=0, P=0, U=0, cond=1, Rn=0, Rt=0
    let encoding: u32 = 0x14500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_ldrb_i_a1_a_field_cond_2_poweroftwo_0_24500000() {
    // Encoding: 0x24500000
    // Test aarch32_LDRB_i_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, imm12=0, cond=2, W=0, Rt=0, U=0, Rn=0
    let encoding: u32 = 0x24500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_ldrb_i_a1_a_field_cond_3_poweroftwo_0_34500000() {
    // Encoding: 0x34500000
    // Test aarch32_LDRB_i_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=3, imm12=0, W=0, P=0, U=0, Rt=0
    let encoding: u32 = 0x34500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_ldrb_i_a1_a_field_cond_4_poweroftwo_0_44500000() {
    // Encoding: 0x44500000
    // Test aarch32_LDRB_i_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, Rn=0, cond=4, P=0, W=0, Rt=0, imm12=0
    let encoding: u32 = 0x44500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_ldrb_i_a1_a_field_cond_5_poweroftwo_0_54500000() {
    // Encoding: 0x54500000
    // Test aarch32_LDRB_i_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=5, U=0, imm12=0, P=0, W=0
    let encoding: u32 = 0x54500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_ldrb_i_a1_a_field_cond_6_poweroftwo_0_64500000() {
    // Encoding: 0x64500000
    // Test aarch32_LDRB_i_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, P=0, U=0, Rt=0, imm12=0, Rn=0, cond=6
    let encoding: u32 = 0x64500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_ldrb_i_a1_a_field_cond_7_poweroftwo_0_74500000() {
    // Encoding: 0x74500000
    // Test aarch32_LDRB_i_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, U=0, cond=7, Rn=0, imm12=0, P=0, W=0
    let encoding: u32 = 0x74500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_ldrb_i_a1_a_field_cond_8_poweroftwo_0_84500000() {
    // Encoding: 0x84500000
    // Test aarch32_LDRB_i_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, P=0, Rt=0, W=0, cond=8, Rn=0, imm12=0
    let encoding: u32 = 0x84500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_ldrb_i_a1_a_field_cond_9_poweroftwo_0_94500000() {
    // Encoding: 0x94500000
    // Test aarch32_LDRB_i_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=0, W=0, U=0, cond=9, P=0, Rt=0, Rn=0
    let encoding: u32 = 0x94500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_ldrb_i_a1_a_field_cond_10_poweroftwo_0_a4500000() {
    // Encoding: 0xA4500000
    // Test aarch32_LDRB_i_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=0, U=0, cond=10, W=0, Rt=0, P=0, Rn=0
    let encoding: u32 = 0xA4500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_ldrb_i_a1_a_field_cond_11_poweroftwo_0_b4500000() {
    // Encoding: 0xB4500000
    // Test aarch32_LDRB_i_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=11, W=0, P=0, Rn=0, Rt=0, U=0, imm12=0
    let encoding: u32 = 0xB4500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_ldrb_i_a1_a_field_cond_12_poweroftwo_0_c4500000() {
    // Encoding: 0xC4500000
    // Test aarch32_LDRB_i_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, Rn=0, cond=12, W=0, Rt=0, U=0, imm12=0
    let encoding: u32 = 0xC4500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_ldrb_i_a1_a_field_cond_13_poweroftwo_0_d4500000() {
    // Encoding: 0xD4500000
    // Test aarch32_LDRB_i_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, cond=13, Rn=0, Rt=0, U=0, imm12=0, W=0
    let encoding: u32 = 0xD4500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_ldrb_i_a1_a_field_cond_14_poweroftwo_0_e4500000() {
    // Encoding: 0xE4500000
    // Test aarch32_LDRB_i_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, Rn=0, cond=14, U=0, Rt=0, imm12=0, P=0
    let encoding: u32 = 0xE4500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_ldrb_i_a1_a_field_cond_15_max_0_f4500000() {
    // Encoding: 0xF4500000
    // Test aarch32_LDRB_i_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: cond=15, U=0, Rn=0, P=0, imm12=0, W=0, Rt=0
    let encoding: u32 = 0xF4500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_i_A1_A
/// ASL: `field P 24 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldrb_i_a1_a_field_p_0_min_0_04500000() {
    // Encoding: 0x04500000
    // Test aarch32_LDRB_i_A1_A field P = 0 (Min)
    // ISET: A32
    // Fields: U=0, cond=0, W=0, Rn=0, P=0, Rt=0, imm12=0
    let encoding: u32 = 0x04500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_i_A1_A
/// ASL: `field P 24 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldrb_i_a1_a_field_p_1_max_0_05500000() {
    // Encoding: 0x05500000
    // Test aarch32_LDRB_i_A1_A field P = 1 (Max)
    // ISET: A32
    // Fields: P=1, U=0, W=0, Rn=0, imm12=0, Rt=0, cond=0
    let encoding: u32 = 0x05500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_i_A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldrb_i_a1_a_field_u_0_min_0_04500000() {
    // Encoding: 0x04500000
    // Test aarch32_LDRB_i_A1_A field U = 0 (Min)
    // ISET: A32
    // Fields: Rt=0, imm12=0, P=0, W=0, cond=0, U=0, Rn=0
    let encoding: u32 = 0x04500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_i_A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldrb_i_a1_a_field_u_1_max_0_04d00000() {
    // Encoding: 0x04D00000
    // Test aarch32_LDRB_i_A1_A field U = 1 (Max)
    // ISET: A32
    // Fields: cond=0, U=1, Rn=0, Rt=0, imm12=0, P=0, W=0
    let encoding: u32 = 0x04D00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_i_A1_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldrb_i_a1_a_field_w_0_min_0_04500000() {
    // Encoding: 0x04500000
    // Test aarch32_LDRB_i_A1_A field W = 0 (Min)
    // ISET: A32
    // Fields: cond=0, U=0, imm12=0, P=0, Rn=0, Rt=0, W=0
    let encoding: u32 = 0x04500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_i_A1_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldrb_i_a1_a_field_w_1_max_0_04700000() {
    // Encoding: 0x04700000
    // Test aarch32_LDRB_i_A1_A field W = 1 (Max)
    // ISET: A32
    // Fields: U=0, Rn=0, Rt=0, imm12=0, W=1, cond=0, P=0
    let encoding: u32 = 0x04700000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_i_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrb_i_a1_a_field_rn_0_min_0_04500000() {
    // Encoding: 0x04500000
    // Test aarch32_LDRB_i_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, cond=0, Rt=0, W=0, imm12=0, P=0, U=0
    let encoding: u32 = 0x04500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_i_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrb_i_a1_a_field_rn_1_poweroftwo_0_04510000() {
    // Encoding: 0x04510000
    // Test aarch32_LDRB_i_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, Rn=1, W=0, Rt=0, imm12=0, P=0, cond=0
    let encoding: u32 = 0x04510000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_i_A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrb_i_a1_a_field_rt_0_min_0_04500000() {
    // Encoding: 0x04500000
    // Test aarch32_LDRB_i_A1_A field Rt = 0 (Min)
    // ISET: A32
    // Fields: W=0, Rn=0, cond=0, Rt=0, P=0, imm12=0, U=0
    let encoding: u32 = 0x04500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_i_A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrb_i_a1_a_field_rt_1_poweroftwo_0_04501000() {
    // Encoding: 0x04501000
    // Test aarch32_LDRB_i_A1_A field Rt = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=0, U=0, cond=0, W=0, Rt=1, P=0, Rn=0
    let encoding: u32 = 0x04501000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_ldrb_i_a1_a_field_imm12_0_zero_0_04500000() {
    // Encoding: 0x04500000
    // Test aarch32_LDRB_i_A1_A field imm12 = 0 (Zero)
    // ISET: A32
    // Fields: Rt=0, cond=0, imm12=0, U=0, W=0, P=0, Rn=0
    let encoding: u32 = 0x04500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_ldrb_i_a1_a_field_imm12_1_poweroftwo_0_04500001() {
    // Encoding: 0x04500001
    // Test aarch32_LDRB_i_A1_A field imm12 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, P=0, imm12=1, U=0, Rn=0, W=0, cond=0
    let encoding: u32 = 0x04500001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_ldrb_i_a1_a_field_imm12_3_poweroftwominusone_0_04500003() {
    // Encoding: 0x04500003
    // Test aarch32_LDRB_i_A1_A field imm12 = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: P=0, W=0, imm12=3, Rn=0, Rt=0, cond=0, U=0
    let encoding: u32 = 0x04500003;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_ldrb_i_a1_a_field_imm12_4_poweroftwo_0_04500004() {
    // Encoding: 0x04500004
    // Test aarch32_LDRB_i_A1_A field imm12 = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, Rn=0, Rt=0, P=0, U=0, imm12=4, cond=0
    let encoding: u32 = 0x04500004;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_ldrb_i_a1_a_field_imm12_7_poweroftwominusone_0_04500007() {
    // Encoding: 0x04500007
    // Test aarch32_LDRB_i_A1_A field imm12 = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: P=0, imm12=7, Rn=0, cond=0, U=0, Rt=0, W=0
    let encoding: u32 = 0x04500007;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_ldrb_i_a1_a_field_imm12_8_poweroftwo_0_04500008() {
    // Encoding: 0x04500008
    // Test aarch32_LDRB_i_A1_A field imm12 = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, P=0, Rn=0, W=0, imm12=8, cond=0, Rt=0
    let encoding: u32 = 0x04500008;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_ldrb_i_a1_a_field_imm12_15_poweroftwominusone_0_0450000f() {
    // Encoding: 0x0450000F
    // Test aarch32_LDRB_i_A1_A field imm12 = 15 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, P=0, U=0, W=0, Rn=0, imm12=15, Rt=0
    let encoding: u32 = 0x0450000F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_ldrb_i_a1_a_field_imm12_16_poweroftwo_0_04500010() {
    // Encoding: 0x04500010
    // Test aarch32_LDRB_i_A1_A field imm12 = 16 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, U=0, Rt=0, W=0, P=0, imm12=16, Rn=0
    let encoding: u32 = 0x04500010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_ldrb_i_a1_a_field_imm12_31_poweroftwominusone_0_0450001f() {
    // Encoding: 0x0450001F
    // Test aarch32_LDRB_i_A1_A field imm12 = 31 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rt=0, cond=0, U=0, W=0, Rn=0, imm12=31, P=0
    let encoding: u32 = 0x0450001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_ldrb_i_a1_a_field_imm12_32_poweroftwo_0_04500020() {
    // Encoding: 0x04500020
    // Test aarch32_LDRB_i_A1_A field imm12 = 32 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, P=0, U=0, Rn=0, W=0, Rt=0, imm12=32
    let encoding: u32 = 0x04500020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_ldrb_i_a1_a_field_imm12_63_poweroftwominusone_0_0450003f() {
    // Encoding: 0x0450003F
    // Test aarch32_LDRB_i_A1_A field imm12 = 63 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: P=0, cond=0, Rt=0, imm12=63, Rn=0, U=0, W=0
    let encoding: u32 = 0x0450003F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_ldrb_i_a1_a_field_imm12_64_poweroftwo_0_04500040() {
    // Encoding: 0x04500040
    // Test aarch32_LDRB_i_A1_A field imm12 = 64 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, P=0, W=0, cond=0, U=0, Rt=0, imm12=64
    let encoding: u32 = 0x04500040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 127, boundary: PowerOfTwoMinusOne }
/// 2^7 - 1 = 127
#[test]
fn test_aarch32_ldrb_i_a1_a_field_imm12_127_poweroftwominusone_0_0450007f() {
    // Encoding: 0x0450007F
    // Test aarch32_LDRB_i_A1_A field imm12 = 127 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, Rn=0, P=0, Rt=0, imm12=127, U=0, W=0
    let encoding: u32 = 0x0450007F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_ldrb_i_a1_a_field_imm12_128_poweroftwo_0_04500080() {
    // Encoding: 0x04500080
    // Test aarch32_LDRB_i_A1_A field imm12 = 128 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, Rn=0, Rt=0, imm12=128, U=0, cond=0, P=0
    let encoding: u32 = 0x04500080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 255, boundary: PowerOfTwoMinusOne }
/// 2^8 - 1 = 255
#[test]
fn test_aarch32_ldrb_i_a1_a_field_imm12_255_poweroftwominusone_0_045000ff() {
    // Encoding: 0x045000FF
    // Test aarch32_LDRB_i_A1_A field imm12 = 255 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, imm12=255, Rt=0, W=0, U=0, P=0, Rn=0
    let encoding: u32 = 0x045000FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 256, boundary: PowerOfTwo }
/// power of 2 (2^8 = 256)
#[test]
fn test_aarch32_ldrb_i_a1_a_field_imm12_256_poweroftwo_0_04500100() {
    // Encoding: 0x04500100
    // Test aarch32_LDRB_i_A1_A field imm12 = 256 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, cond=0, imm12=256, P=0, Rn=0, W=0, U=0
    let encoding: u32 = 0x04500100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 511, boundary: PowerOfTwoMinusOne }
/// 2^9 - 1 = 511
#[test]
fn test_aarch32_ldrb_i_a1_a_field_imm12_511_poweroftwominusone_0_045001ff() {
    // Encoding: 0x045001FF
    // Test aarch32_LDRB_i_A1_A field imm12 = 511 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: P=0, cond=0, Rt=0, U=0, W=0, Rn=0, imm12=511
    let encoding: u32 = 0x045001FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 512, boundary: PowerOfTwo }
/// power of 2 (2^9 = 512)
#[test]
fn test_aarch32_ldrb_i_a1_a_field_imm12_512_poweroftwo_0_04500200() {
    // Encoding: 0x04500200
    // Test aarch32_LDRB_i_A1_A field imm12 = 512 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, imm12=512, U=0, P=0, Rn=0, Rt=0, cond=0
    let encoding: u32 = 0x04500200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1023, boundary: PowerOfTwoMinusOne }
/// 2^10 - 1 = 1023
#[test]
fn test_aarch32_ldrb_i_a1_a_field_imm12_1023_poweroftwominusone_0_045003ff() {
    // Encoding: 0x045003FF
    // Test aarch32_LDRB_i_A1_A field imm12 = 1023 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: P=0, cond=0, Rt=0, imm12=1023, U=0, W=0, Rn=0
    let encoding: u32 = 0x045003FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1024, boundary: PowerOfTwo }
/// power of 2 (2^10 = 1024)
#[test]
fn test_aarch32_ldrb_i_a1_a_field_imm12_1024_poweroftwo_0_04500400() {
    // Encoding: 0x04500400
    // Test aarch32_LDRB_i_A1_A field imm12 = 1024 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, W=0, Rt=0, cond=0, imm12=1024, U=0, Rn=0
    let encoding: u32 = 0x04500400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2047, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (2047)
#[test]
fn test_aarch32_ldrb_i_a1_a_field_imm12_2047_poweroftwominusone_0_045007ff() {
    // Encoding: 0x045007FF
    // Test aarch32_LDRB_i_A1_A field imm12 = 2047 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: U=0, W=0, cond=0, imm12=2047, P=0, Rn=0, Rt=0
    let encoding: u32 = 0x045007FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2048, boundary: PowerOfTwo }
/// power of 2 (2^11 = 2048)
#[test]
fn test_aarch32_ldrb_i_a1_a_field_imm12_2048_poweroftwo_0_04500800() {
    // Encoding: 0x04500800
    // Test aarch32_LDRB_i_A1_A field imm12 = 2048 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=0, U=0, P=0, W=0, Rt=0, imm12=2048
    let encoding: u32 = 0x04500800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4095, boundary: Max }
/// maximum immediate (4095)
#[test]
fn test_aarch32_ldrb_i_a1_a_field_imm12_4095_max_0_04500fff() {
    // Encoding: 0x04500FFF
    // Test aarch32_LDRB_i_A1_A field imm12 = 4095 (Max)
    // ISET: A32
    // Fields: cond=0, U=0, W=0, Rn=0, Rt=0, P=0, imm12=4095
    let encoding: u32 = 0x04500FFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_i_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_ldrb_i_a1_a_combo_0_0_04500000() {
    // Encoding: 0x04500000
    // Test aarch32_LDRB_i_A1_A field combination: cond=0, P=0, U=0, W=0, Rn=0, Rt=0, imm12=0
    // ISET: A32
    // Fields: cond=0, Rt=0, P=0, imm12=0, Rn=0, U=0, W=0
    let encoding: u32 = 0x04500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_i_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_ldrb_i_a1_a_special_cond_0_condition_eq_0_04500000() {
    // Encoding: 0x04500000
    // Test aarch32_LDRB_i_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: cond=0, P=0, U=0, Rn=0, W=0, imm12=0, Rt=0
    let encoding: u32 = 0x04500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_i_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_ldrb_i_a1_a_special_cond_1_condition_ne_0_14500000() {
    // Encoding: 0x14500000
    // Test aarch32_LDRB_i_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: Rn=0, Rt=0, imm12=0, W=0, U=0, cond=1, P=0
    let encoding: u32 = 0x14500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_i_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_ldrb_i_a1_a_special_cond_2_condition_cs_hs_0_24500000() {
    // Encoding: 0x24500000
    // Test aarch32_LDRB_i_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: W=0, imm12=0, cond=2, U=0, P=0, Rn=0, Rt=0
    let encoding: u32 = 0x24500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_i_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_ldrb_i_a1_a_special_cond_3_condition_cc_lo_0_34500000() {
    // Encoding: 0x34500000
    // Test aarch32_LDRB_i_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: W=0, imm12=0, cond=3, Rn=0, Rt=0, P=0, U=0
    let encoding: u32 = 0x34500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_i_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_ldrb_i_a1_a_special_cond_4_condition_mi_0_44500000() {
    // Encoding: 0x44500000
    // Test aarch32_LDRB_i_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: U=0, W=0, Rn=0, P=0, imm12=0, Rt=0, cond=4
    let encoding: u32 = 0x44500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_i_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_ldrb_i_a1_a_special_cond_5_condition_pl_0_54500000() {
    // Encoding: 0x54500000
    // Test aarch32_LDRB_i_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: Rn=0, W=0, cond=5, P=0, Rt=0, imm12=0, U=0
    let encoding: u32 = 0x54500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_i_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_ldrb_i_a1_a_special_cond_6_condition_vs_0_64500000() {
    // Encoding: 0x64500000
    // Test aarch32_LDRB_i_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: imm12=0, cond=6, P=0, W=0, U=0, Rn=0, Rt=0
    let encoding: u32 = 0x64500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_i_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_ldrb_i_a1_a_special_cond_7_condition_vc_0_74500000() {
    // Encoding: 0x74500000
    // Test aarch32_LDRB_i_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: W=0, P=0, Rt=0, cond=7, Rn=0, imm12=0, U=0
    let encoding: u32 = 0x74500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_i_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_ldrb_i_a1_a_special_cond_8_condition_hi_0_84500000() {
    // Encoding: 0x84500000
    // Test aarch32_LDRB_i_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: Rt=0, P=0, U=0, cond=8, Rn=0, imm12=0, W=0
    let encoding: u32 = 0x84500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_i_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_ldrb_i_a1_a_special_cond_9_condition_ls_0_94500000() {
    // Encoding: 0x94500000
    // Test aarch32_LDRB_i_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: W=0, P=0, U=0, Rn=0, Rt=0, cond=9, imm12=0
    let encoding: u32 = 0x94500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_i_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_ldrb_i_a1_a_special_cond_10_condition_ge_0_a4500000() {
    // Encoding: 0xA4500000
    // Test aarch32_LDRB_i_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: P=0, U=0, W=0, Rn=0, cond=10, Rt=0, imm12=0
    let encoding: u32 = 0xA4500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_i_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_ldrb_i_a1_a_special_cond_11_condition_lt_0_b4500000() {
    // Encoding: 0xB4500000
    // Test aarch32_LDRB_i_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: cond=11, P=0, Rt=0, W=0, imm12=0, Rn=0, U=0
    let encoding: u32 = 0xB4500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_i_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_ldrb_i_a1_a_special_cond_12_condition_gt_0_c4500000() {
    // Encoding: 0xC4500000
    // Test aarch32_LDRB_i_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: Rn=0, cond=12, P=0, Rt=0, imm12=0, W=0, U=0
    let encoding: u32 = 0xC4500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_i_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_ldrb_i_a1_a_special_cond_13_condition_le_0_d4500000() {
    // Encoding: 0xD4500000
    // Test aarch32_LDRB_i_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: imm12=0, cond=13, Rn=0, U=0, P=0, W=0, Rt=0
    let encoding: u32 = 0xD4500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_i_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_ldrb_i_a1_a_special_cond_14_condition_al_0_e4500000() {
    // Encoding: 0xE4500000
    // Test aarch32_LDRB_i_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: U=0, cond=14, Rn=0, Rt=0, W=0, P=0, imm12=0
    let encoding: u32 = 0xE4500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_i_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_ldrb_i_a1_a_special_cond_15_condition_nv_0_f4500000() {
    // Encoding: 0xF4500000
    // Test aarch32_LDRB_i_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: cond=15, W=0, Rn=0, P=0, Rt=0, U=0, imm12=0
    let encoding: u32 = 0xF4500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_i_A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Binary { op: Eq, lhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Binary { op: Eq, lhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"wback\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }) } } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrb_i_a1_a_invalid_0_0_04500000() {
    // Encoding: 0x04500000
    // Test aarch32_LDRB_i_A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Binary { op: Eq, lhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) } } }
    // ISET: A32
    // Fields: P=0, W=0, Rt=0, cond=0, imm12=0, Rn=0, U=0
    let encoding: u32 = 0x04500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRB_i_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrb_i_a1_a_invalid_1_0_04500000() {
    // Encoding: 0x04500000
    // Test aarch32_LDRB_i_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: U=0, Rt=0, imm12=0, P=0, W=0, cond=0, Rn=0
    let encoding: u32 = 0x04500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRB_i_T1_A
/// ASL: `field imm5 22 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_ldrb_i_t1_a_field_imm5_0_zero_0_78000000() {
    // Thumb encoding (32): 0x78000000
    // Test aarch32_LDRB_i_T1_A field imm5 = 0 (Zero)
    // ISET: T32
    // Fields: imm5=0, Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x78000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_i_T1_A
/// ASL: `field imm5 22 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_ldrb_i_t1_a_field_imm5_1_poweroftwo_0_78400000() {
    // Thumb encoding (32): 0x78400000
    // Test aarch32_LDRB_i_T1_A field imm5 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm5=1, Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x78400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_i_T1_A
/// ASL: `field imm5 22 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_ldrb_i_t1_a_field_imm5_3_poweroftwominusone_0_78c00000() {
    // Thumb encoding (32): 0x78C00000
    // Test aarch32_LDRB_i_T1_A field imm5 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm5=3, Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x78C00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_i_T1_A
/// ASL: `field imm5 22 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_ldrb_i_t1_a_field_imm5_4_poweroftwo_0_79000000() {
    // Thumb encoding (32): 0x79000000
    // Test aarch32_LDRB_i_T1_A field imm5 = 4 (PowerOfTwo)
    // ISET: T32
    // Fields: imm5=4, Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x79000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_i_T1_A
/// ASL: `field imm5 22 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_ldrb_i_t1_a_field_imm5_7_poweroftwominusone_0_79c00000() {
    // Thumb encoding (32): 0x79C00000
    // Test aarch32_LDRB_i_T1_A field imm5 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, imm5=7, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x79C00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_i_T1_A
/// ASL: `field imm5 22 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_ldrb_i_t1_a_field_imm5_8_poweroftwo_0_7a000000() {
    // Thumb encoding (32): 0x7A000000
    // Test aarch32_LDRB_i_T1_A field imm5 = 8 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, imm5=8, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x7A000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_i_T1_A
/// ASL: `field imm5 22 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 15, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (15)
#[test]
fn test_aarch32_ldrb_i_t1_a_field_imm5_15_poweroftwominusone_0_7bc00000() {
    // Thumb encoding (32): 0x7BC00000
    // Test aarch32_LDRB_i_T1_A field imm5 = 15 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm5=15, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x7BC00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_i_T1_A
/// ASL: `field imm5 22 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_ldrb_i_t1_a_field_imm5_16_poweroftwo_0_7c000000() {
    // Thumb encoding (32): 0x7C000000
    // Test aarch32_LDRB_i_T1_A field imm5 = 16 (PowerOfTwo)
    // ISET: T32
    // Fields: imm5=16, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x7C000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_i_T1_A
/// ASL: `field imm5 22 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 31, boundary: Max }
/// maximum immediate (31)
#[test]
fn test_aarch32_ldrb_i_t1_a_field_imm5_31_max_0_7fc00000() {
    // Thumb encoding (32): 0x7FC00000
    // Test aarch32_LDRB_i_T1_A field imm5 = 31 (Max)
    // ISET: T32
    // Fields: Rn=0, imm5=31, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x7FC00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_i_T1_A
/// ASL: `field Rn 19 +: 3`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrb_i_t1_a_field_rn_0_min_0_78000000() {
    // Thumb encoding (32): 0x78000000
    // Test aarch32_LDRB_i_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: imm5=0, Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x78000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_i_T1_A
/// ASL: `field Rn 19 +: 3`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrb_i_t1_a_field_rn_1_poweroftwo_0_78080000() {
    // Thumb encoding (32): 0x78080000
    // Test aarch32_LDRB_i_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm5=0, Rt=0, Rn=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x78080000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_i_T1_A
/// ASL: `field Rt 16 +: 3`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrb_i_t1_a_field_rt_0_min_0_78000000() {
    // Thumb encoding (32): 0x78000000
    // Test aarch32_LDRB_i_T1_A field Rt = 0 (Min)
    // ISET: T32
    // Fields: imm5=0, Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x78000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_i_T1_A
/// ASL: `field Rt 16 +: 3`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrb_i_t1_a_field_rt_1_poweroftwo_0_78010000() {
    // Thumb encoding (32): 0x78010000
    // Test aarch32_LDRB_i_T1_A field Rt = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=1, Rn=0, imm5=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x78010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_i_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=0 (immediate value 0)
#[test]
fn test_aarch32_ldrb_i_t1_a_combo_0_0_78000000() {
    // Thumb encoding (32): 0x78000000
    // Test aarch32_LDRB_i_T1_A field combination: imm5=0, Rn=0, Rt=0
    // ISET: T32
    // Fields: Rt=0, Rn=0, imm5=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x78000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_i_T2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrb_i_t2_a_field_rn_0_min_0_f8900000() {
    // Thumb encoding (32): 0xF8900000
    // Test aarch32_LDRB_i_T2_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm12=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8900000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_i_T2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrb_i_t2_a_field_rn_1_poweroftwo_0_f8910000() {
    // Thumb encoding (32): 0xF8910000
    // Test aarch32_LDRB_i_T2_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm12=0, Rt=0, Rn=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8910000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_i_T2_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrb_i_t2_a_field_rt_0_min_0_f8900000() {
    // Thumb encoding (32): 0xF8900000
    // Test aarch32_LDRB_i_T2_A field Rt = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm12=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8900000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_i_T2_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrb_i_t2_a_field_rt_1_poweroftwo_0_f8901000() {
    // Thumb encoding (32): 0xF8901000
    // Test aarch32_LDRB_i_T2_A field Rt = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=1, imm12=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8901000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_i_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_ldrb_i_t2_a_field_imm12_0_zero_0_f8900000() {
    // Thumb encoding (32): 0xF8900000
    // Test aarch32_LDRB_i_T2_A field imm12 = 0 (Zero)
    // ISET: T32
    // Fields: Rt=0, Rn=0, imm12=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8900000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_i_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_ldrb_i_t2_a_field_imm12_1_poweroftwo_0_f8900001() {
    // Thumb encoding (32): 0xF8900001
    // Test aarch32_LDRB_i_T2_A field imm12 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm12=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8900001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_i_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_ldrb_i_t2_a_field_imm12_3_poweroftwominusone_0_f8900003() {
    // Thumb encoding (32): 0xF8900003
    // Test aarch32_LDRB_i_T2_A field imm12 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, Rn=0, imm12=3
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8900003;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_i_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_ldrb_i_t2_a_field_imm12_4_poweroftwo_0_f8900004() {
    // Thumb encoding (32): 0xF8900004
    // Test aarch32_LDRB_i_T2_A field imm12 = 4 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, imm12=4, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8900004;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_i_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_ldrb_i_t2_a_field_imm12_7_poweroftwominusone_0_f8900007() {
    // Thumb encoding (32): 0xF8900007
    // Test aarch32_LDRB_i_T2_A field imm12 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, imm12=7, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8900007;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_i_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_ldrb_i_t2_a_field_imm12_8_poweroftwo_0_f8900008() {
    // Thumb encoding (32): 0xF8900008
    // Test aarch32_LDRB_i_T2_A field imm12 = 8 (PowerOfTwo)
    // ISET: T32
    // Fields: imm12=8, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8900008;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_i_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_ldrb_i_t2_a_field_imm12_15_poweroftwominusone_0_f890000f() {
    // Thumb encoding (32): 0xF890000F
    // Test aarch32_LDRB_i_T2_A field imm12 = 15 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm12=15, Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF890000F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_i_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_ldrb_i_t2_a_field_imm12_16_poweroftwo_0_f8900010() {
    // Thumb encoding (32): 0xF8900010
    // Test aarch32_LDRB_i_T2_A field imm12 = 16 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, imm12=16, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8900010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_i_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_ldrb_i_t2_a_field_imm12_31_poweroftwominusone_0_f890001f() {
    // Thumb encoding (32): 0xF890001F
    // Test aarch32_LDRB_i_T2_A field imm12 = 31 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm12=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF890001F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_i_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_ldrb_i_t2_a_field_imm12_32_poweroftwo_0_f8900020() {
    // Thumb encoding (32): 0xF8900020
    // Test aarch32_LDRB_i_T2_A field imm12 = 32 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, imm12=32, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8900020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_i_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_ldrb_i_t2_a_field_imm12_63_poweroftwominusone_0_f890003f() {
    // Thumb encoding (32): 0xF890003F
    // Test aarch32_LDRB_i_T2_A field imm12 = 63 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm12=63, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF890003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_i_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_ldrb_i_t2_a_field_imm12_64_poweroftwo_0_f8900040() {
    // Thumb encoding (32): 0xF8900040
    // Test aarch32_LDRB_i_T2_A field imm12 = 64 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, imm12=64, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8900040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_i_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 127, boundary: PowerOfTwoMinusOne }
/// 2^7 - 1 = 127
#[test]
fn test_aarch32_ldrb_i_t2_a_field_imm12_127_poweroftwominusone_0_f890007f() {
    // Thumb encoding (32): 0xF890007F
    // Test aarch32_LDRB_i_T2_A field imm12 = 127 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, imm12=127, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF890007F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_i_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_ldrb_i_t2_a_field_imm12_128_poweroftwo_0_f8900080() {
    // Thumb encoding (32): 0xF8900080
    // Test aarch32_LDRB_i_T2_A field imm12 = 128 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm12=128
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8900080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_i_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 255, boundary: PowerOfTwoMinusOne }
/// 2^8 - 1 = 255
#[test]
fn test_aarch32_ldrb_i_t2_a_field_imm12_255_poweroftwominusone_0_f89000ff() {
    // Thumb encoding (32): 0xF89000FF
    // Test aarch32_LDRB_i_T2_A field imm12 = 255 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm12=255
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF89000FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_i_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 256, boundary: PowerOfTwo }
/// power of 2 (2^8 = 256)
#[test]
fn test_aarch32_ldrb_i_t2_a_field_imm12_256_poweroftwo_0_f8900100() {
    // Thumb encoding (32): 0xF8900100
    // Test aarch32_LDRB_i_T2_A field imm12 = 256 (PowerOfTwo)
    // ISET: T32
    // Fields: imm12=256, Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8900100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_i_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 511, boundary: PowerOfTwoMinusOne }
/// 2^9 - 1 = 511
#[test]
fn test_aarch32_ldrb_i_t2_a_field_imm12_511_poweroftwominusone_0_f89001ff() {
    // Thumb encoding (32): 0xF89001FF
    // Test aarch32_LDRB_i_T2_A field imm12 = 511 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm12=511
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF89001FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_i_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 512, boundary: PowerOfTwo }
/// power of 2 (2^9 = 512)
#[test]
fn test_aarch32_ldrb_i_t2_a_field_imm12_512_poweroftwo_0_f8900200() {
    // Thumb encoding (32): 0xF8900200
    // Test aarch32_LDRB_i_T2_A field imm12 = 512 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, imm12=512, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8900200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_i_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1023, boundary: PowerOfTwoMinusOne }
/// 2^10 - 1 = 1023
#[test]
fn test_aarch32_ldrb_i_t2_a_field_imm12_1023_poweroftwominusone_0_f89003ff() {
    // Thumb encoding (32): 0xF89003FF
    // Test aarch32_LDRB_i_T2_A field imm12 = 1023 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm12=1023, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF89003FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_i_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1024, boundary: PowerOfTwo }
/// power of 2 (2^10 = 1024)
#[test]
fn test_aarch32_ldrb_i_t2_a_field_imm12_1024_poweroftwo_0_f8900400() {
    // Thumb encoding (32): 0xF8900400
    // Test aarch32_LDRB_i_T2_A field imm12 = 1024 (PowerOfTwo)
    // ISET: T32
    // Fields: imm12=1024, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8900400;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_i_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2047, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (2047)
#[test]
fn test_aarch32_ldrb_i_t2_a_field_imm12_2047_poweroftwominusone_0_f89007ff() {
    // Thumb encoding (32): 0xF89007FF
    // Test aarch32_LDRB_i_T2_A field imm12 = 2047 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, imm12=2047, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF89007FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_i_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2048, boundary: PowerOfTwo }
/// power of 2 (2^11 = 2048)
#[test]
fn test_aarch32_ldrb_i_t2_a_field_imm12_2048_poweroftwo_0_f8900800() {
    // Thumb encoding (32): 0xF8900800
    // Test aarch32_LDRB_i_T2_A field imm12 = 2048 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm12=2048
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8900800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_i_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4095, boundary: Max }
/// maximum immediate (4095)
#[test]
fn test_aarch32_ldrb_i_t2_a_field_imm12_4095_max_0_f8900fff() {
    // Thumb encoding (32): 0xF8900FFF
    // Test aarch32_LDRB_i_T2_A field imm12 = 4095 (Max)
    // ISET: T32
    // Fields: imm12=4095, Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8900FFF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_i_T2_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_ldrb_i_t2_a_combo_0_0_f8900000() {
    // Thumb encoding (32): 0xF8900000
    // Test aarch32_LDRB_i_T2_A field combination: Rn=0, Rt=0, imm12=0
    // ISET: T32
    // Fields: Rn=0, imm12=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8900000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_i_T3_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrb_i_t3_a_field_rn_0_min_800_f8100800() {
    // Thumb encoding (32): 0xF8100800
    // Test aarch32_LDRB_i_T3_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rt=0, P=0, Rn=0, U=0, W=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8100800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_i_T3_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrb_i_t3_a_field_rn_1_poweroftwo_800_f8110800() {
    // Thumb encoding (32): 0xF8110800
    // Test aarch32_LDRB_i_T3_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: P=0, U=0, Rn=1, W=0, imm8=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8110800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_i_T3_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrb_i_t3_a_field_rt_0_min_800_f8100800() {
    // Thumb encoding (32): 0xF8100800
    // Test aarch32_LDRB_i_T3_A field Rt = 0 (Min)
    // ISET: T32
    // Fields: Rt=0, W=0, imm8=0, Rn=0, P=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8100800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_i_T3_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrb_i_t3_a_field_rt_1_poweroftwo_800_f8101800() {
    // Thumb encoding (32): 0xF8101800
    // Test aarch32_LDRB_i_T3_A field Rt = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, P=0, W=0, imm8=0, Rt=1, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8101800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_i_T3_A
/// ASL: `field P 10 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldrb_i_t3_a_field_p_0_min_800_f8100800() {
    // Thumb encoding (32): 0xF8100800
    // Test aarch32_LDRB_i_T3_A field P = 0 (Min)
    // ISET: T32
    // Fields: U=0, imm8=0, W=0, Rt=0, Rn=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8100800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_i_T3_A
/// ASL: `field P 10 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldrb_i_t3_a_field_p_1_max_800_f8100c00() {
    // Thumb encoding (32): 0xF8100C00
    // Test aarch32_LDRB_i_T3_A field P = 1 (Max)
    // ISET: T32
    // Fields: imm8=0, Rn=0, Rt=0, P=1, U=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8100C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_i_T3_A
/// ASL: `field U 9 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldrb_i_t3_a_field_u_0_min_800_f8100800() {
    // Thumb encoding (32): 0xF8100800
    // Test aarch32_LDRB_i_T3_A field U = 0 (Min)
    // ISET: T32
    // Fields: W=0, imm8=0, U=0, P=0, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8100800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_i_T3_A
/// ASL: `field U 9 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldrb_i_t3_a_field_u_1_max_800_f8100a00() {
    // Thumb encoding (32): 0xF8100A00
    // Test aarch32_LDRB_i_T3_A field U = 1 (Max)
    // ISET: T32
    // Fields: W=0, imm8=0, Rt=0, U=1, Rn=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8100A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_i_T3_A
/// ASL: `field W 8 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldrb_i_t3_a_field_w_0_min_800_f8100800() {
    // Thumb encoding (32): 0xF8100800
    // Test aarch32_LDRB_i_T3_A field W = 0 (Min)
    // ISET: T32
    // Fields: W=0, Rt=0, P=0, Rn=0, U=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8100800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_i_T3_A
/// ASL: `field W 8 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldrb_i_t3_a_field_w_1_max_800_f8100900() {
    // Thumb encoding (32): 0xF8100900
    // Test aarch32_LDRB_i_T3_A field W = 1 (Max)
    // ISET: T32
    // Fields: U=0, P=0, Rt=0, W=1, imm8=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8100900;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_ldrb_i_t3_a_field_imm8_0_zero_800_f8100800() {
    // Thumb encoding (32): 0xF8100800
    // Test aarch32_LDRB_i_T3_A field imm8 = 0 (Zero)
    // ISET: T32
    // Fields: U=0, imm8=0, Rt=0, P=0, W=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8100800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_ldrb_i_t3_a_field_imm8_1_poweroftwo_800_f8100801() {
    // Thumb encoding (32): 0xF8100801
    // Test aarch32_LDRB_i_T3_A field imm8 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm8=1, U=0, P=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8100801;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_ldrb_i_t3_a_field_imm8_3_poweroftwominusone_800_f8100803() {
    // Thumb encoding (32): 0xF8100803
    // Test aarch32_LDRB_i_T3_A field imm8 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, U=0, Rn=0, W=0, imm8=3, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8100803;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_ldrb_i_t3_a_field_imm8_4_poweroftwo_800_f8100804() {
    // Thumb encoding (32): 0xF8100804
    // Test aarch32_LDRB_i_T3_A field imm8 = 4 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, P=0, Rn=0, U=0, W=0, imm8=4
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8100804;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_ldrb_i_t3_a_field_imm8_7_poweroftwominusone_800_f8100807() {
    // Thumb encoding (32): 0xF8100807
    // Test aarch32_LDRB_i_T3_A field imm8 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, W=0, imm8=7, Rt=0, U=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8100807;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_ldrb_i_t3_a_field_imm8_8_poweroftwo_800_f8100808() {
    // Thumb encoding (32): 0xF8100808
    // Test aarch32_LDRB_i_T3_A field imm8 = 8 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=8, Rn=0, Rt=0, U=0, P=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8100808;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_ldrb_i_t3_a_field_imm8_15_poweroftwominusone_800_f810080f() {
    // Thumb encoding (32): 0xF810080F
    // Test aarch32_LDRB_i_T3_A field imm8 = 15 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, imm8=15, U=0, Rn=0, W=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF810080F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_ldrb_i_t3_a_field_imm8_16_poweroftwo_800_f8100810() {
    // Thumb encoding (32): 0xF8100810
    // Test aarch32_LDRB_i_T3_A field imm8 = 16 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=16, W=0, Rn=0, Rt=0, P=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8100810;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_ldrb_i_t3_a_field_imm8_31_poweroftwominusone_800_f810081f() {
    // Thumb encoding (32): 0xF810081F
    // Test aarch32_LDRB_i_T3_A field imm8 = 31 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: P=0, W=0, imm8=31, Rt=0, Rn=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF810081F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_ldrb_i_t3_a_field_imm8_32_poweroftwo_800_f8100820() {
    // Thumb encoding (32): 0xF8100820
    // Test aarch32_LDRB_i_T3_A field imm8 = 32 (PowerOfTwo)
    // ISET: T32
    // Fields: P=0, Rn=0, imm8=32, U=0, Rt=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8100820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_ldrb_i_t3_a_field_imm8_63_poweroftwominusone_800_f810083f() {
    // Thumb encoding (32): 0xF810083F
    // Test aarch32_LDRB_i_T3_A field imm8 = 63 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, W=0, Rt=0, P=0, U=0, imm8=63
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF810083F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_ldrb_i_t3_a_field_imm8_64_poweroftwo_800_f8100840() {
    // Thumb encoding (32): 0xF8100840
    // Test aarch32_LDRB_i_T3_A field imm8 = 64 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=64, Rt=0, Rn=0, P=0, U=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8100840;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 127, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (127)
#[test]
fn test_aarch32_ldrb_i_t3_a_field_imm8_127_poweroftwominusone_800_f810087f() {
    // Thumb encoding (32): 0xF810087F
    // Test aarch32_LDRB_i_T3_A field imm8 = 127 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, U=0, W=0, imm8=127, Rt=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF810087F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_ldrb_i_t3_a_field_imm8_128_poweroftwo_800_f8100880() {
    // Thumb encoding (32): 0xF8100880
    // Test aarch32_LDRB_i_T3_A field imm8 = 128 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, P=0, U=0, W=0, imm8=128, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8100880;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 255, boundary: Max }
/// maximum immediate (255)
#[test]
fn test_aarch32_ldrb_i_t3_a_field_imm8_255_max_800_f81008ff() {
    // Thumb encoding (32): 0xF81008FF
    // Test aarch32_LDRB_i_T3_A field imm8 = 255 (Max)
    // ISET: T32
    // Fields: Rt=0, P=0, Rn=0, W=0, U=0, imm8=255
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF81008FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_i_T3_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_ldrb_i_t3_a_combo_0_800_f8100800() {
    // Thumb encoding (32): 0xF8100800
    // Test aarch32_LDRB_i_T3_A field combination: Rn=0, Rt=0, P=0, U=0, W=0, imm8=0
    // ISET: T32
    // Fields: P=0, imm8=0, W=0, Rn=0, Rt=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8100800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_i_T3_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "P" }), rhs: Binary { op: And, lhs: LitBits([false]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "W" }) } }, rhs: LitBits([false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"P\" }), rhs: Binary { op: And, lhs: LitBits([false]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"W\" }) } }, rhs: LitBits([false]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_ldrb_i_t3_a_invalid_0_800_f8100800() {
    // Thumb encoding (32): 0xF8100800
    // Test aarch32_LDRB_i_T3_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "P" }), rhs: Binary { op: And, lhs: LitBits([false]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "W" }) } }, rhs: LitBits([false]) }
    // ISET: T32
    // Fields: P=0, imm8=0, W=0, U=0, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8100800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_LDRB_i_T3_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_ldrb_i_t3_a_invalid_1_800_f8100800() {
    // Thumb encoding (32): 0xF8100800
    // Test aarch32_LDRB_i_T3_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: Rn=0, P=0, imm8=0, U=0, Rt=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8100800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_LDRB_i_T3_A
/// ASL: `Binary { op: Or, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: And, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "W" }) } }, rhs: LitBits([true]) }, rhs: Binary { op: Eq, lhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Or, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: Binary { op: And, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"W\" }) } }, rhs: LitBits([true]) }, rhs: Binary { op: Eq, lhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"wback\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }) } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrb_i_t3_a_invalid_2_800_f8100800() {
    // Thumb encoding (32): 0xF8100800
    // Test aarch32_LDRB_i_T3_A invalid encoding: Binary { op: Or, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: And, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "W" }) } }, rhs: LitBits([true]) }, rhs: Binary { op: Eq, lhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) } }
    // ISET: T32
    // Fields: U=0, W=0, Rn=0, imm8=0, P=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8100800;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRB_i_T3_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrb_i_t3_a_invalid_3_800_f8100800() {
    // Thumb encoding (32): 0xF8100800
    // Test aarch32_LDRB_i_T3_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rn=0, U=0, P=0, W=0, Rt=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8100800;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRB_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 0 (32)
#[test]
fn test_aarch32_ldrb_i_t1_a_lslv_oracle_32_0_78020020() {
    // Test LSLV 32-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x12345678, "W0 should be 0x12345678");
}

/// Provenance: aarch32_LDRB_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 0 (64)
#[test]
fn test_aarch32_ldrb_i_t1_a_lslv_oracle_64_0_f8020020() {
    // Test LSLV 64-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x12345678,
        "X0 should be 0x0000000012345678"
    );
}

/// Provenance: aarch32_LDRB_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4 (32)
#[test]
fn test_aarch32_ldrb_i_t1_a_lslv_oracle_32_1_78020020() {
    // Test LSLV 32-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x4);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x23456780, "W0 should be 0x23456780");
}

/// Provenance: aarch32_LDRB_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 4 (64)
#[test]
fn test_aarch32_ldrb_i_t1_a_lslv_oracle_64_1_f8020020() {
    // Test LSLV 64-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x4);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x23456780,
        "X0 should be 0x0000000123456780"
    );
}

/// Provenance: aarch32_LDRB_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 8 (32)
#[test]
fn test_aarch32_ldrb_i_t1_a_lslv_oracle_32_2_78020020() {
    // Test LSLV 32-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x8);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x34567800, "W0 should be 0x34567800");
}

/// Provenance: aarch32_LDRB_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 8 (64)
#[test]
fn test_aarch32_ldrb_i_t1_a_lslv_oracle_64_2_f8020020() {
    // Test LSLV 64-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x8);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x34567800,
        "X0 should be 0x0000001234567800"
    );
}

/// Provenance: aarch32_LDRB_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1 (32)
#[test]
fn test_aarch32_ldrb_i_t1_a_lslv_oracle_32_3_78020020() {
    // Test LSLV 32-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_LDRB_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// MSB set, shift 1 (64)
#[test]
fn test_aarch32_ldrb_i_t1_a_lslv_oracle_64_3_f8020020() {
    // Test LSLV 64-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_LDRB_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// LSB set, max shift (32)
#[test]
fn test_aarch32_ldrb_i_t1_a_lslv_oracle_32_4_78020020() {
    // Test LSLV 32-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3F);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "W0 should be 0x80000000");
}

/// Provenance: aarch32_LDRB_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// LSB set, max shift (64)
#[test]
fn test_aarch32_ldrb_i_t1_a_lslv_oracle_64_4_f8020020() {
    // Test LSLV 64-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3F);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x8000000000000000");
}

/// Provenance: aarch32_LDRB_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// all ones, shift 32 (32)
#[test]
fn test_aarch32_ldrb_i_t1_a_lslv_oracle_32_5_78020020() {
    // Test LSLV 32-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x20);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "W0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_LDRB_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// all ones, shift 32 (64)
#[test]
fn test_aarch32_ldrb_i_t1_a_lslv_oracle_64_5_f8020020() {
    // Test LSLV 64-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x20);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0xFFFFFFFF00000000");
}

/// Provenance: aarch32_LDRB_i_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// no shift
#[test]
fn test_aarch32_ldrb_i_t1_a_t16_oracle_0_78080000() {
    // Test T16 LSLS: no shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_LDRB_i_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4
#[test]
fn test_aarch32_ldrb_i_t1_a_t16_oracle_1_78080000() {
    // Test T16 LSLS: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    set_w(&mut cpu, 2, 0x4);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF0, "R0 should be 0x00000FF0");
}

/// Provenance: aarch32_LDRB_i_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1
#[test]
fn test_aarch32_ldrb_i_t1_a_t16_oracle_2_78080000() {
    // Test T16 LSLS: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_LDRB_i_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift to MSB
#[test]
fn test_aarch32_ldrb_i_t1_a_t16_oracle_3_78080000() {
    // Test T16 LSLS: shift to MSB (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1F);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "R0 should be 0x80000000");
}

/// Provenance: aarch32_LDRB_i_T3_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple division (32)
#[test]
fn test_aarch32_ldrb_i_t3_a_udiv_oracle_32_0_1ac20820() {
    // Test UDIV 32-bit: simple division (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xA);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA, "W0 should be 0x0000000A");
}

/// Provenance: aarch32_LDRB_i_T3_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple division (64)
#[test]
fn test_aarch32_ldrb_i_t3_a_udiv_oracle_64_0_9ac20820() {
    // Test UDIV 64-bit: simple division (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0xA);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA, "X0 should be 0x000000000000000A");
}

/// Provenance: aarch32_LDRB_i_T3_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// division with remainder (32)
#[test]
fn test_aarch32_ldrb_i_t3_a_udiv_oracle_32_1_1ac20820() {
    // Test UDIV 32-bit: division with remainder (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x21, "W0 should be 0x00000021");
}

/// Provenance: aarch32_LDRB_i_T3_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// division with remainder (64)
#[test]
fn test_aarch32_ldrb_i_t3_a_udiv_oracle_64_1_9ac20820() {
    // Test UDIV 64-bit: division with remainder (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x3);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x21, "X0 should be 0x0000000000000021");
}

/// Provenance: aarch32_LDRB_i_T3_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero dividend (32)
#[test]
fn test_aarch32_ldrb_i_t3_a_udiv_oracle_32_2_1ac20820() {
    // Test UDIV 32-bit: zero dividend (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xA);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_LDRB_i_T3_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero dividend (64)
#[test]
fn test_aarch32_ldrb_i_t3_a_udiv_oracle_64_2_9ac20820() {
    // Test UDIV 64-bit: zero dividend (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xA);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_LDRB_i_T3_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// divide by zero - result is 0 (32)
#[test]
fn test_aarch32_ldrb_i_t3_a_udiv_oracle_32_3_1ac20820() {
    // Test UDIV 32-bit: divide by zero - result is 0 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0xA);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_LDRB_i_T3_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// divide by zero - result is 0 (64)
#[test]
fn test_aarch32_ldrb_i_t3_a_udiv_oracle_64_3_9ac20820() {
    // Test UDIV 64-bit: divide by zero - result is 0 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0xA);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_LDRB_i_T3_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max value / 2 (32)
#[test]
fn test_aarch32_ldrb_i_t3_a_udiv_oracle_32_4_1ac20820() {
    // Test UDIV 32-bit: max value / 2 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FFFFFFF, "W0 should be 0x7FFFFFFF");
}

/// Provenance: aarch32_LDRB_i_T3_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max value / 2 (64)
#[test]
fn test_aarch32_ldrb_i_t3_a_udiv_oracle_64_4_9ac20820() {
    // Test UDIV 64-bit: max value / 2 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0x7FFFFFFFFFFFFFFF"
    );
}

/// Provenance: aarch32_LDRB_i_T3_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set / 2 (32)
#[test]
fn test_aarch32_ldrb_i_t3_a_udiv_oracle_32_5_1ac20820() {
    // Test UDIV 32-bit: MSB set / 2 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_LDRB_i_T3_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// MSB set / 2 (64)
#[test]
fn test_aarch32_ldrb_i_t3_a_udiv_oracle_64_5_9ac20820() {
    // Test UDIV 64-bit: MSB set / 2 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x4000000000000000");
}

/// Provenance: aarch32_LDRB_i_T3_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// self-division (32)
#[test]
fn test_aarch32_ldrb_i_t3_a_udiv_oracle_32_6_1ac20820() {
    // Test UDIV 32-bit: self-division (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x7);
    set_w(&mut cpu, 1, 0x7);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_LDRB_i_T3_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// self-division (64)
#[test]
fn test_aarch32_ldrb_i_t3_a_udiv_oracle_64_6_9ac20820() {
    // Test UDIV 64-bit: self-division (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7);
    set_w(&mut cpu, 2, 0x7);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x0000000000000001");
}

/// Provenance: aarch32_LDRB_i_T3_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// one / one (32)
#[test]
fn test_aarch32_ldrb_i_t3_a_udiv_oracle_32_7_1ac20820() {
    // Test UDIV 32-bit: one / one (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_LDRB_i_T3_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// one / one (64)
#[test]
fn test_aarch32_ldrb_i_t3_a_udiv_oracle_64_7_9ac20820() {
    // Test UDIV 64-bit: one / one (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x0000000000000001");
}

/// Provenance: aarch32_LDRB_i_T3_A
/// ASL: `UDIV R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// exact division
#[test]
fn test_aarch32_ldrb_i_t3_a_t32_oracle_0_f8110800() {
    // Test T32 UDIV: exact division (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xA);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF8110800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA, "R0 should be 0x0000000A");
}

/// Provenance: aarch32_LDRB_i_T3_A
/// ASL: `UDIV R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// with remainder
#[test]
fn test_aarch32_ldrb_i_t3_a_t32_oracle_1_f8110800() {
    // Test T32 UDIV: with remainder (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF8110800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x21, "R0 should be 0x00000021");
}

/// Provenance: aarch32_LDRB_i_T3_A
/// ASL: `UDIV R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero dividend
#[test]
fn test_aarch32_ldrb_i_t3_a_t32_oracle_2_f8110800() {
    // Test T32 UDIV: zero dividend (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xA);
    let encoding: u32 = 0xF8110800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_LDRB_i_T3_A
/// ASL: `UDIV R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// divide by zero
#[test]
fn test_aarch32_ldrb_i_t3_a_t32_oracle_3_f8110800() {
    // Test T32 UDIV: divide by zero (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xA);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xF8110800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

// ============================================================================
// aarch32_LDM_A Tests
// ============================================================================

/// Provenance: aarch32_LDM_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_ldm_a1_a_field_cond_0_min_0_08900000() {
    // Encoding: 0x08900000
    // Test aarch32_LDM_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: register_list=0, W=0, cond=0, Rn=0
    let encoding: u32 = 0x08900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_ldm_a1_a_field_cond_1_poweroftwo_0_18900000() {
    // Encoding: 0x18900000
    // Test aarch32_LDM_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: register_list=0, W=0, cond=1, Rn=0
    let encoding: u32 = 0x18900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_ldm_a1_a_field_cond_2_poweroftwo_0_28900000() {
    // Encoding: 0x28900000
    // Test aarch32_LDM_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: register_list=0, Rn=0, W=0, cond=2
    let encoding: u32 = 0x28900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_ldm_a1_a_field_cond_3_poweroftwo_0_38900000() {
    // Encoding: 0x38900000
    // Test aarch32_LDM_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, register_list=0, W=0, cond=3
    let encoding: u32 = 0x38900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_ldm_a1_a_field_cond_4_poweroftwo_0_48900000() {
    // Encoding: 0x48900000
    // Test aarch32_LDM_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: register_list=0, cond=4, Rn=0, W=0
    let encoding: u32 = 0x48900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_ldm_a1_a_field_cond_5_poweroftwo_0_58900000() {
    // Encoding: 0x58900000
    // Test aarch32_LDM_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: register_list=0, W=0, Rn=0, cond=5
    let encoding: u32 = 0x58900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_ldm_a1_a_field_cond_6_poweroftwo_0_68900000() {
    // Encoding: 0x68900000
    // Test aarch32_LDM_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, Rn=0, cond=6, register_list=0
    let encoding: u32 = 0x68900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_ldm_a1_a_field_cond_7_poweroftwo_0_78900000() {
    // Encoding: 0x78900000
    // Test aarch32_LDM_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, register_list=0, Rn=0, cond=7
    let encoding: u32 = 0x78900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_ldm_a1_a_field_cond_8_poweroftwo_0_88900000() {
    // Encoding: 0x88900000
    // Test aarch32_LDM_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=8, register_list=0, W=0
    let encoding: u32 = 0x88900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_ldm_a1_a_field_cond_9_poweroftwo_0_98900000() {
    // Encoding: 0x98900000
    // Test aarch32_LDM_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: register_list=0, cond=9, W=0, Rn=0
    let encoding: u32 = 0x98900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_ldm_a1_a_field_cond_10_poweroftwo_0_a8900000() {
    // Encoding: 0xA8900000
    // Test aarch32_LDM_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, cond=10, register_list=0, Rn=0
    let encoding: u32 = 0xA8900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_ldm_a1_a_field_cond_11_poweroftwo_0_b8900000() {
    // Encoding: 0xB8900000
    // Test aarch32_LDM_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: register_list=0, Rn=0, W=0, cond=11
    let encoding: u32 = 0xB8900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_ldm_a1_a_field_cond_12_poweroftwo_0_c8900000() {
    // Encoding: 0xC8900000
    // Test aarch32_LDM_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=12, register_list=0, W=0
    let encoding: u32 = 0xC8900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_ldm_a1_a_field_cond_13_poweroftwo_0_d8900000() {
    // Encoding: 0xD8900000
    // Test aarch32_LDM_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: register_list=0, Rn=0, cond=13, W=0
    let encoding: u32 = 0xD8900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_ldm_a1_a_field_cond_14_poweroftwo_0_e8900000() {
    // Encoding: 0xE8900000
    // Test aarch32_LDM_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=14, Rn=0, W=0, register_list=0
    let encoding: u32 = 0xE8900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_ldm_a1_a_field_cond_15_max_0_f8900000() {
    // Encoding: 0xF8900000
    // Test aarch32_LDM_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: Rn=0, W=0, register_list=0, cond=15
    let encoding: u32 = 0xF8900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_A1_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldm_a1_a_field_w_0_min_0_08900000() {
    // Encoding: 0x08900000
    // Test aarch32_LDM_A1_A field W = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, cond=0, W=0, register_list=0
    let encoding: u32 = 0x08900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_A1_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldm_a1_a_field_w_1_max_0_08b00000() {
    // Encoding: 0x08B00000
    // Test aarch32_LDM_A1_A field W = 1 (Max)
    // ISET: A32
    // Fields: register_list=0, cond=0, W=1, Rn=0
    let encoding: u32 = 0x08B00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldm_a1_a_field_rn_0_min_0_08900000() {
    // Encoding: 0x08900000
    // Test aarch32_LDM_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: W=0, Rn=0, cond=0, register_list=0
    let encoding: u32 = 0x08900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldm_a1_a_field_rn_1_poweroftwo_0_08910000() {
    // Encoding: 0x08910000
    // Test aarch32_LDM_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: register_list=0, W=0, Rn=1, cond=0
    let encoding: u32 = 0x08910000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_A1_A
/// ASL: `field register_list 0 +: 16`
/// Requirement: FieldBoundary { field: "register_list", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldm_a1_a_field_register_list_0_min_0_08900000() {
    // Encoding: 0x08900000
    // Test aarch32_LDM_A1_A field register_list = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, register_list=0, W=0, cond=0
    let encoding: u32 = 0x08900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_A1_A
/// ASL: `field register_list 0 +: 16`
/// Requirement: FieldBoundary { field: "register_list", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_ldm_a1_a_field_register_list_1_poweroftwo_0_08900001() {
    // Encoding: 0x08900001
    // Test aarch32_LDM_A1_A field register_list = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, register_list=1, cond=0, Rn=0
    let encoding: u32 = 0x08900001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_A1_A
/// ASL: `field register_list 0 +: 16`
/// Requirement: FieldBoundary { field: "register_list", value: 32767, boundary: PowerOfTwoMinusOne }
/// midpoint (32767)
#[test]
fn test_aarch32_ldm_a1_a_field_register_list_32767_poweroftwominusone_0_08907fff() {
    // Encoding: 0x08907FFF
    // Test aarch32_LDM_A1_A field register_list = 32767 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: W=0, register_list=32767, cond=0, Rn=0
    let encoding: u32 = 0x08907FFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_A1_A
/// ASL: `field register_list 0 +: 16`
/// Requirement: FieldBoundary { field: "register_list", value: 65535, boundary: Max }
/// maximum value (65535)
#[test]
fn test_aarch32_ldm_a1_a_field_register_list_65535_max_0_0890ffff() {
    // Encoding: 0x0890FFFF
    // Test aarch32_LDM_A1_A field register_list = 65535 (Max)
    // ISET: A32
    // Fields: Rn=0, cond=0, W=0, register_list=65535
    let encoding: u32 = 0x0890FFFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_ldm_a1_a_combo_0_0_08900000() {
    // Encoding: 0x08900000
    // Test aarch32_LDM_A1_A field combination: cond=0, W=0, Rn=0, register_list=0
    // ISET: A32
    // Fields: register_list=0, W=0, cond=0, Rn=0
    let encoding: u32 = 0x08900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_ldm_a1_a_special_cond_0_condition_eq_0_08900000() {
    // Encoding: 0x08900000
    // Test aarch32_LDM_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: Rn=0, register_list=0, W=0, cond=0
    let encoding: u32 = 0x08900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_ldm_a1_a_special_cond_1_condition_ne_0_18900000() {
    // Encoding: 0x18900000
    // Test aarch32_LDM_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: W=0, register_list=0, Rn=0, cond=1
    let encoding: u32 = 0x18900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_ldm_a1_a_special_cond_2_condition_cs_hs_0_28900000() {
    // Encoding: 0x28900000
    // Test aarch32_LDM_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: Rn=0, cond=2, W=0, register_list=0
    let encoding: u32 = 0x28900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_ldm_a1_a_special_cond_3_condition_cc_lo_0_38900000() {
    // Encoding: 0x38900000
    // Test aarch32_LDM_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: cond=3, W=0, Rn=0, register_list=0
    let encoding: u32 = 0x38900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_ldm_a1_a_special_cond_4_condition_mi_0_48900000() {
    // Encoding: 0x48900000
    // Test aarch32_LDM_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: register_list=0, W=0, Rn=0, cond=4
    let encoding: u32 = 0x48900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_ldm_a1_a_special_cond_5_condition_pl_0_58900000() {
    // Encoding: 0x58900000
    // Test aarch32_LDM_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: W=0, cond=5, Rn=0, register_list=0
    let encoding: u32 = 0x58900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_ldm_a1_a_special_cond_6_condition_vs_0_68900000() {
    // Encoding: 0x68900000
    // Test aarch32_LDM_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: cond=6, Rn=0, W=0, register_list=0
    let encoding: u32 = 0x68900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_ldm_a1_a_special_cond_7_condition_vc_0_78900000() {
    // Encoding: 0x78900000
    // Test aarch32_LDM_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: register_list=0, Rn=0, W=0, cond=7
    let encoding: u32 = 0x78900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_ldm_a1_a_special_cond_8_condition_hi_0_88900000() {
    // Encoding: 0x88900000
    // Test aarch32_LDM_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: W=0, register_list=0, Rn=0, cond=8
    let encoding: u32 = 0x88900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_ldm_a1_a_special_cond_9_condition_ls_0_98900000() {
    // Encoding: 0x98900000
    // Test aarch32_LDM_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: cond=9, register_list=0, W=0, Rn=0
    let encoding: u32 = 0x98900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_ldm_a1_a_special_cond_10_condition_ge_0_a8900000() {
    // Encoding: 0xA8900000
    // Test aarch32_LDM_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: Rn=0, W=0, cond=10, register_list=0
    let encoding: u32 = 0xA8900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_ldm_a1_a_special_cond_11_condition_lt_0_b8900000() {
    // Encoding: 0xB8900000
    // Test aarch32_LDM_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: Rn=0, cond=11, W=0, register_list=0
    let encoding: u32 = 0xB8900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_ldm_a1_a_special_cond_12_condition_gt_0_c8900000() {
    // Encoding: 0xC8900000
    // Test aarch32_LDM_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: cond=12, register_list=0, W=0, Rn=0
    let encoding: u32 = 0xC8900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_ldm_a1_a_special_cond_13_condition_le_0_d8900000() {
    // Encoding: 0xD8900000
    // Test aarch32_LDM_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: cond=13, register_list=0, W=0, Rn=0
    let encoding: u32 = 0xD8900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_ldm_a1_a_special_cond_14_condition_al_0_e8900000() {
    // Encoding: 0xE8900000
    // Test aarch32_LDM_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: W=0, Rn=0, cond=14, register_list=0
    let encoding: u32 = 0xE8900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_ldm_a1_a_special_cond_15_condition_nv_0_f8900000() {
    // Encoding: 0xF8900000
    // Test aarch32_LDM_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: W=0, Rn=0, cond=15, register_list=0
    let encoding: u32 = 0xF8900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Binary { op: Lt, lhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "BitCount" }, args: [Var(QualifiedIdentifier { qualifier: Any, name: "registers" })] }, rhs: LitInt(1) } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Binary { op: Lt, lhs: Call { name: QualifiedIdentifier { qualifier: Any, name: \"BitCount\" }, args: [Var(QualifiedIdentifier { qualifier: Any, name: \"registers\" })] }, rhs: LitInt(1) } } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldm_a1_a_invalid_0_0_08900000() {
    // Encoding: 0x08900000
    // Test aarch32_LDM_A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Binary { op: Lt, lhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "BitCount" }, args: [Var(QualifiedIdentifier { qualifier: Any, name: "registers" })] }, rhs: LitInt(1) } } }
    // ISET: A32
    // Fields: Rn=0, cond=0, W=0, register_list=0
    let encoding: u32 = 0x08900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDM_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldm_a1_a_invalid_1_0_08900000() {
    // Encoding: 0x08900000
    // Test aarch32_LDM_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: cond=0, W=0, Rn=0, register_list=0
    let encoding: u32 = 0x08900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDM_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "registers" }), indices: [Single(Var(QualifiedIdentifier { qualifier: Any, name: "n" }))] } }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"wback\" }), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"registers\" }), indices: [Single(Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }))] } }, rhs: LitBits([true]) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldm_a1_a_invalid_2_0_08900000() {
    // Encoding: 0x08900000
    // Test aarch32_LDM_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "registers" }), indices: [Single(Var(QualifiedIdentifier { qualifier: Any, name: "n" }))] } }, rhs: LitBits([true]) }
    // ISET: A32
    // Fields: cond=0, Rn=0, W=0, register_list=0
    let encoding: u32 = 0x08900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDM_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldm_a1_a_invalid_3_0_08900000() {
    // Encoding: 0x08900000
    // Test aarch32_LDM_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: cond=0, Rn=0, W=0, register_list=0
    let encoding: u32 = 0x08900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDM_T1_A
/// ASL: `field Rn 24 +: 3`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldm_t1_a_field_rn_0_min_0_c8000000() {
    // Thumb encoding (32): 0xC8000000
    // Test aarch32_LDM_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, register_list=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xC8000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDM_T1_A
/// ASL: `field Rn 24 +: 3`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldm_t1_a_field_rn_1_poweroftwo_0_c9000000() {
    // Thumb encoding (32): 0xC9000000
    // Test aarch32_LDM_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: register_list=0, Rn=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xC9000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDM_T1_A
/// ASL: `field register_list 16 +: 8`
/// Requirement: FieldBoundary { field: "register_list", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldm_t1_a_field_register_list_0_min_0_c8000000() {
    // Thumb encoding (32): 0xC8000000
    // Test aarch32_LDM_T1_A field register_list = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, register_list=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xC8000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDM_T1_A
/// ASL: `field register_list 16 +: 8`
/// Requirement: FieldBoundary { field: "register_list", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_ldm_t1_a_field_register_list_1_poweroftwo_0_c8010000() {
    // Thumb encoding (32): 0xC8010000
    // Test aarch32_LDM_T1_A field register_list = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, register_list=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xC8010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDM_T1_A
/// ASL: `field register_list 16 +: 8`
/// Requirement: FieldBoundary { field: "register_list", value: 127, boundary: PowerOfTwoMinusOne }
/// midpoint (127)
#[test]
fn test_aarch32_ldm_t1_a_field_register_list_127_poweroftwominusone_0_c87f0000() {
    // Thumb encoding (32): 0xC87F0000
    // Test aarch32_LDM_T1_A field register_list = 127 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, register_list=127
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xC87F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDM_T1_A
/// ASL: `field register_list 16 +: 8`
/// Requirement: FieldBoundary { field: "register_list", value: 255, boundary: Max }
/// maximum value (255)
#[test]
fn test_aarch32_ldm_t1_a_field_register_list_255_max_0_c8ff0000() {
    // Thumb encoding (32): 0xC8FF0000
    // Test aarch32_LDM_T1_A field register_list = 255 (Max)
    // ISET: T32
    // Fields: Rn=0, register_list=255
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xC8FF0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDM_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_ldm_t1_a_combo_0_0_c8000000() {
    // Thumb encoding (32): 0xC8000000
    // Test aarch32_LDM_T1_A field combination: Rn=0, register_list=0
    // ISET: T32
    // Fields: Rn=0, register_list=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xC8000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDM_T1_A
/// ASL: `Binary { op: Lt, lhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "BitCount" }, args: [Var(QualifiedIdentifier { qualifier: Any, name: "registers" })] }, rhs: LitInt(1) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Lt, lhs: Call { name: QualifiedIdentifier { qualifier: Any, name: \"BitCount\" }, args: [Var(QualifiedIdentifier { qualifier: Any, name: \"registers\" })] }, rhs: LitInt(1) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldm_t1_a_invalid_0_0_c8000000() {
    // Thumb encoding (32): 0xC8000000
    // Test aarch32_LDM_T1_A invalid encoding: Binary { op: Lt, lhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "BitCount" }, args: [Var(QualifiedIdentifier { qualifier: Any, name: "registers" })] }, rhs: LitInt(1) }
    // ISET: T32
    // Fields: Rn=0, register_list=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xC8000000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_LDM_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldm_t1_a_invalid_1_0_c8000000() {
    // Thumb encoding (32): 0xC8000000
    // Test aarch32_LDM_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: register_list=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xC8000000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_LDM_T2_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldm_t2_a_field_w_0_min_0_e8900000() {
    // Thumb encoding (32): 0xE8900000
    // Test aarch32_LDM_T2_A field W = 0 (Min)
    // ISET: T32
    // Fields: register_list=0, W=0, P=0, M=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8900000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDM_T2_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldm_t2_a_field_w_1_max_0_e8b00000() {
    // Thumb encoding (32): 0xE8B00000
    // Test aarch32_LDM_T2_A field W = 1 (Max)
    // ISET: T32
    // Fields: Rn=0, M=0, register_list=0, W=1, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8B00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDM_T2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldm_t2_a_field_rn_0_min_0_e8900000() {
    // Thumb encoding (32): 0xE8900000
    // Test aarch32_LDM_T2_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: P=0, register_list=0, Rn=0, W=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8900000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDM_T2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldm_t2_a_field_rn_1_poweroftwo_0_e8910000() {
    // Thumb encoding (32): 0xE8910000
    // Test aarch32_LDM_T2_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: W=0, Rn=1, register_list=0, M=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8910000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDM_T2_A
/// ASL: `field P 15 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldm_t2_a_field_p_0_min_0_e8900000() {
    // Thumb encoding (32): 0xE8900000
    // Test aarch32_LDM_T2_A field P = 0 (Min)
    // ISET: T32
    // Fields: M=0, Rn=0, W=0, register_list=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8900000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDM_T2_A
/// ASL: `field P 15 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldm_t2_a_field_p_1_max_0_e8908000() {
    // Thumb encoding (32): 0xE8908000
    // Test aarch32_LDM_T2_A field P = 1 (Max)
    // ISET: T32
    // Fields: W=0, register_list=0, M=0, P=1, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8908000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDM_T2_A
/// ASL: `field M 14 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldm_t2_a_field_m_0_min_0_e8900000() {
    // Thumb encoding (32): 0xE8900000
    // Test aarch32_LDM_T2_A field M = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, M=0, P=0, W=0, register_list=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8900000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDM_T2_A
/// ASL: `field M 14 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldm_t2_a_field_m_1_max_0_e8904000() {
    // Thumb encoding (32): 0xE8904000
    // Test aarch32_LDM_T2_A field M = 1 (Max)
    // ISET: T32
    // Fields: W=0, P=0, Rn=0, M=1, register_list=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8904000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDM_T2_A
/// ASL: `field register_list 0 +: 14`
/// Requirement: FieldBoundary { field: "register_list", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldm_t2_a_field_register_list_0_min_0_e8900000() {
    // Thumb encoding (32): 0xE8900000
    // Test aarch32_LDM_T2_A field register_list = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, register_list=0, W=0, M=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8900000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDM_T2_A
/// ASL: `field register_list 0 +: 14`
/// Requirement: FieldBoundary { field: "register_list", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_ldm_t2_a_field_register_list_1_poweroftwo_0_e8900001() {
    // Thumb encoding (32): 0xE8900001
    // Test aarch32_LDM_T2_A field register_list = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: M=0, register_list=1, W=0, Rn=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8900001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDM_T2_A
/// ASL: `field register_list 0 +: 14`
/// Requirement: FieldBoundary { field: "register_list", value: 8191, boundary: PowerOfTwoMinusOne }
/// midpoint (8191)
#[test]
fn test_aarch32_ldm_t2_a_field_register_list_8191_poweroftwominusone_0_e8901fff() {
    // Thumb encoding (32): 0xE8901FFF
    // Test aarch32_LDM_T2_A field register_list = 8191 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: register_list=8191, P=0, W=0, Rn=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8901FFF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDM_T2_A
/// ASL: `field register_list 0 +: 14`
/// Requirement: FieldBoundary { field: "register_list", value: 16383, boundary: Max }
/// maximum value (16383)
#[test]
fn test_aarch32_ldm_t2_a_field_register_list_16383_max_0_e8903fff() {
    // Thumb encoding (32): 0xE8903FFF
    // Test aarch32_LDM_T2_A field register_list = 16383 (Max)
    // ISET: T32
    // Fields: M=0, register_list=16383, Rn=0, P=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8903FFF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDM_T2_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// W=0 (minimum value)
#[test]
fn test_aarch32_ldm_t2_a_combo_0_0_e8900000() {
    // Thumb encoding (32): 0xE8900000
    // Test aarch32_LDM_T2_A field combination: W=0, Rn=0, P=0, M=0, register_list=0
    // ISET: T32
    // Fields: P=0, W=0, Rn=0, register_list=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8900000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDM_T2_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: Binary { op: Or, lhs: LitInt(15), rhs: Binary { op: Lt, lhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "BitCount" }, args: [Var(QualifiedIdentifier { qualifier: Any, name: "registers" })] }, rhs: LitInt(2) } }, rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "P" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "M" }) } }, rhs: LitBits([true]) } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: Binary { op: Or, lhs: LitInt(15), rhs: Binary { op: Lt, lhs: Call { name: QualifiedIdentifier { qualifier: Any, name: \"BitCount\" }, args: [Var(QualifiedIdentifier { qualifier: Any, name: \"registers\" })] }, rhs: LitInt(2) } }, rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"P\" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"M\" }) } }, rhs: LitBits([true]) } } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldm_t2_a_invalid_0_0_e8900000() {
    // Thumb encoding (32): 0xE8900000
    // Test aarch32_LDM_T2_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: Binary { op: Or, lhs: LitInt(15), rhs: Binary { op: Lt, lhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "BitCount" }, args: [Var(QualifiedIdentifier { qualifier: Any, name: "registers" })] }, rhs: LitInt(2) } }, rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "P" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "M" }) } }, rhs: LitBits([true]) } } }
    // ISET: T32
    // Fields: register_list=0, M=0, Rn=0, W=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8900000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_LDM_T2_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldm_t2_a_invalid_1_0_e8900000() {
    // Thumb encoding (32): 0xE8900000
    // Test aarch32_LDM_T2_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rn=0, P=0, register_list=0, M=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8900000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_LDM_T2_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "registers" }), indices: [Single(Var(QualifiedIdentifier { qualifier: Any, name: "n" }))] } }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"wback\" }), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"registers\" }), indices: [Single(Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }))] } }, rhs: LitBits([true]) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldm_t2_a_invalid_2_0_e8900000() {
    // Thumb encoding (32): 0xE8900000
    // Test aarch32_LDM_T2_A invalid encoding: Binary { op: Eq, lhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "registers" }), indices: [Single(Var(QualifiedIdentifier { qualifier: Any, name: "n" }))] } }, rhs: LitBits([true]) }
    // ISET: T32
    // Fields: W=0, register_list=0, M=0, P=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8900000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_LDM_T2_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldm_t2_a_invalid_3_0_e8900000() {
    // Thumb encoding (32): 0xE8900000
    // Test aarch32_LDM_T2_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: M=0, Rn=0, P=0, register_list=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8900000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_LDM_T2_A
/// ASL: `Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "registers" }), indices: [Single(LitInt(13))] }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"registers\" }), indices: [Single(LitInt(13))] }, rhs: LitBits([true]) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldm_t2_a_invalid_4_0_e8900000() {
    // Thumb encoding (32): 0xE8900000
    // Test aarch32_LDM_T2_A invalid encoding: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "registers" }), indices: [Single(LitInt(13))] }, rhs: LitBits([true]) }
    // ISET: T32
    // Fields: M=0, Rn=0, W=0, P=0, register_list=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8900000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_LDM_T2_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldm_t2_a_invalid_5_0_e8900000() {
    // Thumb encoding (32): 0xE8900000
    // Test aarch32_LDM_T2_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: W=0, register_list=0, Rn=0, P=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8900000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_LDM_T2_A
/// ASL: `Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "registers" }), indices: [Single(LitInt(15))] }, rhs: Binary { op: And, lhs: Binary { op: And, lhs: LitBits([true]), rhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] } }, rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "LastInITBlock" }, args: [] } } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"registers\" }), indices: [Single(LitInt(15))] }, rhs: Binary { op: And, lhs: Binary { op: And, lhs: LitBits([true]), rhs: Call { name: QualifiedIdentifier { qualifier: Any, name: \"InITBlock\" }, args: [] } }, rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"LastInITBlock\" }, args: [] } } } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldm_t2_a_invalid_6_0_e8900000() {
    // Thumb encoding (32): 0xE8900000
    // Test aarch32_LDM_T2_A invalid encoding: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "registers" }), indices: [Single(LitInt(15))] }, rhs: Binary { op: And, lhs: Binary { op: And, lhs: LitBits([true]), rhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] } }, rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "LastInITBlock" }, args: [] } } } }
    // ISET: T32
    // Fields: W=0, M=0, register_list=0, P=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8900000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_LDM_T2_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldm_t2_a_invalid_7_0_e8900000() {
    // Thumb encoding (32): 0xE8900000
    // Test aarch32_LDM_T2_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: M=0, Rn=0, W=0, P=0, register_list=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8900000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_LDM_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 0 (32)
#[test]
fn test_aarch32_ldm_t1_a_lslv_oracle_32_0_c8020020() {
    // Test LSLV 32-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x12345678, "W0 should be 0x12345678");
}

/// Provenance: aarch32_LDM_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 0 (64)
#[test]
fn test_aarch32_ldm_t1_a_lslv_oracle_64_0_c8020020() {
    // Test LSLV 64-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x12345678,
        "X0 should be 0x0000000012345678"
    );
}

/// Provenance: aarch32_LDM_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4 (32)
#[test]
fn test_aarch32_ldm_t1_a_lslv_oracle_32_1_c8020020() {
    // Test LSLV 32-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x4);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x23456780, "W0 should be 0x23456780");
}

/// Provenance: aarch32_LDM_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 4 (64)
#[test]
fn test_aarch32_ldm_t1_a_lslv_oracle_64_1_c8020020() {
    // Test LSLV 64-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x4);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x23456780,
        "X0 should be 0x0000000123456780"
    );
}

/// Provenance: aarch32_LDM_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 8 (32)
#[test]
fn test_aarch32_ldm_t1_a_lslv_oracle_32_2_c8020020() {
    // Test LSLV 32-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x8);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x34567800, "W0 should be 0x34567800");
}

/// Provenance: aarch32_LDM_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 8 (64)
#[test]
fn test_aarch32_ldm_t1_a_lslv_oracle_64_2_c8020020() {
    // Test LSLV 64-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x8);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x34567800,
        "X0 should be 0x0000001234567800"
    );
}

/// Provenance: aarch32_LDM_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1 (32)
#[test]
fn test_aarch32_ldm_t1_a_lslv_oracle_32_3_c8020020() {
    // Test LSLV 32-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_LDM_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// MSB set, shift 1 (64)
#[test]
fn test_aarch32_ldm_t1_a_lslv_oracle_64_3_c8020020() {
    // Test LSLV 64-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_LDM_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// LSB set, max shift (32)
#[test]
fn test_aarch32_ldm_t1_a_lslv_oracle_32_4_c8020020() {
    // Test LSLV 32-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x3F);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "W0 should be 0x80000000");
}

/// Provenance: aarch32_LDM_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// LSB set, max shift (64)
#[test]
fn test_aarch32_ldm_t1_a_lslv_oracle_64_4_c8020020() {
    // Test LSLV 64-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3F);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x8000000000000000");
}

/// Provenance: aarch32_LDM_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// all ones, shift 32 (32)
#[test]
fn test_aarch32_ldm_t1_a_lslv_oracle_32_5_c8020020() {
    // Test LSLV 32-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x20);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "W0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_LDM_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// all ones, shift 32 (64)
#[test]
fn test_aarch32_ldm_t1_a_lslv_oracle_64_5_c8020020() {
    // Test LSLV 64-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x20);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0xFFFFFFFF00000000");
}

/// Provenance: aarch32_LDM_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// no shift
#[test]
fn test_aarch32_ldm_t1_a_t16_oracle_0_c9000000() {
    // Test T16 LSLS: no shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_LDM_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4
#[test]
fn test_aarch32_ldm_t1_a_t16_oracle_1_c9000000() {
    // Test T16 LSLS: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    set_w(&mut cpu, 2, 0x4);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF0, "R0 should be 0x00000FF0");
}

/// Provenance: aarch32_LDM_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1
#[test]
fn test_aarch32_ldm_t1_a_t16_oracle_2_c9000000() {
    // Test T16 LSLS: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_LDM_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift to MSB
#[test]
fn test_aarch32_ldm_t1_a_t16_oracle_3_c9000000() {
    // Test T16 LSLS: shift to MSB (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x1F);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "R0 should be 0x80000000");
}

// ============================================================================
// aarch32_LDAH_A Tests
// ============================================================================

/// Provenance: aarch32_LDAH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_ldah_a1_a_field_cond_0_min_90_01f00090() {
    // Encoding: 0x01F00090
    // Test aarch32_LDAH_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: Rt=0, Rn=0, cond=0
    let encoding: u32 = 0x01F00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_ldah_a1_a_field_cond_1_poweroftwo_90_11f00090() {
    // Encoding: 0x11F00090
    // Test aarch32_LDAH_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=1, Rn=0, Rt=0
    let encoding: u32 = 0x11F00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_ldah_a1_a_field_cond_2_poweroftwo_90_21f00090() {
    // Encoding: 0x21F00090
    // Test aarch32_LDAH_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=2
    let encoding: u32 = 0x21F00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_ldah_a1_a_field_cond_3_poweroftwo_90_31f00090() {
    // Encoding: 0x31F00090
    // Test aarch32_LDAH_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=3, Rt=0, Rn=0
    let encoding: u32 = 0x31F00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_ldah_a1_a_field_cond_4_poweroftwo_90_41f00090() {
    // Encoding: 0x41F00090
    // Test aarch32_LDAH_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, Rn=0, cond=4
    let encoding: u32 = 0x41F00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_ldah_a1_a_field_cond_5_poweroftwo_90_51f00090() {
    // Encoding: 0x51F00090
    // Test aarch32_LDAH_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, cond=5, Rn=0
    let encoding: u32 = 0x51F00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_ldah_a1_a_field_cond_6_poweroftwo_90_61f00090() {
    // Encoding: 0x61F00090
    // Test aarch32_LDAH_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=6
    let encoding: u32 = 0x61F00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_ldah_a1_a_field_cond_7_poweroftwo_90_71f00090() {
    // Encoding: 0x71F00090
    // Test aarch32_LDAH_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=7, Rt=0
    let encoding: u32 = 0x71F00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_ldah_a1_a_field_cond_8_poweroftwo_90_81f00090() {
    // Encoding: 0x81F00090
    // Test aarch32_LDAH_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=8, Rn=0, Rt=0
    let encoding: u32 = 0x81F00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_ldah_a1_a_field_cond_9_poweroftwo_90_91f00090() {
    // Encoding: 0x91F00090
    // Test aarch32_LDAH_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, cond=9, Rn=0
    let encoding: u32 = 0x91F00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_ldah_a1_a_field_cond_10_poweroftwo_90_a1f00090() {
    // Encoding: 0xA1F00090
    // Test aarch32_LDAH_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=10, Rn=0, Rt=0
    let encoding: u32 = 0xA1F00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_ldah_a1_a_field_cond_11_poweroftwo_90_b1f00090() {
    // Encoding: 0xB1F00090
    // Test aarch32_LDAH_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=11, Rn=0, Rt=0
    let encoding: u32 = 0xB1F00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_ldah_a1_a_field_cond_12_poweroftwo_90_c1f00090() {
    // Encoding: 0xC1F00090
    // Test aarch32_LDAH_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=12, Rt=0
    let encoding: u32 = 0xC1F00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_ldah_a1_a_field_cond_13_poweroftwo_90_d1f00090() {
    // Encoding: 0xD1F00090
    // Test aarch32_LDAH_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, Rn=0, cond=13
    let encoding: u32 = 0xD1F00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_ldah_a1_a_field_cond_14_poweroftwo_90_e1f00090() {
    // Encoding: 0xE1F00090
    // Test aarch32_LDAH_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, cond=14, Rn=0
    let encoding: u32 = 0xE1F00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_ldah_a1_a_field_cond_15_max_90_f1f00090() {
    // Encoding: 0xF1F00090
    // Test aarch32_LDAH_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: cond=15, Rn=0, Rt=0
    let encoding: u32 = 0xF1F00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAH_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldah_a1_a_field_rn_0_min_90_01f00090() {
    // Encoding: 0x01F00090
    // Test aarch32_LDAH_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rn=0, Rt=0
    let encoding: u32 = 0x01F00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAH_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldah_a1_a_field_rn_1_poweroftwo_90_01f10090() {
    // Encoding: 0x01F10090
    // Test aarch32_LDAH_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Rn=1, Rt=0
    let encoding: u32 = 0x01F10090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAH_A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldah_a1_a_field_rt_0_min_90_01f00090() {
    // Encoding: 0x01F00090
    // Test aarch32_LDAH_A1_A field Rt = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rn=0, Rt=0
    let encoding: u32 = 0x01F00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAH_A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldah_a1_a_field_rt_1_poweroftwo_90_01f01090() {
    // Encoding: 0x01F01090
    // Test aarch32_LDAH_A1_A field Rt = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=0, Rt=1
    let encoding: u32 = 0x01F01090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAH_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_ldah_a1_a_combo_0_90_01f00090() {
    // Encoding: 0x01F00090
    // Test aarch32_LDAH_A1_A field combination: cond=0, Rn=0, Rt=0
    // ISET: A32
    // Fields: Rt=0, Rn=0, cond=0
    let encoding: u32 = 0x01F00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAH_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_ldah_a1_a_special_cond_0_condition_eq_144_01f00090() {
    // Encoding: 0x01F00090
    // Test aarch32_LDAH_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=0
    let encoding: u32 = 0x01F00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAH_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_ldah_a1_a_special_cond_1_condition_ne_144_11f00090() {
    // Encoding: 0x11F00090
    // Test aarch32_LDAH_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: cond=1, Rt=0, Rn=0
    let encoding: u32 = 0x11F00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAH_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_ldah_a1_a_special_cond_2_condition_cs_hs_144_21f00090() {
    // Encoding: 0x21F00090
    // Test aarch32_LDAH_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: cond=2, Rt=0, Rn=0
    let encoding: u32 = 0x21F00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAH_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_ldah_a1_a_special_cond_3_condition_cc_lo_144_31f00090() {
    // Encoding: 0x31F00090
    // Test aarch32_LDAH_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=3
    let encoding: u32 = 0x31F00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAH_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_ldah_a1_a_special_cond_4_condition_mi_144_41f00090() {
    // Encoding: 0x41F00090
    // Test aarch32_LDAH_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: Rt=0, cond=4, Rn=0
    let encoding: u32 = 0x41F00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAH_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_ldah_a1_a_special_cond_5_condition_pl_144_51f00090() {
    // Encoding: 0x51F00090
    // Test aarch32_LDAH_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: cond=5, Rt=0, Rn=0
    let encoding: u32 = 0x51F00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAH_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_ldah_a1_a_special_cond_6_condition_vs_144_61f00090() {
    // Encoding: 0x61F00090
    // Test aarch32_LDAH_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: cond=6, Rn=0, Rt=0
    let encoding: u32 = 0x61F00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAH_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_ldah_a1_a_special_cond_7_condition_vc_144_71f00090() {
    // Encoding: 0x71F00090
    // Test aarch32_LDAH_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: cond=7, Rn=0, Rt=0
    let encoding: u32 = 0x71F00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAH_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_ldah_a1_a_special_cond_8_condition_hi_144_81f00090() {
    // Encoding: 0x81F00090
    // Test aarch32_LDAH_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=8
    let encoding: u32 = 0x81F00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAH_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_ldah_a1_a_special_cond_9_condition_ls_144_91f00090() {
    // Encoding: 0x91F00090
    // Test aarch32_LDAH_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: Rt=0, Rn=0, cond=9
    let encoding: u32 = 0x91F00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAH_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_ldah_a1_a_special_cond_10_condition_ge_144_a1f00090() {
    // Encoding: 0xA1F00090
    // Test aarch32_LDAH_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: cond=10, Rn=0, Rt=0
    let encoding: u32 = 0xA1F00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAH_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_ldah_a1_a_special_cond_11_condition_lt_144_b1f00090() {
    // Encoding: 0xB1F00090
    // Test aarch32_LDAH_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: Rt=0, Rn=0, cond=11
    let encoding: u32 = 0xB1F00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAH_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_ldah_a1_a_special_cond_12_condition_gt_144_c1f00090() {
    // Encoding: 0xC1F00090
    // Test aarch32_LDAH_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: Rt=0, Rn=0, cond=12
    let encoding: u32 = 0xC1F00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAH_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_ldah_a1_a_special_cond_13_condition_le_144_d1f00090() {
    // Encoding: 0xD1F00090
    // Test aarch32_LDAH_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=13
    let encoding: u32 = 0xD1F00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAH_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_ldah_a1_a_special_cond_14_condition_al_144_e1f00090() {
    // Encoding: 0xE1F00090
    // Test aarch32_LDAH_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: Rt=0, cond=14, Rn=0
    let encoding: u32 = 0xE1F00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAH_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_ldah_a1_a_special_cond_15_condition_nv_144_f1f00090() {
    // Encoding: 0xF1F00090
    // Test aarch32_LDAH_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: cond=15, Rt=0, Rn=0
    let encoding: u32 = 0xF1F00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAH_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldah_a1_a_invalid_0_90_01f00090() {
    // Encoding: 0x01F00090
    // Test aarch32_LDAH_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }
    // ISET: A32
    // Fields: cond=0, Rn=0, Rt=0
    let encoding: u32 = 0x01F00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDAH_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldah_a1_a_invalid_1_90_01f00090() {
    // Encoding: 0x01F00090
    // Test aarch32_LDAH_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: cond=0, Rt=0, Rn=0
    let encoding: u32 = 0x01F00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDAH_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldah_t1_a_field_rn_0_min_90_e8d00090() {
    // Thumb encoding (32): 0xE8D00090
    // Test aarch32_LDAH_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8D00090;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDAH_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldah_t1_a_field_rn_1_poweroftwo_90_e8d10090() {
    // Thumb encoding (32): 0xE8D10090
    // Test aarch32_LDAH_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, Rn=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8D10090;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDAH_T1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldah_t1_a_field_rt_0_min_90_e8d00090() {
    // Thumb encoding (32): 0xE8D00090
    // Test aarch32_LDAH_T1_A field Rt = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8D00090;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDAH_T1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldah_t1_a_field_rt_1_poweroftwo_90_e8d01090() {
    // Thumb encoding (32): 0xE8D01090
    // Test aarch32_LDAH_T1_A field Rt = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Rt=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8D01090;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDAH_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_ldah_t1_a_combo_0_90_e8d00090() {
    // Thumb encoding (32): 0xE8D00090
    // Test aarch32_LDAH_T1_A field combination: Rn=0, Rt=0
    // ISET: T32
    // Fields: Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8D00090;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDAH_T1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldah_t1_a_invalid_0_90_e8d00090() {
    // Thumb encoding (32): 0xE8D00090
    // Test aarch32_LDAH_T1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }
    // ISET: T32
    // Fields: Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8D00090;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_LDAH_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldah_t1_a_invalid_1_90_e8d00090() {
    // Thumb encoding (32): 0xE8D00090
    // Test aarch32_LDAH_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8D00090;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_LDAH_A1_A
/// ASL: `SMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple multiply
#[test]
fn test_aarch32_ldah_a1_a_smull_oracle_0_9b227c20() {
    // Test SMULL: simple multiply (oracle)
    // Encoding: 0x9B227C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3);
    set_w(&mut cpu, 1, 0x2);
    let encoding: u32 = 0x9B227C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6, "X0 should be 0x0000000000000006");
}

/// Provenance: aarch32_LDAH_A1_A
/// ASL: `SMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max 32-bit * 2
#[test]
fn test_aarch32_ldah_a1_a_smull_oracle_1_9b227c20() {
    // Test SMULL: max 32-bit * 2 (oracle)
    // Encoding: 0x9B227C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x9B227C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0xFFFFFFFFFFFFFFFE"
    );
}

/// Provenance: aarch32_LDAH_A1_A
/// ASL: `SMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// large positive * large positive
#[test]
fn test_aarch32_ldah_a1_a_smull_oracle_2_9b227c20() {
    // Test SMULL: large positive * large positive (oracle)
    // Encoding: 0x9B227C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x7FFFFFFF);
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x9B227C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x3FFFFFFF00000001");
}

/// Provenance: aarch32_LDAH_A1_A
/// ASL: `SMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max unsigned * max unsigned
#[test]
fn test_aarch32_ldah_a1_a_smull_oracle_3_9b227c20() {
    // Test SMULL: max unsigned * max unsigned (oracle)
    // Encoding: 0x9B227C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x9B227C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x0000000000000001");
}

/// Provenance: aarch32_LDAH_A1_A
/// ASL: `SMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// medium values
#[test]
fn test_aarch32_ldah_a1_a_smull_oracle_4_9b227c20() {
    // Test SMULL: medium values (oracle)
    // Encoding: 0x9B227C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xC8);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x9B227C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4E20, "X0 should be 0x0000000000004E20");
}

/// Provenance: aarch32_LDAH_A1_A
/// ASL: `SMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// 16-bit values
#[test]
fn test_aarch32_ldah_a1_a_smull_oracle_5_9b227c20() {
    // Test SMULL: 16-bit values (oracle)
    // Encoding: 0x9B227C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x5678);
    set_w(&mut cpu, 1, 0x1234);
    let encoding: u32 = 0x9B227C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6260060, "X0 should be 0x0000000006260060");
}

// ============================================================================
// aarch32_LDRD_l_A Tests
// ============================================================================

/// Provenance: aarch32_LDRD_l_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_ldrd_l_a1_a_field_cond_0_min_d0_004f00d0() {
    // Encoding: 0x004F00D0
    // Test aarch32_LDRD_l_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: imm4L=0, U=0, Rt=0, cond=0, imm4H=0
    let encoding: u32 = 0x004F00D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_l_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_ldrd_l_a1_a_field_cond_1_poweroftwo_d0_104f00d0() {
    // Encoding: 0x104F00D0
    // Test aarch32_LDRD_l_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, U=0, imm4H=0, cond=1, imm4L=0
    let encoding: u32 = 0x104F00D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_l_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_ldrd_l_a1_a_field_cond_2_poweroftwo_d0_204f00d0() {
    // Encoding: 0x204F00D0
    // Test aarch32_LDRD_l_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4L=0, U=0, imm4H=0, Rt=0, cond=2
    let encoding: u32 = 0x204F00D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_l_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_ldrd_l_a1_a_field_cond_3_poweroftwo_d0_304f00d0() {
    // Encoding: 0x304F00D0
    // Test aarch32_LDRD_l_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, cond=3, U=0, imm4H=0, imm4L=0
    let encoding: u32 = 0x304F00D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_l_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_ldrd_l_a1_a_field_cond_4_poweroftwo_d0_404f00d0() {
    // Encoding: 0x404F00D0
    // Test aarch32_LDRD_l_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, imm4H=0, imm4L=0, cond=4, Rt=0
    let encoding: u32 = 0x404F00D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_l_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_ldrd_l_a1_a_field_cond_5_poweroftwo_d0_504f00d0() {
    // Encoding: 0x504F00D0
    // Test aarch32_LDRD_l_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, cond=5, imm4L=0, Rt=0, imm4H=0
    let encoding: u32 = 0x504F00D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_l_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_ldrd_l_a1_a_field_cond_6_poweroftwo_d0_604f00d0() {
    // Encoding: 0x604F00D0
    // Test aarch32_LDRD_l_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, U=0, cond=6, imm4H=0, imm4L=0
    let encoding: u32 = 0x604F00D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_l_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_ldrd_l_a1_a_field_cond_7_poweroftwo_d0_704f00d0() {
    // Encoding: 0x704F00D0
    // Test aarch32_LDRD_l_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, cond=7, imm4H=0, imm4L=0, Rt=0
    let encoding: u32 = 0x704F00D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_l_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_ldrd_l_a1_a_field_cond_8_poweroftwo_d0_804f00d0() {
    // Encoding: 0x804F00D0
    // Test aarch32_LDRD_l_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4L=0, Rt=0, cond=8, U=0, imm4H=0
    let encoding: u32 = 0x804F00D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_l_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_ldrd_l_a1_a_field_cond_9_poweroftwo_d0_904f00d0() {
    // Encoding: 0x904F00D0
    // Test aarch32_LDRD_l_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4L=0, Rt=0, U=0, imm4H=0, cond=9
    let encoding: u32 = 0x904F00D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_l_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_ldrd_l_a1_a_field_cond_10_poweroftwo_d0_a04f00d0() {
    // Encoding: 0xA04F00D0
    // Test aarch32_LDRD_l_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=10, Rt=0, imm4H=0, imm4L=0, U=0
    let encoding: u32 = 0xA04F00D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_l_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_ldrd_l_a1_a_field_cond_11_poweroftwo_d0_b04f00d0() {
    // Encoding: 0xB04F00D0
    // Test aarch32_LDRD_l_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, cond=11, Rt=0, imm4H=0, imm4L=0
    let encoding: u32 = 0xB04F00D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_l_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_ldrd_l_a1_a_field_cond_12_poweroftwo_d0_c04f00d0() {
    // Encoding: 0xC04F00D0
    // Test aarch32_LDRD_l_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, imm4H=0, imm4L=0, cond=12, Rt=0
    let encoding: u32 = 0xC04F00D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_l_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_ldrd_l_a1_a_field_cond_13_poweroftwo_d0_d04f00d0() {
    // Encoding: 0xD04F00D0
    // Test aarch32_LDRD_l_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4H=0, U=0, cond=13, imm4L=0, Rt=0
    let encoding: u32 = 0xD04F00D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_l_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_ldrd_l_a1_a_field_cond_14_poweroftwo_d0_e04f00d0() {
    // Encoding: 0xE04F00D0
    // Test aarch32_LDRD_l_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4H=0, U=0, imm4L=0, Rt=0, cond=14
    let encoding: u32 = 0xE04F00D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_l_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_ldrd_l_a1_a_field_cond_15_max_d0_f04f00d0() {
    // Encoding: 0xF04F00D0
    // Test aarch32_LDRD_l_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: Rt=0, imm4L=0, imm4H=0, cond=15, U=0
    let encoding: u32 = 0xF04F00D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_l_A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldrd_l_a1_a_field_u_0_min_d0_004f00d0() {
    // Encoding: 0x004F00D0
    // Test aarch32_LDRD_l_A1_A field U = 0 (Min)
    // ISET: A32
    // Fields: U=0, imm4H=0, imm4L=0, Rt=0, cond=0
    let encoding: u32 = 0x004F00D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_l_A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldrd_l_a1_a_field_u_1_max_d0_00cf00d0() {
    // Encoding: 0x00CF00D0
    // Test aarch32_LDRD_l_A1_A field U = 1 (Max)
    // ISET: A32
    // Fields: cond=0, imm4L=0, U=1, Rt=0, imm4H=0
    let encoding: u32 = 0x00CF00D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_l_A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrd_l_a1_a_field_rt_0_min_d0_004f00d0() {
    // Encoding: 0x004F00D0
    // Test aarch32_LDRD_l_A1_A field Rt = 0 (Min)
    // ISET: A32
    // Fields: U=0, cond=0, imm4L=0, Rt=0, imm4H=0
    let encoding: u32 = 0x004F00D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_l_A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrd_l_a1_a_field_rt_1_poweroftwo_d0_004f10d0() {
    // Encoding: 0x004F10D0
    // Test aarch32_LDRD_l_A1_A field Rt = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Rt=1, U=0, imm4H=0, imm4L=0
    let encoding: u32 = 0x004F10D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_l_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_ldrd_l_a1_a_field_imm4h_0_zero_d0_004f00d0() {
    // Encoding: 0x004F00D0
    // Test aarch32_LDRD_l_A1_A field imm4H = 0 (Zero)
    // ISET: A32
    // Fields: imm4H=0, imm4L=0, Rt=0, cond=0, U=0
    let encoding: u32 = 0x004F00D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_l_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_ldrd_l_a1_a_field_imm4h_1_poweroftwo_d0_004f01d0() {
    // Encoding: 0x004F01D0
    // Test aarch32_LDRD_l_A1_A field imm4H = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, imm4H=1, cond=0, imm4L=0, U=0
    let encoding: u32 = 0x004F01D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_l_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_ldrd_l_a1_a_field_imm4h_3_poweroftwominusone_d0_004f03d0() {
    // Encoding: 0x004F03D0
    // Test aarch32_LDRD_l_A1_A field imm4H = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, imm4H=3, imm4L=0, U=0, Rt=0
    let encoding: u32 = 0x004F03D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_l_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_ldrd_l_a1_a_field_imm4h_4_poweroftwo_d0_004f04d0() {
    // Encoding: 0x004F04D0
    // Test aarch32_LDRD_l_A1_A field imm4H = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, imm4H=4, U=0, cond=0, imm4L=0
    let encoding: u32 = 0x004F04D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_l_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_aarch32_ldrd_l_a1_a_field_imm4h_7_poweroftwominusone_d0_004f07d0() {
    // Encoding: 0x004F07D0
    // Test aarch32_LDRD_l_A1_A field imm4H = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: U=0, imm4H=7, Rt=0, imm4L=0, cond=0
    let encoding: u32 = 0x004F07D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_l_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_ldrd_l_a1_a_field_imm4h_8_poweroftwo_d0_004f08d0() {
    // Encoding: 0x004F08D0
    // Test aarch32_LDRD_l_A1_A field imm4H = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, imm4H=8, imm4L=0, Rt=0, U=0
    let encoding: u32 = 0x004F08D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_l_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_aarch32_ldrd_l_a1_a_field_imm4h_15_max_d0_004f0fd0() {
    // Encoding: 0x004F0FD0
    // Test aarch32_LDRD_l_A1_A field imm4H = 15 (Max)
    // ISET: A32
    // Fields: cond=0, U=0, Rt=0, imm4L=0, imm4H=15
    let encoding: u32 = 0x004F0FD0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_l_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_ldrd_l_a1_a_field_imm4l_0_zero_d0_004f00d0() {
    // Encoding: 0x004F00D0
    // Test aarch32_LDRD_l_A1_A field imm4L = 0 (Zero)
    // ISET: A32
    // Fields: cond=0, imm4H=0, imm4L=0, U=0, Rt=0
    let encoding: u32 = 0x004F00D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_l_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_ldrd_l_a1_a_field_imm4l_1_poweroftwo_d0_004f00d1() {
    // Encoding: 0x004F00D1
    // Test aarch32_LDRD_l_A1_A field imm4L = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, Rt=0, imm4H=0, cond=0, imm4L=1
    let encoding: u32 = 0x004F00D1;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_l_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_ldrd_l_a1_a_field_imm4l_3_poweroftwominusone_d0_004f00d3() {
    // Encoding: 0x004F00D3
    // Test aarch32_LDRD_l_A1_A field imm4L = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm4H=0, Rt=0, cond=0, imm4L=3, U=0
    let encoding: u32 = 0x004F00D3;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_l_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_ldrd_l_a1_a_field_imm4l_4_poweroftwo_d0_004f00d4() {
    // Encoding: 0x004F00D4
    // Test aarch32_LDRD_l_A1_A field imm4L = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, U=0, Rt=0, imm4H=0, imm4L=4
    let encoding: u32 = 0x004F00D4;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_l_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_aarch32_ldrd_l_a1_a_field_imm4l_7_poweroftwominusone_d0_004f00d7() {
    // Encoding: 0x004F00D7
    // Test aarch32_LDRD_l_A1_A field imm4L = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: U=0, cond=0, imm4L=7, Rt=0, imm4H=0
    let encoding: u32 = 0x004F00D7;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_l_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_ldrd_l_a1_a_field_imm4l_8_poweroftwo_d0_004f00d8() {
    // Encoding: 0x004F00D8
    // Test aarch32_LDRD_l_A1_A field imm4L = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, cond=0, U=0, imm4H=0, imm4L=8
    let encoding: u32 = 0x004F00D8;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_l_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_aarch32_ldrd_l_a1_a_field_imm4l_15_max_d0_004f00df() {
    // Encoding: 0x004F00DF
    // Test aarch32_LDRD_l_A1_A field imm4L = 15 (Max)
    // ISET: A32
    // Fields: Rt=0, U=0, imm4H=0, imm4L=15, cond=0
    let encoding: u32 = 0x004F00DF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_l_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_ldrd_l_a1_a_combo_0_d0_004f00d0() {
    // Encoding: 0x004F00D0
    // Test aarch32_LDRD_l_A1_A field combination: cond=0, U=0, Rt=0, imm4H=0, imm4L=0
    // ISET: A32
    // Fields: U=0, imm4H=0, imm4L=0, cond=0, Rt=0
    let encoding: u32 = 0x004F00D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_l_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_ldrd_l_a1_a_special_cond_0_condition_eq_208_004f00d0() {
    // Encoding: 0x004F00D0
    // Test aarch32_LDRD_l_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: cond=0, imm4L=0, Rt=0, imm4H=0, U=0
    let encoding: u32 = 0x004F00D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_l_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_ldrd_l_a1_a_special_cond_1_condition_ne_208_104f00d0() {
    // Encoding: 0x104F00D0
    // Test aarch32_LDRD_l_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: imm4H=0, Rt=0, cond=1, U=0, imm4L=0
    let encoding: u32 = 0x104F00D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_l_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_ldrd_l_a1_a_special_cond_2_condition_cs_hs_208_204f00d0() {
    // Encoding: 0x204F00D0
    // Test aarch32_LDRD_l_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: imm4H=0, Rt=0, cond=2, imm4L=0, U=0
    let encoding: u32 = 0x204F00D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_l_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_ldrd_l_a1_a_special_cond_3_condition_cc_lo_208_304f00d0() {
    // Encoding: 0x304F00D0
    // Test aarch32_LDRD_l_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: cond=3, imm4H=0, imm4L=0, U=0, Rt=0
    let encoding: u32 = 0x304F00D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_l_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_ldrd_l_a1_a_special_cond_4_condition_mi_208_404f00d0() {
    // Encoding: 0x404F00D0
    // Test aarch32_LDRD_l_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: imm4H=0, U=0, imm4L=0, cond=4, Rt=0
    let encoding: u32 = 0x404F00D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_l_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_ldrd_l_a1_a_special_cond_5_condition_pl_208_504f00d0() {
    // Encoding: 0x504F00D0
    // Test aarch32_LDRD_l_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: cond=5, imm4H=0, imm4L=0, Rt=0, U=0
    let encoding: u32 = 0x504F00D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_l_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_ldrd_l_a1_a_special_cond_6_condition_vs_208_604f00d0() {
    // Encoding: 0x604F00D0
    // Test aarch32_LDRD_l_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: U=0, imm4H=0, imm4L=0, cond=6, Rt=0
    let encoding: u32 = 0x604F00D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_l_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_ldrd_l_a1_a_special_cond_7_condition_vc_208_704f00d0() {
    // Encoding: 0x704F00D0
    // Test aarch32_LDRD_l_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: U=0, Rt=0, imm4L=0, cond=7, imm4H=0
    let encoding: u32 = 0x704F00D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_l_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_ldrd_l_a1_a_special_cond_8_condition_hi_208_804f00d0() {
    // Encoding: 0x804F00D0
    // Test aarch32_LDRD_l_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: U=0, Rt=0, imm4H=0, cond=8, imm4L=0
    let encoding: u32 = 0x804F00D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_l_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_ldrd_l_a1_a_special_cond_9_condition_ls_208_904f00d0() {
    // Encoding: 0x904F00D0
    // Test aarch32_LDRD_l_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: imm4L=0, cond=9, Rt=0, imm4H=0, U=0
    let encoding: u32 = 0x904F00D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_l_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_ldrd_l_a1_a_special_cond_10_condition_ge_208_a04f00d0() {
    // Encoding: 0xA04F00D0
    // Test aarch32_LDRD_l_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: U=0, cond=10, imm4H=0, imm4L=0, Rt=0
    let encoding: u32 = 0xA04F00D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_l_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_ldrd_l_a1_a_special_cond_11_condition_lt_208_b04f00d0() {
    // Encoding: 0xB04F00D0
    // Test aarch32_LDRD_l_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: U=0, Rt=0, imm4H=0, imm4L=0, cond=11
    let encoding: u32 = 0xB04F00D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_l_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_ldrd_l_a1_a_special_cond_12_condition_gt_208_c04f00d0() {
    // Encoding: 0xC04F00D0
    // Test aarch32_LDRD_l_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: U=0, imm4L=0, cond=12, Rt=0, imm4H=0
    let encoding: u32 = 0xC04F00D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_l_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_ldrd_l_a1_a_special_cond_13_condition_le_208_d04f00d0() {
    // Encoding: 0xD04F00D0
    // Test aarch32_LDRD_l_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: cond=13, Rt=0, U=0, imm4L=0, imm4H=0
    let encoding: u32 = 0xD04F00D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_l_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_ldrd_l_a1_a_special_cond_14_condition_al_208_e04f00d0() {
    // Encoding: 0xE04F00D0
    // Test aarch32_LDRD_l_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: Rt=0, imm4H=0, imm4L=0, U=0, cond=14
    let encoding: u32 = 0xE04F00D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_l_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_ldrd_l_a1_a_special_cond_15_condition_nv_208_f04f00d0() {
    // Encoding: 0xF04F00D0
    // Test aarch32_LDRD_l_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: U=0, Rt=0, cond=15, imm4L=0, imm4H=0
    let encoding: u32 = 0xF04F00D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_l_A1_A
/// ASL: `Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Rt" }), indices: [Single(LitInt(0))] }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Rt\" }), indices: [Single(LitInt(0))] }, rhs: LitBits([true]) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrd_l_a1_a_invalid_0_d0_004f00d0() {
    // Encoding: 0x004F00D0
    // Test aarch32_LDRD_l_A1_A invalid encoding: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Rt" }), indices: [Single(LitInt(0))] }, rhs: LitBits([true]) }
    // ISET: A32
    // Fields: cond=0, U=0, Rt=0, imm4L=0, imm4H=0
    let encoding: u32 = 0x004F00D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRD_l_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrd_l_a1_a_invalid_1_d0_004f00d0() {
    // Encoding: 0x004F00D0
    // Test aarch32_LDRD_l_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: imm4L=0, U=0, cond=0, Rt=0, imm4H=0
    let encoding: u32 = 0x004F00D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRD_l_A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t2" }), rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t2\" }), rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrd_l_a1_a_invalid_2_d0_004f00d0() {
    // Encoding: 0x004F00D0
    // Test aarch32_LDRD_l_A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t2" }), rhs: LitInt(15) }
    // ISET: A32
    // Fields: U=0, Rt=0, cond=0, imm4H=0, imm4L=0
    let encoding: u32 = 0x004F00D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRD_l_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrd_l_a1_a_invalid_3_d0_004f00d0() {
    // Encoding: 0x004F00D0
    // Test aarch32_LDRD_l_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: U=0, imm4H=0, cond=0, imm4L=0, Rt=0
    let encoding: u32 = 0x004F00D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRD_l_T1_A
/// ASL: `field P 24 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldrd_l_t1_a_field_p_0_min_0_e85f0000() {
    // Thumb encoding (32): 0xE85F0000
    // Test aarch32_LDRD_l_T1_A field P = 0 (Min)
    // ISET: T32
    // Fields: Rt=0, W=0, imm8=0, U=0, Rt2=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE85F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRD_l_T1_A
/// ASL: `field P 24 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldrd_l_t1_a_field_p_1_max_0_e95f0000() {
    // Thumb encoding (32): 0xE95F0000
    // Test aarch32_LDRD_l_T1_A field P = 1 (Max)
    // ISET: T32
    // Fields: Rt=0, imm8=0, U=0, Rt2=0, P=1, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE95F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRD_l_T1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldrd_l_t1_a_field_u_0_min_0_e85f0000() {
    // Thumb encoding (32): 0xE85F0000
    // Test aarch32_LDRD_l_T1_A field U = 0 (Min)
    // ISET: T32
    // Fields: P=0, W=0, U=0, Rt=0, Rt2=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE85F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRD_l_T1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldrd_l_t1_a_field_u_1_max_0_e8df0000() {
    // Thumb encoding (32): 0xE8DF0000
    // Test aarch32_LDRD_l_T1_A field U = 1 (Max)
    // ISET: T32
    // Fields: U=1, Rt=0, W=0, Rt2=0, P=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8DF0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRD_l_T1_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldrd_l_t1_a_field_w_0_min_0_e85f0000() {
    // Thumb encoding (32): 0xE85F0000
    // Test aarch32_LDRD_l_T1_A field W = 0 (Min)
    // ISET: T32
    // Fields: Rt=0, W=0, U=0, Rt2=0, P=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE85F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRD_l_T1_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldrd_l_t1_a_field_w_1_max_0_e87f0000() {
    // Thumb encoding (32): 0xE87F0000
    // Test aarch32_LDRD_l_T1_A field W = 1 (Max)
    // ISET: T32
    // Fields: U=0, Rt=0, W=1, Rt2=0, imm8=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE87F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRD_l_T1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrd_l_t1_a_field_rt_0_min_0_e85f0000() {
    // Thumb encoding (32): 0xE85F0000
    // Test aarch32_LDRD_l_T1_A field Rt = 0 (Min)
    // ISET: T32
    // Fields: P=0, Rt=0, Rt2=0, imm8=0, W=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE85F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRD_l_T1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrd_l_t1_a_field_rt_1_poweroftwo_0_e85f1000() {
    // Thumb encoding (32): 0xE85F1000
    // Test aarch32_LDRD_l_T1_A field Rt = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=0, Rt=1, W=0, P=0, Rt2=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE85F1000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRD_l_T1_A
/// ASL: `field Rt2 8 +: 4`
/// Requirement: FieldBoundary { field: "Rt2", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrd_l_t1_a_field_rt2_0_min_0_e85f0000() {
    // Thumb encoding (32): 0xE85F0000
    // Test aarch32_LDRD_l_T1_A field Rt2 = 0 (Min)
    // ISET: T32
    // Fields: Rt=0, U=0, Rt2=0, imm8=0, W=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE85F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRD_l_T1_A
/// ASL: `field Rt2 8 +: 4`
/// Requirement: FieldBoundary { field: "Rt2", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrd_l_t1_a_field_rt2_1_poweroftwo_0_e85f0100() {
    // Thumb encoding (32): 0xE85F0100
    // Test aarch32_LDRD_l_T1_A field Rt2 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=0, W=0, Rt=0, P=0, Rt2=1, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE85F0100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRD_l_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_ldrd_l_t1_a_field_imm8_0_zero_0_e85f0000() {
    // Thumb encoding (32): 0xE85F0000
    // Test aarch32_LDRD_l_T1_A field imm8 = 0 (Zero)
    // ISET: T32
    // Fields: W=0, Rt2=0, P=0, Rt=0, imm8=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE85F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRD_l_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_ldrd_l_t1_a_field_imm8_1_poweroftwo_0_e85f0001() {
    // Thumb encoding (32): 0xE85F0001
    // Test aarch32_LDRD_l_T1_A field imm8 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: P=0, Rt2=0, W=0, U=0, imm8=1, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE85F0001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRD_l_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_ldrd_l_t1_a_field_imm8_3_poweroftwominusone_0_e85f0003() {
    // Thumb encoding (32): 0xE85F0003
    // Test aarch32_LDRD_l_T1_A field imm8 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt2=0, Rt=0, imm8=3, P=0, U=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE85F0003;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRD_l_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_ldrd_l_t1_a_field_imm8_4_poweroftwo_0_e85f0004() {
    // Thumb encoding (32): 0xE85F0004
    // Test aarch32_LDRD_l_T1_A field imm8 = 4 (PowerOfTwo)
    // ISET: T32
    // Fields: P=0, Rt2=0, imm8=4, W=0, Rt=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE85F0004;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRD_l_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_ldrd_l_t1_a_field_imm8_7_poweroftwominusone_0_e85f0007() {
    // Thumb encoding (32): 0xE85F0007
    // Test aarch32_LDRD_l_T1_A field imm8 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, U=0, P=0, W=0, Rt2=0, imm8=7
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE85F0007;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRD_l_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_ldrd_l_t1_a_field_imm8_8_poweroftwo_0_e85f0008() {
    // Thumb encoding (32): 0xE85F0008
    // Test aarch32_LDRD_l_T1_A field imm8 = 8 (PowerOfTwo)
    // ISET: T32
    // Fields: U=0, imm8=8, Rt=0, P=0, W=0, Rt2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE85F0008;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRD_l_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_ldrd_l_t1_a_field_imm8_15_poweroftwominusone_0_e85f000f() {
    // Thumb encoding (32): 0xE85F000F
    // Test aarch32_LDRD_l_T1_A field imm8 = 15 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt2=0, U=0, P=0, Rt=0, imm8=15, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE85F000F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRD_l_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_ldrd_l_t1_a_field_imm8_16_poweroftwo_0_e85f0010() {
    // Thumb encoding (32): 0xE85F0010
    // Test aarch32_LDRD_l_T1_A field imm8 = 16 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt2=0, imm8=16, U=0, W=0, Rt=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE85F0010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRD_l_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_ldrd_l_t1_a_field_imm8_31_poweroftwominusone_0_e85f001f() {
    // Thumb encoding (32): 0xE85F001F
    // Test aarch32_LDRD_l_T1_A field imm8 = 31 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm8=31, Rt=0, U=0, P=0, W=0, Rt2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE85F001F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRD_l_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_ldrd_l_t1_a_field_imm8_32_poweroftwo_0_e85f0020() {
    // Thumb encoding (32): 0xE85F0020
    // Test aarch32_LDRD_l_T1_A field imm8 = 32 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=32, Rt2=0, U=0, P=0, W=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE85F0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRD_l_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_ldrd_l_t1_a_field_imm8_63_poweroftwominusone_0_e85f003f() {
    // Thumb encoding (32): 0xE85F003F
    // Test aarch32_LDRD_l_T1_A field imm8 = 63 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: P=0, W=0, imm8=63, U=0, Rt2=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE85F003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRD_l_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_ldrd_l_t1_a_field_imm8_64_poweroftwo_0_e85f0040() {
    // Thumb encoding (32): 0xE85F0040
    // Test aarch32_LDRD_l_T1_A field imm8 = 64 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt2=0, W=0, imm8=64, U=0, P=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE85F0040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRD_l_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 127, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (127)
#[test]
fn test_aarch32_ldrd_l_t1_a_field_imm8_127_poweroftwominusone_0_e85f007f() {
    // Thumb encoding (32): 0xE85F007F
    // Test aarch32_LDRD_l_T1_A field imm8 = 127 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt2=0, imm8=127, W=0, U=0, P=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE85F007F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRD_l_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_ldrd_l_t1_a_field_imm8_128_poweroftwo_0_e85f0080() {
    // Thumb encoding (32): 0xE85F0080
    // Test aarch32_LDRD_l_T1_A field imm8 = 128 (PowerOfTwo)
    // ISET: T32
    // Fields: U=0, P=0, Rt=0, Rt2=0, imm8=128, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE85F0080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRD_l_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 255, boundary: Max }
/// maximum immediate (255)
#[test]
fn test_aarch32_ldrd_l_t1_a_field_imm8_255_max_0_e85f00ff() {
    // Thumb encoding (32): 0xE85F00FF
    // Test aarch32_LDRD_l_T1_A field imm8 = 255 (Max)
    // ISET: T32
    // Fields: W=0, imm8=255, Rt2=0, P=0, Rt=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE85F00FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRD_l_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// P=0 (minimum value)
#[test]
fn test_aarch32_ldrd_l_t1_a_combo_0_0_e85f0000() {
    // Thumb encoding (32): 0xE85F0000
    // Test aarch32_LDRD_l_T1_A field combination: P=0, U=0, W=0, Rt=0, Rt2=0, imm8=0
    // ISET: T32
    // Fields: U=0, Rt2=0, imm8=0, P=0, Rt=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE85F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRD_l_T1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t2" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t2" }) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t2\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t2\" }) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrd_l_t1_a_invalid_0_0_e85f0000() {
    // Thumb encoding (32): 0xE85F0000
    // Test aarch32_LDRD_l_T1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t2" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t2" }) }
    // ISET: T32
    // Fields: U=0, Rt2=0, W=0, imm8=0, P=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE85F0000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRD_l_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrd_l_t1_a_invalid_1_0_e85f0000() {
    // Thumb encoding (32): 0xE85F0000
    // Test aarch32_LDRD_l_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: P=0, U=0, Rt2=0, imm8=0, W=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE85F0000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRD_l_T1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "W" }), rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"W\" }), rhs: LitBits([true]) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrd_l_t1_a_invalid_2_0_e85f0000() {
    // Thumb encoding (32): 0xE85F0000
    // Test aarch32_LDRD_l_T1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "W" }), rhs: LitBits([true]) }
    // ISET: T32
    // Fields: W=0, Rt2=0, Rt=0, imm8=0, P=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE85F0000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRD_l_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrd_l_t1_a_invalid_3_0_e85f0000() {
    // Thumb encoding (32): 0xE85F0000
    // Test aarch32_LDRD_l_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rt2=0, W=0, imm8=0, Rt=0, U=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE85F0000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRD_l_A1_A
/// ASL: `UMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple multiply
#[test]
fn test_aarch32_ldrd_l_a1_a_umull_oracle_0_9ba27c20() {
    // Test UMULL: simple multiply (oracle)
    // Encoding: 0x9BA27C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x2);
    set_w(&mut cpu, 2, 0x3);
    let encoding: u32 = 0x9BA27C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6, "X0 should be 0x0000000000000006");
}

/// Provenance: aarch32_LDRD_l_A1_A
/// ASL: `UMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max 32-bit * 2
#[test]
fn test_aarch32_ldrd_l_a1_a_umull_oracle_1_9ba27c20() {
    // Test UMULL: max 32-bit * 2 (oracle)
    // Encoding: 0x9BA27C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x9BA27C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0x00000001FFFFFFFE"
    );
}

/// Provenance: aarch32_LDRD_l_A1_A
/// ASL: `UMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// large positive * large positive
#[test]
fn test_aarch32_ldrd_l_a1_a_umull_oracle_2_9ba27c20() {
    // Test UMULL: large positive * large positive (oracle)
    // Encoding: 0x9BA27C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x7FFFFFFF);
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x9BA27C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x3FFFFFFF00000001");
}

/// Provenance: aarch32_LDRD_l_A1_A
/// ASL: `UMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max unsigned * max unsigned
#[test]
fn test_aarch32_ldrd_l_a1_a_umull_oracle_3_9ba27c20() {
    // Test UMULL: max unsigned * max unsigned (oracle)
    // Encoding: 0x9BA27C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x9BA27C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0xFFFFFFFE00000001");
}

/// Provenance: aarch32_LDRD_l_A1_A
/// ASL: `UMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// medium values
#[test]
fn test_aarch32_ldrd_l_a1_a_umull_oracle_4_9ba27c20() {
    // Test UMULL: medium values (oracle)
    // Encoding: 0x9BA27C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xC8);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x9BA27C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4E20, "X0 should be 0x0000000000004E20");
}

/// Provenance: aarch32_LDRD_l_A1_A
/// ASL: `UMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// 16-bit values
#[test]
fn test_aarch32_ldrd_l_a1_a_umull_oracle_5_9ba27c20() {
    // Test UMULL: 16-bit values (oracle)
    // Encoding: 0x9BA27C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x5678);
    set_w(&mut cpu, 1, 0x1234);
    let encoding: u32 = 0x9BA27C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6260060, "X0 should be 0x0000000006260060");
}

// ============================================================================
// aarch32_LDRH_l_A Tests
// ============================================================================

/// Provenance: aarch32_LDRH_l_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_ldrh_l_a1_a_field_cond_0_min_b0_005f00b0() {
    // Encoding: 0x005F00B0
    // Test aarch32_LDRH_l_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: P=0, imm4L=0, W=0, cond=0, Rt=0, imm4H=0, U=0
    let encoding: u32 = 0x005F00B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_l_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_ldrh_l_a1_a_field_cond_1_poweroftwo_b0_105f00b0() {
    // Encoding: 0x105F00B0
    // Test aarch32_LDRH_l_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, W=0, Rt=0, imm4H=0, cond=1, imm4L=0, P=0
    let encoding: u32 = 0x105F00B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_l_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_ldrh_l_a1_a_field_cond_2_poweroftwo_b0_205f00b0() {
    // Encoding: 0x205F00B0
    // Test aarch32_LDRH_l_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=2, U=0, imm4H=0, W=0, imm4L=0, Rt=0, P=0
    let encoding: u32 = 0x205F00B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_l_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_ldrh_l_a1_a_field_cond_3_poweroftwo_b0_305f00b0() {
    // Encoding: 0x305F00B0
    // Test aarch32_LDRH_l_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, cond=3, P=0, Rt=0, U=0, imm4H=0, imm4L=0
    let encoding: u32 = 0x305F00B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_l_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_ldrh_l_a1_a_field_cond_4_poweroftwo_b0_405f00b0() {
    // Encoding: 0x405F00B0
    // Test aarch32_LDRH_l_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4L=0, cond=4, P=0, U=0, W=0, Rt=0, imm4H=0
    let encoding: u32 = 0x405F00B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_l_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_ldrh_l_a1_a_field_cond_5_poweroftwo_b0_505f00b0() {
    // Encoding: 0x505F00B0
    // Test aarch32_LDRH_l_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4H=0, imm4L=0, Rt=0, U=0, cond=5, W=0, P=0
    let encoding: u32 = 0x505F00B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_l_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_ldrh_l_a1_a_field_cond_6_poweroftwo_b0_605f00b0() {
    // Encoding: 0x605F00B0
    // Test aarch32_LDRH_l_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, U=0, imm4H=0, P=0, Rt=0, imm4L=0, cond=6
    let encoding: u32 = 0x605F00B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_l_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_ldrh_l_a1_a_field_cond_7_poweroftwo_b0_705f00b0() {
    // Encoding: 0x705F00B0
    // Test aarch32_LDRH_l_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4H=0, P=0, U=0, cond=7, imm4L=0, W=0, Rt=0
    let encoding: u32 = 0x705F00B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_l_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_ldrh_l_a1_a_field_cond_8_poweroftwo_b0_805f00b0() {
    // Encoding: 0x805F00B0
    // Test aarch32_LDRH_l_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, imm4L=0, W=0, U=0, Rt=0, imm4H=0, cond=8
    let encoding: u32 = 0x805F00B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_l_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_ldrh_l_a1_a_field_cond_9_poweroftwo_b0_905f00b0() {
    // Encoding: 0x905F00B0
    // Test aarch32_LDRH_l_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, cond=9, W=0, imm4L=0, Rt=0, P=0, imm4H=0
    let encoding: u32 = 0x905F00B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_l_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_ldrh_l_a1_a_field_cond_10_poweroftwo_b0_a05f00b0() {
    // Encoding: 0xA05F00B0
    // Test aarch32_LDRH_l_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, cond=10, imm4L=0, P=0, imm4H=0, Rt=0, W=0
    let encoding: u32 = 0xA05F00B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_l_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_ldrh_l_a1_a_field_cond_11_poweroftwo_b0_b05f00b0() {
    // Encoding: 0xB05F00B0
    // Test aarch32_LDRH_l_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, cond=11, P=0, Rt=0, U=0, imm4H=0, imm4L=0
    let encoding: u32 = 0xB05F00B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_l_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_ldrh_l_a1_a_field_cond_12_poweroftwo_b0_c05f00b0() {
    // Encoding: 0xC05F00B0
    // Test aarch32_LDRH_l_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, cond=12, P=0, Rt=0, imm4H=0, imm4L=0, W=0
    let encoding: u32 = 0xC05F00B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_l_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_ldrh_l_a1_a_field_cond_13_poweroftwo_b0_d05f00b0() {
    // Encoding: 0xD05F00B0
    // Test aarch32_LDRH_l_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, P=0, imm4H=0, U=0, cond=13, W=0, imm4L=0
    let encoding: u32 = 0xD05F00B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_l_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_ldrh_l_a1_a_field_cond_14_poweroftwo_b0_e05f00b0() {
    // Encoding: 0xE05F00B0
    // Test aarch32_LDRH_l_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=14, P=0, W=0, Rt=0, U=0, imm4H=0, imm4L=0
    let encoding: u32 = 0xE05F00B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_l_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_ldrh_l_a1_a_field_cond_15_max_b0_f05f00b0() {
    // Encoding: 0xF05F00B0
    // Test aarch32_LDRH_l_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: W=0, Rt=0, imm4H=0, U=0, imm4L=0, P=0, cond=15
    let encoding: u32 = 0xF05F00B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_l_A1_A
/// ASL: `field P 24 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldrh_l_a1_a_field_p_0_min_b0_005f00b0() {
    // Encoding: 0x005F00B0
    // Test aarch32_LDRH_l_A1_A field P = 0 (Min)
    // ISET: A32
    // Fields: U=0, P=0, W=0, imm4H=0, imm4L=0, Rt=0, cond=0
    let encoding: u32 = 0x005F00B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_l_A1_A
/// ASL: `field P 24 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldrh_l_a1_a_field_p_1_max_b0_015f00b0() {
    // Encoding: 0x015F00B0
    // Test aarch32_LDRH_l_A1_A field P = 1 (Max)
    // ISET: A32
    // Fields: imm4L=0, imm4H=0, P=1, W=0, U=0, cond=0, Rt=0
    let encoding: u32 = 0x015F00B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_l_A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldrh_l_a1_a_field_u_0_min_b0_005f00b0() {
    // Encoding: 0x005F00B0
    // Test aarch32_LDRH_l_A1_A field U = 0 (Min)
    // ISET: A32
    // Fields: cond=0, imm4H=0, U=0, Rt=0, imm4L=0, P=0, W=0
    let encoding: u32 = 0x005F00B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_l_A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldrh_l_a1_a_field_u_1_max_b0_00df00b0() {
    // Encoding: 0x00DF00B0
    // Test aarch32_LDRH_l_A1_A field U = 1 (Max)
    // ISET: A32
    // Fields: imm4H=0, cond=0, imm4L=0, W=0, P=0, U=1, Rt=0
    let encoding: u32 = 0x00DF00B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_l_A1_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldrh_l_a1_a_field_w_0_min_b0_005f00b0() {
    // Encoding: 0x005F00B0
    // Test aarch32_LDRH_l_A1_A field W = 0 (Min)
    // ISET: A32
    // Fields: P=0, U=0, W=0, imm4L=0, cond=0, Rt=0, imm4H=0
    let encoding: u32 = 0x005F00B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_l_A1_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldrh_l_a1_a_field_w_1_max_b0_007f00b0() {
    // Encoding: 0x007F00B0
    // Test aarch32_LDRH_l_A1_A field W = 1 (Max)
    // ISET: A32
    // Fields: Rt=0, imm4H=0, imm4L=0, U=0, P=0, cond=0, W=1
    let encoding: u32 = 0x007F00B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_l_A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrh_l_a1_a_field_rt_0_min_b0_005f00b0() {
    // Encoding: 0x005F00B0
    // Test aarch32_LDRH_l_A1_A field Rt = 0 (Min)
    // ISET: A32
    // Fields: W=0, Rt=0, U=0, cond=0, P=0, imm4H=0, imm4L=0
    let encoding: u32 = 0x005F00B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_l_A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrh_l_a1_a_field_rt_1_poweroftwo_b0_005f10b0() {
    // Encoding: 0x005F10B0
    // Test aarch32_LDRH_l_A1_A field Rt = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4H=0, imm4L=0, U=0, cond=0, P=0, W=0, Rt=1
    let encoding: u32 = 0x005F10B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_l_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_ldrh_l_a1_a_field_imm4h_0_zero_b0_005f00b0() {
    // Encoding: 0x005F00B0
    // Test aarch32_LDRH_l_A1_A field imm4H = 0 (Zero)
    // ISET: A32
    // Fields: imm4H=0, Rt=0, P=0, W=0, imm4L=0, U=0, cond=0
    let encoding: u32 = 0x005F00B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_l_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_ldrh_l_a1_a_field_imm4h_1_poweroftwo_b0_005f01b0() {
    // Encoding: 0x005F01B0
    // Test aarch32_LDRH_l_A1_A field imm4H = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4L=0, cond=0, Rt=0, U=0, imm4H=1, P=0, W=0
    let encoding: u32 = 0x005F01B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_l_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_ldrh_l_a1_a_field_imm4h_3_poweroftwominusone_b0_005f03b0() {
    // Encoding: 0x005F03B0
    // Test aarch32_LDRH_l_A1_A field imm4H = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, imm4H=3, P=0, Rt=0, imm4L=0, W=0, U=0
    let encoding: u32 = 0x005F03B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_l_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_ldrh_l_a1_a_field_imm4h_4_poweroftwo_b0_005f04b0() {
    // Encoding: 0x005F04B0
    // Test aarch32_LDRH_l_A1_A field imm4H = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, cond=0, P=0, U=0, imm4H=4, imm4L=0, W=0
    let encoding: u32 = 0x005F04B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_l_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_aarch32_ldrh_l_a1_a_field_imm4h_7_poweroftwominusone_b0_005f07b0() {
    // Encoding: 0x005F07B0
    // Test aarch32_LDRH_l_A1_A field imm4H = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: W=0, P=0, Rt=0, imm4L=0, cond=0, U=0, imm4H=7
    let encoding: u32 = 0x005F07B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_l_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_ldrh_l_a1_a_field_imm4h_8_poweroftwo_b0_005f08b0() {
    // Encoding: 0x005F08B0
    // Test aarch32_LDRH_l_A1_A field imm4H = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, U=0, imm4H=8, imm4L=0, cond=0, W=0, Rt=0
    let encoding: u32 = 0x005F08B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_l_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_aarch32_ldrh_l_a1_a_field_imm4h_15_max_b0_005f0fb0() {
    // Encoding: 0x005F0FB0
    // Test aarch32_LDRH_l_A1_A field imm4H = 15 (Max)
    // ISET: A32
    // Fields: W=0, imm4H=15, P=0, cond=0, imm4L=0, U=0, Rt=0
    let encoding: u32 = 0x005F0FB0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_l_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_ldrh_l_a1_a_field_imm4l_0_zero_b0_005f00b0() {
    // Encoding: 0x005F00B0
    // Test aarch32_LDRH_l_A1_A field imm4L = 0 (Zero)
    // ISET: A32
    // Fields: cond=0, P=0, W=0, U=0, imm4H=0, imm4L=0, Rt=0
    let encoding: u32 = 0x005F00B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_l_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_ldrh_l_a1_a_field_imm4l_1_poweroftwo_b0_005f00b1() {
    // Encoding: 0x005F00B1
    // Test aarch32_LDRH_l_A1_A field imm4L = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, imm4L=1, U=0, Rt=0, imm4H=0, W=0, P=0
    let encoding: u32 = 0x005F00B1;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_l_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_ldrh_l_a1_a_field_imm4l_3_poweroftwominusone_b0_005f00b3() {
    // Encoding: 0x005F00B3
    // Test aarch32_LDRH_l_A1_A field imm4L = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rt=0, P=0, imm4H=0, imm4L=3, W=0, U=0, cond=0
    let encoding: u32 = 0x005F00B3;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_l_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_ldrh_l_a1_a_field_imm4l_4_poweroftwo_b0_005f00b4() {
    // Encoding: 0x005F00B4
    // Test aarch32_LDRH_l_A1_A field imm4L = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, imm4H=0, Rt=0, cond=0, imm4L=4, P=0, U=0
    let encoding: u32 = 0x005F00B4;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_l_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_aarch32_ldrh_l_a1_a_field_imm4l_7_poweroftwominusone_b0_005f00b7() {
    // Encoding: 0x005F00B7
    // Test aarch32_LDRH_l_A1_A field imm4L = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: U=0, cond=0, imm4H=0, P=0, W=0, Rt=0, imm4L=7
    let encoding: u32 = 0x005F00B7;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_l_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_ldrh_l_a1_a_field_imm4l_8_poweroftwo_b0_005f00b8() {
    // Encoding: 0x005F00B8
    // Test aarch32_LDRH_l_A1_A field imm4L = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4L=8, Rt=0, cond=0, P=0, imm4H=0, U=0, W=0
    let encoding: u32 = 0x005F00B8;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_l_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_aarch32_ldrh_l_a1_a_field_imm4l_15_max_b0_005f00bf() {
    // Encoding: 0x005F00BF
    // Test aarch32_LDRH_l_A1_A field imm4L = 15 (Max)
    // ISET: A32
    // Fields: cond=0, U=0, P=0, W=0, imm4L=15, imm4H=0, Rt=0
    let encoding: u32 = 0x005F00BF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_l_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_ldrh_l_a1_a_combo_0_b0_005f00b0() {
    // Encoding: 0x005F00B0
    // Test aarch32_LDRH_l_A1_A field combination: cond=0, P=0, U=0, W=0, Rt=0, imm4H=0, imm4L=0
    // ISET: A32
    // Fields: W=0, imm4H=0, P=0, imm4L=0, U=0, cond=0, Rt=0
    let encoding: u32 = 0x005F00B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_l_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_ldrh_l_a1_a_special_cond_0_condition_eq_176_005f00b0() {
    // Encoding: 0x005F00B0
    // Test aarch32_LDRH_l_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: P=0, W=0, imm4H=0, cond=0, imm4L=0, U=0, Rt=0
    let encoding: u32 = 0x005F00B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_l_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_ldrh_l_a1_a_special_cond_1_condition_ne_176_105f00b0() {
    // Encoding: 0x105F00B0
    // Test aarch32_LDRH_l_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: P=0, U=0, W=0, Rt=0, cond=1, imm4H=0, imm4L=0
    let encoding: u32 = 0x105F00B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_l_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_ldrh_l_a1_a_special_cond_2_condition_cs_hs_176_205f00b0() {
    // Encoding: 0x205F00B0
    // Test aarch32_LDRH_l_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: Rt=0, cond=2, imm4L=0, W=0, imm4H=0, P=0, U=0
    let encoding: u32 = 0x205F00B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_l_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_ldrh_l_a1_a_special_cond_3_condition_cc_lo_176_305f00b0() {
    // Encoding: 0x305F00B0
    // Test aarch32_LDRH_l_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: P=0, U=0, imm4L=0, W=0, Rt=0, cond=3, imm4H=0
    let encoding: u32 = 0x305F00B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_l_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_ldrh_l_a1_a_special_cond_4_condition_mi_176_405f00b0() {
    // Encoding: 0x405F00B0
    // Test aarch32_LDRH_l_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: W=0, P=0, cond=4, U=0, Rt=0, imm4H=0, imm4L=0
    let encoding: u32 = 0x405F00B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_l_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_ldrh_l_a1_a_special_cond_5_condition_pl_176_505f00b0() {
    // Encoding: 0x505F00B0
    // Test aarch32_LDRH_l_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: imm4H=0, imm4L=0, cond=5, W=0, P=0, U=0, Rt=0
    let encoding: u32 = 0x505F00B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_l_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_ldrh_l_a1_a_special_cond_6_condition_vs_176_605f00b0() {
    // Encoding: 0x605F00B0
    // Test aarch32_LDRH_l_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: P=0, Rt=0, imm4H=0, cond=6, U=0, W=0, imm4L=0
    let encoding: u32 = 0x605F00B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_l_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_ldrh_l_a1_a_special_cond_7_condition_vc_176_705f00b0() {
    // Encoding: 0x705F00B0
    // Test aarch32_LDRH_l_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: imm4H=0, P=0, W=0, Rt=0, U=0, imm4L=0, cond=7
    let encoding: u32 = 0x705F00B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_l_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_ldrh_l_a1_a_special_cond_8_condition_hi_176_805f00b0() {
    // Encoding: 0x805F00B0
    // Test aarch32_LDRH_l_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: Rt=0, cond=8, P=0, U=0, W=0, imm4H=0, imm4L=0
    let encoding: u32 = 0x805F00B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_l_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_ldrh_l_a1_a_special_cond_9_condition_ls_176_905f00b0() {
    // Encoding: 0x905F00B0
    // Test aarch32_LDRH_l_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: imm4H=0, U=0, P=0, cond=9, W=0, Rt=0, imm4L=0
    let encoding: u32 = 0x905F00B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_l_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_ldrh_l_a1_a_special_cond_10_condition_ge_176_a05f00b0() {
    // Encoding: 0xA05F00B0
    // Test aarch32_LDRH_l_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: imm4L=0, cond=10, imm4H=0, P=0, U=0, W=0, Rt=0
    let encoding: u32 = 0xA05F00B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_l_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_ldrh_l_a1_a_special_cond_11_condition_lt_176_b05f00b0() {
    // Encoding: 0xB05F00B0
    // Test aarch32_LDRH_l_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: cond=11, P=0, Rt=0, W=0, U=0, imm4L=0, imm4H=0
    let encoding: u32 = 0xB05F00B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_l_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_ldrh_l_a1_a_special_cond_12_condition_gt_176_c05f00b0() {
    // Encoding: 0xC05F00B0
    // Test aarch32_LDRH_l_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: U=0, cond=12, P=0, W=0, Rt=0, imm4H=0, imm4L=0
    let encoding: u32 = 0xC05F00B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_l_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_ldrh_l_a1_a_special_cond_13_condition_le_176_d05f00b0() {
    // Encoding: 0xD05F00B0
    // Test aarch32_LDRH_l_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: U=0, imm4H=0, P=0, Rt=0, imm4L=0, W=0, cond=13
    let encoding: u32 = 0xD05F00B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_l_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_ldrh_l_a1_a_special_cond_14_condition_al_176_e05f00b0() {
    // Encoding: 0xE05F00B0
    // Test aarch32_LDRH_l_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: P=0, imm4H=0, U=0, imm4L=0, cond=14, W=0, Rt=0
    let encoding: u32 = 0xE05F00B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_l_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_ldrh_l_a1_a_special_cond_15_condition_nv_176_f05f00b0() {
    // Encoding: 0xF05F00B0
    // Test aarch32_LDRH_l_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: cond=15, U=0, P=0, Rt=0, imm4H=0, imm4L=0, W=0
    let encoding: u32 = 0xF05F00B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_l_A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }) } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"wback\" }) } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrh_l_a1_a_invalid_0_b0_005f00b0() {
    // Encoding: 0x005F00B0
    // Test aarch32_LDRH_l_A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }) } }
    // ISET: A32
    // Fields: cond=0, imm4H=0, Rt=0, imm4L=0, W=0, U=0, P=0
    let encoding: u32 = 0x005F00B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRH_l_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrh_l_a1_a_invalid_1_b0_005f00b0() {
    // Encoding: 0x005F00B0
    // Test aarch32_LDRH_l_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: cond=0, U=0, P=0, imm4L=0, W=0, imm4H=0, Rt=0
    let encoding: u32 = 0x005F00B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRH_l_T1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldrh_l_t1_a_field_u_0_min_0_f83f0000() {
    // Thumb encoding (32): 0xF83F0000
    // Test aarch32_LDRH_l_T1_A field U = 0 (Min)
    // ISET: T32
    // Fields: U=0, Rt=0, imm12=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF83F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_l_T1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldrh_l_t1_a_field_u_1_max_0_f8bf0000() {
    // Thumb encoding (32): 0xF8BF0000
    // Test aarch32_LDRH_l_T1_A field U = 1 (Max)
    // ISET: T32
    // Fields: imm12=0, Rt=0, U=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8BF0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_l_T1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrh_l_t1_a_field_rt_0_min_0_f83f0000() {
    // Thumb encoding (32): 0xF83F0000
    // Test aarch32_LDRH_l_T1_A field Rt = 0 (Min)
    // ISET: T32
    // Fields: U=0, Rt=0, imm12=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF83F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_l_T1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrh_l_t1_a_field_rt_1_poweroftwo_0_f83f1000() {
    // Thumb encoding (32): 0xF83F1000
    // Test aarch32_LDRH_l_T1_A field Rt = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm12=0, Rt=1, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF83F1000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_ldrh_l_t1_a_field_imm12_0_zero_0_f83f0000() {
    // Thumb encoding (32): 0xF83F0000
    // Test aarch32_LDRH_l_T1_A field imm12 = 0 (Zero)
    // ISET: T32
    // Fields: imm12=0, U=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF83F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_ldrh_l_t1_a_field_imm12_1_poweroftwo_0_f83f0001() {
    // Thumb encoding (32): 0xF83F0001
    // Test aarch32_LDRH_l_T1_A field imm12 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: U=0, Rt=0, imm12=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF83F0001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_ldrh_l_t1_a_field_imm12_3_poweroftwominusone_0_f83f0003() {
    // Thumb encoding (32): 0xF83F0003
    // Test aarch32_LDRH_l_T1_A field imm12 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: U=0, Rt=0, imm12=3
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF83F0003;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_ldrh_l_t1_a_field_imm12_4_poweroftwo_0_f83f0004() {
    // Thumb encoding (32): 0xF83F0004
    // Test aarch32_LDRH_l_T1_A field imm12 = 4 (PowerOfTwo)
    // ISET: T32
    // Fields: imm12=4, U=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF83F0004;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_ldrh_l_t1_a_field_imm12_7_poweroftwominusone_0_f83f0007() {
    // Thumb encoding (32): 0xF83F0007
    // Test aarch32_LDRH_l_T1_A field imm12 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: U=0, Rt=0, imm12=7
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF83F0007;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_ldrh_l_t1_a_field_imm12_8_poweroftwo_0_f83f0008() {
    // Thumb encoding (32): 0xF83F0008
    // Test aarch32_LDRH_l_T1_A field imm12 = 8 (PowerOfTwo)
    // ISET: T32
    // Fields: U=0, Rt=0, imm12=8
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF83F0008;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_ldrh_l_t1_a_field_imm12_15_poweroftwominusone_0_f83f000f() {
    // Thumb encoding (32): 0xF83F000F
    // Test aarch32_LDRH_l_T1_A field imm12 = 15 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: U=0, imm12=15, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF83F000F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_ldrh_l_t1_a_field_imm12_16_poweroftwo_0_f83f0010() {
    // Thumb encoding (32): 0xF83F0010
    // Test aarch32_LDRH_l_T1_A field imm12 = 16 (PowerOfTwo)
    // ISET: T32
    // Fields: imm12=16, U=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF83F0010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_ldrh_l_t1_a_field_imm12_31_poweroftwominusone_0_f83f001f() {
    // Thumb encoding (32): 0xF83F001F
    // Test aarch32_LDRH_l_T1_A field imm12 = 31 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, imm12=31, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF83F001F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_ldrh_l_t1_a_field_imm12_32_poweroftwo_0_f83f0020() {
    // Thumb encoding (32): 0xF83F0020
    // Test aarch32_LDRH_l_T1_A field imm12 = 32 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, U=0, imm12=32
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF83F0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_ldrh_l_t1_a_field_imm12_63_poweroftwominusone_0_f83f003f() {
    // Thumb encoding (32): 0xF83F003F
    // Test aarch32_LDRH_l_T1_A field imm12 = 63 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, imm12=63, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF83F003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_ldrh_l_t1_a_field_imm12_64_poweroftwo_0_f83f0040() {
    // Thumb encoding (32): 0xF83F0040
    // Test aarch32_LDRH_l_T1_A field imm12 = 64 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, U=0, imm12=64
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF83F0040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 127, boundary: PowerOfTwoMinusOne }
/// 2^7 - 1 = 127
#[test]
fn test_aarch32_ldrh_l_t1_a_field_imm12_127_poweroftwominusone_0_f83f007f() {
    // Thumb encoding (32): 0xF83F007F
    // Test aarch32_LDRH_l_T1_A field imm12 = 127 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: U=0, Rt=0, imm12=127
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF83F007F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_ldrh_l_t1_a_field_imm12_128_poweroftwo_0_f83f0080() {
    // Thumb encoding (32): 0xF83F0080
    // Test aarch32_LDRH_l_T1_A field imm12 = 128 (PowerOfTwo)
    // ISET: T32
    // Fields: imm12=128, U=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF83F0080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 255, boundary: PowerOfTwoMinusOne }
/// 2^8 - 1 = 255
#[test]
fn test_aarch32_ldrh_l_t1_a_field_imm12_255_poweroftwominusone_0_f83f00ff() {
    // Thumb encoding (32): 0xF83F00FF
    // Test aarch32_LDRH_l_T1_A field imm12 = 255 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, U=0, imm12=255
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF83F00FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 256, boundary: PowerOfTwo }
/// power of 2 (2^8 = 256)
#[test]
fn test_aarch32_ldrh_l_t1_a_field_imm12_256_poweroftwo_0_f83f0100() {
    // Thumb encoding (32): 0xF83F0100
    // Test aarch32_LDRH_l_T1_A field imm12 = 256 (PowerOfTwo)
    // ISET: T32
    // Fields: imm12=256, U=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF83F0100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 511, boundary: PowerOfTwoMinusOne }
/// 2^9 - 1 = 511
#[test]
fn test_aarch32_ldrh_l_t1_a_field_imm12_511_poweroftwominusone_0_f83f01ff() {
    // Thumb encoding (32): 0xF83F01FF
    // Test aarch32_LDRH_l_T1_A field imm12 = 511 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: U=0, Rt=0, imm12=511
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF83F01FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 512, boundary: PowerOfTwo }
/// power of 2 (2^9 = 512)
#[test]
fn test_aarch32_ldrh_l_t1_a_field_imm12_512_poweroftwo_0_f83f0200() {
    // Thumb encoding (32): 0xF83F0200
    // Test aarch32_LDRH_l_T1_A field imm12 = 512 (PowerOfTwo)
    // ISET: T32
    // Fields: imm12=512, U=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF83F0200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1023, boundary: PowerOfTwoMinusOne }
/// 2^10 - 1 = 1023
#[test]
fn test_aarch32_ldrh_l_t1_a_field_imm12_1023_poweroftwominusone_0_f83f03ff() {
    // Thumb encoding (32): 0xF83F03FF
    // Test aarch32_LDRH_l_T1_A field imm12 = 1023 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, U=0, imm12=1023
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF83F03FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1024, boundary: PowerOfTwo }
/// power of 2 (2^10 = 1024)
#[test]
fn test_aarch32_ldrh_l_t1_a_field_imm12_1024_poweroftwo_0_f83f0400() {
    // Thumb encoding (32): 0xF83F0400
    // Test aarch32_LDRH_l_T1_A field imm12 = 1024 (PowerOfTwo)
    // ISET: T32
    // Fields: U=0, imm12=1024, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF83F0400;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2047, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (2047)
#[test]
fn test_aarch32_ldrh_l_t1_a_field_imm12_2047_poweroftwominusone_0_f83f07ff() {
    // Thumb encoding (32): 0xF83F07FF
    // Test aarch32_LDRH_l_T1_A field imm12 = 2047 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, imm12=2047, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF83F07FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2048, boundary: PowerOfTwo }
/// power of 2 (2^11 = 2048)
#[test]
fn test_aarch32_ldrh_l_t1_a_field_imm12_2048_poweroftwo_0_f83f0800() {
    // Thumb encoding (32): 0xF83F0800
    // Test aarch32_LDRH_l_T1_A field imm12 = 2048 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, U=0, imm12=2048
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF83F0800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4095, boundary: Max }
/// maximum immediate (4095)
#[test]
fn test_aarch32_ldrh_l_t1_a_field_imm12_4095_max_0_f83f0fff() {
    // Thumb encoding (32): 0xF83F0FFF
    // Test aarch32_LDRH_l_T1_A field imm12 = 4095 (Max)
    // ISET: T32
    // Fields: U=0, imm12=4095, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF83F0FFF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_l_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=0 (minimum value)
#[test]
fn test_aarch32_ldrh_l_t1_a_combo_0_0_f83f0000() {
    // Thumb encoding (32): 0xF83F0000
    // Test aarch32_LDRH_l_T1_A field combination: U=0, Rt=0, imm12=0
    // ISET: T32
    // Fields: Rt=0, imm12=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF83F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_l_A1_A
/// ASL: `UMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple multiply
#[test]
fn test_aarch32_ldrh_l_a1_a_umull_oracle_0_9ba27c20() {
    // Test UMULL: simple multiply (oracle)
    // Encoding: 0x9BA27C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3);
    set_w(&mut cpu, 1, 0x2);
    let encoding: u32 = 0x9BA27C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6, "X0 should be 0x0000000000000006");
}

/// Provenance: aarch32_LDRH_l_A1_A
/// ASL: `UMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max 32-bit * 2
#[test]
fn test_aarch32_ldrh_l_a1_a_umull_oracle_1_9ba27c20() {
    // Test UMULL: max 32-bit * 2 (oracle)
    // Encoding: 0x9BA27C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x9BA27C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0x00000001FFFFFFFE"
    );
}

/// Provenance: aarch32_LDRH_l_A1_A
/// ASL: `UMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// large positive * large positive
#[test]
fn test_aarch32_ldrh_l_a1_a_umull_oracle_2_9ba27c20() {
    // Test UMULL: large positive * large positive (oracle)
    // Encoding: 0x9BA27C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    set_w(&mut cpu, 2, 0x7FFFFFFF);
    let encoding: u32 = 0x9BA27C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x3FFFFFFF00000001");
}

/// Provenance: aarch32_LDRH_l_A1_A
/// ASL: `UMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max unsigned * max unsigned
#[test]
fn test_aarch32_ldrh_l_a1_a_umull_oracle_3_9ba27c20() {
    // Test UMULL: max unsigned * max unsigned (oracle)
    // Encoding: 0x9BA27C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x9BA27C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0xFFFFFFFE00000001");
}

/// Provenance: aarch32_LDRH_l_A1_A
/// ASL: `UMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// medium values
#[test]
fn test_aarch32_ldrh_l_a1_a_umull_oracle_4_9ba27c20() {
    // Test UMULL: medium values (oracle)
    // Encoding: 0x9BA27C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xC8);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x9BA27C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4E20, "X0 should be 0x0000000000004E20");
}

/// Provenance: aarch32_LDRH_l_A1_A
/// ASL: `UMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// 16-bit values
#[test]
fn test_aarch32_ldrh_l_a1_a_umull_oracle_5_9ba27c20() {
    // Test UMULL: 16-bit values (oracle)
    // Encoding: 0x9BA27C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1234);
    set_w(&mut cpu, 2, 0x5678);
    let encoding: u32 = 0x9BA27C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6260060, "X0 should be 0x0000000006260060");
}

// ============================================================================
// aarch32_LDAEXB_A Tests
// ============================================================================

/// Provenance: aarch32_LDAEXB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_ldaexb_a1_a_field_cond_0_min_290_01d00290() {
    // Encoding: 0x01D00290
    // Test aarch32_LDAEXB_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rn=0, Rt=0
    let encoding: u32 = 0x01D00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_ldaexb_a1_a_field_cond_1_poweroftwo_290_11d00290() {
    // Encoding: 0x11D00290
    // Test aarch32_LDAEXB_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, Rn=0, cond=1
    let encoding: u32 = 0x11D00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_ldaexb_a1_a_field_cond_2_poweroftwo_290_21d00290() {
    // Encoding: 0x21D00290
    // Test aarch32_LDAEXB_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=2, Rt=0
    let encoding: u32 = 0x21D00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_ldaexb_a1_a_field_cond_3_poweroftwo_290_31d00290() {
    // Encoding: 0x31D00290
    // Test aarch32_LDAEXB_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=3
    let encoding: u32 = 0x31D00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_ldaexb_a1_a_field_cond_4_poweroftwo_290_41d00290() {
    // Encoding: 0x41D00290
    // Test aarch32_LDAEXB_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=4
    let encoding: u32 = 0x41D00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_ldaexb_a1_a_field_cond_5_poweroftwo_290_51d00290() {
    // Encoding: 0x51D00290
    // Test aarch32_LDAEXB_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=5, Rn=0, Rt=0
    let encoding: u32 = 0x51D00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_ldaexb_a1_a_field_cond_6_poweroftwo_290_61d00290() {
    // Encoding: 0x61D00290
    // Test aarch32_LDAEXB_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=6, Rt=0
    let encoding: u32 = 0x61D00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_ldaexb_a1_a_field_cond_7_poweroftwo_290_71d00290() {
    // Encoding: 0x71D00290
    // Test aarch32_LDAEXB_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=7, Rt=0
    let encoding: u32 = 0x71D00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_ldaexb_a1_a_field_cond_8_poweroftwo_290_81d00290() {
    // Encoding: 0x81D00290
    // Test aarch32_LDAEXB_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=8, Rn=0, Rt=0
    let encoding: u32 = 0x81D00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_ldaexb_a1_a_field_cond_9_poweroftwo_290_91d00290() {
    // Encoding: 0x91D00290
    // Test aarch32_LDAEXB_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=9, Rt=0
    let encoding: u32 = 0x91D00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_ldaexb_a1_a_field_cond_10_poweroftwo_290_a1d00290() {
    // Encoding: 0xA1D00290
    // Test aarch32_LDAEXB_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=10, Rt=0
    let encoding: u32 = 0xA1D00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_ldaexb_a1_a_field_cond_11_poweroftwo_290_b1d00290() {
    // Encoding: 0xB1D00290
    // Test aarch32_LDAEXB_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=11, Rt=0, Rn=0
    let encoding: u32 = 0xB1D00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_ldaexb_a1_a_field_cond_12_poweroftwo_290_c1d00290() {
    // Encoding: 0xC1D00290
    // Test aarch32_LDAEXB_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=12, Rt=0
    let encoding: u32 = 0xC1D00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_ldaexb_a1_a_field_cond_13_poweroftwo_290_d1d00290() {
    // Encoding: 0xD1D00290
    // Test aarch32_LDAEXB_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=13, Rt=0, Rn=0
    let encoding: u32 = 0xD1D00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_ldaexb_a1_a_field_cond_14_poweroftwo_290_e1d00290() {
    // Encoding: 0xE1D00290
    // Test aarch32_LDAEXB_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=14, Rt=0
    let encoding: u32 = 0xE1D00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_ldaexb_a1_a_field_cond_15_max_290_f1d00290() {
    // Encoding: 0xF1D00290
    // Test aarch32_LDAEXB_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: cond=15, Rt=0, Rn=0
    let encoding: u32 = 0xF1D00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXB_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldaexb_a1_a_field_rn_0_min_290_01d00290() {
    // Encoding: 0x01D00290
    // Test aarch32_LDAEXB_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rn=0, Rt=0
    let encoding: u32 = 0x01D00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXB_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldaexb_a1_a_field_rn_1_poweroftwo_290_01d10290() {
    // Encoding: 0x01D10290
    // Test aarch32_LDAEXB_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Rt=0, Rn=1
    let encoding: u32 = 0x01D10290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXB_A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldaexb_a1_a_field_rt_0_min_290_01d00290() {
    // Encoding: 0x01D00290
    // Test aarch32_LDAEXB_A1_A field Rt = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rt=0, Rn=0
    let encoding: u32 = 0x01D00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXB_A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldaexb_a1_a_field_rt_1_poweroftwo_290_01d01290() {
    // Encoding: 0x01D01290
    // Test aarch32_LDAEXB_A1_A field Rt = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Rn=0, Rt=1
    let encoding: u32 = 0x01D01290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXB_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_ldaexb_a1_a_combo_0_290_01d00290() {
    // Encoding: 0x01D00290
    // Test aarch32_LDAEXB_A1_A field combination: cond=0, Rn=0, Rt=0
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=0
    let encoding: u32 = 0x01D00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXB_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_ldaexb_a1_a_special_cond_0_condition_eq_656_01d00290() {
    // Encoding: 0x01D00290
    // Test aarch32_LDAEXB_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=0
    let encoding: u32 = 0x01D00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXB_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_ldaexb_a1_a_special_cond_1_condition_ne_656_11d00290() {
    // Encoding: 0x11D00290
    // Test aarch32_LDAEXB_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: Rt=0, cond=1, Rn=0
    let encoding: u32 = 0x11D00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXB_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_ldaexb_a1_a_special_cond_2_condition_cs_hs_656_21d00290() {
    // Encoding: 0x21D00290
    // Test aarch32_LDAEXB_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: cond=2, Rt=0, Rn=0
    let encoding: u32 = 0x21D00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXB_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_ldaexb_a1_a_special_cond_3_condition_cc_lo_656_31d00290() {
    // Encoding: 0x31D00290
    // Test aarch32_LDAEXB_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=3
    let encoding: u32 = 0x31D00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXB_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_ldaexb_a1_a_special_cond_4_condition_mi_656_41d00290() {
    // Encoding: 0x41D00290
    // Test aarch32_LDAEXB_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: cond=4, Rt=0, Rn=0
    let encoding: u32 = 0x41D00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXB_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_ldaexb_a1_a_special_cond_5_condition_pl_656_51d00290() {
    // Encoding: 0x51D00290
    // Test aarch32_LDAEXB_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: cond=5, Rn=0, Rt=0
    let encoding: u32 = 0x51D00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXB_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_ldaexb_a1_a_special_cond_6_condition_vs_656_61d00290() {
    // Encoding: 0x61D00290
    // Test aarch32_LDAEXB_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: cond=6, Rt=0, Rn=0
    let encoding: u32 = 0x61D00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXB_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_ldaexb_a1_a_special_cond_7_condition_vc_656_71d00290() {
    // Encoding: 0x71D00290
    // Test aarch32_LDAEXB_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: Rt=0, cond=7, Rn=0
    let encoding: u32 = 0x71D00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXB_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_ldaexb_a1_a_special_cond_8_condition_hi_656_81d00290() {
    // Encoding: 0x81D00290
    // Test aarch32_LDAEXB_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: Rt=0, cond=8, Rn=0
    let encoding: u32 = 0x81D00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXB_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_ldaexb_a1_a_special_cond_9_condition_ls_656_91d00290() {
    // Encoding: 0x91D00290
    // Test aarch32_LDAEXB_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=9
    let encoding: u32 = 0x91D00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXB_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_ldaexb_a1_a_special_cond_10_condition_ge_656_a1d00290() {
    // Encoding: 0xA1D00290
    // Test aarch32_LDAEXB_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: Rt=0, cond=10, Rn=0
    let encoding: u32 = 0xA1D00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXB_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_ldaexb_a1_a_special_cond_11_condition_lt_656_b1d00290() {
    // Encoding: 0xB1D00290
    // Test aarch32_LDAEXB_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: cond=11, Rn=0, Rt=0
    let encoding: u32 = 0xB1D00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXB_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_ldaexb_a1_a_special_cond_12_condition_gt_656_c1d00290() {
    // Encoding: 0xC1D00290
    // Test aarch32_LDAEXB_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: Rn=0, cond=12, Rt=0
    let encoding: u32 = 0xC1D00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXB_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_ldaexb_a1_a_special_cond_13_condition_le_656_d1d00290() {
    // Encoding: 0xD1D00290
    // Test aarch32_LDAEXB_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: Rt=0, cond=13, Rn=0
    let encoding: u32 = 0xD1D00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXB_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_ldaexb_a1_a_special_cond_14_condition_al_656_e1d00290() {
    // Encoding: 0xE1D00290
    // Test aarch32_LDAEXB_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: cond=14, Rt=0, Rn=0
    let encoding: u32 = 0xE1D00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXB_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_ldaexb_a1_a_special_cond_15_condition_nv_656_f1d00290() {
    // Encoding: 0xF1D00290
    // Test aarch32_LDAEXB_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: Rt=0, cond=15, Rn=0
    let encoding: u32 = 0xF1D00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXB_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldaexb_a1_a_invalid_0_290_01d00290() {
    // Encoding: 0x01D00290
    // Test aarch32_LDAEXB_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }
    // ISET: A32
    // Fields: Rn=0, cond=0, Rt=0
    let encoding: u32 = 0x01D00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDAEXB_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldaexb_a1_a_invalid_1_290_01d00290() {
    // Encoding: 0x01D00290
    // Test aarch32_LDAEXB_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: cond=0, Rt=0, Rn=0
    let encoding: u32 = 0x01D00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDAEXB_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldaexb_t1_a_field_rn_0_min_c0_e8d000c0() {
    // Thumb encoding (32): 0xE8D000C0
    // Test aarch32_LDAEXB_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8D000C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDAEXB_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldaexb_t1_a_field_rn_1_poweroftwo_c0_e8d100c0() {
    // Thumb encoding (32): 0xE8D100C0
    // Test aarch32_LDAEXB_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, Rn=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8D100C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDAEXB_T1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldaexb_t1_a_field_rt_0_min_c0_e8d000c0() {
    // Thumb encoding (32): 0xE8D000C0
    // Test aarch32_LDAEXB_T1_A field Rt = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8D000C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDAEXB_T1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldaexb_t1_a_field_rt_1_poweroftwo_c0_e8d010c0() {
    // Thumb encoding (32): 0xE8D010C0
    // Test aarch32_LDAEXB_T1_A field Rt = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Rt=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8D010C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDAEXB_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_ldaexb_t1_a_combo_0_c0_e8d000c0() {
    // Thumb encoding (32): 0xE8D000C0
    // Test aarch32_LDAEXB_T1_A field combination: Rn=0, Rt=0
    // ISET: T32
    // Fields: Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8D000C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDAEXB_T1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldaexb_t1_a_invalid_0_c0_e8d000c0() {
    // Thumb encoding (32): 0xE8D000C0
    // Test aarch32_LDAEXB_T1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }
    // ISET: T32
    // Fields: Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8D000C0;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_LDAEXB_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldaexb_t1_a_invalid_1_c0_e8d000c0() {
    // Thumb encoding (32): 0xE8D000C0
    // Test aarch32_LDAEXB_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8D000C0;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_LDAEXB_A1_A
/// ASL: `SMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple multiply
#[test]
fn test_aarch32_ldaexb_a1_a_smull_oracle_0_9b227c20() {
    // Test SMULL: simple multiply (oracle)
    // Encoding: 0x9B227C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x2);
    set_w(&mut cpu, 2, 0x3);
    let encoding: u32 = 0x9B227C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6, "X0 should be 0x0000000000000006");
}

/// Provenance: aarch32_LDAEXB_A1_A
/// ASL: `SMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max 32-bit * 2
#[test]
fn test_aarch32_ldaexb_a1_a_smull_oracle_1_9b227c20() {
    // Test SMULL: max 32-bit * 2 (oracle)
    // Encoding: 0x9B227C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x9B227C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0xFFFFFFFFFFFFFFFE"
    );
}

/// Provenance: aarch32_LDAEXB_A1_A
/// ASL: `SMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// large positive * large positive
#[test]
fn test_aarch32_ldaexb_a1_a_smull_oracle_2_9b227c20() {
    // Test SMULL: large positive * large positive (oracle)
    // Encoding: 0x9B227C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x7FFFFFFF);
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x9B227C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x3FFFFFFF00000001");
}

/// Provenance: aarch32_LDAEXB_A1_A
/// ASL: `SMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max unsigned * max unsigned
#[test]
fn test_aarch32_ldaexb_a1_a_smull_oracle_3_9b227c20() {
    // Test SMULL: max unsigned * max unsigned (oracle)
    // Encoding: 0x9B227C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x9B227C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x0000000000000001");
}

/// Provenance: aarch32_LDAEXB_A1_A
/// ASL: `SMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// medium values
#[test]
fn test_aarch32_ldaexb_a1_a_smull_oracle_4_9b227c20() {
    // Test SMULL: medium values (oracle)
    // Encoding: 0x9B227C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xC8);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x9B227C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4E20, "X0 should be 0x0000000000004E20");
}

/// Provenance: aarch32_LDAEXB_A1_A
/// ASL: `SMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// 16-bit values
#[test]
fn test_aarch32_ldaexb_a1_a_smull_oracle_5_9b227c20() {
    // Test SMULL: 16-bit values (oracle)
    // Encoding: 0x9B227C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x5678);
    set_w(&mut cpu, 1, 0x1234);
    let encoding: u32 = 0x9B227C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6260060, "X0 should be 0x0000000006260060");
}

// ============================================================================
// aarch32_LDREXH_A Tests
// ============================================================================

/// Provenance: aarch32_LDREXH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_ldrexh_a1_a_field_cond_0_min_390_01f00390() {
    // Encoding: 0x01F00390
    // Test aarch32_LDREXH_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: Rt=0, Rn=0, cond=0
    let encoding: u32 = 0x01F00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_ldrexh_a1_a_field_cond_1_poweroftwo_390_11f00390() {
    // Encoding: 0x11F00390
    // Test aarch32_LDREXH_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=1
    let encoding: u32 = 0x11F00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_ldrexh_a1_a_field_cond_2_poweroftwo_390_21f00390() {
    // Encoding: 0x21F00390
    // Test aarch32_LDREXH_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=2
    let encoding: u32 = 0x21F00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_ldrexh_a1_a_field_cond_3_poweroftwo_390_31f00390() {
    // Encoding: 0x31F00390
    // Test aarch32_LDREXH_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=3
    let encoding: u32 = 0x31F00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_ldrexh_a1_a_field_cond_4_poweroftwo_390_41f00390() {
    // Encoding: 0x41F00390
    // Test aarch32_LDREXH_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, cond=4, Rn=0
    let encoding: u32 = 0x41F00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_ldrexh_a1_a_field_cond_5_poweroftwo_390_51f00390() {
    // Encoding: 0x51F00390
    // Test aarch32_LDREXH_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=5, Rn=0, Rt=0
    let encoding: u32 = 0x51F00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_ldrexh_a1_a_field_cond_6_poweroftwo_390_61f00390() {
    // Encoding: 0x61F00390
    // Test aarch32_LDREXH_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, cond=6, Rn=0
    let encoding: u32 = 0x61F00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_ldrexh_a1_a_field_cond_7_poweroftwo_390_71f00390() {
    // Encoding: 0x71F00390
    // Test aarch32_LDREXH_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=7, Rt=0
    let encoding: u32 = 0x71F00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_ldrexh_a1_a_field_cond_8_poweroftwo_390_81f00390() {
    // Encoding: 0x81F00390
    // Test aarch32_LDREXH_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=8, Rt=0
    let encoding: u32 = 0x81F00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_ldrexh_a1_a_field_cond_9_poweroftwo_390_91f00390() {
    // Encoding: 0x91F00390
    // Test aarch32_LDREXH_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=9, Rt=0
    let encoding: u32 = 0x91F00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_ldrexh_a1_a_field_cond_10_poweroftwo_390_a1f00390() {
    // Encoding: 0xA1F00390
    // Test aarch32_LDREXH_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=10, Rt=0
    let encoding: u32 = 0xA1F00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_ldrexh_a1_a_field_cond_11_poweroftwo_390_b1f00390() {
    // Encoding: 0xB1F00390
    // Test aarch32_LDREXH_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=11, Rn=0, Rt=0
    let encoding: u32 = 0xB1F00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_ldrexh_a1_a_field_cond_12_poweroftwo_390_c1f00390() {
    // Encoding: 0xC1F00390
    // Test aarch32_LDREXH_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=12, Rn=0, Rt=0
    let encoding: u32 = 0xC1F00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_ldrexh_a1_a_field_cond_13_poweroftwo_390_d1f00390() {
    // Encoding: 0xD1F00390
    // Test aarch32_LDREXH_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=13, Rt=0
    let encoding: u32 = 0xD1F00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_ldrexh_a1_a_field_cond_14_poweroftwo_390_e1f00390() {
    // Encoding: 0xE1F00390
    // Test aarch32_LDREXH_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=14, Rt=0
    let encoding: u32 = 0xE1F00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_ldrexh_a1_a_field_cond_15_max_390_f1f00390() {
    // Encoding: 0xF1F00390
    // Test aarch32_LDREXH_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: Rn=0, cond=15, Rt=0
    let encoding: u32 = 0xF1F00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXH_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrexh_a1_a_field_rn_0_min_390_01f00390() {
    // Encoding: 0x01F00390
    // Test aarch32_LDREXH_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rt=0, Rn=0
    let encoding: u32 = 0x01F00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXH_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrexh_a1_a_field_rn_1_poweroftwo_390_01f10390() {
    // Encoding: 0x01F10390
    // Test aarch32_LDREXH_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=1, cond=0, Rt=0
    let encoding: u32 = 0x01F10390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXH_A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrexh_a1_a_field_rt_0_min_390_01f00390() {
    // Encoding: 0x01F00390
    // Test aarch32_LDREXH_A1_A field Rt = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rn=0, Rt=0
    let encoding: u32 = 0x01F00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXH_A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrexh_a1_a_field_rt_1_poweroftwo_390_01f01390() {
    // Encoding: 0x01F01390
    // Test aarch32_LDREXH_A1_A field Rt = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rt=1, cond=0
    let encoding: u32 = 0x01F01390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXH_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_ldrexh_a1_a_combo_0_390_01f00390() {
    // Encoding: 0x01F00390
    // Test aarch32_LDREXH_A1_A field combination: cond=0, Rn=0, Rt=0
    // ISET: A32
    // Fields: cond=0, Rn=0, Rt=0
    let encoding: u32 = 0x01F00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXH_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_ldrexh_a1_a_special_cond_0_condition_eq_912_01f00390() {
    // Encoding: 0x01F00390
    // Test aarch32_LDREXH_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=0
    let encoding: u32 = 0x01F00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXH_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_ldrexh_a1_a_special_cond_1_condition_ne_912_11f00390() {
    // Encoding: 0x11F00390
    // Test aarch32_LDREXH_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: Rn=0, cond=1, Rt=0
    let encoding: u32 = 0x11F00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXH_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_ldrexh_a1_a_special_cond_2_condition_cs_hs_912_21f00390() {
    // Encoding: 0x21F00390
    // Test aarch32_LDREXH_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: Rn=0, cond=2, Rt=0
    let encoding: u32 = 0x21F00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXH_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_ldrexh_a1_a_special_cond_3_condition_cc_lo_912_31f00390() {
    // Encoding: 0x31F00390
    // Test aarch32_LDREXH_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: Rt=0, cond=3, Rn=0
    let encoding: u32 = 0x31F00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXH_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_ldrexh_a1_a_special_cond_4_condition_mi_912_41f00390() {
    // Encoding: 0x41F00390
    // Test aarch32_LDREXH_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: Rn=0, cond=4, Rt=0
    let encoding: u32 = 0x41F00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXH_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_ldrexh_a1_a_special_cond_5_condition_pl_912_51f00390() {
    // Encoding: 0x51F00390
    // Test aarch32_LDREXH_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: Rt=0, cond=5, Rn=0
    let encoding: u32 = 0x51F00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXH_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_ldrexh_a1_a_special_cond_6_condition_vs_912_61f00390() {
    // Encoding: 0x61F00390
    // Test aarch32_LDREXH_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: Rn=0, cond=6, Rt=0
    let encoding: u32 = 0x61F00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXH_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_ldrexh_a1_a_special_cond_7_condition_vc_912_71f00390() {
    // Encoding: 0x71F00390
    // Test aarch32_LDREXH_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: Rn=0, cond=7, Rt=0
    let encoding: u32 = 0x71F00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXH_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_ldrexh_a1_a_special_cond_8_condition_hi_912_81f00390() {
    // Encoding: 0x81F00390
    // Test aarch32_LDREXH_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: cond=8, Rt=0, Rn=0
    let encoding: u32 = 0x81F00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXH_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_ldrexh_a1_a_special_cond_9_condition_ls_912_91f00390() {
    // Encoding: 0x91F00390
    // Test aarch32_LDREXH_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: Rt=0, Rn=0, cond=9
    let encoding: u32 = 0x91F00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXH_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_ldrexh_a1_a_special_cond_10_condition_ge_912_a1f00390() {
    // Encoding: 0xA1F00390
    // Test aarch32_LDREXH_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: Rt=0, Rn=0, cond=10
    let encoding: u32 = 0xA1F00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXH_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_ldrexh_a1_a_special_cond_11_condition_lt_912_b1f00390() {
    // Encoding: 0xB1F00390
    // Test aarch32_LDREXH_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: cond=11, Rn=0, Rt=0
    let encoding: u32 = 0xB1F00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXH_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_ldrexh_a1_a_special_cond_12_condition_gt_912_c1f00390() {
    // Encoding: 0xC1F00390
    // Test aarch32_LDREXH_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=12
    let encoding: u32 = 0xC1F00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXH_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_ldrexh_a1_a_special_cond_13_condition_le_912_d1f00390() {
    // Encoding: 0xD1F00390
    // Test aarch32_LDREXH_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: Rn=0, cond=13, Rt=0
    let encoding: u32 = 0xD1F00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXH_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_ldrexh_a1_a_special_cond_14_condition_al_912_e1f00390() {
    // Encoding: 0xE1F00390
    // Test aarch32_LDREXH_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: cond=14, Rn=0, Rt=0
    let encoding: u32 = 0xE1F00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXH_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_ldrexh_a1_a_special_cond_15_condition_nv_912_f1f00390() {
    // Encoding: 0xF1F00390
    // Test aarch32_LDREXH_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: cond=15, Rt=0, Rn=0
    let encoding: u32 = 0xF1F00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDREXH_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrexh_a1_a_invalid_0_390_01f00390() {
    // Encoding: 0x01F00390
    // Test aarch32_LDREXH_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=0
    let encoding: u32 = 0x01F00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDREXH_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrexh_a1_a_invalid_1_390_01f00390() {
    // Encoding: 0x01F00390
    // Test aarch32_LDREXH_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Rn=0, cond=0, Rt=0
    let encoding: u32 = 0x01F00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDREXH_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrexh_t1_a_field_rn_0_min_50_e8d00050() {
    // Thumb encoding (32): 0xE8D00050
    // Test aarch32_LDREXH_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8D00050;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDREXH_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrexh_t1_a_field_rn_1_poweroftwo_50_e8d10050() {
    // Thumb encoding (32): 0xE8D10050
    // Test aarch32_LDREXH_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=1, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8D10050;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDREXH_T1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrexh_t1_a_field_rt_0_min_50_e8d00050() {
    // Thumb encoding (32): 0xE8D00050
    // Test aarch32_LDREXH_T1_A field Rt = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8D00050;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDREXH_T1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrexh_t1_a_field_rt_1_poweroftwo_50_e8d01050() {
    // Thumb encoding (32): 0xE8D01050
    // Test aarch32_LDREXH_T1_A field Rt = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=1, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8D01050;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDREXH_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_ldrexh_t1_a_combo_0_50_e8d00050() {
    // Thumb encoding (32): 0xE8D00050
    // Test aarch32_LDREXH_T1_A field combination: Rn=0, Rt=0
    // ISET: T32
    // Fields: Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8D00050;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDREXH_T1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrexh_t1_a_invalid_0_50_e8d00050() {
    // Thumb encoding (32): 0xE8D00050
    // Test aarch32_LDREXH_T1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }
    // ISET: T32
    // Fields: Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8D00050;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_LDREXH_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrexh_t1_a_invalid_1_50_e8d00050() {
    // Thumb encoding (32): 0xE8D00050
    // Test aarch32_LDREXH_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8D00050;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_LDREXH_A1_A
/// ASL: `SMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple multiply
#[test]
fn test_aarch32_ldrexh_a1_a_smull_oracle_0_9b227c20() {
    // Test SMULL: simple multiply (oracle)
    // Encoding: 0x9B227C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3);
    set_w(&mut cpu, 1, 0x2);
    let encoding: u32 = 0x9B227C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6, "X0 should be 0x0000000000000006");
}

/// Provenance: aarch32_LDREXH_A1_A
/// ASL: `SMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max 32-bit * 2
#[test]
fn test_aarch32_ldrexh_a1_a_smull_oracle_1_9b227c20() {
    // Test SMULL: max 32-bit * 2 (oracle)
    // Encoding: 0x9B227C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x9B227C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0xFFFFFFFFFFFFFFFE"
    );
}

/// Provenance: aarch32_LDREXH_A1_A
/// ASL: `SMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// large positive * large positive
#[test]
fn test_aarch32_ldrexh_a1_a_smull_oracle_2_9b227c20() {
    // Test SMULL: large positive * large positive (oracle)
    // Encoding: 0x9B227C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    set_w(&mut cpu, 2, 0x7FFFFFFF);
    let encoding: u32 = 0x9B227C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x3FFFFFFF00000001");
}

/// Provenance: aarch32_LDREXH_A1_A
/// ASL: `SMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max unsigned * max unsigned
#[test]
fn test_aarch32_ldrexh_a1_a_smull_oracle_3_9b227c20() {
    // Test SMULL: max unsigned * max unsigned (oracle)
    // Encoding: 0x9B227C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x9B227C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x0000000000000001");
}

/// Provenance: aarch32_LDREXH_A1_A
/// ASL: `SMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// medium values
#[test]
fn test_aarch32_ldrexh_a1_a_smull_oracle_4_9b227c20() {
    // Test SMULL: medium values (oracle)
    // Encoding: 0x9B227C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xC8);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x9B227C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4E20, "X0 should be 0x0000000000004E20");
}

/// Provenance: aarch32_LDREXH_A1_A
/// ASL: `SMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// 16-bit values
#[test]
fn test_aarch32_ldrexh_a1_a_smull_oracle_5_9b227c20() {
    // Test SMULL: 16-bit values (oracle)
    // Encoding: 0x9B227C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x5678);
    set_w(&mut cpu, 1, 0x1234);
    let encoding: u32 = 0x9B227C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6260060, "X0 should be 0x0000000006260060");
}

// ============================================================================
// aarch32_LDRB_r_A Tests
// ============================================================================

/// Provenance: aarch32_LDRB_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_ldrb_r_a1_a_field_cond_0_min_0_06500000() {
    // Encoding: 0x06500000
    // Test aarch32_LDRB_r_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: cond=0, imm5=0, W=0, U=0, Rm=0, Rt=0, P=0, Rn=0, type1=0
    let encoding: u32 = 0x06500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_ldrb_r_a1_a_field_cond_1_poweroftwo_0_16500000() {
    // Encoding: 0x16500000
    // Test aarch32_LDRB_r_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, Rn=0, Rm=0, imm5=0, cond=1, type1=0, P=0, W=0, U=0
    let encoding: u32 = 0x16500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_ldrb_r_a1_a_field_cond_2_poweroftwo_0_26500000() {
    // Encoding: 0x26500000
    // Test aarch32_LDRB_r_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=2, imm5=0, type1=0, Rm=0, U=0, Rn=0, W=0, P=0, Rt=0
    let encoding: u32 = 0x26500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_ldrb_r_a1_a_field_cond_3_poweroftwo_0_36500000() {
    // Encoding: 0x36500000
    // Test aarch32_LDRB_r_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, Rn=0, Rt=0, cond=3, P=0, U=0, imm5=0, type1=0, Rm=0
    let encoding: u32 = 0x36500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_ldrb_r_a1_a_field_cond_4_poweroftwo_0_46500000() {
    // Encoding: 0x46500000
    // Test aarch32_LDRB_r_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: type1=0, Rn=0, Rt=0, P=0, U=0, imm5=0, Rm=0, cond=4, W=0
    let encoding: u32 = 0x46500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_ldrb_r_a1_a_field_cond_5_poweroftwo_0_56500000() {
    // Encoding: 0x56500000
    // Test aarch32_LDRB_r_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: imm5=0, Rn=0, cond=5, P=0, Rt=0, type1=0, U=0, Rm=0, W=0
    let encoding: u32 = 0x56500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_ldrb_r_a1_a_field_cond_6_poweroftwo_0_66500000() {
    // Encoding: 0x66500000
    // Test aarch32_LDRB_r_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, Rt=0, type1=0, cond=6, Rn=0, Rm=0, U=0, imm5=0, W=0
    let encoding: u32 = 0x66500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_ldrb_r_a1_a_field_cond_7_poweroftwo_0_76500000() {
    // Encoding: 0x76500000
    // Test aarch32_LDRB_r_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: imm5=0, W=0, Rt=0, type1=0, U=0, cond=7, P=0, Rn=0, Rm=0
    let encoding: u32 = 0x76500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_ldrb_r_a1_a_field_cond_8_poweroftwo_0_86500000() {
    // Encoding: 0x86500000
    // Test aarch32_LDRB_r_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, imm5=0, type1=0, U=0, W=0, P=0, cond=8, Rt=0, Rn=0
    let encoding: u32 = 0x86500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_ldrb_r_a1_a_field_cond_9_poweroftwo_0_96500000() {
    // Encoding: 0x96500000
    // Test aarch32_LDRB_r_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, Rt=0, cond=9, W=0, type1=0, P=0, Rm=0, Rn=0, imm5=0
    let encoding: u32 = 0x96500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_ldrb_r_a1_a_field_cond_10_poweroftwo_0_a6500000() {
    // Encoding: 0xA6500000
    // Test aarch32_LDRB_r_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, cond=10, W=0, imm5=0, U=0, Rt=0, type1=0, Rm=0, Rn=0
    let encoding: u32 = 0xA6500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_ldrb_r_a1_a_field_cond_11_poweroftwo_0_b6500000() {
    // Encoding: 0xB6500000
    // Test aarch32_LDRB_r_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: type1=0, P=0, cond=11, Rm=0, W=0, U=0, imm5=0, Rn=0, Rt=0
    let encoding: u32 = 0xB6500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_ldrb_r_a1_a_field_cond_12_poweroftwo_0_c6500000() {
    // Encoding: 0xC6500000
    // Test aarch32_LDRB_r_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: type1=0, Rn=0, U=0, imm5=0, P=0, Rm=0, W=0, cond=12, Rt=0
    let encoding: u32 = 0xC6500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_ldrb_r_a1_a_field_cond_13_poweroftwo_0_d6500000() {
    // Encoding: 0xD6500000
    // Test aarch32_LDRB_r_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, U=0, cond=13, Rn=0, W=0, imm5=0, P=0, Rt=0, type1=0
    let encoding: u32 = 0xD6500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_ldrb_r_a1_a_field_cond_14_poweroftwo_0_e6500000() {
    // Encoding: 0xE6500000
    // Test aarch32_LDRB_r_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: type1=0, U=0, imm5=0, P=0, Rm=0, W=0, cond=14, Rn=0, Rt=0
    let encoding: u32 = 0xE6500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_ldrb_r_a1_a_field_cond_15_max_0_f6500000() {
    // Encoding: 0xF6500000
    // Test aarch32_LDRB_r_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: cond=15, U=0, type1=0, W=0, imm5=0, Rt=0, P=0, Rn=0, Rm=0
    let encoding: u32 = 0xF6500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_r_A1_A
/// ASL: `field P 24 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldrb_r_a1_a_field_p_0_min_0_06500000() {
    // Encoding: 0x06500000
    // Test aarch32_LDRB_r_A1_A field P = 0 (Min)
    // ISET: A32
    // Fields: imm5=0, Rn=0, type1=0, Rt=0, W=0, U=0, Rm=0, cond=0, P=0
    let encoding: u32 = 0x06500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_r_A1_A
/// ASL: `field P 24 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldrb_r_a1_a_field_p_1_max_0_07500000() {
    // Encoding: 0x07500000
    // Test aarch32_LDRB_r_A1_A field P = 1 (Max)
    // ISET: A32
    // Fields: cond=0, W=0, P=1, Rn=0, type1=0, Rm=0, U=0, Rt=0, imm5=0
    let encoding: u32 = 0x07500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_r_A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldrb_r_a1_a_field_u_0_min_0_06500000() {
    // Encoding: 0x06500000
    // Test aarch32_LDRB_r_A1_A field U = 0 (Min)
    // ISET: A32
    // Fields: P=0, U=0, Rn=0, cond=0, type1=0, Rm=0, W=0, Rt=0, imm5=0
    let encoding: u32 = 0x06500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_r_A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldrb_r_a1_a_field_u_1_max_0_06d00000() {
    // Encoding: 0x06D00000
    // Test aarch32_LDRB_r_A1_A field U = 1 (Max)
    // ISET: A32
    // Fields: P=0, Rn=0, U=1, imm5=0, cond=0, type1=0, Rm=0, W=0, Rt=0
    let encoding: u32 = 0x06D00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_r_A1_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldrb_r_a1_a_field_w_0_min_0_06500000() {
    // Encoding: 0x06500000
    // Test aarch32_LDRB_r_A1_A field W = 0 (Min)
    // ISET: A32
    // Fields: W=0, U=0, cond=0, Rt=0, Rn=0, type1=0, P=0, imm5=0, Rm=0
    let encoding: u32 = 0x06500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_r_A1_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldrb_r_a1_a_field_w_1_max_0_06700000() {
    // Encoding: 0x06700000
    // Test aarch32_LDRB_r_A1_A field W = 1 (Max)
    // ISET: A32
    // Fields: imm5=0, P=0, Rt=0, Rm=0, cond=0, W=1, type1=0, U=0, Rn=0
    let encoding: u32 = 0x06700000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_r_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrb_r_a1_a_field_rn_0_min_0_06500000() {
    // Encoding: 0x06500000
    // Test aarch32_LDRB_r_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, U=0, Rt=0, type1=0, cond=0, W=0, P=0, Rn=0, imm5=0
    let encoding: u32 = 0x06500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_r_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrb_r_a1_a_field_rn_1_poweroftwo_0_06510000() {
    // Encoding: 0x06510000
    // Test aarch32_LDRB_r_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, W=0, Rn=1, imm5=0, cond=0, type1=0, Rm=0, P=0, Rt=0
    let encoding: u32 = 0x06510000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_r_A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrb_r_a1_a_field_rt_0_min_0_06500000() {
    // Encoding: 0x06500000
    // Test aarch32_LDRB_r_A1_A field Rt = 0 (Min)
    // ISET: A32
    // Fields: type1=0, Rn=0, P=0, cond=0, imm5=0, Rm=0, Rt=0, U=0, W=0
    let encoding: u32 = 0x06500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_r_A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrb_r_a1_a_field_rt_1_poweroftwo_0_06501000() {
    // Encoding: 0x06501000
    // Test aarch32_LDRB_r_A1_A field Rt = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, Rm=0, Rt=1, imm5=0, P=0, type1=0, cond=0, W=0, Rn=0
    let encoding: u32 = 0x06501000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_ldrb_r_a1_a_field_imm5_0_zero_0_06500000() {
    // Encoding: 0x06500000
    // Test aarch32_LDRB_r_A1_A field imm5 = 0 (Zero)
    // ISET: A32
    // Fields: Rm=0, W=0, imm5=0, Rn=0, type1=0, cond=0, U=0, Rt=0, P=0
    let encoding: u32 = 0x06500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_ldrb_r_a1_a_field_imm5_1_poweroftwo_0_06500080() {
    // Encoding: 0x06500080
    // Test aarch32_LDRB_r_A1_A field imm5 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, W=0, Rm=0, type1=0, cond=0, Rn=0, U=0, Rt=0, imm5=1
    let encoding: u32 = 0x06500080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_ldrb_r_a1_a_field_imm5_3_poweroftwominusone_0_06500180() {
    // Encoding: 0x06500180
    // Test aarch32_LDRB_r_A1_A field imm5 = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: W=0, cond=0, Rn=0, U=0, type1=0, Rm=0, P=0, Rt=0, imm5=3
    let encoding: u32 = 0x06500180;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_ldrb_r_a1_a_field_imm5_4_poweroftwo_0_06500200() {
    // Encoding: 0x06500200
    // Test aarch32_LDRB_r_A1_A field imm5 = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: type1=0, Rt=0, Rn=0, imm5=4, Rm=0, P=0, cond=0, W=0, U=0
    let encoding: u32 = 0x06500200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_ldrb_r_a1_a_field_imm5_7_poweroftwominusone_0_06500380() {
    // Encoding: 0x06500380
    // Test aarch32_LDRB_r_A1_A field imm5 = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rn=0, type1=0, Rm=0, Rt=0, U=0, imm5=7, cond=0, P=0, W=0
    let encoding: u32 = 0x06500380;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_ldrb_r_a1_a_field_imm5_8_poweroftwo_0_06500400() {
    // Encoding: 0x06500400
    // Test aarch32_LDRB_r_A1_A field imm5 = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, Rt=0, cond=0, U=0, Rn=0, type1=0, imm5=8, Rm=0, W=0
    let encoding: u32 = 0x06500400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 15, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (15)
#[test]
fn test_aarch32_ldrb_r_a1_a_field_imm5_15_poweroftwominusone_0_06500780() {
    // Encoding: 0x06500780
    // Test aarch32_LDRB_r_A1_A field imm5 = 15 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: P=0, Rn=0, Rm=0, Rt=0, imm5=15, U=0, type1=0, W=0, cond=0
    let encoding: u32 = 0x06500780;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_ldrb_r_a1_a_field_imm5_16_poweroftwo_0_06500800() {
    // Encoding: 0x06500800
    // Test aarch32_LDRB_r_A1_A field imm5 = 16 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, cond=0, Rn=0, Rt=0, Rm=0, W=0, imm5=16, type1=0, U=0
    let encoding: u32 = 0x06500800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 31, boundary: Max }
/// maximum immediate (31)
#[test]
fn test_aarch32_ldrb_r_a1_a_field_imm5_31_max_0_06500f80() {
    // Encoding: 0x06500F80
    // Test aarch32_LDRB_r_A1_A field imm5 = 31 (Max)
    // ISET: A32
    // Fields: Rm=0, cond=0, U=0, type1=0, imm5=31, P=0, W=0, Rt=0, Rn=0
    let encoding: u32 = 0x06500F80;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_r_A1_A
/// ASL: `field type1 5 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldrb_r_a1_a_field_type1_0_min_0_06500000() {
    // Encoding: 0x06500000
    // Test aarch32_LDRB_r_A1_A field type1 = 0 (Min)
    // ISET: A32
    // Fields: type1=0, Rt=0, W=0, U=0, Rn=0, P=0, imm5=0, Rm=0, cond=0
    let encoding: u32 = 0x06500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_r_A1_A
/// ASL: `field type1 5 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_ldrb_r_a1_a_field_type1_1_poweroftwo_0_06500020() {
    // Encoding: 0x06500020
    // Test aarch32_LDRB_r_A1_A field type1 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, type1=1, U=0, Rn=0, imm5=0, P=0, W=0, Rm=0, Rt=0
    let encoding: u32 = 0x06500020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_r_A1_A
/// ASL: `field type1 5 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_aarch32_ldrb_r_a1_a_field_type1_3_max_0_06500060() {
    // Encoding: 0x06500060
    // Test aarch32_LDRB_r_A1_A field type1 = 3 (Max)
    // ISET: A32
    // Fields: P=0, U=0, Rm=0, Rn=0, imm5=0, W=0, Rt=0, type1=3, cond=0
    let encoding: u32 = 0x06500060;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_r_A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrb_r_a1_a_field_rm_0_min_0_06500000() {
    // Encoding: 0x06500000
    // Test aarch32_LDRB_r_A1_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: type1=0, imm5=0, Rt=0, cond=0, U=0, Rm=0, W=0, P=0, Rn=0
    let encoding: u32 = 0x06500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_r_A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrb_r_a1_a_field_rm_1_poweroftwo_0_06500001() {
    // Encoding: 0x06500001
    // Test aarch32_LDRB_r_A1_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=1, imm5=0, Rt=0, Rn=0, P=0, U=0, type1=0, W=0, cond=0
    let encoding: u32 = 0x06500001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_r_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_ldrb_r_a1_a_combo_0_0_06500000() {
    // Encoding: 0x06500000
    // Test aarch32_LDRB_r_A1_A field combination: cond=0, P=0, U=0, W=0, Rn=0, Rt=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: Rm=0, imm5=0, U=0, P=0, cond=0, W=0, type1=0, Rn=0, Rt=0
    let encoding: u32 = 0x06500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_r_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_ldrb_r_a1_a_special_cond_0_condition_eq_0_06500000() {
    // Encoding: 0x06500000
    // Test aarch32_LDRB_r_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: W=0, P=0, U=0, type1=0, Rm=0, imm5=0, Rt=0, cond=0, Rn=0
    let encoding: u32 = 0x06500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_r_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_ldrb_r_a1_a_special_cond_1_condition_ne_0_16500000() {
    // Encoding: 0x16500000
    // Test aarch32_LDRB_r_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: cond=1, Rt=0, W=0, imm5=0, U=0, Rm=0, P=0, Rn=0, type1=0
    let encoding: u32 = 0x16500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_r_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_ldrb_r_a1_a_special_cond_2_condition_cs_hs_0_26500000() {
    // Encoding: 0x26500000
    // Test aarch32_LDRB_r_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: cond=2, P=0, U=0, Rn=0, Rm=0, Rt=0, W=0, imm5=0, type1=0
    let encoding: u32 = 0x26500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_r_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_ldrb_r_a1_a_special_cond_3_condition_cc_lo_0_36500000() {
    // Encoding: 0x36500000
    // Test aarch32_LDRB_r_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: type1=0, Rm=0, cond=3, P=0, U=0, Rt=0, W=0, Rn=0, imm5=0
    let encoding: u32 = 0x36500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_r_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_ldrb_r_a1_a_special_cond_4_condition_mi_0_46500000() {
    // Encoding: 0x46500000
    // Test aarch32_LDRB_r_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: Rm=0, W=0, P=0, type1=0, cond=4, U=0, Rn=0, Rt=0, imm5=0
    let encoding: u32 = 0x46500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_r_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_ldrb_r_a1_a_special_cond_5_condition_pl_0_56500000() {
    // Encoding: 0x56500000
    // Test aarch32_LDRB_r_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: Rn=0, Rt=0, type1=0, cond=5, U=0, W=0, Rm=0, P=0, imm5=0
    let encoding: u32 = 0x56500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_r_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_ldrb_r_a1_a_special_cond_6_condition_vs_0_66500000() {
    // Encoding: 0x66500000
    // Test aarch32_LDRB_r_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: U=0, W=0, type1=0, cond=6, Rn=0, P=0, imm5=0, Rm=0, Rt=0
    let encoding: u32 = 0x66500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_r_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_ldrb_r_a1_a_special_cond_7_condition_vc_0_76500000() {
    // Encoding: 0x76500000
    // Test aarch32_LDRB_r_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: imm5=0, Rt=0, U=0, Rn=0, P=0, cond=7, type1=0, W=0, Rm=0
    let encoding: u32 = 0x76500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_r_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_ldrb_r_a1_a_special_cond_8_condition_hi_0_86500000() {
    // Encoding: 0x86500000
    // Test aarch32_LDRB_r_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: Rm=0, P=0, U=0, W=0, type1=0, Rn=0, Rt=0, cond=8, imm5=0
    let encoding: u32 = 0x86500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_r_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_ldrb_r_a1_a_special_cond_9_condition_ls_0_96500000() {
    // Encoding: 0x96500000
    // Test aarch32_LDRB_r_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: Rn=0, W=0, type1=0, Rm=0, U=0, P=0, cond=9, imm5=0, Rt=0
    let encoding: u32 = 0x96500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_r_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_ldrb_r_a1_a_special_cond_10_condition_ge_0_a6500000() {
    // Encoding: 0xA6500000
    // Test aarch32_LDRB_r_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: U=0, Rt=0, type1=0, Rn=0, Rm=0, imm5=0, cond=10, W=0, P=0
    let encoding: u32 = 0xA6500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_r_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_ldrb_r_a1_a_special_cond_11_condition_lt_0_b6500000() {
    // Encoding: 0xB6500000
    // Test aarch32_LDRB_r_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: P=0, Rt=0, type1=0, W=0, Rn=0, Rm=0, cond=11, imm5=0, U=0
    let encoding: u32 = 0xB6500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_r_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_ldrb_r_a1_a_special_cond_12_condition_gt_0_c6500000() {
    // Encoding: 0xC6500000
    // Test aarch32_LDRB_r_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: P=0, type1=0, cond=12, Rn=0, Rm=0, U=0, imm5=0, Rt=0, W=0
    let encoding: u32 = 0xC6500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_r_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_ldrb_r_a1_a_special_cond_13_condition_le_0_d6500000() {
    // Encoding: 0xD6500000
    // Test aarch32_LDRB_r_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: cond=13, imm5=0, Rm=0, U=0, Rn=0, P=0, Rt=0, W=0, type1=0
    let encoding: u32 = 0xD6500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_r_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_ldrb_r_a1_a_special_cond_14_condition_al_0_e6500000() {
    // Encoding: 0xE6500000
    // Test aarch32_LDRB_r_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: U=0, type1=0, imm5=0, P=0, Rt=0, Rn=0, cond=14, W=0, Rm=0
    let encoding: u32 = 0xE6500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_r_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_ldrb_r_a1_a_special_cond_15_condition_nv_0_f6500000() {
    // Encoding: 0xF6500000
    // Test aarch32_LDRB_r_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: cond=15, imm5=0, Rt=0, P=0, W=0, Rm=0, type1=0, Rn=0, U=0
    let encoding: u32 = 0xF6500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRB_r_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrb_r_a1_a_invalid_0_0_06500000() {
    // Encoding: 0x06500000
    // Test aarch32_LDRB_r_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }
    // ISET: A32
    // Fields: imm5=0, cond=0, W=0, Rn=0, Rm=0, P=0, U=0, type1=0, Rt=0
    let encoding: u32 = 0x06500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRB_r_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrb_r_a1_a_invalid_1_0_06500000() {
    // Encoding: 0x06500000
    // Test aarch32_LDRB_r_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Rn=0, type1=0, Rm=0, P=0, cond=0, W=0, Rt=0, U=0, imm5=0
    let encoding: u32 = 0x06500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRB_r_A1_A
/// ASL: `Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"wback\" }), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }) } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrb_r_a1_a_invalid_2_0_06500000() {
    // Encoding: 0x06500000
    // Test aarch32_LDRB_r_A1_A invalid encoding: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) } }
    // ISET: A32
    // Fields: U=0, Rm=0, imm5=0, type1=0, cond=0, W=0, Rn=0, Rt=0, P=0
    let encoding: u32 = 0x06500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRB_r_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrb_r_a1_a_invalid_3_0_06500000() {
    // Encoding: 0x06500000
    // Test aarch32_LDRB_r_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: U=0, imm5=0, Rm=0, cond=0, Rt=0, P=0, Rn=0, type1=0, W=0
    let encoding: u32 = 0x06500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRB_r_T1_A
/// ASL: `field Rm 22 +: 3`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrb_r_t1_a_field_rm_0_min_0_5c000000() {
    // Thumb encoding (32): 0x5C000000
    // Test aarch32_LDRB_r_T1_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rt=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x5C000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_r_T1_A
/// ASL: `field Rm 22 +: 3`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrb_r_t1_a_field_rm_1_poweroftwo_0_5c400000() {
    // Thumb encoding (32): 0x5C400000
    // Test aarch32_LDRB_r_T1_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=1, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x5C400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_r_T1_A
/// ASL: `field Rn 19 +: 3`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrb_r_t1_a_field_rn_0_min_0_5c000000() {
    // Thumb encoding (32): 0x5C000000
    // Test aarch32_LDRB_r_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rt=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x5C000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_r_T1_A
/// ASL: `field Rn 19 +: 3`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrb_r_t1_a_field_rn_1_poweroftwo_0_5c080000() {
    // Thumb encoding (32): 0x5C080000
    // Test aarch32_LDRB_r_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=1, Rt=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x5C080000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_r_T1_A
/// ASL: `field Rt 16 +: 3`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrb_r_t1_a_field_rt_0_min_0_5c000000() {
    // Thumb encoding (32): 0x5C000000
    // Test aarch32_LDRB_r_T1_A field Rt = 0 (Min)
    // ISET: T32
    // Fields: Rt=0, Rm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x5C000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_r_T1_A
/// ASL: `field Rt 16 +: 3`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrb_r_t1_a_field_rt_1_poweroftwo_0_5c010000() {
    // Thumb encoding (32): 0x5C010000
    // Test aarch32_LDRB_r_T1_A field Rt = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=1, Rn=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x5C010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_r_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch32_ldrb_r_t1_a_combo_0_0_5c000000() {
    // Thumb encoding (32): 0x5C000000
    // Test aarch32_LDRB_r_T1_A field combination: Rm=0, Rn=0, Rt=0
    // ISET: T32
    // Fields: Rn=0, Rt=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x5C000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_r_T2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrb_r_t2_a_field_rn_0_min_0_f8100000() {
    // Thumb encoding (32): 0xF8100000
    // Test aarch32_LDRB_r_T2_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rm=0, imm2=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8100000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_r_T2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrb_r_t2_a_field_rn_1_poweroftwo_0_f8110000() {
    // Thumb encoding (32): 0xF8110000
    // Test aarch32_LDRB_r_T2_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=1, Rt=0, imm2=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8110000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_r_T2_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrb_r_t2_a_field_rt_0_min_0_f8100000() {
    // Thumb encoding (32): 0xF8100000
    // Test aarch32_LDRB_r_T2_A field Rt = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rt=0, Rm=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8100000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_r_T2_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrb_r_t2_a_field_rt_1_poweroftwo_0_f8101000() {
    // Thumb encoding (32): 0xF8101000
    // Test aarch32_LDRB_r_T2_A field Rt = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Rt=1, imm2=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8101000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_r_T2_A
/// ASL: `field imm2 4 +: 2`
/// Requirement: FieldBoundary { field: "imm2", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_ldrb_r_t2_a_field_imm2_0_zero_0_f8100000() {
    // Thumb encoding (32): 0xF8100000
    // Test aarch32_LDRB_r_T2_A field imm2 = 0 (Zero)
    // ISET: T32
    // Fields: Rm=0, Rt=0, imm2=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8100000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_r_T2_A
/// ASL: `field imm2 4 +: 2`
/// Requirement: FieldBoundary { field: "imm2", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_ldrb_r_t2_a_field_imm2_1_poweroftwo_0_f8100010() {
    // Thumb encoding (32): 0xF8100010
    // Test aarch32_LDRB_r_T2_A field imm2 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Rm=0, imm2=1, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8100010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_r_T2_A
/// ASL: `field imm2 4 +: 2`
/// Requirement: FieldBoundary { field: "imm2", value: 3, boundary: Max }
/// maximum immediate (3)
#[test]
fn test_aarch32_ldrb_r_t2_a_field_imm2_3_max_0_f8100030() {
    // Thumb encoding (32): 0xF8100030
    // Test aarch32_LDRB_r_T2_A field imm2 = 3 (Max)
    // ISET: T32
    // Fields: Rm=0, Rt=0, imm2=3, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8100030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_r_T2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrb_r_t2_a_field_rm_0_min_0_f8100000() {
    // Thumb encoding (32): 0xF8100000
    // Test aarch32_LDRB_r_T2_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: Rt=0, imm2=0, Rm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8100000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_r_T2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrb_r_t2_a_field_rm_1_poweroftwo_0_f8100001() {
    // Thumb encoding (32): 0xF8100001
    // Test aarch32_LDRB_r_T2_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, Rm=1, Rn=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8100001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_r_T2_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_ldrb_r_t2_a_combo_0_0_f8100000() {
    // Thumb encoding (32): 0xF8100000
    // Test aarch32_LDRB_r_T2_A field combination: Rn=0, Rt=0, imm2=0, Rm=0
    // ISET: T32
    // Fields: Rm=0, Rn=0, imm2=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8100000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRB_r_T2_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }), rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }), rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrb_r_t2_a_invalid_0_0_f8100000() {
    // Thumb encoding (32): 0xF8100000
    // Test aarch32_LDRB_r_T2_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }), rhs: LitInt(15) }
    // ISET: T32
    // Fields: Rt=0, Rm=0, imm2=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8100000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRB_r_T2_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrb_r_t2_a_invalid_1_0_f8100000() {
    // Thumb encoding (32): 0xF8100000
    // Test aarch32_LDRB_r_T2_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm2=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8100000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRB_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 0 (32)
#[test]
fn test_aarch32_ldrb_r_t1_a_lslv_oracle_32_0_5c020020() {
    // Test LSLV 32-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x12345678, "W0 should be 0x12345678");
}

/// Provenance: aarch32_LDRB_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 0 (64)
#[test]
fn test_aarch32_ldrb_r_t1_a_lslv_oracle_64_0_dc020020() {
    // Test LSLV 64-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x12345678,
        "X0 should be 0x0000000012345678"
    );
}

/// Provenance: aarch32_LDRB_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4 (32)
#[test]
fn test_aarch32_ldrb_r_t1_a_lslv_oracle_32_1_5c020020() {
    // Test LSLV 32-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x4);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x23456780, "W0 should be 0x23456780");
}

/// Provenance: aarch32_LDRB_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 4 (64)
#[test]
fn test_aarch32_ldrb_r_t1_a_lslv_oracle_64_1_dc020020() {
    // Test LSLV 64-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x4);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x23456780,
        "X0 should be 0x0000000123456780"
    );
}

/// Provenance: aarch32_LDRB_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 8 (32)
#[test]
fn test_aarch32_ldrb_r_t1_a_lslv_oracle_32_2_5c020020() {
    // Test LSLV 32-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x8);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x34567800, "W0 should be 0x34567800");
}

/// Provenance: aarch32_LDRB_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 8 (64)
#[test]
fn test_aarch32_ldrb_r_t1_a_lslv_oracle_64_2_dc020020() {
    // Test LSLV 64-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x8);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x34567800,
        "X0 should be 0x0000001234567800"
    );
}

/// Provenance: aarch32_LDRB_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1 (32)
#[test]
fn test_aarch32_ldrb_r_t1_a_lslv_oracle_32_3_5c020020() {
    // Test LSLV 32-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_LDRB_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// MSB set, shift 1 (64)
#[test]
fn test_aarch32_ldrb_r_t1_a_lslv_oracle_64_3_dc020020() {
    // Test LSLV 64-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_LDRB_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// LSB set, max shift (32)
#[test]
fn test_aarch32_ldrb_r_t1_a_lslv_oracle_32_4_5c020020() {
    // Test LSLV 32-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3F);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "W0 should be 0x80000000");
}

/// Provenance: aarch32_LDRB_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// LSB set, max shift (64)
#[test]
fn test_aarch32_ldrb_r_t1_a_lslv_oracle_64_4_dc020020() {
    // Test LSLV 64-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3F);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x8000000000000000");
}

/// Provenance: aarch32_LDRB_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// all ones, shift 32 (32)
#[test]
fn test_aarch32_ldrb_r_t1_a_lslv_oracle_32_5_5c020020() {
    // Test LSLV 32-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x20);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "W0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_LDRB_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// all ones, shift 32 (64)
#[test]
fn test_aarch32_ldrb_r_t1_a_lslv_oracle_64_5_dc020020() {
    // Test LSLV 64-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x20);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0xFFFFFFFF00000000");
}

/// Provenance: aarch32_LDRB_r_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// no shift
#[test]
fn test_aarch32_ldrb_r_t1_a_t16_oracle_0_5c880000() {
    // Test T16 LSLS: no shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_LDRB_r_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4
#[test]
fn test_aarch32_ldrb_r_t1_a_t16_oracle_1_5c880000() {
    // Test T16 LSLS: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x4);
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF0, "R0 should be 0x00000FF0");
}

/// Provenance: aarch32_LDRB_r_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1
#[test]
fn test_aarch32_ldrb_r_t1_a_t16_oracle_2_5c880000() {
    // Test T16 LSLS: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_LDRB_r_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift to MSB
#[test]
fn test_aarch32_ldrb_r_t1_a_t16_oracle_3_5c880000() {
    // Test T16 LSLS: shift to MSB (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x1F);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "R0 should be 0x80000000");
}

/// Provenance: aarch32_LDRB_r_T2_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple division (32)
#[test]
fn test_aarch32_ldrb_r_t2_a_udiv_oracle_32_0_1ac20820() {
    // Test UDIV 32-bit: simple division (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xA);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA, "W0 should be 0x0000000A");
}

/// Provenance: aarch32_LDRB_r_T2_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple division (64)
#[test]
fn test_aarch32_ldrb_r_t2_a_udiv_oracle_64_0_9ac20820() {
    // Test UDIV 64-bit: simple division (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xA);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA, "X0 should be 0x000000000000000A");
}

/// Provenance: aarch32_LDRB_r_T2_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// division with remainder (32)
#[test]
fn test_aarch32_ldrb_r_t2_a_udiv_oracle_32_1_1ac20820() {
    // Test UDIV 32-bit: division with remainder (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x3);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x21, "W0 should be 0x00000021");
}

/// Provenance: aarch32_LDRB_r_T2_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// division with remainder (64)
#[test]
fn test_aarch32_ldrb_r_t2_a_udiv_oracle_64_1_9ac20820() {
    // Test UDIV 64-bit: division with remainder (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x3);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x21, "X0 should be 0x0000000000000021");
}

/// Provenance: aarch32_LDRB_r_T2_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero dividend (32)
#[test]
fn test_aarch32_ldrb_r_t2_a_udiv_oracle_32_2_1ac20820() {
    // Test UDIV 32-bit: zero dividend (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xA);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_LDRB_r_T2_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero dividend (64)
#[test]
fn test_aarch32_ldrb_r_t2_a_udiv_oracle_64_2_9ac20820() {
    // Test UDIV 64-bit: zero dividend (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xA);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_LDRB_r_T2_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// divide by zero - result is 0 (32)
#[test]
fn test_aarch32_ldrb_r_t2_a_udiv_oracle_32_3_1ac20820() {
    // Test UDIV 32-bit: divide by zero - result is 0 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xA);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_LDRB_r_T2_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// divide by zero - result is 0 (64)
#[test]
fn test_aarch32_ldrb_r_t2_a_udiv_oracle_64_3_9ac20820() {
    // Test UDIV 64-bit: divide by zero - result is 0 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xA);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_LDRB_r_T2_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max value / 2 (32)
#[test]
fn test_aarch32_ldrb_r_t2_a_udiv_oracle_32_4_1ac20820() {
    // Test UDIV 32-bit: max value / 2 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FFFFFFF, "W0 should be 0x7FFFFFFF");
}

/// Provenance: aarch32_LDRB_r_T2_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max value / 2 (64)
#[test]
fn test_aarch32_ldrb_r_t2_a_udiv_oracle_64_4_9ac20820() {
    // Test UDIV 64-bit: max value / 2 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0x7FFFFFFFFFFFFFFF"
    );
}

/// Provenance: aarch32_LDRB_r_T2_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set / 2 (32)
#[test]
fn test_aarch32_ldrb_r_t2_a_udiv_oracle_32_5_1ac20820() {
    // Test UDIV 32-bit: MSB set / 2 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_LDRB_r_T2_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// MSB set / 2 (64)
#[test]
fn test_aarch32_ldrb_r_t2_a_udiv_oracle_64_5_9ac20820() {
    // Test UDIV 64-bit: MSB set / 2 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x4000000000000000");
}

/// Provenance: aarch32_LDRB_r_T2_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// self-division (32)
#[test]
fn test_aarch32_ldrb_r_t2_a_udiv_oracle_32_6_1ac20820() {
    // Test UDIV 32-bit: self-division (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7);
    set_w(&mut cpu, 2, 0x7);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_LDRB_r_T2_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// self-division (64)
#[test]
fn test_aarch32_ldrb_r_t2_a_udiv_oracle_64_6_9ac20820() {
    // Test UDIV 64-bit: self-division (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x7);
    set_w(&mut cpu, 1, 0x7);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x0000000000000001");
}

/// Provenance: aarch32_LDRB_r_T2_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// one / one (32)
#[test]
fn test_aarch32_ldrb_r_t2_a_udiv_oracle_32_7_1ac20820() {
    // Test UDIV 32-bit: one / one (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_LDRB_r_T2_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// one / one (64)
#[test]
fn test_aarch32_ldrb_r_t2_a_udiv_oracle_64_7_9ac20820() {
    // Test UDIV 64-bit: one / one (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x0000000000000001");
}

/// Provenance: aarch32_LDRB_r_T2_A
/// ASL: `UDIV R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// exact division
#[test]
fn test_aarch32_ldrb_r_t2_a_t32_oracle_0_f8110002() {
    // Test T32 UDIV: exact division (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0xA);
    let encoding: u32 = 0xF8110002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA, "R0 should be 0x0000000A");
}

/// Provenance: aarch32_LDRB_r_T2_A
/// ASL: `UDIV R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// with remainder
#[test]
fn test_aarch32_ldrb_r_t2_a_t32_oracle_1_f8110002() {
    // Test T32 UDIV: with remainder (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF8110002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x21, "R0 should be 0x00000021");
}

/// Provenance: aarch32_LDRB_r_T2_A
/// ASL: `UDIV R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero dividend
#[test]
fn test_aarch32_ldrb_r_t2_a_t32_oracle_2_f8110002() {
    // Test T32 UDIV: zero dividend (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xA);
    let encoding: u32 = 0xF8110002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_LDRB_r_T2_A
/// ASL: `UDIV R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// divide by zero
#[test]
fn test_aarch32_ldrb_r_t2_a_t32_oracle_3_f8110002() {
    // Test T32 UDIV: divide by zero (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xA);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xF8110002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

// ============================================================================
// aarch32_LDA_A Tests
// ============================================================================

/// Provenance: aarch32_LDA_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_lda_a1_a_field_cond_0_min_90_01900090() {
    // Encoding: 0x01900090
    // Test aarch32_LDA_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=0
    let encoding: u32 = 0x01900090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDA_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_lda_a1_a_field_cond_1_poweroftwo_90_11900090() {
    // Encoding: 0x11900090
    // Test aarch32_LDA_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=1, Rt=0
    let encoding: u32 = 0x11900090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDA_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_lda_a1_a_field_cond_2_poweroftwo_90_21900090() {
    // Encoding: 0x21900090
    // Test aarch32_LDA_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=2
    let encoding: u32 = 0x21900090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDA_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_lda_a1_a_field_cond_3_poweroftwo_90_31900090() {
    // Encoding: 0x31900090
    // Test aarch32_LDA_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=3
    let encoding: u32 = 0x31900090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDA_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_lda_a1_a_field_cond_4_poweroftwo_90_41900090() {
    // Encoding: 0x41900090
    // Test aarch32_LDA_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, cond=4, Rn=0
    let encoding: u32 = 0x41900090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDA_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_lda_a1_a_field_cond_5_poweroftwo_90_51900090() {
    // Encoding: 0x51900090
    // Test aarch32_LDA_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, Rn=0, cond=5
    let encoding: u32 = 0x51900090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDA_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_lda_a1_a_field_cond_6_poweroftwo_90_61900090() {
    // Encoding: 0x61900090
    // Test aarch32_LDA_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=6, Rt=0, Rn=0
    let encoding: u32 = 0x61900090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDA_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_lda_a1_a_field_cond_7_poweroftwo_90_71900090() {
    // Encoding: 0x71900090
    // Test aarch32_LDA_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=7, Rn=0, Rt=0
    let encoding: u32 = 0x71900090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDA_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_lda_a1_a_field_cond_8_poweroftwo_90_81900090() {
    // Encoding: 0x81900090
    // Test aarch32_LDA_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, cond=8, Rn=0
    let encoding: u32 = 0x81900090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDA_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_lda_a1_a_field_cond_9_poweroftwo_90_91900090() {
    // Encoding: 0x91900090
    // Test aarch32_LDA_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=9, Rt=0, Rn=0
    let encoding: u32 = 0x91900090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDA_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_lda_a1_a_field_cond_10_poweroftwo_90_a1900090() {
    // Encoding: 0xA1900090
    // Test aarch32_LDA_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, cond=10, Rn=0
    let encoding: u32 = 0xA1900090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDA_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_lda_a1_a_field_cond_11_poweroftwo_90_b1900090() {
    // Encoding: 0xB1900090
    // Test aarch32_LDA_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, cond=11, Rn=0
    let encoding: u32 = 0xB1900090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDA_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_lda_a1_a_field_cond_12_poweroftwo_90_c1900090() {
    // Encoding: 0xC1900090
    // Test aarch32_LDA_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=12
    let encoding: u32 = 0xC1900090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDA_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_lda_a1_a_field_cond_13_poweroftwo_90_d1900090() {
    // Encoding: 0xD1900090
    // Test aarch32_LDA_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=13, Rt=0, Rn=0
    let encoding: u32 = 0xD1900090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDA_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_lda_a1_a_field_cond_14_poweroftwo_90_e1900090() {
    // Encoding: 0xE1900090
    // Test aarch32_LDA_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=14
    let encoding: u32 = 0xE1900090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDA_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_lda_a1_a_field_cond_15_max_90_f1900090() {
    // Encoding: 0xF1900090
    // Test aarch32_LDA_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: cond=15, Rn=0, Rt=0
    let encoding: u32 = 0xF1900090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDA_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_lda_a1_a_field_rn_0_min_90_01900090() {
    // Encoding: 0x01900090
    // Test aarch32_LDA_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=0
    let encoding: u32 = 0x01900090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDA_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_lda_a1_a_field_rn_1_poweroftwo_90_01910090() {
    // Encoding: 0x01910090
    // Test aarch32_LDA_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, Rn=1, cond=0
    let encoding: u32 = 0x01910090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDA_A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_lda_a1_a_field_rt_0_min_90_01900090() {
    // Encoding: 0x01900090
    // Test aarch32_LDA_A1_A field Rt = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rt=0, Rn=0
    let encoding: u32 = 0x01900090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDA_A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_lda_a1_a_field_rt_1_poweroftwo_90_01901090() {
    // Encoding: 0x01901090
    // Test aarch32_LDA_A1_A field Rt = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rt=1, cond=0
    let encoding: u32 = 0x01901090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDA_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_lda_a1_a_combo_0_90_01900090() {
    // Encoding: 0x01900090
    // Test aarch32_LDA_A1_A field combination: cond=0, Rn=0, Rt=0
    // ISET: A32
    // Fields: Rn=0, cond=0, Rt=0
    let encoding: u32 = 0x01900090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDA_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_lda_a1_a_special_cond_0_condition_eq_144_01900090() {
    // Encoding: 0x01900090
    // Test aarch32_LDA_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: cond=0, Rt=0, Rn=0
    let encoding: u32 = 0x01900090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDA_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_lda_a1_a_special_cond_1_condition_ne_144_11900090() {
    // Encoding: 0x11900090
    // Test aarch32_LDA_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: Rn=0, cond=1, Rt=0
    let encoding: u32 = 0x11900090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDA_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_lda_a1_a_special_cond_2_condition_cs_hs_144_21900090() {
    // Encoding: 0x21900090
    // Test aarch32_LDA_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: cond=2, Rn=0, Rt=0
    let encoding: u32 = 0x21900090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDA_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_lda_a1_a_special_cond_3_condition_cc_lo_144_31900090() {
    // Encoding: 0x31900090
    // Test aarch32_LDA_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=3
    let encoding: u32 = 0x31900090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDA_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_lda_a1_a_special_cond_4_condition_mi_144_41900090() {
    // Encoding: 0x41900090
    // Test aarch32_LDA_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: cond=4, Rn=0, Rt=0
    let encoding: u32 = 0x41900090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDA_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_lda_a1_a_special_cond_5_condition_pl_144_51900090() {
    // Encoding: 0x51900090
    // Test aarch32_LDA_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: cond=5, Rn=0, Rt=0
    let encoding: u32 = 0x51900090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDA_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_lda_a1_a_special_cond_6_condition_vs_144_61900090() {
    // Encoding: 0x61900090
    // Test aarch32_LDA_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: Rt=0, cond=6, Rn=0
    let encoding: u32 = 0x61900090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDA_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_lda_a1_a_special_cond_7_condition_vc_144_71900090() {
    // Encoding: 0x71900090
    // Test aarch32_LDA_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: Rn=0, cond=7, Rt=0
    let encoding: u32 = 0x71900090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDA_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_lda_a1_a_special_cond_8_condition_hi_144_81900090() {
    // Encoding: 0x81900090
    // Test aarch32_LDA_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: cond=8, Rt=0, Rn=0
    let encoding: u32 = 0x81900090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDA_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_lda_a1_a_special_cond_9_condition_ls_144_91900090() {
    // Encoding: 0x91900090
    // Test aarch32_LDA_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: cond=9, Rt=0, Rn=0
    let encoding: u32 = 0x91900090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDA_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_lda_a1_a_special_cond_10_condition_ge_144_a1900090() {
    // Encoding: 0xA1900090
    // Test aarch32_LDA_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=10
    let encoding: u32 = 0xA1900090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDA_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_lda_a1_a_special_cond_11_condition_lt_144_b1900090() {
    // Encoding: 0xB1900090
    // Test aarch32_LDA_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=11
    let encoding: u32 = 0xB1900090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDA_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_lda_a1_a_special_cond_12_condition_gt_144_c1900090() {
    // Encoding: 0xC1900090
    // Test aarch32_LDA_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: cond=12, Rt=0, Rn=0
    let encoding: u32 = 0xC1900090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDA_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_lda_a1_a_special_cond_13_condition_le_144_d1900090() {
    // Encoding: 0xD1900090
    // Test aarch32_LDA_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=13
    let encoding: u32 = 0xD1900090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDA_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_lda_a1_a_special_cond_14_condition_al_144_e1900090() {
    // Encoding: 0xE1900090
    // Test aarch32_LDA_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: cond=14, Rn=0, Rt=0
    let encoding: u32 = 0xE1900090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDA_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_lda_a1_a_special_cond_15_condition_nv_144_f1900090() {
    // Encoding: 0xF1900090
    // Test aarch32_LDA_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: cond=15, Rn=0, Rt=0
    let encoding: u32 = 0xF1900090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDA_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_lda_a1_a_invalid_0_90_01900090() {
    // Encoding: 0x01900090
    // Test aarch32_LDA_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }
    // ISET: A32
    // Fields: Rt=0, Rn=0, cond=0
    let encoding: u32 = 0x01900090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDA_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_lda_a1_a_invalid_1_90_01900090() {
    // Encoding: 0x01900090
    // Test aarch32_LDA_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Rt=0, cond=0, Rn=0
    let encoding: u32 = 0x01900090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDA_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_lda_t1_a_field_rn_0_min_a0_e8d000a0() {
    // Thumb encoding (32): 0xE8D000A0
    // Test aarch32_LDA_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8D000A0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDA_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_lda_t1_a_field_rn_1_poweroftwo_a0_e8d100a0() {
    // Thumb encoding (32): 0xE8D100A0
    // Test aarch32_LDA_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, Rn=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8D100A0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDA_T1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_lda_t1_a_field_rt_0_min_a0_e8d000a0() {
    // Thumb encoding (32): 0xE8D000A0
    // Test aarch32_LDA_T1_A field Rt = 0 (Min)
    // ISET: T32
    // Fields: Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8D000A0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDA_T1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_lda_t1_a_field_rt_1_poweroftwo_a0_e8d010a0() {
    // Thumb encoding (32): 0xE8D010A0
    // Test aarch32_LDA_T1_A field Rt = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Rt=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8D010A0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDA_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_lda_t1_a_combo_0_a0_e8d000a0() {
    // Thumb encoding (32): 0xE8D000A0
    // Test aarch32_LDA_T1_A field combination: Rn=0, Rt=0
    // ISET: T32
    // Fields: Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8D000A0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDA_T1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_lda_t1_a_invalid_0_a0_e8d000a0() {
    // Thumb encoding (32): 0xE8D000A0
    // Test aarch32_LDA_T1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }
    // ISET: T32
    // Fields: Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8D000A0;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_LDA_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_lda_t1_a_invalid_1_a0_e8d000a0() {
    // Thumb encoding (32): 0xE8D000A0
    // Test aarch32_LDA_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8D000A0;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

// ============================================================================
// aarch32_LDAEXD_A Tests
// ============================================================================

/// Provenance: aarch32_LDAEXD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_ldaexd_a1_a_field_cond_0_min_290_01b00290() {
    // Encoding: 0x01B00290
    // Test aarch32_LDAEXD_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rn=0, Rt=0
    let encoding: u32 = 0x01B00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_ldaexd_a1_a_field_cond_1_poweroftwo_290_11b00290() {
    // Encoding: 0x11B00290
    // Test aarch32_LDAEXD_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=1
    let encoding: u32 = 0x11B00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_ldaexd_a1_a_field_cond_2_poweroftwo_290_21b00290() {
    // Encoding: 0x21B00290
    // Test aarch32_LDAEXD_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=2, Rn=0, Rt=0
    let encoding: u32 = 0x21B00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_ldaexd_a1_a_field_cond_3_poweroftwo_290_31b00290() {
    // Encoding: 0x31B00290
    // Test aarch32_LDAEXD_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, Rn=0, cond=3
    let encoding: u32 = 0x31B00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_ldaexd_a1_a_field_cond_4_poweroftwo_290_41b00290() {
    // Encoding: 0x41B00290
    // Test aarch32_LDAEXD_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=4
    let encoding: u32 = 0x41B00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_ldaexd_a1_a_field_cond_5_poweroftwo_290_51b00290() {
    // Encoding: 0x51B00290
    // Test aarch32_LDAEXD_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=5, Rt=0, Rn=0
    let encoding: u32 = 0x51B00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_ldaexd_a1_a_field_cond_6_poweroftwo_290_61b00290() {
    // Encoding: 0x61B00290
    // Test aarch32_LDAEXD_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, cond=6, Rn=0
    let encoding: u32 = 0x61B00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_ldaexd_a1_a_field_cond_7_poweroftwo_290_71b00290() {
    // Encoding: 0x71B00290
    // Test aarch32_LDAEXD_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=7, Rt=0
    let encoding: u32 = 0x71B00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_ldaexd_a1_a_field_cond_8_poweroftwo_290_81b00290() {
    // Encoding: 0x81B00290
    // Test aarch32_LDAEXD_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=8, Rt=0, Rn=0
    let encoding: u32 = 0x81B00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_ldaexd_a1_a_field_cond_9_poweroftwo_290_91b00290() {
    // Encoding: 0x91B00290
    // Test aarch32_LDAEXD_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=9, Rt=0
    let encoding: u32 = 0x91B00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_ldaexd_a1_a_field_cond_10_poweroftwo_290_a1b00290() {
    // Encoding: 0xA1B00290
    // Test aarch32_LDAEXD_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, Rn=0, cond=10
    let encoding: u32 = 0xA1B00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_ldaexd_a1_a_field_cond_11_poweroftwo_290_b1b00290() {
    // Encoding: 0xB1B00290
    // Test aarch32_LDAEXD_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, cond=11, Rn=0
    let encoding: u32 = 0xB1B00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_ldaexd_a1_a_field_cond_12_poweroftwo_290_c1b00290() {
    // Encoding: 0xC1B00290
    // Test aarch32_LDAEXD_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, cond=12, Rn=0
    let encoding: u32 = 0xC1B00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_ldaexd_a1_a_field_cond_13_poweroftwo_290_d1b00290() {
    // Encoding: 0xD1B00290
    // Test aarch32_LDAEXD_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=13, Rn=0, Rt=0
    let encoding: u32 = 0xD1B00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_ldaexd_a1_a_field_cond_14_poweroftwo_290_e1b00290() {
    // Encoding: 0xE1B00290
    // Test aarch32_LDAEXD_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=14, Rt=0, Rn=0
    let encoding: u32 = 0xE1B00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_ldaexd_a1_a_field_cond_15_max_290_f1b00290() {
    // Encoding: 0xF1B00290
    // Test aarch32_LDAEXD_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: cond=15, Rn=0, Rt=0
    let encoding: u32 = 0xF1B00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXD_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldaexd_a1_a_field_rn_0_min_290_01b00290() {
    // Encoding: 0x01B00290
    // Test aarch32_LDAEXD_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rt=0, Rn=0
    let encoding: u32 = 0x01B00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXD_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldaexd_a1_a_field_rn_1_poweroftwo_290_01b10290() {
    // Encoding: 0x01B10290
    // Test aarch32_LDAEXD_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=1, Rt=0, cond=0
    let encoding: u32 = 0x01B10290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXD_A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldaexd_a1_a_field_rt_0_min_290_01b00290() {
    // Encoding: 0x01B00290
    // Test aarch32_LDAEXD_A1_A field Rt = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rt=0, Rn=0
    let encoding: u32 = 0x01B00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXD_A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldaexd_a1_a_field_rt_1_poweroftwo_290_01b01290() {
    // Encoding: 0x01B01290
    // Test aarch32_LDAEXD_A1_A field Rt = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=1, cond=0, Rn=0
    let encoding: u32 = 0x01B01290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXD_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_ldaexd_a1_a_combo_0_290_01b00290() {
    // Encoding: 0x01B00290
    // Test aarch32_LDAEXD_A1_A field combination: cond=0, Rn=0, Rt=0
    // ISET: A32
    // Fields: cond=0, Rt=0, Rn=0
    let encoding: u32 = 0x01B00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXD_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_ldaexd_a1_a_special_cond_0_condition_eq_656_01b00290() {
    // Encoding: 0x01B00290
    // Test aarch32_LDAEXD_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=0
    let encoding: u32 = 0x01B00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXD_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_ldaexd_a1_a_special_cond_1_condition_ne_656_11b00290() {
    // Encoding: 0x11B00290
    // Test aarch32_LDAEXD_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: Rt=0, cond=1, Rn=0
    let encoding: u32 = 0x11B00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXD_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_ldaexd_a1_a_special_cond_2_condition_cs_hs_656_21b00290() {
    // Encoding: 0x21B00290
    // Test aarch32_LDAEXD_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=2
    let encoding: u32 = 0x21B00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXD_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_ldaexd_a1_a_special_cond_3_condition_cc_lo_656_31b00290() {
    // Encoding: 0x31B00290
    // Test aarch32_LDAEXD_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: cond=3, Rn=0, Rt=0
    let encoding: u32 = 0x31B00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXD_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_ldaexd_a1_a_special_cond_4_condition_mi_656_41b00290() {
    // Encoding: 0x41B00290
    // Test aarch32_LDAEXD_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: cond=4, Rt=0, Rn=0
    let encoding: u32 = 0x41B00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXD_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_ldaexd_a1_a_special_cond_5_condition_pl_656_51b00290() {
    // Encoding: 0x51B00290
    // Test aarch32_LDAEXD_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: Rn=0, cond=5, Rt=0
    let encoding: u32 = 0x51B00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXD_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_ldaexd_a1_a_special_cond_6_condition_vs_656_61b00290() {
    // Encoding: 0x61B00290
    // Test aarch32_LDAEXD_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: Rt=0, cond=6, Rn=0
    let encoding: u32 = 0x61B00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXD_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_ldaexd_a1_a_special_cond_7_condition_vc_656_71b00290() {
    // Encoding: 0x71B00290
    // Test aarch32_LDAEXD_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: cond=7, Rn=0, Rt=0
    let encoding: u32 = 0x71B00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXD_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_ldaexd_a1_a_special_cond_8_condition_hi_656_81b00290() {
    // Encoding: 0x81B00290
    // Test aarch32_LDAEXD_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: cond=8, Rn=0, Rt=0
    let encoding: u32 = 0x81B00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXD_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_ldaexd_a1_a_special_cond_9_condition_ls_656_91b00290() {
    // Encoding: 0x91B00290
    // Test aarch32_LDAEXD_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: Rt=0, Rn=0, cond=9
    let encoding: u32 = 0x91B00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXD_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_ldaexd_a1_a_special_cond_10_condition_ge_656_a1b00290() {
    // Encoding: 0xA1B00290
    // Test aarch32_LDAEXD_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: Rt=0, cond=10, Rn=0
    let encoding: u32 = 0xA1B00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXD_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_ldaexd_a1_a_special_cond_11_condition_lt_656_b1b00290() {
    // Encoding: 0xB1B00290
    // Test aarch32_LDAEXD_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: cond=11, Rn=0, Rt=0
    let encoding: u32 = 0xB1B00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXD_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_ldaexd_a1_a_special_cond_12_condition_gt_656_c1b00290() {
    // Encoding: 0xC1B00290
    // Test aarch32_LDAEXD_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=12
    let encoding: u32 = 0xC1B00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXD_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_ldaexd_a1_a_special_cond_13_condition_le_656_d1b00290() {
    // Encoding: 0xD1B00290
    // Test aarch32_LDAEXD_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=13
    let encoding: u32 = 0xD1B00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXD_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_ldaexd_a1_a_special_cond_14_condition_al_656_e1b00290() {
    // Encoding: 0xE1B00290
    // Test aarch32_LDAEXD_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=14
    let encoding: u32 = 0xE1B00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXD_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_ldaexd_a1_a_special_cond_15_condition_nv_656_f1b00290() {
    // Encoding: 0xF1B00290
    // Test aarch32_LDAEXD_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=15
    let encoding: u32 = 0xF1B00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEXD_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Rt" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t2" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Rt\" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t2\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldaexd_a1_a_invalid_0_290_01b00290() {
    // Encoding: 0x01B00290
    // Test aarch32_LDAEXD_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Rt" }), indices: [Single(LitInt(0))] }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t2" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }
    // ISET: A32
    // Fields: Rt=0, cond=0, Rn=0
    let encoding: u32 = 0x01B00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDAEXD_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldaexd_a1_a_invalid_1_290_01b00290() {
    // Encoding: 0x01B00290
    // Test aarch32_LDAEXD_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=0
    let encoding: u32 = 0x01B00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDAEXD_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldaexd_t1_a_field_rn_0_min_f0_e8d000f0() {
    // Thumb encoding (32): 0xE8D000F0
    // Test aarch32_LDAEXD_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rt=0, Rt2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8D000F0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDAEXD_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldaexd_t1_a_field_rn_1_poweroftwo_f0_e8d100f0() {
    // Thumb encoding (32): 0xE8D100F0
    // Test aarch32_LDAEXD_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=1, Rt2=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8D100F0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDAEXD_T1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldaexd_t1_a_field_rt_0_min_f0_e8d000f0() {
    // Thumb encoding (32): 0xE8D000F0
    // Test aarch32_LDAEXD_T1_A field Rt = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rt2=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8D000F0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDAEXD_T1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldaexd_t1_a_field_rt_1_poweroftwo_f0_e8d010f0() {
    // Thumb encoding (32): 0xE8D010F0
    // Test aarch32_LDAEXD_T1_A field Rt = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Rt=1, Rt2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8D010F0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDAEXD_T1_A
/// ASL: `field Rt2 8 +: 4`
/// Requirement: FieldBoundary { field: "Rt2", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldaexd_t1_a_field_rt2_0_min_f0_e8d000f0() {
    // Thumb encoding (32): 0xE8D000F0
    // Test aarch32_LDAEXD_T1_A field Rt2 = 0 (Min)
    // ISET: T32
    // Fields: Rt2=0, Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8D000F0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDAEXD_T1_A
/// ASL: `field Rt2 8 +: 4`
/// Requirement: FieldBoundary { field: "Rt2", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldaexd_t1_a_field_rt2_1_poweroftwo_f0_e8d001f0() {
    // Thumb encoding (32): 0xE8D001F0
    // Test aarch32_LDAEXD_T1_A field Rt2 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt2=1, Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8D001F0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDAEXD_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_ldaexd_t1_a_combo_0_f0_e8d000f0() {
    // Thumb encoding (32): 0xE8D000F0
    // Test aarch32_LDAEXD_T1_A field combination: Rn=0, Rt=0, Rt2=0
    // ISET: T32
    // Fields: Rt2=0, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8D000F0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDAEXD_T1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t2" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) } }, rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t2" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t2\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }) } }, rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t2\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldaexd_t1_a_invalid_0_f0_e8d000f0() {
    // Thumb encoding (32): 0xE8D000F0
    // Test aarch32_LDAEXD_T1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t2" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) } }, rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t2" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }
    // ISET: T32
    // Fields: Rt2=0, Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8D000F0;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_LDAEXD_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldaexd_t1_a_invalid_1_f0_e8d000f0() {
    // Thumb encoding (32): 0xE8D000F0
    // Test aarch32_LDAEXD_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rt2=0, Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8D000F0;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

// ============================================================================
// aarch32_LDRH_i_A Tests
// ============================================================================

/// Provenance: aarch32_LDRH_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_ldrh_i_a1_a_field_cond_0_min_b0_005000b0() {
    // Encoding: 0x005000B0
    // Test aarch32_LDRH_i_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: Rt=0, U=0, imm4H=0, imm4L=0, W=0, Rn=0, P=0, cond=0
    let encoding: u32 = 0x005000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_ldrh_i_a1_a_field_cond_1_poweroftwo_b0_105000b0() {
    // Encoding: 0x105000B0
    // Test aarch32_LDRH_i_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, Rn=0, imm4L=0, U=0, cond=1, Rt=0, W=0, imm4H=0
    let encoding: u32 = 0x105000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_ldrh_i_a1_a_field_cond_2_poweroftwo_b0_205000b0() {
    // Encoding: 0x205000B0
    // Test aarch32_LDRH_i_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rt=0, U=0, P=0, imm4L=0, W=0, imm4H=0, cond=2
    let encoding: u32 = 0x205000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_ldrh_i_a1_a_field_cond_3_poweroftwo_b0_305000b0() {
    // Encoding: 0x305000B0
    // Test aarch32_LDRH_i_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, imm4L=0, Rt=0, imm4H=0, P=0, W=0, cond=3, U=0
    let encoding: u32 = 0x305000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_ldrh_i_a1_a_field_cond_4_poweroftwo_b0_405000b0() {
    // Encoding: 0x405000B0
    // Test aarch32_LDRH_i_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, Rn=0, imm4H=0, imm4L=0, Rt=0, cond=4, U=0, W=0
    let encoding: u32 = 0x405000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_ldrh_i_a1_a_field_cond_5_poweroftwo_b0_505000b0() {
    // Encoding: 0x505000B0
    // Test aarch32_LDRH_i_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, Rn=0, imm4L=0, imm4H=0, cond=5, W=0, Rt=0, P=0
    let encoding: u32 = 0x505000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_ldrh_i_a1_a_field_cond_6_poweroftwo_b0_605000b0() {
    // Encoding: 0x605000B0
    // Test aarch32_LDRH_i_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, P=0, U=0, Rt=0, imm4L=0, cond=6, imm4H=0, W=0
    let encoding: u32 = 0x605000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_ldrh_i_a1_a_field_cond_7_poweroftwo_b0_705000b0() {
    // Encoding: 0x705000B0
    // Test aarch32_LDRH_i_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4H=0, U=0, imm4L=0, Rn=0, W=0, Rt=0, cond=7, P=0
    let encoding: u32 = 0x705000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_ldrh_i_a1_a_field_cond_8_poweroftwo_b0_805000b0() {
    // Encoding: 0x805000B0
    // Test aarch32_LDRH_i_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, imm4L=0, cond=8, imm4H=0, W=0, Rt=0, Rn=0, U=0
    let encoding: u32 = 0x805000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_ldrh_i_a1_a_field_cond_9_poweroftwo_b0_905000b0() {
    // Encoding: 0x905000B0
    // Test aarch32_LDRH_i_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, Rt=0, imm4L=0, P=0, imm4H=0, cond=9, U=0, Rn=0
    let encoding: u32 = 0x905000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_ldrh_i_a1_a_field_cond_10_poweroftwo_b0_a05000b0() {
    // Encoding: 0xA05000B0
    // Test aarch32_LDRH_i_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=10, imm4H=0, Rt=0, Rn=0, U=0, P=0, imm4L=0, W=0
    let encoding: u32 = 0xA05000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_ldrh_i_a1_a_field_cond_11_poweroftwo_b0_b05000b0() {
    // Encoding: 0xB05000B0
    // Test aarch32_LDRH_i_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4H=0, cond=11, Rt=0, Rn=0, imm4L=0, P=0, W=0, U=0
    let encoding: u32 = 0xB05000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_ldrh_i_a1_a_field_cond_12_poweroftwo_b0_c05000b0() {
    // Encoding: 0xC05000B0
    // Test aarch32_LDRH_i_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, U=0, W=0, Rt=0, P=0, imm4H=0, imm4L=0, cond=12
    let encoding: u32 = 0xC05000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_ldrh_i_a1_a_field_cond_13_poweroftwo_b0_d05000b0() {
    // Encoding: 0xD05000B0
    // Test aarch32_LDRH_i_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4L=0, W=0, Rt=0, U=0, cond=13, P=0, Rn=0, imm4H=0
    let encoding: u32 = 0xD05000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_ldrh_i_a1_a_field_cond_14_poweroftwo_b0_e05000b0() {
    // Encoding: 0xE05000B0
    // Test aarch32_LDRH_i_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, imm4H=0, P=0, W=0, Rn=0, U=0, imm4L=0, cond=14
    let encoding: u32 = 0xE05000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_ldrh_i_a1_a_field_cond_15_max_b0_f05000b0() {
    // Encoding: 0xF05000B0
    // Test aarch32_LDRH_i_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: Rn=0, P=0, Rt=0, U=0, W=0, cond=15, imm4L=0, imm4H=0
    let encoding: u32 = 0xF05000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_i_A1_A
/// ASL: `field P 24 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldrh_i_a1_a_field_p_0_min_b0_005000b0() {
    // Encoding: 0x005000B0
    // Test aarch32_LDRH_i_A1_A field P = 0 (Min)
    // ISET: A32
    // Fields: cond=0, P=0, W=0, Rn=0, imm4L=0, Rt=0, imm4H=0, U=0
    let encoding: u32 = 0x005000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_i_A1_A
/// ASL: `field P 24 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldrh_i_a1_a_field_p_1_max_b0_015000b0() {
    // Encoding: 0x015000B0
    // Test aarch32_LDRH_i_A1_A field P = 1 (Max)
    // ISET: A32
    // Fields: W=0, imm4H=0, Rn=0, imm4L=0, P=1, cond=0, Rt=0, U=0
    let encoding: u32 = 0x015000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_i_A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldrh_i_a1_a_field_u_0_min_b0_005000b0() {
    // Encoding: 0x005000B0
    // Test aarch32_LDRH_i_A1_A field U = 0 (Min)
    // ISET: A32
    // Fields: imm4L=0, Rt=0, U=0, P=0, cond=0, W=0, imm4H=0, Rn=0
    let encoding: u32 = 0x005000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_i_A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldrh_i_a1_a_field_u_1_max_b0_00d000b0() {
    // Encoding: 0x00D000B0
    // Test aarch32_LDRH_i_A1_A field U = 1 (Max)
    // ISET: A32
    // Fields: W=0, Rt=0, Rn=0, cond=0, U=1, imm4H=0, P=0, imm4L=0
    let encoding: u32 = 0x00D000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_i_A1_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldrh_i_a1_a_field_w_0_min_b0_005000b0() {
    // Encoding: 0x005000B0
    // Test aarch32_LDRH_i_A1_A field W = 0 (Min)
    // ISET: A32
    // Fields: Rt=0, W=0, Rn=0, U=0, P=0, imm4H=0, imm4L=0, cond=0
    let encoding: u32 = 0x005000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_i_A1_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldrh_i_a1_a_field_w_1_max_b0_007000b0() {
    // Encoding: 0x007000B0
    // Test aarch32_LDRH_i_A1_A field W = 1 (Max)
    // ISET: A32
    // Fields: U=0, imm4L=0, imm4H=0, cond=0, Rn=0, W=1, P=0, Rt=0
    let encoding: u32 = 0x007000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_i_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrh_i_a1_a_field_rn_0_min_b0_005000b0() {
    // Encoding: 0x005000B0
    // Test aarch32_LDRH_i_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: imm4L=0, imm4H=0, Rt=0, U=0, cond=0, W=0, Rn=0, P=0
    let encoding: u32 = 0x005000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_i_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrh_i_a1_a_field_rn_1_poweroftwo_b0_005100b0() {
    // Encoding: 0x005100B0
    // Test aarch32_LDRH_i_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, U=0, Rn=1, imm4H=0, cond=0, Rt=0, imm4L=0, W=0
    let encoding: u32 = 0x005100B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_i_A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrh_i_a1_a_field_rt_0_min_b0_005000b0() {
    // Encoding: 0x005000B0
    // Test aarch32_LDRH_i_A1_A field Rt = 0 (Min)
    // ISET: A32
    // Fields: U=0, cond=0, imm4L=0, W=0, P=0, Rt=0, imm4H=0, Rn=0
    let encoding: u32 = 0x005000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_i_A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrh_i_a1_a_field_rt_1_poweroftwo_b0_005010b0() {
    // Encoding: 0x005010B0
    // Test aarch32_LDRH_i_A1_A field Rt = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, imm4L=0, cond=0, U=0, imm4H=0, Rn=0, Rt=1, P=0
    let encoding: u32 = 0x005010B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_i_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_ldrh_i_a1_a_field_imm4h_0_zero_b0_005000b0() {
    // Encoding: 0x005000B0
    // Test aarch32_LDRH_i_A1_A field imm4H = 0 (Zero)
    // ISET: A32
    // Fields: cond=0, imm4L=0, imm4H=0, P=0, W=0, U=0, Rt=0, Rn=0
    let encoding: u32 = 0x005000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_i_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_ldrh_i_a1_a_field_imm4h_1_poweroftwo_b0_005001b0() {
    // Encoding: 0x005001B0
    // Test aarch32_LDRH_i_A1_A field imm4H = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, imm4L=0, Rn=0, cond=0, imm4H=1, U=0, P=0, W=0
    let encoding: u32 = 0x005001B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_i_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_ldrh_i_a1_a_field_imm4h_3_poweroftwominusone_b0_005003b0() {
    // Encoding: 0x005003B0
    // Test aarch32_LDRH_i_A1_A field imm4H = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, P=0, W=0, Rt=0, U=0, Rn=0, imm4H=3, imm4L=0
    let encoding: u32 = 0x005003B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_i_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_ldrh_i_a1_a_field_imm4h_4_poweroftwo_b0_005004b0() {
    // Encoding: 0x005004B0
    // Test aarch32_LDRH_i_A1_A field imm4H = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, Rn=0, P=0, cond=0, U=0, imm4L=0, imm4H=4, Rt=0
    let encoding: u32 = 0x005004B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_i_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_aarch32_ldrh_i_a1_a_field_imm4h_7_poweroftwominusone_b0_005007b0() {
    // Encoding: 0x005007B0
    // Test aarch32_LDRH_i_A1_A field imm4H = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: P=0, Rn=0, W=0, imm4H=7, U=0, cond=0, imm4L=0, Rt=0
    let encoding: u32 = 0x005007B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_i_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_ldrh_i_a1_a_field_imm4h_8_poweroftwo_b0_005008b0() {
    // Encoding: 0x005008B0
    // Test aarch32_LDRH_i_A1_A field imm4H = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4L=0, W=0, P=0, Rn=0, U=0, imm4H=8, Rt=0, cond=0
    let encoding: u32 = 0x005008B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_i_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_aarch32_ldrh_i_a1_a_field_imm4h_15_max_b0_00500fb0() {
    // Encoding: 0x00500FB0
    // Test aarch32_LDRH_i_A1_A field imm4H = 15 (Max)
    // ISET: A32
    // Fields: U=0, cond=0, imm4H=15, Rn=0, Rt=0, P=0, W=0, imm4L=0
    let encoding: u32 = 0x00500FB0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_i_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_ldrh_i_a1_a_field_imm4l_0_zero_b0_005000b0() {
    // Encoding: 0x005000B0
    // Test aarch32_LDRH_i_A1_A field imm4L = 0 (Zero)
    // ISET: A32
    // Fields: imm4H=0, W=0, P=0, Rn=0, Rt=0, U=0, cond=0, imm4L=0
    let encoding: u32 = 0x005000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_i_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_ldrh_i_a1_a_field_imm4l_1_poweroftwo_b0_005000b1() {
    // Encoding: 0x005000B1
    // Test aarch32_LDRH_i_A1_A field imm4L = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, imm4L=1, imm4H=0, Rt=0, Rn=0, cond=0, P=0, W=0
    let encoding: u32 = 0x005000B1;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_i_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_ldrh_i_a1_a_field_imm4l_3_poweroftwominusone_b0_005000b3() {
    // Encoding: 0x005000B3
    // Test aarch32_LDRH_i_A1_A field imm4L = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm4H=0, imm4L=3, P=0, W=0, Rn=0, U=0, Rt=0, cond=0
    let encoding: u32 = 0x005000B3;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_i_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_ldrh_i_a1_a_field_imm4l_4_poweroftwo_b0_005000b4() {
    // Encoding: 0x005000B4
    // Test aarch32_LDRH_i_A1_A field imm4L = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, U=0, cond=0, imm4H=0, W=0, Rn=0, Rt=0, imm4L=4
    let encoding: u32 = 0x005000B4;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_i_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_aarch32_ldrh_i_a1_a_field_imm4l_7_poweroftwominusone_b0_005000b7() {
    // Encoding: 0x005000B7
    // Test aarch32_LDRH_i_A1_A field imm4L = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: U=0, Rn=0, P=0, W=0, cond=0, imm4L=7, imm4H=0, Rt=0
    let encoding: u32 = 0x005000B7;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_i_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_ldrh_i_a1_a_field_imm4l_8_poweroftwo_b0_005000b8() {
    // Encoding: 0x005000B8
    // Test aarch32_LDRH_i_A1_A field imm4L = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, P=0, U=0, W=0, Rt=0, imm4L=8, imm4H=0, Rn=0
    let encoding: u32 = 0x005000B8;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_i_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_aarch32_ldrh_i_a1_a_field_imm4l_15_max_b0_005000bf() {
    // Encoding: 0x005000BF
    // Test aarch32_LDRH_i_A1_A field imm4L = 15 (Max)
    // ISET: A32
    // Fields: imm4L=15, imm4H=0, U=0, W=0, Rn=0, Rt=0, cond=0, P=0
    let encoding: u32 = 0x005000BF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_i_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_ldrh_i_a1_a_combo_0_b0_005000b0() {
    // Encoding: 0x005000B0
    // Test aarch32_LDRH_i_A1_A field combination: cond=0, P=0, U=0, W=0, Rn=0, Rt=0, imm4H=0, imm4L=0
    // ISET: A32
    // Fields: Rt=0, Rn=0, U=0, imm4L=0, cond=0, W=0, P=0, imm4H=0
    let encoding: u32 = 0x005000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_i_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_ldrh_i_a1_a_special_cond_0_condition_eq_176_005000b0() {
    // Encoding: 0x005000B0
    // Test aarch32_LDRH_i_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: P=0, Rn=0, W=0, U=0, imm4L=0, cond=0, imm4H=0, Rt=0
    let encoding: u32 = 0x005000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_i_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_ldrh_i_a1_a_special_cond_1_condition_ne_176_105000b0() {
    // Encoding: 0x105000B0
    // Test aarch32_LDRH_i_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: imm4H=0, Rt=0, W=0, Rn=0, U=0, imm4L=0, cond=1, P=0
    let encoding: u32 = 0x105000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_i_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_ldrh_i_a1_a_special_cond_2_condition_cs_hs_176_205000b0() {
    // Encoding: 0x205000B0
    // Test aarch32_LDRH_i_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: Rt=0, cond=2, P=0, W=0, U=0, Rn=0, imm4H=0, imm4L=0
    let encoding: u32 = 0x205000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_i_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_ldrh_i_a1_a_special_cond_3_condition_cc_lo_176_305000b0() {
    // Encoding: 0x305000B0
    // Test aarch32_LDRH_i_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: cond=3, U=0, Rt=0, Rn=0, W=0, imm4L=0, imm4H=0, P=0
    let encoding: u32 = 0x305000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_i_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_ldrh_i_a1_a_special_cond_4_condition_mi_176_405000b0() {
    // Encoding: 0x405000B0
    // Test aarch32_LDRH_i_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: P=0, Rt=0, cond=4, imm4H=0, U=0, Rn=0, W=0, imm4L=0
    let encoding: u32 = 0x405000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_i_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_ldrh_i_a1_a_special_cond_5_condition_pl_176_505000b0() {
    // Encoding: 0x505000B0
    // Test aarch32_LDRH_i_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: P=0, imm4L=0, U=0, Rn=0, W=0, imm4H=0, Rt=0, cond=5
    let encoding: u32 = 0x505000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_i_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_ldrh_i_a1_a_special_cond_6_condition_vs_176_605000b0() {
    // Encoding: 0x605000B0
    // Test aarch32_LDRH_i_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: P=0, W=0, cond=6, Rt=0, imm4L=0, imm4H=0, U=0, Rn=0
    let encoding: u32 = 0x605000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_i_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_ldrh_i_a1_a_special_cond_7_condition_vc_176_705000b0() {
    // Encoding: 0x705000B0
    // Test aarch32_LDRH_i_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: U=0, imm4L=0, imm4H=0, cond=7, W=0, Rn=0, P=0, Rt=0
    let encoding: u32 = 0x705000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_i_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_ldrh_i_a1_a_special_cond_8_condition_hi_176_805000b0() {
    // Encoding: 0x805000B0
    // Test aarch32_LDRH_i_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: U=0, W=0, imm4L=0, imm4H=0, Rt=0, P=0, Rn=0, cond=8
    let encoding: u32 = 0x805000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_i_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_ldrh_i_a1_a_special_cond_9_condition_ls_176_905000b0() {
    // Encoding: 0x905000B0
    // Test aarch32_LDRH_i_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: Rn=0, imm4L=0, P=0, imm4H=0, cond=9, U=0, W=0, Rt=0
    let encoding: u32 = 0x905000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_i_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_ldrh_i_a1_a_special_cond_10_condition_ge_176_a05000b0() {
    // Encoding: 0xA05000B0
    // Test aarch32_LDRH_i_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: imm4L=0, W=0, Rn=0, Rt=0, cond=10, imm4H=0, P=0, U=0
    let encoding: u32 = 0xA05000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_i_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_ldrh_i_a1_a_special_cond_11_condition_lt_176_b05000b0() {
    // Encoding: 0xB05000B0
    // Test aarch32_LDRH_i_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: imm4H=0, cond=11, W=0, Rt=0, Rn=0, imm4L=0, U=0, P=0
    let encoding: u32 = 0xB05000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_i_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_ldrh_i_a1_a_special_cond_12_condition_gt_176_c05000b0() {
    // Encoding: 0xC05000B0
    // Test aarch32_LDRH_i_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: U=0, W=0, Rn=0, Rt=0, imm4L=0, imm4H=0, cond=12, P=0
    let encoding: u32 = 0xC05000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_i_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_ldrh_i_a1_a_special_cond_13_condition_le_176_d05000b0() {
    // Encoding: 0xD05000B0
    // Test aarch32_LDRH_i_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: P=0, imm4H=0, W=0, Rt=0, U=0, Rn=0, imm4L=0, cond=13
    let encoding: u32 = 0xD05000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_i_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_ldrh_i_a1_a_special_cond_14_condition_al_176_e05000b0() {
    // Encoding: 0xE05000B0
    // Test aarch32_LDRH_i_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: imm4H=0, U=0, Rn=0, Rt=0, W=0, cond=14, imm4L=0, P=0
    let encoding: u32 = 0xE05000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_i_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_ldrh_i_a1_a_special_cond_15_condition_nv_176_f05000b0() {
    // Encoding: 0xF05000B0
    // Test aarch32_LDRH_i_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: cond=15, Rn=0, imm4H=0, U=0, W=0, Rt=0, P=0, imm4L=0
    let encoding: u32 = 0xF05000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRH_i_A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Binary { op: Eq, lhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Binary { op: Eq, lhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"wback\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }) } } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrh_i_a1_a_invalid_0_b0_005000b0() {
    // Encoding: 0x005000B0
    // Test aarch32_LDRH_i_A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Binary { op: Eq, lhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) } } }
    // ISET: A32
    // Fields: imm4H=0, cond=0, W=0, imm4L=0, U=0, P=0, Rn=0, Rt=0
    let encoding: u32 = 0x005000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRH_i_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrh_i_a1_a_invalid_1_b0_005000b0() {
    // Encoding: 0x005000B0
    // Test aarch32_LDRH_i_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: U=0, P=0, W=0, imm4L=0, Rn=0, imm4H=0, Rt=0, cond=0
    let encoding: u32 = 0x005000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRH_i_T1_A
/// ASL: `field imm5 22 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_ldrh_i_t1_a_field_imm5_0_zero_0_88000000() {
    // Thumb encoding (32): 0x88000000
    // Test aarch32_LDRH_i_T1_A field imm5 = 0 (Zero)
    // ISET: T32
    // Fields: Rt=0, imm5=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x88000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_i_T1_A
/// ASL: `field imm5 22 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_ldrh_i_t1_a_field_imm5_1_poweroftwo_0_88400000() {
    // Thumb encoding (32): 0x88400000
    // Test aarch32_LDRH_i_T1_A field imm5 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, Rn=0, imm5=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x88400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_i_T1_A
/// ASL: `field imm5 22 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_ldrh_i_t1_a_field_imm5_3_poweroftwominusone_0_88c00000() {
    // Thumb encoding (32): 0x88C00000
    // Test aarch32_LDRH_i_T1_A field imm5 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, imm5=3, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x88C00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_i_T1_A
/// ASL: `field imm5 22 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_ldrh_i_t1_a_field_imm5_4_poweroftwo_0_89000000() {
    // Thumb encoding (32): 0x89000000
    // Test aarch32_LDRH_i_T1_A field imm5 = 4 (PowerOfTwo)
    // ISET: T32
    // Fields: imm5=4, Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x89000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_i_T1_A
/// ASL: `field imm5 22 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_ldrh_i_t1_a_field_imm5_7_poweroftwominusone_0_89c00000() {
    // Thumb encoding (32): 0x89C00000
    // Test aarch32_LDRH_i_T1_A field imm5 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, imm5=7, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x89C00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_i_T1_A
/// ASL: `field imm5 22 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_ldrh_i_t1_a_field_imm5_8_poweroftwo_0_8a000000() {
    // Thumb encoding (32): 0x8A000000
    // Test aarch32_LDRH_i_T1_A field imm5 = 8 (PowerOfTwo)
    // ISET: T32
    // Fields: imm5=8, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x8A000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_i_T1_A
/// ASL: `field imm5 22 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 15, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (15)
#[test]
fn test_aarch32_ldrh_i_t1_a_field_imm5_15_poweroftwominusone_0_8bc00000() {
    // Thumb encoding (32): 0x8BC00000
    // Test aarch32_LDRH_i_T1_A field imm5 = 15 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm5=15, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x8BC00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_i_T1_A
/// ASL: `field imm5 22 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_ldrh_i_t1_a_field_imm5_16_poweroftwo_0_8c000000() {
    // Thumb encoding (32): 0x8C000000
    // Test aarch32_LDRH_i_T1_A field imm5 = 16 (PowerOfTwo)
    // ISET: T32
    // Fields: imm5=16, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x8C000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_i_T1_A
/// ASL: `field imm5 22 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 31, boundary: Max }
/// maximum immediate (31)
#[test]
fn test_aarch32_ldrh_i_t1_a_field_imm5_31_max_0_8fc00000() {
    // Thumb encoding (32): 0x8FC00000
    // Test aarch32_LDRH_i_T1_A field imm5 = 31 (Max)
    // ISET: T32
    // Fields: Rt=0, imm5=31, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x8FC00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_i_T1_A
/// ASL: `field Rn 19 +: 3`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrh_i_t1_a_field_rn_0_min_0_88000000() {
    // Thumb encoding (32): 0x88000000
    // Test aarch32_LDRH_i_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: imm5=0, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x88000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_i_T1_A
/// ASL: `field Rn 19 +: 3`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrh_i_t1_a_field_rn_1_poweroftwo_0_88080000() {
    // Thumb encoding (32): 0x88080000
    // Test aarch32_LDRH_i_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm5=0, Rn=1, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x88080000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_i_T1_A
/// ASL: `field Rt 16 +: 3`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrh_i_t1_a_field_rt_0_min_0_88000000() {
    // Thumb encoding (32): 0x88000000
    // Test aarch32_LDRH_i_T1_A field Rt = 0 (Min)
    // ISET: T32
    // Fields: imm5=0, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x88000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_i_T1_A
/// ASL: `field Rt 16 +: 3`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrh_i_t1_a_field_rt_1_poweroftwo_0_88010000() {
    // Thumb encoding (32): 0x88010000
    // Test aarch32_LDRH_i_T1_A field Rt = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Rt=1, imm5=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x88010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_i_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=0 (immediate value 0)
#[test]
fn test_aarch32_ldrh_i_t1_a_combo_0_0_88000000() {
    // Thumb encoding (32): 0x88000000
    // Test aarch32_LDRH_i_T1_A field combination: imm5=0, Rn=0, Rt=0
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm5=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x88000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_i_T2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrh_i_t2_a_field_rn_0_min_0_f8b00000() {
    // Thumb encoding (32): 0xF8B00000
    // Test aarch32_LDRH_i_T2_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, imm12=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8B00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_i_T2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrh_i_t2_a_field_rn_1_poweroftwo_0_f8b10000() {
    // Thumb encoding (32): 0xF8B10000
    // Test aarch32_LDRH_i_T2_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm12=0, Rn=1, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8B10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_i_T2_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrh_i_t2_a_field_rt_0_min_0_f8b00000() {
    // Thumb encoding (32): 0xF8B00000
    // Test aarch32_LDRH_i_T2_A field Rt = 0 (Min)
    // ISET: T32
    // Fields: imm12=0, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8B00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_i_T2_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrh_i_t2_a_field_rt_1_poweroftwo_0_f8b01000() {
    // Thumb encoding (32): 0xF8B01000
    // Test aarch32_LDRH_i_T2_A field Rt = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=1, Rn=0, imm12=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8B01000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_i_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_ldrh_i_t2_a_field_imm12_0_zero_0_f8b00000() {
    // Thumb encoding (32): 0xF8B00000
    // Test aarch32_LDRH_i_T2_A field imm12 = 0 (Zero)
    // ISET: T32
    // Fields: imm12=0, Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8B00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_i_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_ldrh_i_t2_a_field_imm12_1_poweroftwo_0_f8b00001() {
    // Thumb encoding (32): 0xF8B00001
    // Test aarch32_LDRH_i_T2_A field imm12 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, imm12=1, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8B00001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_i_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_ldrh_i_t2_a_field_imm12_3_poweroftwominusone_0_f8b00003() {
    // Thumb encoding (32): 0xF8B00003
    // Test aarch32_LDRH_i_T2_A field imm12 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm12=3
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8B00003;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_i_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_ldrh_i_t2_a_field_imm12_4_poweroftwo_0_f8b00004() {
    // Thumb encoding (32): 0xF8B00004
    // Test aarch32_LDRH_i_T2_A field imm12 = 4 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm12=4
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8B00004;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_i_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_ldrh_i_t2_a_field_imm12_7_poweroftwominusone_0_f8b00007() {
    // Thumb encoding (32): 0xF8B00007
    // Test aarch32_LDRH_i_T2_A field imm12 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm12=7
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8B00007;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_i_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_ldrh_i_t2_a_field_imm12_8_poweroftwo_0_f8b00008() {
    // Thumb encoding (32): 0xF8B00008
    // Test aarch32_LDRH_i_T2_A field imm12 = 8 (PowerOfTwo)
    // ISET: T32
    // Fields: imm12=8, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8B00008;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_i_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_ldrh_i_t2_a_field_imm12_15_poweroftwominusone_0_f8b0000f() {
    // Thumb encoding (32): 0xF8B0000F
    // Test aarch32_LDRH_i_T2_A field imm12 = 15 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm12=15, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8B0000F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_i_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_ldrh_i_t2_a_field_imm12_16_poweroftwo_0_f8b00010() {
    // Thumb encoding (32): 0xF8B00010
    // Test aarch32_LDRH_i_T2_A field imm12 = 16 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, Rn=0, imm12=16
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8B00010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_i_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_ldrh_i_t2_a_field_imm12_31_poweroftwominusone_0_f8b0001f() {
    // Thumb encoding (32): 0xF8B0001F
    // Test aarch32_LDRH_i_T2_A field imm12 = 31 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, Rn=0, imm12=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8B0001F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_i_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_ldrh_i_t2_a_field_imm12_32_poweroftwo_0_f8b00020() {
    // Thumb encoding (32): 0xF8B00020
    // Test aarch32_LDRH_i_T2_A field imm12 = 32 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, imm12=32, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8B00020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_i_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_ldrh_i_t2_a_field_imm12_63_poweroftwominusone_0_f8b0003f() {
    // Thumb encoding (32): 0xF8B0003F
    // Test aarch32_LDRH_i_T2_A field imm12 = 63 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, Rn=0, imm12=63
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8B0003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_i_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_ldrh_i_t2_a_field_imm12_64_poweroftwo_0_f8b00040() {
    // Thumb encoding (32): 0xF8B00040
    // Test aarch32_LDRH_i_T2_A field imm12 = 64 (PowerOfTwo)
    // ISET: T32
    // Fields: imm12=64, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8B00040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_i_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 127, boundary: PowerOfTwoMinusOne }
/// 2^7 - 1 = 127
#[test]
fn test_aarch32_ldrh_i_t2_a_field_imm12_127_poweroftwominusone_0_f8b0007f() {
    // Thumb encoding (32): 0xF8B0007F
    // Test aarch32_LDRH_i_T2_A field imm12 = 127 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm12=127, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8B0007F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_i_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_ldrh_i_t2_a_field_imm12_128_poweroftwo_0_f8b00080() {
    // Thumb encoding (32): 0xF8B00080
    // Test aarch32_LDRH_i_T2_A field imm12 = 128 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, imm12=128, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8B00080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_i_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 255, boundary: PowerOfTwoMinusOne }
/// 2^8 - 1 = 255
#[test]
fn test_aarch32_ldrh_i_t2_a_field_imm12_255_poweroftwominusone_0_f8b000ff() {
    // Thumb encoding (32): 0xF8B000FF
    // Test aarch32_LDRH_i_T2_A field imm12 = 255 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, imm12=255, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8B000FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_i_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 256, boundary: PowerOfTwo }
/// power of 2 (2^8 = 256)
#[test]
fn test_aarch32_ldrh_i_t2_a_field_imm12_256_poweroftwo_0_f8b00100() {
    // Thumb encoding (32): 0xF8B00100
    // Test aarch32_LDRH_i_T2_A field imm12 = 256 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm12=256
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8B00100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_i_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 511, boundary: PowerOfTwoMinusOne }
/// 2^9 - 1 = 511
#[test]
fn test_aarch32_ldrh_i_t2_a_field_imm12_511_poweroftwominusone_0_f8b001ff() {
    // Thumb encoding (32): 0xF8B001FF
    // Test aarch32_LDRH_i_T2_A field imm12 = 511 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm12=511
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8B001FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_i_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 512, boundary: PowerOfTwo }
/// power of 2 (2^9 = 512)
#[test]
fn test_aarch32_ldrh_i_t2_a_field_imm12_512_poweroftwo_0_f8b00200() {
    // Thumb encoding (32): 0xF8B00200
    // Test aarch32_LDRH_i_T2_A field imm12 = 512 (PowerOfTwo)
    // ISET: T32
    // Fields: imm12=512, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8B00200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_i_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1023, boundary: PowerOfTwoMinusOne }
/// 2^10 - 1 = 1023
#[test]
fn test_aarch32_ldrh_i_t2_a_field_imm12_1023_poweroftwominusone_0_f8b003ff() {
    // Thumb encoding (32): 0xF8B003FF
    // Test aarch32_LDRH_i_T2_A field imm12 = 1023 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm12=1023, Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8B003FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_i_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1024, boundary: PowerOfTwo }
/// power of 2 (2^10 = 1024)
#[test]
fn test_aarch32_ldrh_i_t2_a_field_imm12_1024_poweroftwo_0_f8b00400() {
    // Thumb encoding (32): 0xF8B00400
    // Test aarch32_LDRH_i_T2_A field imm12 = 1024 (PowerOfTwo)
    // ISET: T32
    // Fields: imm12=1024, Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8B00400;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_i_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2047, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (2047)
#[test]
fn test_aarch32_ldrh_i_t2_a_field_imm12_2047_poweroftwominusone_0_f8b007ff() {
    // Thumb encoding (32): 0xF8B007FF
    // Test aarch32_LDRH_i_T2_A field imm12 = 2047 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, imm12=2047, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8B007FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_i_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2048, boundary: PowerOfTwo }
/// power of 2 (2^11 = 2048)
#[test]
fn test_aarch32_ldrh_i_t2_a_field_imm12_2048_poweroftwo_0_f8b00800() {
    // Thumb encoding (32): 0xF8B00800
    // Test aarch32_LDRH_i_T2_A field imm12 = 2048 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, imm12=2048, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8B00800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_i_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4095, boundary: Max }
/// maximum immediate (4095)
#[test]
fn test_aarch32_ldrh_i_t2_a_field_imm12_4095_max_0_f8b00fff() {
    // Thumb encoding (32): 0xF8B00FFF
    // Test aarch32_LDRH_i_T2_A field imm12 = 4095 (Max)
    // ISET: T32
    // Fields: imm12=4095, Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8B00FFF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_i_T2_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_ldrh_i_t2_a_combo_0_0_f8b00000() {
    // Thumb encoding (32): 0xF8B00000
    // Test aarch32_LDRH_i_T2_A field combination: Rn=0, Rt=0, imm12=0
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm12=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8B00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_i_T3_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrh_i_t3_a_field_rn_0_min_800_f8300800() {
    // Thumb encoding (32): 0xF8300800
    // Test aarch32_LDRH_i_T3_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: imm8=0, Rn=0, Rt=0, U=0, W=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8300800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_i_T3_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrh_i_t3_a_field_rn_1_poweroftwo_800_f8310800() {
    // Thumb encoding (32): 0xF8310800
    // Test aarch32_LDRH_i_T3_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=0, Rt=0, P=0, U=0, W=0, Rn=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8310800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_i_T3_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrh_i_t3_a_field_rt_0_min_800_f8300800() {
    // Thumb encoding (32): 0xF8300800
    // Test aarch32_LDRH_i_T3_A field Rt = 0 (Min)
    // ISET: T32
    // Fields: Rt=0, U=0, W=0, P=0, imm8=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8300800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_i_T3_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrh_i_t3_a_field_rt_1_poweroftwo_800_f8301800() {
    // Thumb encoding (32): 0xF8301800
    // Test aarch32_LDRH_i_T3_A field Rt = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=1, U=0, W=0, Rn=0, P=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8301800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_i_T3_A
/// ASL: `field P 10 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldrh_i_t3_a_field_p_0_min_800_f8300800() {
    // Thumb encoding (32): 0xF8300800
    // Test aarch32_LDRH_i_T3_A field P = 0 (Min)
    // ISET: T32
    // Fields: W=0, P=0, imm8=0, Rn=0, U=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8300800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_i_T3_A
/// ASL: `field P 10 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldrh_i_t3_a_field_p_1_max_800_f8300c00() {
    // Thumb encoding (32): 0xF8300C00
    // Test aarch32_LDRH_i_T3_A field P = 1 (Max)
    // ISET: T32
    // Fields: Rt=0, Rn=0, P=1, U=0, W=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8300C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_i_T3_A
/// ASL: `field U 9 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldrh_i_t3_a_field_u_0_min_800_f8300800() {
    // Thumb encoding (32): 0xF8300800
    // Test aarch32_LDRH_i_T3_A field U = 0 (Min)
    // ISET: T32
    // Fields: U=0, imm8=0, W=0, Rt=0, Rn=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8300800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_i_T3_A
/// ASL: `field U 9 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldrh_i_t3_a_field_u_1_max_800_f8300a00() {
    // Thumb encoding (32): 0xF8300A00
    // Test aarch32_LDRH_i_T3_A field U = 1 (Max)
    // ISET: T32
    // Fields: Rn=0, Rt=0, U=1, W=0, imm8=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8300A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_i_T3_A
/// ASL: `field W 8 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldrh_i_t3_a_field_w_0_min_800_f8300800() {
    // Thumb encoding (32): 0xF8300800
    // Test aarch32_LDRH_i_T3_A field W = 0 (Min)
    // ISET: T32
    // Fields: U=0, W=0, Rt=0, imm8=0, Rn=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8300800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_i_T3_A
/// ASL: `field W 8 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldrh_i_t3_a_field_w_1_max_800_f8300900() {
    // Thumb encoding (32): 0xF8300900
    // Test aarch32_LDRH_i_T3_A field W = 1 (Max)
    // ISET: T32
    // Fields: Rn=0, P=0, W=1, Rt=0, U=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8300900;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_ldrh_i_t3_a_field_imm8_0_zero_800_f8300800() {
    // Thumb encoding (32): 0xF8300800
    // Test aarch32_LDRH_i_T3_A field imm8 = 0 (Zero)
    // ISET: T32
    // Fields: Rt=0, P=0, Rn=0, U=0, W=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8300800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_ldrh_i_t3_a_field_imm8_1_poweroftwo_800_f8300801() {
    // Thumb encoding (32): 0xF8300801
    // Test aarch32_LDRH_i_T3_A field imm8 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: W=0, imm8=1, P=0, Rn=0, Rt=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8300801;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_ldrh_i_t3_a_field_imm8_3_poweroftwominusone_800_f8300803() {
    // Thumb encoding (32): 0xF8300803
    // Test aarch32_LDRH_i_T3_A field imm8 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm8=3, Rt=0, Rn=0, U=0, P=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8300803;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_ldrh_i_t3_a_field_imm8_4_poweroftwo_800_f8300804() {
    // Thumb encoding (32): 0xF8300804
    // Test aarch32_LDRH_i_T3_A field imm8 = 4 (PowerOfTwo)
    // ISET: T32
    // Fields: P=0, W=0, Rn=0, Rt=0, U=0, imm8=4
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8300804;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_ldrh_i_t3_a_field_imm8_7_poweroftwominusone_800_f8300807() {
    // Thumb encoding (32): 0xF8300807
    // Test aarch32_LDRH_i_T3_A field imm8 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, imm8=7, Rt=0, P=0, U=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8300807;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_ldrh_i_t3_a_field_imm8_8_poweroftwo_800_f8300808() {
    // Thumb encoding (32): 0xF8300808
    // Test aarch32_LDRH_i_T3_A field imm8 = 8 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, W=0, P=0, Rn=0, imm8=8, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8300808;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_ldrh_i_t3_a_field_imm8_15_poweroftwominusone_800_f830080f() {
    // Thumb encoding (32): 0xF830080F
    // Test aarch32_LDRH_i_T3_A field imm8 = 15 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm8=15, P=0, W=0, U=0, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF830080F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_ldrh_i_t3_a_field_imm8_16_poweroftwo_800_f8300810() {
    // Thumb encoding (32): 0xF8300810
    // Test aarch32_LDRH_i_T3_A field imm8 = 16 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=16, Rt=0, U=0, W=0, P=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8300810;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_ldrh_i_t3_a_field_imm8_31_poweroftwominusone_800_f830081f() {
    // Thumb encoding (32): 0xF830081F
    // Test aarch32_LDRH_i_T3_A field imm8 = 31 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: U=0, imm8=31, W=0, Rt=0, P=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF830081F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_ldrh_i_t3_a_field_imm8_32_poweroftwo_800_f8300820() {
    // Thumb encoding (32): 0xF8300820
    // Test aarch32_LDRH_i_T3_A field imm8 = 32 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, P=0, U=0, W=0, imm8=32, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8300820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_ldrh_i_t3_a_field_imm8_63_poweroftwominusone_800_f830083f() {
    // Thumb encoding (32): 0xF830083F
    // Test aarch32_LDRH_i_T3_A field imm8 = 63 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, Rn=0, W=0, U=0, P=0, imm8=63
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF830083F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_ldrh_i_t3_a_field_imm8_64_poweroftwo_800_f8300840() {
    // Thumb encoding (32): 0xF8300840
    // Test aarch32_LDRH_i_T3_A field imm8 = 64 (PowerOfTwo)
    // ISET: T32
    // Fields: W=0, U=0, imm8=64, Rt=0, Rn=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8300840;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 127, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (127)
#[test]
fn test_aarch32_ldrh_i_t3_a_field_imm8_127_poweroftwominusone_800_f830087f() {
    // Thumb encoding (32): 0xF830087F
    // Test aarch32_LDRH_i_T3_A field imm8 = 127 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: P=0, U=0, Rt=0, imm8=127, W=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF830087F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_ldrh_i_t3_a_field_imm8_128_poweroftwo_800_f8300880() {
    // Thumb encoding (32): 0xF8300880
    // Test aarch32_LDRH_i_T3_A field imm8 = 128 (PowerOfTwo)
    // ISET: T32
    // Fields: U=0, P=0, Rt=0, Rn=0, W=0, imm8=128
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8300880;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 255, boundary: Max }
/// maximum immediate (255)
#[test]
fn test_aarch32_ldrh_i_t3_a_field_imm8_255_max_800_f83008ff() {
    // Thumb encoding (32): 0xF83008FF
    // Test aarch32_LDRH_i_T3_A field imm8 = 255 (Max)
    // ISET: T32
    // Fields: W=0, imm8=255, U=0, Rt=0, P=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF83008FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_i_T3_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_ldrh_i_t3_a_combo_0_800_f8300800() {
    // Thumb encoding (32): 0xF8300800
    // Test aarch32_LDRH_i_T3_A field combination: Rn=0, Rt=0, P=0, U=0, W=0, imm8=0
    // ISET: T32
    // Fields: imm8=0, Rt=0, U=0, Rn=0, W=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8300800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRH_i_T3_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "P" }), rhs: Binary { op: And, lhs: LitBits([false]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "W" }) } }, rhs: LitBits([false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"P\" }), rhs: Binary { op: And, lhs: LitBits([false]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"W\" }) } }, rhs: LitBits([false]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_ldrh_i_t3_a_invalid_0_800_f8300800() {
    // Thumb encoding (32): 0xF8300800
    // Test aarch32_LDRH_i_T3_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "P" }), rhs: Binary { op: And, lhs: LitBits([false]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "W" }) } }, rhs: LitBits([false]) }
    // ISET: T32
    // Fields: U=0, Rt=0, P=0, Rn=0, imm8=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8300800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_LDRH_i_T3_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_ldrh_i_t3_a_invalid_1_800_f8300800() {
    // Thumb encoding (32): 0xF8300800
    // Test aarch32_LDRH_i_T3_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: P=0, Rn=0, W=0, imm8=0, U=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8300800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_LDRH_i_T3_A
/// ASL: `Binary { op: Or, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: And, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "W" }) } }, rhs: LitBits([true]) }, rhs: Binary { op: Eq, lhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Or, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: Binary { op: And, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"W\" }) } }, rhs: LitBits([true]) }, rhs: Binary { op: Eq, lhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"wback\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }) } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrh_i_t3_a_invalid_2_800_f8300800() {
    // Thumb encoding (32): 0xF8300800
    // Test aarch32_LDRH_i_T3_A invalid encoding: Binary { op: Or, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: And, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "W" }) } }, rhs: LitBits([true]) }, rhs: Binary { op: Eq, lhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) } }
    // ISET: T32
    // Fields: W=0, U=0, imm8=0, Rn=0, P=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8300800;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRH_i_T3_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrh_i_t3_a_invalid_3_800_f8300800() {
    // Thumb encoding (32): 0xF8300800
    // Test aarch32_LDRH_i_T3_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rn=0, P=0, Rt=0, U=0, W=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8300800;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRH_i_A1_A
/// ASL: `UMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple multiply
#[test]
fn test_aarch32_ldrh_i_a1_a_umull_oracle_0_9ba27c20() {
    // Test UMULL: simple multiply (oracle)
    // Encoding: 0x9BA27C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3);
    set_w(&mut cpu, 1, 0x2);
    let encoding: u32 = 0x9BA27C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6, "X0 should be 0x0000000000000006");
}

/// Provenance: aarch32_LDRH_i_A1_A
/// ASL: `UMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max 32-bit * 2
#[test]
fn test_aarch32_ldrh_i_a1_a_umull_oracle_1_9ba27c20() {
    // Test UMULL: max 32-bit * 2 (oracle)
    // Encoding: 0x9BA27C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x9BA27C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0x00000001FFFFFFFE"
    );
}

/// Provenance: aarch32_LDRH_i_A1_A
/// ASL: `UMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// large positive * large positive
#[test]
fn test_aarch32_ldrh_i_a1_a_umull_oracle_2_9ba27c20() {
    // Test UMULL: large positive * large positive (oracle)
    // Encoding: 0x9BA27C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    set_w(&mut cpu, 2, 0x7FFFFFFF);
    let encoding: u32 = 0x9BA27C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x3FFFFFFF00000001");
}

/// Provenance: aarch32_LDRH_i_A1_A
/// ASL: `UMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max unsigned * max unsigned
#[test]
fn test_aarch32_ldrh_i_a1_a_umull_oracle_3_9ba27c20() {
    // Test UMULL: max unsigned * max unsigned (oracle)
    // Encoding: 0x9BA27C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x9BA27C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0xFFFFFFFE00000001");
}

/// Provenance: aarch32_LDRH_i_A1_A
/// ASL: `UMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// medium values
#[test]
fn test_aarch32_ldrh_i_a1_a_umull_oracle_4_9ba27c20() {
    // Test UMULL: medium values (oracle)
    // Encoding: 0x9BA27C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xC8);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x9BA27C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4E20, "X0 should be 0x0000000000004E20");
}

/// Provenance: aarch32_LDRH_i_A1_A
/// ASL: `UMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// 16-bit values
#[test]
fn test_aarch32_ldrh_i_a1_a_umull_oracle_5_9ba27c20() {
    // Test UMULL: 16-bit values (oracle)
    // Encoding: 0x9BA27C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x5678);
    set_w(&mut cpu, 1, 0x1234);
    let encoding: u32 = 0x9BA27C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6260060, "X0 should be 0x0000000006260060");
}

/// Provenance: aarch32_LDRH_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 0 (32)
#[test]
fn test_aarch32_ldrh_i_t1_a_lslv_oracle_32_0_88020020() {
    // Test LSLV 32-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x12345678, "W0 should be 0x12345678");
}

/// Provenance: aarch32_LDRH_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 0 (64)
#[test]
fn test_aarch32_ldrh_i_t1_a_lslv_oracle_64_0_88020020() {
    // Test LSLV 64-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x12345678,
        "X0 should be 0x0000000012345678"
    );
}

/// Provenance: aarch32_LDRH_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4 (32)
#[test]
fn test_aarch32_ldrh_i_t1_a_lslv_oracle_32_1_88020020() {
    // Test LSLV 32-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x4);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x23456780, "W0 should be 0x23456780");
}

/// Provenance: aarch32_LDRH_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 4 (64)
#[test]
fn test_aarch32_ldrh_i_t1_a_lslv_oracle_64_1_88020020() {
    // Test LSLV 64-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x4);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x23456780,
        "X0 should be 0x0000000123456780"
    );
}

/// Provenance: aarch32_LDRH_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 8 (32)
#[test]
fn test_aarch32_ldrh_i_t1_a_lslv_oracle_32_2_88020020() {
    // Test LSLV 32-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x8);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x34567800, "W0 should be 0x34567800");
}

/// Provenance: aarch32_LDRH_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 8 (64)
#[test]
fn test_aarch32_ldrh_i_t1_a_lslv_oracle_64_2_88020020() {
    // Test LSLV 64-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x8);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x34567800,
        "X0 should be 0x0000001234567800"
    );
}

/// Provenance: aarch32_LDRH_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1 (32)
#[test]
fn test_aarch32_ldrh_i_t1_a_lslv_oracle_32_3_88020020() {
    // Test LSLV 32-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_LDRH_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// MSB set, shift 1 (64)
#[test]
fn test_aarch32_ldrh_i_t1_a_lslv_oracle_64_3_88020020() {
    // Test LSLV 64-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_LDRH_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// LSB set, max shift (32)
#[test]
fn test_aarch32_ldrh_i_t1_a_lslv_oracle_32_4_88020020() {
    // Test LSLV 32-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x3F);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "W0 should be 0x80000000");
}

/// Provenance: aarch32_LDRH_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// LSB set, max shift (64)
#[test]
fn test_aarch32_ldrh_i_t1_a_lslv_oracle_64_4_88020020() {
    // Test LSLV 64-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x3F);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x8000000000000000");
}

/// Provenance: aarch32_LDRH_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// all ones, shift 32 (32)
#[test]
fn test_aarch32_ldrh_i_t1_a_lslv_oracle_32_5_88020020() {
    // Test LSLV 32-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x20);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "W0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_LDRH_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// all ones, shift 32 (64)
#[test]
fn test_aarch32_ldrh_i_t1_a_lslv_oracle_64_5_88020020() {
    // Test LSLV 64-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x20);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0xFFFFFFFF00000000");
}

/// Provenance: aarch32_LDRH_i_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// no shift
#[test]
fn test_aarch32_ldrh_i_t1_a_t16_oracle_0_88080000() {
    // Test T16 LSLS: no shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_LDRH_i_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4
#[test]
fn test_aarch32_ldrh_i_t1_a_t16_oracle_1_88080000() {
    // Test T16 LSLS: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x4);
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF0, "R0 should be 0x00000FF0");
}

/// Provenance: aarch32_LDRH_i_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1
#[test]
fn test_aarch32_ldrh_i_t1_a_t16_oracle_2_88080000() {
    // Test T16 LSLS: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_LDRH_i_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift to MSB
#[test]
fn test_aarch32_ldrh_i_t1_a_t16_oracle_3_88080000() {
    // Test T16 LSLS: shift to MSB (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1F);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "R0 should be 0x80000000");
}

// ============================================================================
// aarch32_LDRBT_A Tests
// ============================================================================

/// Provenance: aarch32_LDRBT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_ldrbt_a1_a_field_cond_0_min_0_04700000() {
    // Encoding: 0x04700000
    // Test aarch32_LDRBT_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, U=0, cond=0, Rt=0, imm12=0
    let encoding: u32 = 0x04700000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_ldrbt_a1_a_field_cond_1_poweroftwo_0_14700000() {
    // Encoding: 0x14700000
    // Test aarch32_LDRBT_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=1, Rt=0, imm12=0, U=0, Rn=0
    let encoding: u32 = 0x14700000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_ldrbt_a1_a_field_cond_2_poweroftwo_0_24700000() {
    // Encoding: 0x24700000
    // Test aarch32_LDRBT_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=2, imm12=0, U=0, Rn=0, Rt=0
    let encoding: u32 = 0x24700000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_ldrbt_a1_a_field_cond_3_poweroftwo_0_34700000() {
    // Encoding: 0x34700000
    // Test aarch32_LDRBT_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, imm12=0, U=0, cond=3, Rt=0
    let encoding: u32 = 0x34700000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_ldrbt_a1_a_field_cond_4_poweroftwo_0_44700000() {
    // Encoding: 0x44700000
    // Test aarch32_LDRBT_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rt=0, U=0, imm12=0, cond=4
    let encoding: u32 = 0x44700000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_ldrbt_a1_a_field_cond_5_poweroftwo_0_54700000() {
    // Encoding: 0x54700000
    // Test aarch32_LDRBT_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, cond=5, Rn=0, U=0, imm12=0
    let encoding: u32 = 0x54700000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_ldrbt_a1_a_field_cond_6_poweroftwo_0_64700000() {
    // Encoding: 0x64700000
    // Test aarch32_LDRBT_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, Rn=0, cond=6, imm12=0, Rt=0
    let encoding: u32 = 0x64700000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_ldrbt_a1_a_field_cond_7_poweroftwo_0_74700000() {
    // Encoding: 0x74700000
    // Test aarch32_LDRBT_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, Rn=0, Rt=0, imm12=0, cond=7
    let encoding: u32 = 0x74700000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_ldrbt_a1_a_field_cond_8_poweroftwo_0_84700000() {
    // Encoding: 0x84700000
    // Test aarch32_LDRBT_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=0, cond=8, U=0, Rn=0, Rt=0
    let encoding: u32 = 0x84700000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_ldrbt_a1_a_field_cond_9_poweroftwo_0_94700000() {
    // Encoding: 0x94700000
    // Test aarch32_LDRBT_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, imm12=0, Rt=0, cond=9, Rn=0
    let encoding: u32 = 0x94700000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_ldrbt_a1_a_field_cond_10_poweroftwo_0_a4700000() {
    // Encoding: 0xA4700000
    // Test aarch32_LDRBT_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=0, Rt=0, cond=10, U=0, Rn=0
    let encoding: u32 = 0xA4700000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_ldrbt_a1_a_field_cond_11_poweroftwo_0_b4700000() {
    // Encoding: 0xB4700000
    // Test aarch32_LDRBT_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, imm12=0, cond=11, Rn=0, Rt=0
    let encoding: u32 = 0xB4700000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_ldrbt_a1_a_field_cond_12_poweroftwo_0_c4700000() {
    // Encoding: 0xC4700000
    // Test aarch32_LDRBT_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, Rn=0, imm12=0, cond=12, U=0
    let encoding: u32 = 0xC4700000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_ldrbt_a1_a_field_cond_13_poweroftwo_0_d4700000() {
    // Encoding: 0xD4700000
    // Test aarch32_LDRBT_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=0, cond=13, Rn=0, Rt=0, U=0
    let encoding: u32 = 0xD4700000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_ldrbt_a1_a_field_cond_14_poweroftwo_0_e4700000() {
    // Encoding: 0xE4700000
    // Test aarch32_LDRBT_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, Rn=0, cond=14, Rt=0, imm12=0
    let encoding: u32 = 0xE4700000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_ldrbt_a1_a_field_cond_15_max_0_f4700000() {
    // Encoding: 0xF4700000
    // Test aarch32_LDRBT_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: cond=15, Rt=0, imm12=0, Rn=0, U=0
    let encoding: u32 = 0xF4700000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldrbt_a1_a_field_u_0_min_0_04700000() {
    // Encoding: 0x04700000
    // Test aarch32_LDRBT_A1_A field U = 0 (Min)
    // ISET: A32
    // Fields: U=0, Rn=0, cond=0, imm12=0, Rt=0
    let encoding: u32 = 0x04700000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldrbt_a1_a_field_u_1_max_0_04f00000() {
    // Encoding: 0x04F00000
    // Test aarch32_LDRBT_A1_A field U = 1 (Max)
    // ISET: A32
    // Fields: cond=0, U=1, imm12=0, Rn=0, Rt=0
    let encoding: u32 = 0x04F00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrbt_a1_a_field_rn_0_min_0_04700000() {
    // Encoding: 0x04700000
    // Test aarch32_LDRBT_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: Rt=0, cond=0, imm12=0, Rn=0, U=0
    let encoding: u32 = 0x04700000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrbt_a1_a_field_rn_1_poweroftwo_0_04710000() {
    // Encoding: 0x04710000
    // Test aarch32_LDRBT_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=1, U=0, cond=0, imm12=0, Rt=0
    let encoding: u32 = 0x04710000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrbt_a1_a_field_rt_0_min_0_04700000() {
    // Encoding: 0x04700000
    // Test aarch32_LDRBT_A1_A field Rt = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rt=0, imm12=0, U=0, Rn=0
    let encoding: u32 = 0x04700000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrbt_a1_a_field_rt_1_poweroftwo_0_04701000() {
    // Encoding: 0x04701000
    // Test aarch32_LDRBT_A1_A field Rt = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, U=0, Rt=1, imm12=0, Rn=0
    let encoding: u32 = 0x04701000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_ldrbt_a1_a_field_imm12_0_zero_0_04700000() {
    // Encoding: 0x04700000
    // Test aarch32_LDRBT_A1_A field imm12 = 0 (Zero)
    // ISET: A32
    // Fields: imm12=0, cond=0, Rn=0, Rt=0, U=0
    let encoding: u32 = 0x04700000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_ldrbt_a1_a_field_imm12_1_poweroftwo_0_04700001() {
    // Encoding: 0x04700001
    // Test aarch32_LDRBT_A1_A field imm12 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, imm12=1, Rn=0, Rt=0, U=0
    let encoding: u32 = 0x04700001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_ldrbt_a1_a_field_imm12_3_poweroftwominusone_0_04700003() {
    // Encoding: 0x04700003
    // Test aarch32_LDRBT_A1_A field imm12 = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: U=0, Rn=0, Rt=0, imm12=3, cond=0
    let encoding: u32 = 0x04700003;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_ldrbt_a1_a_field_imm12_4_poweroftwo_0_04700004() {
    // Encoding: 0x04700004
    // Test aarch32_LDRBT_A1_A field imm12 = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, Rn=0, cond=0, Rt=0, imm12=4
    let encoding: u32 = 0x04700004;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_ldrbt_a1_a_field_imm12_7_poweroftwominusone_0_04700007() {
    // Encoding: 0x04700007
    // Test aarch32_LDRBT_A1_A field imm12 = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: U=0, cond=0, Rn=0, imm12=7, Rt=0
    let encoding: u32 = 0x04700007;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_ldrbt_a1_a_field_imm12_8_poweroftwo_0_04700008() {
    // Encoding: 0x04700008
    // Test aarch32_LDRBT_A1_A field imm12 = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, Rn=0, imm12=8, cond=0, Rt=0
    let encoding: u32 = 0x04700008;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_ldrbt_a1_a_field_imm12_15_poweroftwominusone_0_0470000f() {
    // Encoding: 0x0470000F
    // Test aarch32_LDRBT_A1_A field imm12 = 15 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: U=0, imm12=15, cond=0, Rn=0, Rt=0
    let encoding: u32 = 0x0470000F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_ldrbt_a1_a_field_imm12_16_poweroftwo_0_04700010() {
    // Encoding: 0x04700010
    // Test aarch32_LDRBT_A1_A field imm12 = 16 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, U=0, imm12=16, cond=0, Rn=0
    let encoding: u32 = 0x04700010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_ldrbt_a1_a_field_imm12_31_poweroftwominusone_0_0470001f() {
    // Encoding: 0x0470001F
    // Test aarch32_LDRBT_A1_A field imm12 = 31 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: U=0, cond=0, imm12=31, Rt=0, Rn=0
    let encoding: u32 = 0x0470001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_ldrbt_a1_a_field_imm12_32_poweroftwo_0_04700020() {
    // Encoding: 0x04700020
    // Test aarch32_LDRBT_A1_A field imm12 = 32 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Rn=0, U=0, Rt=0, imm12=32
    let encoding: u32 = 0x04700020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_ldrbt_a1_a_field_imm12_63_poweroftwominusone_0_0470003f() {
    // Encoding: 0x0470003F
    // Test aarch32_LDRBT_A1_A field imm12 = 63 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm12=63, U=0, Rn=0, Rt=0, cond=0
    let encoding: u32 = 0x0470003F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_ldrbt_a1_a_field_imm12_64_poweroftwo_0_04700040() {
    // Encoding: 0x04700040
    // Test aarch32_LDRBT_A1_A field imm12 = 64 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, U=0, Rn=0, imm12=64, cond=0
    let encoding: u32 = 0x04700040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 127, boundary: PowerOfTwoMinusOne }
/// 2^7 - 1 = 127
#[test]
fn test_aarch32_ldrbt_a1_a_field_imm12_127_poweroftwominusone_0_0470007f() {
    // Encoding: 0x0470007F
    // Test aarch32_LDRBT_A1_A field imm12 = 127 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rt=0, cond=0, imm12=127, Rn=0, U=0
    let encoding: u32 = 0x0470007F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_ldrbt_a1_a_field_imm12_128_poweroftwo_0_04700080() {
    // Encoding: 0x04700080
    // Test aarch32_LDRBT_A1_A field imm12 = 128 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, U=0, Rt=0, imm12=128, Rn=0
    let encoding: u32 = 0x04700080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 255, boundary: PowerOfTwoMinusOne }
/// 2^8 - 1 = 255
#[test]
fn test_aarch32_ldrbt_a1_a_field_imm12_255_poweroftwominusone_0_047000ff() {
    // Encoding: 0x047000FF
    // Test aarch32_LDRBT_A1_A field imm12 = 255 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rt=0, U=0, cond=0, imm12=255, Rn=0
    let encoding: u32 = 0x047000FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 256, boundary: PowerOfTwo }
/// power of 2 (2^8 = 256)
#[test]
fn test_aarch32_ldrbt_a1_a_field_imm12_256_poweroftwo_0_04700100() {
    // Encoding: 0x04700100
    // Test aarch32_LDRBT_A1_A field imm12 = 256 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, U=0, Rt=0, imm12=256, cond=0
    let encoding: u32 = 0x04700100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 511, boundary: PowerOfTwoMinusOne }
/// 2^9 - 1 = 511
#[test]
fn test_aarch32_ldrbt_a1_a_field_imm12_511_poweroftwominusone_0_047001ff() {
    // Encoding: 0x047001FF
    // Test aarch32_LDRBT_A1_A field imm12 = 511 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm12=511, Rn=0, U=0, Rt=0, cond=0
    let encoding: u32 = 0x047001FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 512, boundary: PowerOfTwo }
/// power of 2 (2^9 = 512)
#[test]
fn test_aarch32_ldrbt_a1_a_field_imm12_512_poweroftwo_0_04700200() {
    // Encoding: 0x04700200
    // Test aarch32_LDRBT_A1_A field imm12 = 512 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, imm12=512, Rn=0, U=0, Rt=0
    let encoding: u32 = 0x04700200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1023, boundary: PowerOfTwoMinusOne }
/// 2^10 - 1 = 1023
#[test]
fn test_aarch32_ldrbt_a1_a_field_imm12_1023_poweroftwominusone_0_047003ff() {
    // Encoding: 0x047003FF
    // Test aarch32_LDRBT_A1_A field imm12 = 1023 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rn=0, Rt=0, U=0, imm12=1023, cond=0
    let encoding: u32 = 0x047003FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1024, boundary: PowerOfTwo }
/// power of 2 (2^10 = 1024)
#[test]
fn test_aarch32_ldrbt_a1_a_field_imm12_1024_poweroftwo_0_04700400() {
    // Encoding: 0x04700400
    // Test aarch32_LDRBT_A1_A field imm12 = 1024 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, imm12=1024, cond=0, Rn=0, U=0
    let encoding: u32 = 0x04700400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2047, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (2047)
#[test]
fn test_aarch32_ldrbt_a1_a_field_imm12_2047_poweroftwominusone_0_047007ff() {
    // Encoding: 0x047007FF
    // Test aarch32_LDRBT_A1_A field imm12 = 2047 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, Rn=0, U=0, Rt=0, imm12=2047
    let encoding: u32 = 0x047007FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2048, boundary: PowerOfTwo }
/// power of 2 (2^11 = 2048)
#[test]
fn test_aarch32_ldrbt_a1_a_field_imm12_2048_poweroftwo_0_04700800() {
    // Encoding: 0x04700800
    // Test aarch32_LDRBT_A1_A field imm12 = 2048 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=2048, cond=0, Rn=0, U=0, Rt=0
    let encoding: u32 = 0x04700800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4095, boundary: Max }
/// maximum immediate (4095)
#[test]
fn test_aarch32_ldrbt_a1_a_field_imm12_4095_max_0_04700fff() {
    // Encoding: 0x04700FFF
    // Test aarch32_LDRBT_A1_A field imm12 = 4095 (Max)
    // ISET: A32
    // Fields: Rn=0, imm12=4095, U=0, Rt=0, cond=0
    let encoding: u32 = 0x04700FFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_ldrbt_a1_a_combo_0_0_04700000() {
    // Encoding: 0x04700000
    // Test aarch32_LDRBT_A1_A field combination: cond=0, U=0, Rn=0, Rt=0, imm12=0
    // ISET: A32
    // Fields: U=0, cond=0, imm12=0, Rn=0, Rt=0
    let encoding: u32 = 0x04700000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_ldrbt_a1_a_special_cond_0_condition_eq_0_04700000() {
    // Encoding: 0x04700000
    // Test aarch32_LDRBT_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: Rt=0, Rn=0, cond=0, imm12=0, U=0
    let encoding: u32 = 0x04700000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_ldrbt_a1_a_special_cond_1_condition_ne_0_14700000() {
    // Encoding: 0x14700000
    // Test aarch32_LDRBT_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: imm12=0, cond=1, Rt=0, Rn=0, U=0
    let encoding: u32 = 0x14700000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_ldrbt_a1_a_special_cond_2_condition_cs_hs_0_24700000() {
    // Encoding: 0x24700000
    // Test aarch32_LDRBT_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: cond=2, U=0, imm12=0, Rt=0, Rn=0
    let encoding: u32 = 0x24700000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_ldrbt_a1_a_special_cond_3_condition_cc_lo_0_34700000() {
    // Encoding: 0x34700000
    // Test aarch32_LDRBT_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: U=0, Rn=0, cond=3, Rt=0, imm12=0
    let encoding: u32 = 0x34700000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_ldrbt_a1_a_special_cond_4_condition_mi_0_44700000() {
    // Encoding: 0x44700000
    // Test aarch32_LDRBT_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: Rt=0, imm12=0, Rn=0, U=0, cond=4
    let encoding: u32 = 0x44700000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_ldrbt_a1_a_special_cond_5_condition_pl_0_54700000() {
    // Encoding: 0x54700000
    // Test aarch32_LDRBT_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: imm12=0, U=0, Rn=0, cond=5, Rt=0
    let encoding: u32 = 0x54700000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_ldrbt_a1_a_special_cond_6_condition_vs_0_64700000() {
    // Encoding: 0x64700000
    // Test aarch32_LDRBT_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: imm12=0, Rt=0, Rn=0, U=0, cond=6
    let encoding: u32 = 0x64700000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_ldrbt_a1_a_special_cond_7_condition_vc_0_74700000() {
    // Encoding: 0x74700000
    // Test aarch32_LDRBT_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: imm12=0, Rn=0, cond=7, U=0, Rt=0
    let encoding: u32 = 0x74700000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_ldrbt_a1_a_special_cond_8_condition_hi_0_84700000() {
    // Encoding: 0x84700000
    // Test aarch32_LDRBT_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: Rt=0, imm12=0, cond=8, Rn=0, U=0
    let encoding: u32 = 0x84700000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_ldrbt_a1_a_special_cond_9_condition_ls_0_94700000() {
    // Encoding: 0x94700000
    // Test aarch32_LDRBT_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: imm12=0, U=0, Rn=0, cond=9, Rt=0
    let encoding: u32 = 0x94700000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_ldrbt_a1_a_special_cond_10_condition_ge_0_a4700000() {
    // Encoding: 0xA4700000
    // Test aarch32_LDRBT_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: cond=10, U=0, imm12=0, Rn=0, Rt=0
    let encoding: u32 = 0xA4700000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_ldrbt_a1_a_special_cond_11_condition_lt_0_b4700000() {
    // Encoding: 0xB4700000
    // Test aarch32_LDRBT_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: imm12=0, Rt=0, cond=11, U=0, Rn=0
    let encoding: u32 = 0xB4700000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_ldrbt_a1_a_special_cond_12_condition_gt_0_c4700000() {
    // Encoding: 0xC4700000
    // Test aarch32_LDRBT_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: Rt=0, imm12=0, cond=12, U=0, Rn=0
    let encoding: u32 = 0xC4700000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_ldrbt_a1_a_special_cond_13_condition_le_0_d4700000() {
    // Encoding: 0xD4700000
    // Test aarch32_LDRBT_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: imm12=0, U=0, cond=13, Rt=0, Rn=0
    let encoding: u32 = 0xD4700000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_ldrbt_a1_a_special_cond_14_condition_al_0_e4700000() {
    // Encoding: 0xE4700000
    // Test aarch32_LDRBT_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: U=0, Rt=0, Rn=0, imm12=0, cond=14
    let encoding: u32 = 0xE4700000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_ldrbt_a1_a_special_cond_15_condition_nv_0_f4700000() {
    // Encoding: 0xF4700000
    // Test aarch32_LDRBT_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: Rn=0, cond=15, Rt=0, imm12=0, U=0
    let encoding: u32 = 0xF4700000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrbt_a1_a_invalid_0_0_04700000() {
    // Encoding: 0x04700000
    // Test aarch32_LDRBT_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) }
    // ISET: A32
    // Fields: U=0, Rn=0, Rt=0, imm12=0, cond=0
    let encoding: u32 = 0x04700000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRBT_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrbt_a1_a_invalid_1_0_04700000() {
    // Encoding: 0x04700000
    // Test aarch32_LDRBT_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Rn=0, cond=0, U=0, Rt=0, imm12=0
    let encoding: u32 = 0x04700000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRBT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_ldrbt_a2_a_field_cond_0_min_0_06700000() {
    // Encoding: 0x06700000
    // Test aarch32_LDRBT_A2_A field cond = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, U=0, cond=0, Rn=0, Rt=0, type1=0, imm5=0
    let encoding: u32 = 0x06700000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_ldrbt_a2_a_field_cond_1_poweroftwo_0_16700000() {
    // Encoding: 0x16700000
    // Test aarch32_LDRBT_A2_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, cond=1, Rn=0, Rt=0, imm5=0, U=0, type1=0
    let encoding: u32 = 0x16700000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_ldrbt_a2_a_field_cond_2_poweroftwo_0_26700000() {
    // Encoding: 0x26700000
    // Test aarch32_LDRBT_A2_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=2, type1=0, Rn=0, Rt=0, U=0, Rm=0, imm5=0
    let encoding: u32 = 0x26700000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_ldrbt_a2_a_field_cond_3_poweroftwo_0_36700000() {
    // Encoding: 0x36700000
    // Test aarch32_LDRBT_A2_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=3, Rn=0, Rt=0, type1=0, Rm=0, imm5=0, U=0
    let encoding: u32 = 0x36700000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_ldrbt_a2_a_field_cond_4_poweroftwo_0_46700000() {
    // Encoding: 0x46700000
    // Test aarch32_LDRBT_A2_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, imm5=0, type1=0, Rm=0, Rt=0, Rn=0, cond=4
    let encoding: u32 = 0x46700000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_ldrbt_a2_a_field_cond_5_poweroftwo_0_56700000() {
    // Encoding: 0x56700000
    // Test aarch32_LDRBT_A2_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, Rn=0, type1=0, Rt=0, imm5=0, cond=5, Rm=0
    let encoding: u32 = 0x56700000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_ldrbt_a2_a_field_cond_6_poweroftwo_0_66700000() {
    // Encoding: 0x66700000
    // Test aarch32_LDRBT_A2_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, Rn=0, imm5=0, type1=0, U=0, Rm=0, cond=6
    let encoding: u32 = 0x66700000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_ldrbt_a2_a_field_cond_7_poweroftwo_0_76700000() {
    // Encoding: 0x76700000
    // Test aarch32_LDRBT_A2_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, Rn=0, type1=0, U=0, imm5=0, Rm=0, cond=7
    let encoding: u32 = 0x76700000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_ldrbt_a2_a_field_cond_8_poweroftwo_0_86700000() {
    // Encoding: 0x86700000
    // Test aarch32_LDRBT_A2_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, cond=8, Rn=0, Rt=0, imm5=0, type1=0, Rm=0
    let encoding: u32 = 0x86700000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_ldrbt_a2_a_field_cond_9_poweroftwo_0_96700000() {
    // Encoding: 0x96700000
    // Test aarch32_LDRBT_A2_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: imm5=0, Rm=0, U=0, cond=9, Rt=0, type1=0, Rn=0
    let encoding: u32 = 0x96700000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_ldrbt_a2_a_field_cond_10_poweroftwo_0_a6700000() {
    // Encoding: 0xA6700000
    // Test aarch32_LDRBT_A2_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: imm5=0, U=0, cond=10, Rn=0, Rt=0, type1=0, Rm=0
    let encoding: u32 = 0xA6700000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_ldrbt_a2_a_field_cond_11_poweroftwo_0_b6700000() {
    // Encoding: 0xB6700000
    // Test aarch32_LDRBT_A2_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, type1=0, Rt=0, imm5=0, Rm=0, U=0, cond=11
    let encoding: u32 = 0xB6700000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_ldrbt_a2_a_field_cond_12_poweroftwo_0_c6700000() {
    // Encoding: 0xC6700000
    // Test aarch32_LDRBT_A2_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: type1=0, cond=12, Rn=0, Rm=0, U=0, Rt=0, imm5=0
    let encoding: u32 = 0xC6700000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_ldrbt_a2_a_field_cond_13_poweroftwo_0_d6700000() {
    // Encoding: 0xD6700000
    // Test aarch32_LDRBT_A2_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, type1=0, Rn=0, Rt=0, cond=13, U=0, imm5=0
    let encoding: u32 = 0xD6700000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_ldrbt_a2_a_field_cond_14_poweroftwo_0_e6700000() {
    // Encoding: 0xE6700000
    // Test aarch32_LDRBT_A2_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, cond=14, imm5=0, Rt=0, Rn=0, type1=0, Rm=0
    let encoding: u32 = 0xE6700000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_ldrbt_a2_a_field_cond_15_max_0_f6700000() {
    // Encoding: 0xF6700000
    // Test aarch32_LDRBT_A2_A field cond = 15 (Max)
    // ISET: A32
    // Fields: Rn=0, Rt=0, type1=0, Rm=0, imm5=0, cond=15, U=0
    let encoding: u32 = 0xF6700000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A2_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldrbt_a2_a_field_u_0_min_0_06700000() {
    // Encoding: 0x06700000
    // Test aarch32_LDRBT_A2_A field U = 0 (Min)
    // ISET: A32
    // Fields: imm5=0, Rt=0, U=0, type1=0, cond=0, Rn=0, Rm=0
    let encoding: u32 = 0x06700000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A2_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldrbt_a2_a_field_u_1_max_0_06f00000() {
    // Encoding: 0x06F00000
    // Test aarch32_LDRBT_A2_A field U = 1 (Max)
    // ISET: A32
    // Fields: Rt=0, type1=0, U=1, Rm=0, imm5=0, cond=0, Rn=0
    let encoding: u32 = 0x06F00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrbt_a2_a_field_rn_0_min_0_06700000() {
    // Encoding: 0x06700000
    // Test aarch32_LDRBT_A2_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, imm5=0, U=0, cond=0, type1=0, Rt=0, Rm=0
    let encoding: u32 = 0x06700000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrbt_a2_a_field_rn_1_poweroftwo_0_06710000() {
    // Encoding: 0x06710000
    // Test aarch32_LDRBT_A2_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, U=0, imm5=0, type1=0, cond=0, Rn=1, Rt=0
    let encoding: u32 = 0x06710000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A2_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrbt_a2_a_field_rt_0_min_0_06700000() {
    // Encoding: 0x06700000
    // Test aarch32_LDRBT_A2_A field Rt = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, cond=0, Rt=0, imm5=0, Rm=0, U=0, type1=0
    let encoding: u32 = 0x06700000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A2_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrbt_a2_a_field_rt_1_poweroftwo_0_06701000() {
    // Encoding: 0x06701000
    // Test aarch32_LDRBT_A2_A field Rt = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: type1=0, Rm=0, U=0, Rn=0, cond=0, Rt=1, imm5=0
    let encoding: u32 = 0x06701000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A2_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_ldrbt_a2_a_field_imm5_0_zero_0_06700000() {
    // Encoding: 0x06700000
    // Test aarch32_LDRBT_A2_A field imm5 = 0 (Zero)
    // ISET: A32
    // Fields: imm5=0, Rn=0, U=0, cond=0, Rt=0, type1=0, Rm=0
    let encoding: u32 = 0x06700000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A2_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_ldrbt_a2_a_field_imm5_1_poweroftwo_0_06700080() {
    // Encoding: 0x06700080
    // Test aarch32_LDRBT_A2_A field imm5 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, Rn=0, imm5=1, U=0, type1=0, Rm=0, cond=0
    let encoding: u32 = 0x06700080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A2_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_ldrbt_a2_a_field_imm5_3_poweroftwominusone_0_06700180() {
    // Encoding: 0x06700180
    // Test aarch32_LDRBT_A2_A field imm5 = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rn=0, Rt=0, imm5=3, Rm=0, type1=0, cond=0, U=0
    let encoding: u32 = 0x06700180;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A2_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_ldrbt_a2_a_field_imm5_4_poweroftwo_0_06700200() {
    // Encoding: 0x06700200
    // Test aarch32_LDRBT_A2_A field imm5 = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, cond=0, Rn=0, imm5=4, Rt=0, U=0, type1=0
    let encoding: u32 = 0x06700200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A2_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_ldrbt_a2_a_field_imm5_7_poweroftwominusone_0_06700380() {
    // Encoding: 0x06700380
    // Test aarch32_LDRBT_A2_A field imm5 = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, Rm=0, Rn=0, U=0, Rt=0, imm5=7, type1=0
    let encoding: u32 = 0x06700380;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A2_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_ldrbt_a2_a_field_imm5_8_poweroftwo_0_06700400() {
    // Encoding: 0x06700400
    // Test aarch32_LDRBT_A2_A field imm5 = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, type1=0, Rm=0, cond=0, Rn=0, imm5=8, U=0
    let encoding: u32 = 0x06700400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A2_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 15, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (15)
#[test]
fn test_aarch32_ldrbt_a2_a_field_imm5_15_poweroftwominusone_0_06700780() {
    // Encoding: 0x06700780
    // Test aarch32_LDRBT_A2_A field imm5 = 15 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rt=0, type1=0, Rm=0, cond=0, U=0, imm5=15, Rn=0
    let encoding: u32 = 0x06700780;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A2_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_ldrbt_a2_a_field_imm5_16_poweroftwo_0_06700800() {
    // Encoding: 0x06700800
    // Test aarch32_LDRBT_A2_A field imm5 = 16 (PowerOfTwo)
    // ISET: A32
    // Fields: imm5=16, Rm=0, Rt=0, Rn=0, type1=0, U=0, cond=0
    let encoding: u32 = 0x06700800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A2_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 31, boundary: Max }
/// maximum immediate (31)
#[test]
fn test_aarch32_ldrbt_a2_a_field_imm5_31_max_0_06700f80() {
    // Encoding: 0x06700F80
    // Test aarch32_LDRBT_A2_A field imm5 = 31 (Max)
    // ISET: A32
    // Fields: type1=0, Rm=0, U=0, imm5=31, cond=0, Rt=0, Rn=0
    let encoding: u32 = 0x06700F80;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A2_A
/// ASL: `field type1 5 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldrbt_a2_a_field_type1_0_min_0_06700000() {
    // Encoding: 0x06700000
    // Test aarch32_LDRBT_A2_A field type1 = 0 (Min)
    // ISET: A32
    // Fields: Rt=0, cond=0, U=0, type1=0, imm5=0, Rm=0, Rn=0
    let encoding: u32 = 0x06700000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A2_A
/// ASL: `field type1 5 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_ldrbt_a2_a_field_type1_1_poweroftwo_0_06700020() {
    // Encoding: 0x06700020
    // Test aarch32_LDRBT_A2_A field type1 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: imm5=0, type1=1, U=0, Rm=0, Rt=0, Rn=0, cond=0
    let encoding: u32 = 0x06700020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A2_A
/// ASL: `field type1 5 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_aarch32_ldrbt_a2_a_field_type1_3_max_0_06700060() {
    // Encoding: 0x06700060
    // Test aarch32_LDRBT_A2_A field type1 = 3 (Max)
    // ISET: A32
    // Fields: U=0, Rm=0, Rt=0, cond=0, imm5=0, Rn=0, type1=3
    let encoding: u32 = 0x06700060;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrbt_a2_a_field_rm_0_min_0_06700000() {
    // Encoding: 0x06700000
    // Test aarch32_LDRBT_A2_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: imm5=0, Rn=0, type1=0, Rm=0, cond=0, U=0, Rt=0
    let encoding: u32 = 0x06700000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrbt_a2_a_field_rm_1_poweroftwo_0_06700001() {
    // Encoding: 0x06700001
    // Test aarch32_LDRBT_A2_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: type1=0, imm5=0, U=0, Rt=0, cond=0, Rm=1, Rn=0
    let encoding: u32 = 0x06700001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A2_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_ldrbt_a2_a_combo_0_0_06700000() {
    // Encoding: 0x06700000
    // Test aarch32_LDRBT_A2_A field combination: cond=0, U=0, Rn=0, Rt=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: type1=0, U=0, Rt=0, Rn=0, cond=0, imm5=0, Rm=0
    let encoding: u32 = 0x06700000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A2_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_ldrbt_a2_a_special_cond_0_condition_eq_0_06700000() {
    // Encoding: 0x06700000
    // Test aarch32_LDRBT_A2_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: Rt=0, imm5=0, Rm=0, type1=0, U=0, Rn=0, cond=0
    let encoding: u32 = 0x06700000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A2_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_ldrbt_a2_a_special_cond_1_condition_ne_0_16700000() {
    // Encoding: 0x16700000
    // Test aarch32_LDRBT_A2_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: Rm=0, Rt=0, Rn=0, type1=0, cond=1, U=0, imm5=0
    let encoding: u32 = 0x16700000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A2_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_ldrbt_a2_a_special_cond_2_condition_cs_hs_0_26700000() {
    // Encoding: 0x26700000
    // Test aarch32_LDRBT_A2_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: cond=2, type1=0, Rn=0, Rm=0, Rt=0, U=0, imm5=0
    let encoding: u32 = 0x26700000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A2_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_ldrbt_a2_a_special_cond_3_condition_cc_lo_0_36700000() {
    // Encoding: 0x36700000
    // Test aarch32_LDRBT_A2_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: Rt=0, cond=3, U=0, Rn=0, imm5=0, type1=0, Rm=0
    let encoding: u32 = 0x36700000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A2_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_ldrbt_a2_a_special_cond_4_condition_mi_0_46700000() {
    // Encoding: 0x46700000
    // Test aarch32_LDRBT_A2_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: U=0, type1=0, Rm=0, cond=4, Rn=0, Rt=0, imm5=0
    let encoding: u32 = 0x46700000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A2_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_ldrbt_a2_a_special_cond_5_condition_pl_0_56700000() {
    // Encoding: 0x56700000
    // Test aarch32_LDRBT_A2_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: type1=0, Rt=0, cond=5, Rn=0, U=0, imm5=0, Rm=0
    let encoding: u32 = 0x56700000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A2_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_ldrbt_a2_a_special_cond_6_condition_vs_0_66700000() {
    // Encoding: 0x66700000
    // Test aarch32_LDRBT_A2_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: Rm=0, cond=6, U=0, Rn=0, imm5=0, type1=0, Rt=0
    let encoding: u32 = 0x66700000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A2_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_ldrbt_a2_a_special_cond_7_condition_vc_0_76700000() {
    // Encoding: 0x76700000
    // Test aarch32_LDRBT_A2_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: Rm=0, U=0, Rt=0, Rn=0, cond=7, imm5=0, type1=0
    let encoding: u32 = 0x76700000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A2_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_ldrbt_a2_a_special_cond_8_condition_hi_0_86700000() {
    // Encoding: 0x86700000
    // Test aarch32_LDRBT_A2_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: type1=0, cond=8, Rn=0, imm5=0, Rt=0, Rm=0, U=0
    let encoding: u32 = 0x86700000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A2_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_ldrbt_a2_a_special_cond_9_condition_ls_0_96700000() {
    // Encoding: 0x96700000
    // Test aarch32_LDRBT_A2_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: cond=9, imm5=0, U=0, type1=0, Rm=0, Rt=0, Rn=0
    let encoding: u32 = 0x96700000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A2_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_ldrbt_a2_a_special_cond_10_condition_ge_0_a6700000() {
    // Encoding: 0xA6700000
    // Test aarch32_LDRBT_A2_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: Rn=0, cond=10, U=0, imm5=0, Rt=0, type1=0, Rm=0
    let encoding: u32 = 0xA6700000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A2_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_ldrbt_a2_a_special_cond_11_condition_lt_0_b6700000() {
    // Encoding: 0xB6700000
    // Test aarch32_LDRBT_A2_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: cond=11, Rn=0, U=0, imm5=0, Rt=0, type1=0, Rm=0
    let encoding: u32 = 0xB6700000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A2_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_ldrbt_a2_a_special_cond_12_condition_gt_0_c6700000() {
    // Encoding: 0xC6700000
    // Test aarch32_LDRBT_A2_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: imm5=0, type1=0, Rm=0, Rn=0, U=0, cond=12, Rt=0
    let encoding: u32 = 0xC6700000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A2_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_ldrbt_a2_a_special_cond_13_condition_le_0_d6700000() {
    // Encoding: 0xD6700000
    // Test aarch32_LDRBT_A2_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: Rt=0, cond=13, imm5=0, U=0, type1=0, Rm=0, Rn=0
    let encoding: u32 = 0xD6700000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A2_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_ldrbt_a2_a_special_cond_14_condition_al_0_e6700000() {
    // Encoding: 0xE6700000
    // Test aarch32_LDRBT_A2_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: imm5=0, Rm=0, U=0, cond=14, type1=0, Rt=0, Rn=0
    let encoding: u32 = 0xE6700000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A2_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_ldrbt_a2_a_special_cond_15_condition_nv_0_f6700000() {
    // Encoding: 0xF6700000
    // Test aarch32_LDRBT_A2_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: U=0, type1=0, Rn=0, imm5=0, cond=15, Rm=0, Rt=0
    let encoding: u32 = 0xF6700000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRBT_A2_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrbt_a2_a_invalid_0_0_06700000() {
    // Encoding: 0x06700000
    // Test aarch32_LDRBT_A2_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }
    // ISET: A32
    // Fields: Rm=0, U=0, Rn=0, Rt=0, imm5=0, type1=0, cond=0
    let encoding: u32 = 0x06700000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRBT_A2_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrbt_a2_a_invalid_1_0_06700000() {
    // Encoding: 0x06700000
    // Test aarch32_LDRBT_A2_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: U=0, Rn=0, imm5=0, type1=0, cond=0, Rt=0, Rm=0
    let encoding: u32 = 0x06700000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRBT_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrbt_t1_a_field_rn_0_min_e00_f8100e00() {
    // Thumb encoding (32): 0xF8100E00
    // Test aarch32_LDRBT_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rt=0, Rn=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8100E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRBT_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrbt_t1_a_field_rn_1_poweroftwo_e00_f8110e00() {
    // Thumb encoding (32): 0xF8110E00
    // Test aarch32_LDRBT_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=0, Rn=1, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8110E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRBT_T1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrbt_t1_a_field_rt_0_min_e00_f8100e00() {
    // Thumb encoding (32): 0xF8100E00
    // Test aarch32_LDRBT_T1_A field Rt = 0 (Min)
    // ISET: T32
    // Fields: Rt=0, Rn=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8100E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRBT_T1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrbt_t1_a_field_rt_1_poweroftwo_e00_f8101e00() {
    // Thumb encoding (32): 0xF8101E00
    // Test aarch32_LDRBT_T1_A field Rt = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Rt=1, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8101E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRBT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_ldrbt_t1_a_field_imm8_0_zero_e00_f8100e00() {
    // Thumb encoding (32): 0xF8100E00
    // Test aarch32_LDRBT_T1_A field imm8 = 0 (Zero)
    // ISET: T32
    // Fields: imm8=0, Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8100E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRBT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_ldrbt_t1_a_field_imm8_1_poweroftwo_e00_f8100e01() {
    // Thumb encoding (32): 0xF8100E01
    // Test aarch32_LDRBT_T1_A field imm8 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, imm8=1, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8100E01;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRBT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_ldrbt_t1_a_field_imm8_3_poweroftwominusone_e00_f8100e03() {
    // Thumb encoding (32): 0xF8100E03
    // Test aarch32_LDRBT_T1_A field imm8 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, Rn=0, imm8=3
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8100E03;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRBT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_ldrbt_t1_a_field_imm8_4_poweroftwo_e00_f8100e04() {
    // Thumb encoding (32): 0xF8100E04
    // Test aarch32_LDRBT_T1_A field imm8 = 4 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm8=4
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8100E04;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRBT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_ldrbt_t1_a_field_imm8_7_poweroftwominusone_e00_f8100e07() {
    // Thumb encoding (32): 0xF8100E07
    // Test aarch32_LDRBT_T1_A field imm8 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm8=7, Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8100E07;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRBT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_ldrbt_t1_a_field_imm8_8_poweroftwo_e00_f8100e08() {
    // Thumb encoding (32): 0xF8100E08
    // Test aarch32_LDRBT_T1_A field imm8 = 8 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, Rn=0, imm8=8
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8100E08;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRBT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_ldrbt_t1_a_field_imm8_15_poweroftwominusone_e00_f8100e0f() {
    // Thumb encoding (32): 0xF8100E0F
    // Test aarch32_LDRBT_T1_A field imm8 = 15 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, Rn=0, imm8=15
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8100E0F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRBT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_ldrbt_t1_a_field_imm8_16_poweroftwo_e00_f8100e10() {
    // Thumb encoding (32): 0xF8100E10
    // Test aarch32_LDRBT_T1_A field imm8 = 16 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, imm8=16, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8100E10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRBT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_ldrbt_t1_a_field_imm8_31_poweroftwominusone_e00_f8100e1f() {
    // Thumb encoding (32): 0xF8100E1F
    // Test aarch32_LDRBT_T1_A field imm8 = 31 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, imm8=31, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8100E1F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRBT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_ldrbt_t1_a_field_imm8_32_poweroftwo_e00_f8100e20() {
    // Thumb encoding (32): 0xF8100E20
    // Test aarch32_LDRBT_T1_A field imm8 = 32 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, imm8=32, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8100E20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRBT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_ldrbt_t1_a_field_imm8_63_poweroftwominusone_e00_f8100e3f() {
    // Thumb encoding (32): 0xF8100E3F
    // Test aarch32_LDRBT_T1_A field imm8 = 63 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm8=63, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8100E3F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRBT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_ldrbt_t1_a_field_imm8_64_poweroftwo_e00_f8100e40() {
    // Thumb encoding (32): 0xF8100E40
    // Test aarch32_LDRBT_T1_A field imm8 = 64 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm8=64
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8100E40;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRBT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 127, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (127)
#[test]
fn test_aarch32_ldrbt_t1_a_field_imm8_127_poweroftwominusone_e00_f8100e7f() {
    // Thumb encoding (32): 0xF8100E7F
    // Test aarch32_LDRBT_T1_A field imm8 = 127 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, Rn=0, imm8=127
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8100E7F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRBT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_ldrbt_t1_a_field_imm8_128_poweroftwo_e00_f8100e80() {
    // Thumb encoding (32): 0xF8100E80
    // Test aarch32_LDRBT_T1_A field imm8 = 128 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, imm8=128, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8100E80;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRBT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 255, boundary: Max }
/// maximum immediate (255)
#[test]
fn test_aarch32_ldrbt_t1_a_field_imm8_255_max_e00_f8100eff() {
    // Thumb encoding (32): 0xF8100EFF
    // Test aarch32_LDRBT_T1_A field imm8 = 255 (Max)
    // ISET: T32
    // Fields: Rt=0, imm8=255, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8100EFF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRBT_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_ldrbt_t1_a_combo_0_e00_f8100e00() {
    // Thumb encoding (32): 0xF8100E00
    // Test aarch32_LDRBT_T1_A field combination: Rn=0, Rt=0, imm8=0
    // ISET: T32
    // Fields: imm8=0, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8100E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRBT_T1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrbt_t1_a_invalid_0_e00_f8100e00() {
    // Thumb encoding (32): 0xF8100E00
    // Test aarch32_LDRBT_T1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: LitInt(15) }
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8100E00;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRBT_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrbt_t1_a_invalid_1_e00_f8100e00() {
    // Thumb encoding (32): 0xF8100E00
    // Test aarch32_LDRBT_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8100E00;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRBT_A1_A
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrbt_a1_a_exception_0_04700000() {
    // Test aarch32_LDRBT_A1_A exception: Unpredictable
    // Encoding: 0x04700000
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04700000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_LDRBT_A2_A
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrbt_a2_a_exception_0_06700000() {
    // Test aarch32_LDRBT_A2_A exception: Unpredictable
    // Encoding: 0x06700000
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x06700000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_LDRBT_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple division (32)
#[test]
fn test_aarch32_ldrbt_t1_a_udiv_oracle_32_0_1ac20820() {
    // Test UDIV 32-bit: simple division (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xA);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA, "W0 should be 0x0000000A");
}

/// Provenance: aarch32_LDRBT_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple division (64)
#[test]
fn test_aarch32_ldrbt_t1_a_udiv_oracle_64_0_9ac20820() {
    // Test UDIV 64-bit: simple division (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xA);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA, "X0 should be 0x000000000000000A");
}

/// Provenance: aarch32_LDRBT_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// division with remainder (32)
#[test]
fn test_aarch32_ldrbt_t1_a_udiv_oracle_32_1_1ac20820() {
    // Test UDIV 32-bit: division with remainder (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x3);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x21, "W0 should be 0x00000021");
}

/// Provenance: aarch32_LDRBT_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// division with remainder (64)
#[test]
fn test_aarch32_ldrbt_t1_a_udiv_oracle_64_1_9ac20820() {
    // Test UDIV 64-bit: division with remainder (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x3);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x21, "X0 should be 0x0000000000000021");
}

/// Provenance: aarch32_LDRBT_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero dividend (32)
#[test]
fn test_aarch32_ldrbt_t1_a_udiv_oracle_32_2_1ac20820() {
    // Test UDIV 32-bit: zero dividend (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xA);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_LDRBT_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero dividend (64)
#[test]
fn test_aarch32_ldrbt_t1_a_udiv_oracle_64_2_9ac20820() {
    // Test UDIV 64-bit: zero dividend (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xA);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_LDRBT_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// divide by zero - result is 0 (32)
#[test]
fn test_aarch32_ldrbt_t1_a_udiv_oracle_32_3_1ac20820() {
    // Test UDIV 32-bit: divide by zero - result is 0 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0xA);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_LDRBT_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// divide by zero - result is 0 (64)
#[test]
fn test_aarch32_ldrbt_t1_a_udiv_oracle_64_3_9ac20820() {
    // Test UDIV 64-bit: divide by zero - result is 0 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xA);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_LDRBT_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max value / 2 (32)
#[test]
fn test_aarch32_ldrbt_t1_a_udiv_oracle_32_4_1ac20820() {
    // Test UDIV 32-bit: max value / 2 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FFFFFFF, "W0 should be 0x7FFFFFFF");
}

/// Provenance: aarch32_LDRBT_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max value / 2 (64)
#[test]
fn test_aarch32_ldrbt_t1_a_udiv_oracle_64_4_9ac20820() {
    // Test UDIV 64-bit: max value / 2 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0x7FFFFFFFFFFFFFFF"
    );
}

/// Provenance: aarch32_LDRBT_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set / 2 (32)
#[test]
fn test_aarch32_ldrbt_t1_a_udiv_oracle_32_5_1ac20820() {
    // Test UDIV 32-bit: MSB set / 2 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_LDRBT_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// MSB set / 2 (64)
#[test]
fn test_aarch32_ldrbt_t1_a_udiv_oracle_64_5_9ac20820() {
    // Test UDIV 64-bit: MSB set / 2 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x4000000000000000");
}

/// Provenance: aarch32_LDRBT_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// self-division (32)
#[test]
fn test_aarch32_ldrbt_t1_a_udiv_oracle_32_6_1ac20820() {
    // Test UDIV 32-bit: self-division (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7);
    set_w(&mut cpu, 2, 0x7);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_LDRBT_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// self-division (64)
#[test]
fn test_aarch32_ldrbt_t1_a_udiv_oracle_64_6_9ac20820() {
    // Test UDIV 64-bit: self-division (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x7);
    set_w(&mut cpu, 1, 0x7);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x0000000000000001");
}

/// Provenance: aarch32_LDRBT_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// one / one (32)
#[test]
fn test_aarch32_ldrbt_t1_a_udiv_oracle_32_7_1ac20820() {
    // Test UDIV 32-bit: one / one (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_LDRBT_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// one / one (64)
#[test]
fn test_aarch32_ldrbt_t1_a_udiv_oracle_64_7_9ac20820() {
    // Test UDIV 64-bit: one / one (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x0000000000000001");
}

/// Provenance: aarch32_LDRBT_T1_A
/// ASL: `UDIV R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// exact division
#[test]
fn test_aarch32_ldrbt_t1_a_t32_oracle_0_f8110e00() {
    // Test T32 UDIV: exact division (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0xA);
    let encoding: u32 = 0xF8110E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA, "R0 should be 0x0000000A");
}

/// Provenance: aarch32_LDRBT_T1_A
/// ASL: `UDIV R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// with remainder
#[test]
fn test_aarch32_ldrbt_t1_a_t32_oracle_1_f8110e00() {
    // Test T32 UDIV: with remainder (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x3);
    let encoding: u32 = 0xF8110E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x21, "R0 should be 0x00000021");
}

/// Provenance: aarch32_LDRBT_T1_A
/// ASL: `UDIV R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero dividend
#[test]
fn test_aarch32_ldrbt_t1_a_t32_oracle_2_f8110e00() {
    // Test T32 UDIV: zero dividend (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xA);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF8110E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_LDRBT_T1_A
/// ASL: `UDIV R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// divide by zero
#[test]
fn test_aarch32_ldrbt_t1_a_t32_oracle_3_f8110e00() {
    // Test T32 UDIV: divide by zero (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xA);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xF8110E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_LDRBT_T1_A
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrbt_t1_a_exception_0_f8100e00() {
    // Test aarch32_LDRBT_T1_A exception: Unpredictable
    // ISET: T32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF8100E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// aarch32_LDAB_A Tests
// ============================================================================

/// Provenance: aarch32_LDAB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_ldab_a1_a_field_cond_0_min_90_01d00090() {
    // Encoding: 0x01D00090
    // Test aarch32_LDAB_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=0
    let encoding: u32 = 0x01D00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_ldab_a1_a_field_cond_1_poweroftwo_90_11d00090() {
    // Encoding: 0x11D00090
    // Test aarch32_LDAB_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, cond=1, Rn=0
    let encoding: u32 = 0x11D00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_ldab_a1_a_field_cond_2_poweroftwo_90_21d00090() {
    // Encoding: 0x21D00090
    // Test aarch32_LDAB_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=2
    let encoding: u32 = 0x21D00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_ldab_a1_a_field_cond_3_poweroftwo_90_31d00090() {
    // Encoding: 0x31D00090
    // Test aarch32_LDAB_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=3, Rn=0, Rt=0
    let encoding: u32 = 0x31D00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_ldab_a1_a_field_cond_4_poweroftwo_90_41d00090() {
    // Encoding: 0x41D00090
    // Test aarch32_LDAB_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=4, Rt=0
    let encoding: u32 = 0x41D00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_ldab_a1_a_field_cond_5_poweroftwo_90_51d00090() {
    // Encoding: 0x51D00090
    // Test aarch32_LDAB_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, cond=5, Rn=0
    let encoding: u32 = 0x51D00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_ldab_a1_a_field_cond_6_poweroftwo_90_61d00090() {
    // Encoding: 0x61D00090
    // Test aarch32_LDAB_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=6, Rt=0
    let encoding: u32 = 0x61D00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_ldab_a1_a_field_cond_7_poweroftwo_90_71d00090() {
    // Encoding: 0x71D00090
    // Test aarch32_LDAB_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=7, Rt=0, Rn=0
    let encoding: u32 = 0x71D00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_ldab_a1_a_field_cond_8_poweroftwo_90_81d00090() {
    // Encoding: 0x81D00090
    // Test aarch32_LDAB_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, cond=8, Rn=0
    let encoding: u32 = 0x81D00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_ldab_a1_a_field_cond_9_poweroftwo_90_91d00090() {
    // Encoding: 0x91D00090
    // Test aarch32_LDAB_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=9, Rn=0, Rt=0
    let encoding: u32 = 0x91D00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_ldab_a1_a_field_cond_10_poweroftwo_90_a1d00090() {
    // Encoding: 0xA1D00090
    // Test aarch32_LDAB_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=10, Rn=0, Rt=0
    let encoding: u32 = 0xA1D00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_ldab_a1_a_field_cond_11_poweroftwo_90_b1d00090() {
    // Encoding: 0xB1D00090
    // Test aarch32_LDAB_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=11, Rt=0, Rn=0
    let encoding: u32 = 0xB1D00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_ldab_a1_a_field_cond_12_poweroftwo_90_c1d00090() {
    // Encoding: 0xC1D00090
    // Test aarch32_LDAB_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, Rn=0, cond=12
    let encoding: u32 = 0xC1D00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_ldab_a1_a_field_cond_13_poweroftwo_90_d1d00090() {
    // Encoding: 0xD1D00090
    // Test aarch32_LDAB_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=13, Rn=0, Rt=0
    let encoding: u32 = 0xD1D00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_ldab_a1_a_field_cond_14_poweroftwo_90_e1d00090() {
    // Encoding: 0xE1D00090
    // Test aarch32_LDAB_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, Rn=0, cond=14
    let encoding: u32 = 0xE1D00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_ldab_a1_a_field_cond_15_max_90_f1d00090() {
    // Encoding: 0xF1D00090
    // Test aarch32_LDAB_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: Rt=0, cond=15, Rn=0
    let encoding: u32 = 0xF1D00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAB_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldab_a1_a_field_rn_0_min_90_01d00090() {
    // Encoding: 0x01D00090
    // Test aarch32_LDAB_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rn=0, Rt=0
    let encoding: u32 = 0x01D00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAB_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldab_a1_a_field_rn_1_poweroftwo_90_01d10090() {
    // Encoding: 0x01D10090
    // Test aarch32_LDAB_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Rn=1, Rt=0
    let encoding: u32 = 0x01D10090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAB_A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldab_a1_a_field_rt_0_min_90_01d00090() {
    // Encoding: 0x01D00090
    // Test aarch32_LDAB_A1_A field Rt = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rn=0, Rt=0
    let encoding: u32 = 0x01D00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAB_A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldab_a1_a_field_rt_1_poweroftwo_90_01d01090() {
    // Encoding: 0x01D01090
    // Test aarch32_LDAB_A1_A field Rt = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=1, cond=0, Rn=0
    let encoding: u32 = 0x01D01090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAB_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_ldab_a1_a_combo_0_90_01d00090() {
    // Encoding: 0x01D00090
    // Test aarch32_LDAB_A1_A field combination: cond=0, Rn=0, Rt=0
    // ISET: A32
    // Fields: Rn=0, cond=0, Rt=0
    let encoding: u32 = 0x01D00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAB_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_ldab_a1_a_special_cond_0_condition_eq_144_01d00090() {
    // Encoding: 0x01D00090
    // Test aarch32_LDAB_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=0
    let encoding: u32 = 0x01D00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAB_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_ldab_a1_a_special_cond_1_condition_ne_144_11d00090() {
    // Encoding: 0x11D00090
    // Test aarch32_LDAB_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: Rn=0, cond=1, Rt=0
    let encoding: u32 = 0x11D00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAB_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_ldab_a1_a_special_cond_2_condition_cs_hs_144_21d00090() {
    // Encoding: 0x21D00090
    // Test aarch32_LDAB_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=2
    let encoding: u32 = 0x21D00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAB_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_ldab_a1_a_special_cond_3_condition_cc_lo_144_31d00090() {
    // Encoding: 0x31D00090
    // Test aarch32_LDAB_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: cond=3, Rn=0, Rt=0
    let encoding: u32 = 0x31D00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAB_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_ldab_a1_a_special_cond_4_condition_mi_144_41d00090() {
    // Encoding: 0x41D00090
    // Test aarch32_LDAB_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: cond=4, Rn=0, Rt=0
    let encoding: u32 = 0x41D00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAB_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_ldab_a1_a_special_cond_5_condition_pl_144_51d00090() {
    // Encoding: 0x51D00090
    // Test aarch32_LDAB_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: Rt=0, cond=5, Rn=0
    let encoding: u32 = 0x51D00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAB_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_ldab_a1_a_special_cond_6_condition_vs_144_61d00090() {
    // Encoding: 0x61D00090
    // Test aarch32_LDAB_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=6
    let encoding: u32 = 0x61D00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAB_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_ldab_a1_a_special_cond_7_condition_vc_144_71d00090() {
    // Encoding: 0x71D00090
    // Test aarch32_LDAB_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: cond=7, Rn=0, Rt=0
    let encoding: u32 = 0x71D00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAB_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_ldab_a1_a_special_cond_8_condition_hi_144_81d00090() {
    // Encoding: 0x81D00090
    // Test aarch32_LDAB_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: Rt=0, cond=8, Rn=0
    let encoding: u32 = 0x81D00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAB_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_ldab_a1_a_special_cond_9_condition_ls_144_91d00090() {
    // Encoding: 0x91D00090
    // Test aarch32_LDAB_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: cond=9, Rn=0, Rt=0
    let encoding: u32 = 0x91D00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAB_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_ldab_a1_a_special_cond_10_condition_ge_144_a1d00090() {
    // Encoding: 0xA1D00090
    // Test aarch32_LDAB_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: cond=10, Rt=0, Rn=0
    let encoding: u32 = 0xA1D00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAB_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_ldab_a1_a_special_cond_11_condition_lt_144_b1d00090() {
    // Encoding: 0xB1D00090
    // Test aarch32_LDAB_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: Rt=0, cond=11, Rn=0
    let encoding: u32 = 0xB1D00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAB_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_ldab_a1_a_special_cond_12_condition_gt_144_c1d00090() {
    // Encoding: 0xC1D00090
    // Test aarch32_LDAB_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: cond=12, Rn=0, Rt=0
    let encoding: u32 = 0xC1D00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAB_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_ldab_a1_a_special_cond_13_condition_le_144_d1d00090() {
    // Encoding: 0xD1D00090
    // Test aarch32_LDAB_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: Rt=0, Rn=0, cond=13
    let encoding: u32 = 0xD1D00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAB_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_ldab_a1_a_special_cond_14_condition_al_144_e1d00090() {
    // Encoding: 0xE1D00090
    // Test aarch32_LDAB_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: cond=14, Rt=0, Rn=0
    let encoding: u32 = 0xE1D00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAB_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_ldab_a1_a_special_cond_15_condition_nv_144_f1d00090() {
    // Encoding: 0xF1D00090
    // Test aarch32_LDAB_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: cond=15, Rt=0, Rn=0
    let encoding: u32 = 0xF1D00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAB_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldab_a1_a_invalid_0_90_01d00090() {
    // Encoding: 0x01D00090
    // Test aarch32_LDAB_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }
    // ISET: A32
    // Fields: Rt=0, cond=0, Rn=0
    let encoding: u32 = 0x01D00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDAB_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldab_a1_a_invalid_1_90_01d00090() {
    // Encoding: 0x01D00090
    // Test aarch32_LDAB_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Rt=0, cond=0, Rn=0
    let encoding: u32 = 0x01D00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDAB_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldab_t1_a_field_rn_0_min_80_e8d00080() {
    // Thumb encoding (32): 0xE8D00080
    // Test aarch32_LDAB_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8D00080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDAB_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldab_t1_a_field_rn_1_poweroftwo_80_e8d10080() {
    // Thumb encoding (32): 0xE8D10080
    // Test aarch32_LDAB_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, Rn=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8D10080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDAB_T1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldab_t1_a_field_rt_0_min_80_e8d00080() {
    // Thumb encoding (32): 0xE8D00080
    // Test aarch32_LDAB_T1_A field Rt = 0 (Min)
    // ISET: T32
    // Fields: Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8D00080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDAB_T1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldab_t1_a_field_rt_1_poweroftwo_80_e8d01080() {
    // Thumb encoding (32): 0xE8D01080
    // Test aarch32_LDAB_T1_A field Rt = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=1, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8D01080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDAB_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_ldab_t1_a_combo_0_80_e8d00080() {
    // Thumb encoding (32): 0xE8D00080
    // Test aarch32_LDAB_T1_A field combination: Rn=0, Rt=0
    // ISET: T32
    // Fields: Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8D00080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDAB_T1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldab_t1_a_invalid_0_80_e8d00080() {
    // Thumb encoding (32): 0xE8D00080
    // Test aarch32_LDAB_T1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }
    // ISET: T32
    // Fields: Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8D00080;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_LDAB_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldab_t1_a_invalid_1_80_e8d00080() {
    // Thumb encoding (32): 0xE8D00080
    // Test aarch32_LDAB_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8D00080;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_LDAB_A1_A
/// ASL: `SMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple multiply
#[test]
fn test_aarch32_ldab_a1_a_smull_oracle_0_9b227c20() {
    // Test SMULL: simple multiply (oracle)
    // Encoding: 0x9B227C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x2);
    set_w(&mut cpu, 2, 0x3);
    let encoding: u32 = 0x9B227C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6, "X0 should be 0x0000000000000006");
}

/// Provenance: aarch32_LDAB_A1_A
/// ASL: `SMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max 32-bit * 2
#[test]
fn test_aarch32_ldab_a1_a_smull_oracle_1_9b227c20() {
    // Test SMULL: max 32-bit * 2 (oracle)
    // Encoding: 0x9B227C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x9B227C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0xFFFFFFFFFFFFFFFE"
    );
}

/// Provenance: aarch32_LDAB_A1_A
/// ASL: `SMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// large positive * large positive
#[test]
fn test_aarch32_ldab_a1_a_smull_oracle_2_9b227c20() {
    // Test SMULL: large positive * large positive (oracle)
    // Encoding: 0x9B227C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x7FFFFFFF);
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x9B227C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x3FFFFFFF00000001");
}

/// Provenance: aarch32_LDAB_A1_A
/// ASL: `SMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max unsigned * max unsigned
#[test]
fn test_aarch32_ldab_a1_a_smull_oracle_3_9b227c20() {
    // Test SMULL: max unsigned * max unsigned (oracle)
    // Encoding: 0x9B227C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x9B227C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x0000000000000001");
}

/// Provenance: aarch32_LDAB_A1_A
/// ASL: `SMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// medium values
#[test]
fn test_aarch32_ldab_a1_a_smull_oracle_4_9b227c20() {
    // Test SMULL: medium values (oracle)
    // Encoding: 0x9B227C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xC8);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x9B227C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4E20, "X0 should be 0x0000000000004E20");
}

/// Provenance: aarch32_LDAB_A1_A
/// ASL: `SMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// 16-bit values
#[test]
fn test_aarch32_ldab_a1_a_smull_oracle_5_9b227c20() {
    // Test SMULL: 16-bit values (oracle)
    // Encoding: 0x9B227C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1234);
    set_w(&mut cpu, 2, 0x5678);
    let encoding: u32 = 0x9B227C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6260060, "X0 should be 0x0000000006260060");
}

// ============================================================================
// aarch32_LDRD_r_A Tests
// ============================================================================

/// Provenance: aarch32_LDRD_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_ldrd_r_a1_a_field_cond_0_min_d0_000000d0() {
    // Encoding: 0x000000D0
    // Test aarch32_LDRD_r_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rt=0, Rn=0, Rm=0, U=0, P=0, W=0
    let encoding: u32 = 0x000000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_ldrd_r_a1_a_field_cond_1_poweroftwo_d0_100000d0() {
    // Encoding: 0x100000D0
    // Test aarch32_LDRD_r_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, U=0, P=0, W=0, Rn=0, cond=1, Rt=0
    let encoding: u32 = 0x100000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_ldrd_r_a1_a_field_cond_2_poweroftwo_d0_200000d0() {
    // Encoding: 0x200000D0
    // Test aarch32_LDRD_r_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, W=0, U=0, Rn=0, cond=2, Rt=0, Rm=0
    let encoding: u32 = 0x200000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_ldrd_r_a1_a_field_cond_3_poweroftwo_d0_300000d0() {
    // Encoding: 0x300000D0
    // Test aarch32_LDRD_r_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, U=0, Rm=0, P=0, cond=3, W=0, Rn=0
    let encoding: u32 = 0x300000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_ldrd_r_a1_a_field_cond_4_poweroftwo_d0_400000d0() {
    // Encoding: 0x400000D0
    // Test aarch32_LDRD_r_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=4, Rm=0, Rn=0, Rt=0, W=0, P=0, U=0
    let encoding: u32 = 0x400000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_ldrd_r_a1_a_field_cond_5_poweroftwo_d0_500000d0() {
    // Encoding: 0x500000D0
    // Test aarch32_LDRD_r_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, W=0, P=0, U=0, Rt=0, Rn=0, cond=5
    let encoding: u32 = 0x500000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_ldrd_r_a1_a_field_cond_6_poweroftwo_d0_600000d0() {
    // Encoding: 0x600000D0
    // Test aarch32_LDRD_r_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, Rn=0, cond=6, Rt=0, U=0, Rm=0, P=0
    let encoding: u32 = 0x600000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_ldrd_r_a1_a_field_cond_7_poweroftwo_d0_700000d0() {
    // Encoding: 0x700000D0
    // Test aarch32_LDRD_r_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, U=0, Rn=0, Rm=0, P=0, W=0, cond=7
    let encoding: u32 = 0x700000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_ldrd_r_a1_a_field_cond_8_poweroftwo_d0_800000d0() {
    // Encoding: 0x800000D0
    // Test aarch32_LDRD_r_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, U=0, W=0, P=0, Rt=0, Rm=0, cond=8
    let encoding: u32 = 0x800000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_ldrd_r_a1_a_field_cond_9_poweroftwo_d0_900000d0() {
    // Encoding: 0x900000D0
    // Test aarch32_LDRD_r_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, W=0, Rt=0, Rm=0, cond=9, U=0, Rn=0
    let encoding: u32 = 0x900000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_ldrd_r_a1_a_field_cond_10_poweroftwo_d0_a00000d0() {
    // Encoding: 0xA00000D0
    // Test aarch32_LDRD_r_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, P=0, U=0, W=0, cond=10, Rn=0, Rm=0
    let encoding: u32 = 0xA00000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_ldrd_r_a1_a_field_cond_11_poweroftwo_d0_b00000d0() {
    // Encoding: 0xB00000D0
    // Test aarch32_LDRD_r_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=11, P=0, U=0, Rn=0, Rm=0, Rt=0, W=0
    let encoding: u32 = 0xB00000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_ldrd_r_a1_a_field_cond_12_poweroftwo_d0_c00000d0() {
    // Encoding: 0xC00000D0
    // Test aarch32_LDRD_r_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, W=0, cond=12, Rt=0, U=0, Rn=0, P=0
    let encoding: u32 = 0xC00000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_ldrd_r_a1_a_field_cond_13_poweroftwo_d0_d00000d0() {
    // Encoding: 0xD00000D0
    // Test aarch32_LDRD_r_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, P=0, cond=13, W=0, Rn=0, U=0, Rt=0
    let encoding: u32 = 0xD00000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_ldrd_r_a1_a_field_cond_14_poweroftwo_d0_e00000d0() {
    // Encoding: 0xE00000D0
    // Test aarch32_LDRD_r_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, U=0, Rt=0, Rm=0, Rn=0, cond=14, P=0
    let encoding: u32 = 0xE00000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_ldrd_r_a1_a_field_cond_15_max_d0_f00000d0() {
    // Encoding: 0xF00000D0
    // Test aarch32_LDRD_r_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: U=0, Rt=0, W=0, Rm=0, P=0, Rn=0, cond=15
    let encoding: u32 = 0xF00000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_r_A1_A
/// ASL: `field P 24 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldrd_r_a1_a_field_p_0_min_d0_000000d0() {
    // Encoding: 0x000000D0
    // Test aarch32_LDRD_r_A1_A field P = 0 (Min)
    // ISET: A32
    // Fields: cond=0, U=0, W=0, Rn=0, Rt=0, P=0, Rm=0
    let encoding: u32 = 0x000000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_r_A1_A
/// ASL: `field P 24 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldrd_r_a1_a_field_p_1_max_d0_010000d0() {
    // Encoding: 0x010000D0
    // Test aarch32_LDRD_r_A1_A field P = 1 (Max)
    // ISET: A32
    // Fields: U=0, W=0, Rn=0, cond=0, Rm=0, Rt=0, P=1
    let encoding: u32 = 0x010000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_r_A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldrd_r_a1_a_field_u_0_min_d0_000000d0() {
    // Encoding: 0x000000D0
    // Test aarch32_LDRD_r_A1_A field U = 0 (Min)
    // ISET: A32
    // Fields: U=0, P=0, W=0, Rt=0, cond=0, Rn=0, Rm=0
    let encoding: u32 = 0x000000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_r_A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldrd_r_a1_a_field_u_1_max_d0_008000d0() {
    // Encoding: 0x008000D0
    // Test aarch32_LDRD_r_A1_A field U = 1 (Max)
    // ISET: A32
    // Fields: U=1, Rn=0, Rt=0, W=0, Rm=0, cond=0, P=0
    let encoding: u32 = 0x008000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_r_A1_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldrd_r_a1_a_field_w_0_min_d0_000000d0() {
    // Encoding: 0x000000D0
    // Test aarch32_LDRD_r_A1_A field W = 0 (Min)
    // ISET: A32
    // Fields: Rt=0, Rm=0, cond=0, P=0, W=0, U=0, Rn=0
    let encoding: u32 = 0x000000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_r_A1_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldrd_r_a1_a_field_w_1_max_d0_002000d0() {
    // Encoding: 0x002000D0
    // Test aarch32_LDRD_r_A1_A field W = 1 (Max)
    // ISET: A32
    // Fields: Rn=0, U=0, W=1, Rt=0, cond=0, P=0, Rm=0
    let encoding: u32 = 0x002000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_r_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrd_r_a1_a_field_rn_0_min_d0_000000d0() {
    // Encoding: 0x000000D0
    // Test aarch32_LDRD_r_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: W=0, U=0, Rm=0, P=0, Rt=0, Rn=0, cond=0
    let encoding: u32 = 0x000000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_r_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrd_r_a1_a_field_rn_1_poweroftwo_d0_000100d0() {
    // Encoding: 0x000100D0
    // Test aarch32_LDRD_r_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Rt=0, U=0, P=0, W=0, Rn=1, Rm=0
    let encoding: u32 = 0x000100D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_r_A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrd_r_a1_a_field_rt_0_min_d0_000000d0() {
    // Encoding: 0x000000D0
    // Test aarch32_LDRD_r_A1_A field Rt = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, cond=0, P=0, W=0, U=0, Rn=0, Rt=0
    let encoding: u32 = 0x000000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_r_A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrd_r_a1_a_field_rt_1_poweroftwo_d0_000010d0() {
    // Encoding: 0x000010D0
    // Test aarch32_LDRD_r_A1_A field Rt = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, W=0, U=0, cond=0, Rn=0, P=0, Rt=1
    let encoding: u32 = 0x000010D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_r_A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrd_r_a1_a_field_rm_0_min_d0_000000d0() {
    // Encoding: 0x000000D0
    // Test aarch32_LDRD_r_A1_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: cond=0, U=0, Rn=0, Rt=0, Rm=0, W=0, P=0
    let encoding: u32 = 0x000000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_r_A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrd_r_a1_a_field_rm_1_poweroftwo_d0_000000d1() {
    // Encoding: 0x000000D1
    // Test aarch32_LDRD_r_A1_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, U=0, W=0, Rn=0, Rt=0, cond=0, Rm=1
    let encoding: u32 = 0x000000D1;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_r_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_ldrd_r_a1_a_combo_0_d0_000000d0() {
    // Encoding: 0x000000D0
    // Test aarch32_LDRD_r_A1_A field combination: cond=0, P=0, U=0, W=0, Rn=0, Rt=0, Rm=0
    // ISET: A32
    // Fields: U=0, W=0, Rt=0, Rn=0, P=0, Rm=0, cond=0
    let encoding: u32 = 0x000000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_r_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_ldrd_r_a1_a_special_cond_0_condition_eq_208_000000d0() {
    // Encoding: 0x000000D0
    // Test aarch32_LDRD_r_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: Rm=0, W=0, P=0, cond=0, Rn=0, U=0, Rt=0
    let encoding: u32 = 0x000000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_r_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_ldrd_r_a1_a_special_cond_1_condition_ne_208_100000d0() {
    // Encoding: 0x100000D0
    // Test aarch32_LDRD_r_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: Rt=0, U=0, Rn=0, Rm=0, W=0, P=0, cond=1
    let encoding: u32 = 0x100000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_r_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_ldrd_r_a1_a_special_cond_2_condition_cs_hs_208_200000d0() {
    // Encoding: 0x200000D0
    // Test aarch32_LDRD_r_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: W=0, U=0, Rn=0, Rt=0, Rm=0, cond=2, P=0
    let encoding: u32 = 0x200000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_r_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_ldrd_r_a1_a_special_cond_3_condition_cc_lo_208_300000d0() {
    // Encoding: 0x300000D0
    // Test aarch32_LDRD_r_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: Rt=0, Rn=0, cond=3, P=0, W=0, Rm=0, U=0
    let encoding: u32 = 0x300000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_r_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_ldrd_r_a1_a_special_cond_4_condition_mi_208_400000d0() {
    // Encoding: 0x400000D0
    // Test aarch32_LDRD_r_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: Rn=0, cond=4, U=0, Rt=0, P=0, Rm=0, W=0
    let encoding: u32 = 0x400000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_r_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_ldrd_r_a1_a_special_cond_5_condition_pl_208_500000d0() {
    // Encoding: 0x500000D0
    // Test aarch32_LDRD_r_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: U=0, P=0, Rt=0, Rm=0, cond=5, W=0, Rn=0
    let encoding: u32 = 0x500000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_r_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_ldrd_r_a1_a_special_cond_6_condition_vs_208_600000d0() {
    // Encoding: 0x600000D0
    // Test aarch32_LDRD_r_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: U=0, Rn=0, Rt=0, W=0, Rm=0, cond=6, P=0
    let encoding: u32 = 0x600000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_r_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_ldrd_r_a1_a_special_cond_7_condition_vc_208_700000d0() {
    // Encoding: 0x700000D0
    // Test aarch32_LDRD_r_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: P=0, W=0, Rn=0, Rm=0, cond=7, U=0, Rt=0
    let encoding: u32 = 0x700000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_r_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_ldrd_r_a1_a_special_cond_8_condition_hi_208_800000d0() {
    // Encoding: 0x800000D0
    // Test aarch32_LDRD_r_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: Rn=0, Rt=0, P=0, U=0, cond=8, Rm=0, W=0
    let encoding: u32 = 0x800000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_r_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_ldrd_r_a1_a_special_cond_9_condition_ls_208_900000d0() {
    // Encoding: 0x900000D0
    // Test aarch32_LDRD_r_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: Rm=0, Rt=0, P=0, Rn=0, U=0, cond=9, W=0
    let encoding: u32 = 0x900000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_r_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_ldrd_r_a1_a_special_cond_10_condition_ge_208_a00000d0() {
    // Encoding: 0xA00000D0
    // Test aarch32_LDRD_r_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: Rt=0, Rn=0, Rm=0, cond=10, P=0, U=0, W=0
    let encoding: u32 = 0xA00000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_r_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_ldrd_r_a1_a_special_cond_11_condition_lt_208_b00000d0() {
    // Encoding: 0xB00000D0
    // Test aarch32_LDRD_r_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: Rm=0, P=0, W=0, U=0, cond=11, Rt=0, Rn=0
    let encoding: u32 = 0xB00000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_r_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_ldrd_r_a1_a_special_cond_12_condition_gt_208_c00000d0() {
    // Encoding: 0xC00000D0
    // Test aarch32_LDRD_r_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: W=0, cond=12, Rt=0, Rn=0, Rm=0, P=0, U=0
    let encoding: u32 = 0xC00000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_r_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_ldrd_r_a1_a_special_cond_13_condition_le_208_d00000d0() {
    // Encoding: 0xD00000D0
    // Test aarch32_LDRD_r_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: Rm=0, P=0, cond=13, U=0, W=0, Rn=0, Rt=0
    let encoding: u32 = 0xD00000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_r_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_ldrd_r_a1_a_special_cond_14_condition_al_208_e00000d0() {
    // Encoding: 0xE00000D0
    // Test aarch32_LDRD_r_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: Rm=0, W=0, P=0, U=0, cond=14, Rn=0, Rt=0
    let encoding: u32 = 0xE00000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_r_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_ldrd_r_a1_a_special_cond_15_condition_nv_208_f00000d0() {
    // Encoding: 0xF00000D0
    // Test aarch32_LDRD_r_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: Rt=0, Rm=0, Rn=0, P=0, cond=15, U=0, W=0
    let encoding: u32 = 0xF00000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRD_r_A1_A
/// ASL: `Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Rt" }), indices: [Single(LitInt(0))] }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Rt\" }), indices: [Single(LitInt(0))] }, rhs: LitBits([true]) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrd_r_a1_a_invalid_0_d0_000000d0() {
    // Encoding: 0x000000D0
    // Test aarch32_LDRD_r_A1_A invalid encoding: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Rt" }), indices: [Single(LitInt(0))] }, rhs: LitBits([true]) }
    // ISET: A32
    // Fields: Rn=0, Rt=0, P=0, Rm=0, W=0, cond=0, U=0
    let encoding: u32 = 0x000000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRD_r_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrd_r_a1_a_invalid_1_d0_000000d0() {
    // Encoding: 0x000000D0
    // Test aarch32_LDRD_r_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: U=0, Rt=0, cond=0, P=0, W=0, Rn=0, Rm=0
    let encoding: u32 = 0x000000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRD_r_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "P" }), rhs: Binary { op: And, lhs: LitBits([false]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "W" }) } }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"P\" }), rhs: Binary { op: And, lhs: LitBits([false]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"W\" }) } }, rhs: LitBits([true]) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrd_r_a1_a_invalid_2_d0_000000d0() {
    // Encoding: 0x000000D0
    // Test aarch32_LDRD_r_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "P" }), rhs: Binary { op: And, lhs: LitBits([false]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "W" }) } }, rhs: LitBits([true]) }
    // ISET: A32
    // Fields: P=0, Rm=0, Rn=0, U=0, W=0, Rt=0, cond=0
    let encoding: u32 = 0x000000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRD_r_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrd_r_a1_a_invalid_3_d0_000000d0() {
    // Encoding: 0x000000D0
    // Test aarch32_LDRD_r_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Rt=0, Rm=0, P=0, U=0, cond=0, W=0, Rn=0
    let encoding: u32 = 0x000000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRD_r_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t2" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t2" }) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t2\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t2\" }) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrd_r_a1_a_invalid_4_d0_000000d0() {
    // Encoding: 0x000000D0
    // Test aarch32_LDRD_r_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t2" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t2" }) }
    // ISET: A32
    // Fields: Rm=0, Rn=0, cond=0, U=0, Rt=0, P=0, W=0
    let encoding: u32 = 0x000000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRD_r_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrd_r_a1_a_invalid_5_d0_000000d0() {
    // Encoding: 0x000000D0
    // Test aarch32_LDRD_r_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: U=0, P=0, W=0, cond=0, Rt=0, Rn=0, Rm=0
    let encoding: u32 = 0x000000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRD_r_A1_A
/// ASL: `Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t2" }) } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"wback\" }), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t2\" }) } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrd_r_a1_a_invalid_6_d0_000000d0() {
    // Encoding: 0x000000D0
    // Test aarch32_LDRD_r_A1_A invalid encoding: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t2" }) } }
    // ISET: A32
    // Fields: W=0, Rt=0, Rm=0, Rn=0, cond=0, U=0, P=0
    let encoding: u32 = 0x000000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRD_r_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrd_r_a1_a_invalid_7_d0_000000d0() {
    // Encoding: 0x000000D0
    // Test aarch32_LDRD_r_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: cond=0, U=0, Rn=0, P=0, W=0, Rt=0, Rm=0
    let encoding: u32 = 0x000000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRD_r_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple multiply (32)
#[test]
fn test_aarch32_ldrd_r_a1_a_mul_oracle_32_0_1b027c20() {
    // Test MUL 32-bit: simple multiply (oracle)
    // Encoding: 0x1B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3);
    set_w(&mut cpu, 1, 0x2);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6, "W0 should be 0x00000006");
}

/// Provenance: aarch32_LDRD_r_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple multiply (64)
#[test]
fn test_aarch32_ldrd_r_a1_a_mul_oracle_64_0_9b027c20() {
    // Test MUL 64-bit: simple multiply (oracle)
    // Encoding: 0x9B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x2);
    set_w(&mut cpu, 2, 0x3);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6, "X0 should be 0x0000000000000006");
}

/// Provenance: aarch32_LDRD_r_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// multiply by zero (32)
#[test]
fn test_aarch32_ldrd_r_a1_a_mul_oracle_32_1_1b027c20() {
    // Test MUL 32-bit: multiply by zero (oracle)
    // Encoding: 0x1B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x64);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_LDRD_r_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// multiply by zero (64)
#[test]
fn test_aarch32_ldrd_r_a1_a_mul_oracle_64_1_9b027c20() {
    // Test MUL 64-bit: multiply by zero (oracle)
    // Encoding: 0x9B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x64);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_LDRD_r_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// multiply by one (32)
#[test]
fn test_aarch32_ldrd_r_a1_a_mul_oracle_32_2_1b027c20() {
    // Test MUL 32-bit: multiply by one (oracle)
    // Encoding: 0x1B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_LDRD_r_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// multiply by one (64)
#[test]
fn test_aarch32_ldrd_r_a1_a_mul_oracle_64_2_9b027c20() {
    // Test MUL 64-bit: multiply by one (oracle)
    // Encoding: 0x9B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x0000000000000001");
}

/// Provenance: aarch32_LDRD_r_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// 16-bit max * 16-bit max (32)
#[test]
fn test_aarch32_ldrd_r_a1_a_mul_oracle_32_3_1b027c20() {
    // Test MUL 32-bit: 16-bit max * 16-bit max (oracle)
    // Encoding: 0x1B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFF);
    set_w(&mut cpu, 2, 0xFFFF);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFE0001, "W0 should be 0xFFFE0001");
}

/// Provenance: aarch32_LDRD_r_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// 16-bit max * 16-bit max (64)
#[test]
fn test_aarch32_ldrd_r_a1_a_mul_oracle_64_3_9b027c20() {
    // Test MUL 64-bit: 16-bit max * 16-bit max (oracle)
    // Encoding: 0x9B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFF);
    set_w(&mut cpu, 2, 0xFFFF);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFE0001,
        "X0 should be 0x00000000FFFE0001"
    );
}

/// Provenance: aarch32_LDRD_r_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift-like multiply (32)
#[test]
fn test_aarch32_ldrd_r_a1_a_mul_oracle_32_4_1b027c20() {
    // Test MUL 32-bit: shift-like multiply (oracle)
    // Encoding: 0x1B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x2468ACF0, "W0 should be 0x2468ACF0");
}

/// Provenance: aarch32_LDRD_r_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift-like multiply (64)
#[test]
fn test_aarch32_ldrd_r_a1_a_mul_oracle_64_4_9b027c20() {
    // Test MUL 64-bit: shift-like multiply (oracle)
    // Encoding: 0x9B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x2468ACF0,
        "X0 should be 0x000000002468ACF0"
    );
}

/// Provenance: aarch32_LDRD_r_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// larger values (32)
#[test]
fn test_aarch32_ldrd_r_a1_a_mul_oracle_32_5_1b027c20() {
    // Test MUL 32-bit: larger values (oracle)
    // Encoding: 0x1B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0xC8);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4E20, "W0 should be 0x00004E20");
}

/// Provenance: aarch32_LDRD_r_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// larger values (64)
#[test]
fn test_aarch32_ldrd_r_a1_a_mul_oracle_64_5_9b027c20() {
    // Test MUL 64-bit: larger values (oracle)
    // Encoding: 0x9B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0xC8);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4E20, "X0 should be 0x0000000000004E20");
}

/// Provenance: aarch32_LDRD_r_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// 32-bit overflow (32)
#[test]
fn test_aarch32_ldrd_r_a1_a_mul_oracle_32_6_1b027c20() {
    // Test MUL 32-bit: 32-bit overflow (oracle)
    // Encoding: 0x1B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_LDRD_r_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// 32-bit overflow (64)
#[test]
fn test_aarch32_ldrd_r_a1_a_mul_oracle_64_6_9b027c20() {
    // Test MUL 64-bit: 32-bit overflow (oracle)
    // Encoding: 0x9B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0xFFFFFFFE00000001");
}

/// Provenance: aarch32_LDRD_r_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// prime numbers (32)
#[test]
fn test_aarch32_ldrd_r_a1_a_mul_oracle_32_7_1b027c20() {
    // Test MUL 32-bit: prime numbers (oracle)
    // Encoding: 0x1B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7);
    set_w(&mut cpu, 2, 0xB);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4D, "W0 should be 0x0000004D");
}

/// Provenance: aarch32_LDRD_r_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// prime numbers (64)
#[test]
fn test_aarch32_ldrd_r_a1_a_mul_oracle_64_7_9b027c20() {
    // Test MUL 64-bit: prime numbers (oracle)
    // Encoding: 0x9B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xB);
    set_w(&mut cpu, 1, 0x7);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4D, "X0 should be 0x000000000000004D");
}

/// Provenance: aarch32_LDRD_r_A1_A
/// ASL: `MUL R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple values
#[test]
fn test_aarch32_ldrd_r_a1_a_a32_mul_0_0000f291() {
    // Test A32 MUL: simple values (oracle)
    // Encoding: 0x0000F291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x32);
    let encoding: u32 = 0x0000F291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1388, "R0 should be 0x00001388");
}

/// Provenance: aarch32_LDRD_r_A1_A
/// ASL: `MUL R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero values
#[test]
fn test_aarch32_ldrd_r_a1_a_a32_mul_1_0000f291() {
    // Test A32 MUL: zero values (oracle)
    // Encoding: 0x0000F291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x0000F291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_LDRD_r_A1_A
/// ASL: `MUL R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max value
#[test]
fn test_aarch32_ldrd_r_a1_a_a32_mul_2_0000f291() {
    // Test A32 MUL: max value (oracle)
    // Encoding: 0x0000F291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x0000F291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "R0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_LDRD_r_A1_A
/// ASL: `MUL R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set
#[test]
fn test_aarch32_ldrd_r_a1_a_a32_mul_3_0000f291() {
    // Test A32 MUL: MSB set (oracle)
    // Encoding: 0x0000F291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x80000000);
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0x0000F291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_LDRD_r_A1_A
/// ASL: `MUL R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// mixed pattern
#[test]
fn test_aarch32_ldrd_r_a1_a_a32_mul_4_0000f291() {
    // Test A32 MUL: mixed pattern (oracle)
    // Encoding: 0x0000F291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x9ABCDEF0);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u32 = 0x0000F291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x242D2080, "R0 should be 0x242D2080");
}

// ============================================================================
// aarch32_LDRSH_r_A Tests
// ============================================================================

/// Provenance: aarch32_LDRSH_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_ldrsh_r_a1_a_field_cond_0_min_f0_001000f0() {
    // Encoding: 0x001000F0
    // Test aarch32_LDRSH_r_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: P=0, W=0, U=0, Rn=0, cond=0, Rt=0, Rm=0
    let encoding: u32 = 0x001000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_ldrsh_r_a1_a_field_cond_1_poweroftwo_f0_101000f0() {
    // Encoding: 0x101000F0
    // Test aarch32_LDRSH_r_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, Rt=0, Rm=0, Rn=0, P=0, U=0, cond=1
    let encoding: u32 = 0x101000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_ldrsh_r_a1_a_field_cond_2_poweroftwo_f0_201000f0() {
    // Encoding: 0x201000F0
    // Test aarch32_LDRSH_r_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, Rt=0, Rm=0, cond=2, U=0, W=0, Rn=0
    let encoding: u32 = 0x201000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_ldrsh_r_a1_a_field_cond_3_poweroftwo_f0_301000f0() {
    // Encoding: 0x301000F0
    // Test aarch32_LDRSH_r_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, cond=3, U=0, Rt=0, P=0, Rn=0, Rm=0
    let encoding: u32 = 0x301000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_ldrsh_r_a1_a_field_cond_4_poweroftwo_f0_401000f0() {
    // Encoding: 0x401000F0
    // Test aarch32_LDRSH_r_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, W=0, Rn=0, Rt=0, U=0, Rm=0, cond=4
    let encoding: u32 = 0x401000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_ldrsh_r_a1_a_field_cond_5_poweroftwo_f0_501000f0() {
    // Encoding: 0x501000F0
    // Test aarch32_LDRSH_r_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rm=0, W=0, cond=5, U=0, P=0, Rt=0
    let encoding: u32 = 0x501000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_ldrsh_r_a1_a_field_cond_6_poweroftwo_f0_601000f0() {
    // Encoding: 0x601000F0
    // Test aarch32_LDRSH_r_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=6, Rt=0, Rm=0, U=0, W=0, P=0, Rn=0
    let encoding: u32 = 0x601000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_ldrsh_r_a1_a_field_cond_7_poweroftwo_f0_701000f0() {
    // Encoding: 0x701000F0
    // Test aarch32_LDRSH_r_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rt=0, Rm=0, cond=7, P=0, U=0, W=0
    let encoding: u32 = 0x701000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_ldrsh_r_a1_a_field_cond_8_poweroftwo_f0_801000f0() {
    // Encoding: 0x801000F0
    // Test aarch32_LDRSH_r_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, cond=8, W=0, Rn=0, Rt=0, U=0, Rm=0
    let encoding: u32 = 0x801000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_ldrsh_r_a1_a_field_cond_9_poweroftwo_f0_901000f0() {
    // Encoding: 0x901000F0
    // Test aarch32_LDRSH_r_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=9, P=0, Rn=0, Rt=0, U=0, Rm=0, W=0
    let encoding: u32 = 0x901000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_ldrsh_r_a1_a_field_cond_10_poweroftwo_f0_a01000f0() {
    // Encoding: 0xA01000F0
    // Test aarch32_LDRSH_r_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, Rt=0, W=0, U=0, cond=10, Rm=0, Rn=0
    let encoding: u32 = 0xA01000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_ldrsh_r_a1_a_field_cond_11_poweroftwo_f0_b01000f0() {
    // Encoding: 0xB01000F0
    // Test aarch32_LDRSH_r_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, Rt=0, Rn=0, cond=11, P=0, U=0, Rm=0
    let encoding: u32 = 0xB01000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_ldrsh_r_a1_a_field_cond_12_poweroftwo_f0_c01000f0() {
    // Encoding: 0xC01000F0
    // Test aarch32_LDRSH_r_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=12, U=0, Rn=0, Rm=0, P=0, Rt=0, W=0
    let encoding: u32 = 0xC01000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_ldrsh_r_a1_a_field_cond_13_poweroftwo_f0_d01000f0() {
    // Encoding: 0xD01000F0
    // Test aarch32_LDRSH_r_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rt=0, P=0, Rm=0, cond=13, U=0, W=0
    let encoding: u32 = 0xD01000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_ldrsh_r_a1_a_field_cond_14_poweroftwo_f0_e01000f0() {
    // Encoding: 0xE01000F0
    // Test aarch32_LDRSH_r_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, U=0, Rt=0, P=0, Rm=0, cond=14, Rn=0
    let encoding: u32 = 0xE01000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_ldrsh_r_a1_a_field_cond_15_max_f0_f01000f0() {
    // Encoding: 0xF01000F0
    // Test aarch32_LDRSH_r_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: W=0, Rn=0, P=0, Rm=0, Rt=0, U=0, cond=15
    let encoding: u32 = 0xF01000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_r_A1_A
/// ASL: `field P 24 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldrsh_r_a1_a_field_p_0_min_f0_001000f0() {
    // Encoding: 0x001000F0
    // Test aarch32_LDRSH_r_A1_A field P = 0 (Min)
    // ISET: A32
    // Fields: P=0, Rn=0, W=0, cond=0, Rt=0, Rm=0, U=0
    let encoding: u32 = 0x001000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_r_A1_A
/// ASL: `field P 24 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldrsh_r_a1_a_field_p_1_max_f0_011000f0() {
    // Encoding: 0x011000F0
    // Test aarch32_LDRSH_r_A1_A field P = 1 (Max)
    // ISET: A32
    // Fields: Rm=0, Rn=0, cond=0, U=0, Rt=0, P=1, W=0
    let encoding: u32 = 0x011000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_r_A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldrsh_r_a1_a_field_u_0_min_f0_001000f0() {
    // Encoding: 0x001000F0
    // Test aarch32_LDRSH_r_A1_A field U = 0 (Min)
    // ISET: A32
    // Fields: W=0, Rn=0, cond=0, P=0, Rt=0, U=0, Rm=0
    let encoding: u32 = 0x001000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_r_A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldrsh_r_a1_a_field_u_1_max_f0_009000f0() {
    // Encoding: 0x009000F0
    // Test aarch32_LDRSH_r_A1_A field U = 1 (Max)
    // ISET: A32
    // Fields: cond=0, P=0, Rn=0, W=0, Rt=0, Rm=0, U=1
    let encoding: u32 = 0x009000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_r_A1_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldrsh_r_a1_a_field_w_0_min_f0_001000f0() {
    // Encoding: 0x001000F0
    // Test aarch32_LDRSH_r_A1_A field W = 0 (Min)
    // ISET: A32
    // Fields: P=0, W=0, Rn=0, Rt=0, cond=0, Rm=0, U=0
    let encoding: u32 = 0x001000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_r_A1_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldrsh_r_a1_a_field_w_1_max_f0_003000f0() {
    // Encoding: 0x003000F0
    // Test aarch32_LDRSH_r_A1_A field W = 1 (Max)
    // ISET: A32
    // Fields: Rt=0, Rm=0, U=0, cond=0, W=1, P=0, Rn=0
    let encoding: u32 = 0x003000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_r_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrsh_r_a1_a_field_rn_0_min_f0_001000f0() {
    // Encoding: 0x001000F0
    // Test aarch32_LDRSH_r_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, W=0, Rm=0, U=0, cond=0, P=0, Rt=0
    let encoding: u32 = 0x001000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_r_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrsh_r_a1_a_field_rn_1_poweroftwo_f0_001100f0() {
    // Encoding: 0x001100F0
    // Test aarch32_LDRSH_r_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=1, Rm=0, U=0, Rt=0, P=0, W=0, cond=0
    let encoding: u32 = 0x001100F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_r_A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrsh_r_a1_a_field_rt_0_min_f0_001000f0() {
    // Encoding: 0x001000F0
    // Test aarch32_LDRSH_r_A1_A field Rt = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rm=0, Rt=0, P=0, W=0, Rn=0, U=0
    let encoding: u32 = 0x001000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_r_A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrsh_r_a1_a_field_rt_1_poweroftwo_f0_001010f0() {
    // Encoding: 0x001010F0
    // Test aarch32_LDRSH_r_A1_A field Rt = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, Rt=1, Rm=0, Rn=0, U=0, W=0, cond=0
    let encoding: u32 = 0x001010F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_r_A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrsh_r_a1_a_field_rm_0_min_f0_001000f0() {
    // Encoding: 0x001000F0
    // Test aarch32_LDRSH_r_A1_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, W=0, cond=0, Rt=0, Rm=0, U=0, P=0
    let encoding: u32 = 0x001000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_r_A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrsh_r_a1_a_field_rm_1_poweroftwo_f0_001000f1() {
    // Encoding: 0x001000F1
    // Test aarch32_LDRSH_r_A1_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Rm=1, W=0, P=0, Rn=0, Rt=0, U=0
    let encoding: u32 = 0x001000F1;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_r_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_ldrsh_r_a1_a_combo_0_f0_001000f0() {
    // Encoding: 0x001000F0
    // Test aarch32_LDRSH_r_A1_A field combination: cond=0, P=0, U=0, W=0, Rn=0, Rt=0, Rm=0
    // ISET: A32
    // Fields: P=0, U=0, W=0, Rm=0, Rt=0, cond=0, Rn=0
    let encoding: u32 = 0x001000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_r_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_ldrsh_r_a1_a_special_cond_0_condition_eq_240_001000f0() {
    // Encoding: 0x001000F0
    // Test aarch32_LDRSH_r_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: Rm=0, Rt=0, P=0, U=0, Rn=0, W=0, cond=0
    let encoding: u32 = 0x001000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_r_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_ldrsh_r_a1_a_special_cond_1_condition_ne_240_101000f0() {
    // Encoding: 0x101000F0
    // Test aarch32_LDRSH_r_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: Rm=0, cond=1, Rn=0, Rt=0, U=0, P=0, W=0
    let encoding: u32 = 0x101000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_r_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_ldrsh_r_a1_a_special_cond_2_condition_cs_hs_240_201000f0() {
    // Encoding: 0x201000F0
    // Test aarch32_LDRSH_r_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: Rm=0, Rt=0, Rn=0, U=0, cond=2, P=0, W=0
    let encoding: u32 = 0x201000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_r_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_ldrsh_r_a1_a_special_cond_3_condition_cc_lo_240_301000f0() {
    // Encoding: 0x301000F0
    // Test aarch32_LDRSH_r_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: P=0, Rm=0, Rn=0, Rt=0, W=0, U=0, cond=3
    let encoding: u32 = 0x301000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_r_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_ldrsh_r_a1_a_special_cond_4_condition_mi_240_401000f0() {
    // Encoding: 0x401000F0
    // Test aarch32_LDRSH_r_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: U=0, Rn=0, P=0, W=0, Rt=0, Rm=0, cond=4
    let encoding: u32 = 0x401000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_r_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_ldrsh_r_a1_a_special_cond_5_condition_pl_240_501000f0() {
    // Encoding: 0x501000F0
    // Test aarch32_LDRSH_r_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: cond=5, P=0, U=0, Rn=0, W=0, Rt=0, Rm=0
    let encoding: u32 = 0x501000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_r_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_ldrsh_r_a1_a_special_cond_6_condition_vs_240_601000f0() {
    // Encoding: 0x601000F0
    // Test aarch32_LDRSH_r_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: Rn=0, W=0, Rt=0, U=0, Rm=0, P=0, cond=6
    let encoding: u32 = 0x601000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_r_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_ldrsh_r_a1_a_special_cond_7_condition_vc_240_701000f0() {
    // Encoding: 0x701000F0
    // Test aarch32_LDRSH_r_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: Rm=0, cond=7, P=0, U=0, Rn=0, W=0, Rt=0
    let encoding: u32 = 0x701000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_r_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_ldrsh_r_a1_a_special_cond_8_condition_hi_240_801000f0() {
    // Encoding: 0x801000F0
    // Test aarch32_LDRSH_r_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: Rm=0, U=0, P=0, cond=8, W=0, Rn=0, Rt=0
    let encoding: u32 = 0x801000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_r_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_ldrsh_r_a1_a_special_cond_9_condition_ls_240_901000f0() {
    // Encoding: 0x901000F0
    // Test aarch32_LDRSH_r_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: P=0, U=0, Rn=0, W=0, cond=9, Rt=0, Rm=0
    let encoding: u32 = 0x901000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_r_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_ldrsh_r_a1_a_special_cond_10_condition_ge_240_a01000f0() {
    // Encoding: 0xA01000F0
    // Test aarch32_LDRSH_r_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: Rn=0, Rt=0, Rm=0, W=0, cond=10, P=0, U=0
    let encoding: u32 = 0xA01000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_r_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_ldrsh_r_a1_a_special_cond_11_condition_lt_240_b01000f0() {
    // Encoding: 0xB01000F0
    // Test aarch32_LDRSH_r_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: U=0, Rt=0, P=0, Rn=0, W=0, Rm=0, cond=11
    let encoding: u32 = 0xB01000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_r_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_ldrsh_r_a1_a_special_cond_12_condition_gt_240_c01000f0() {
    // Encoding: 0xC01000F0
    // Test aarch32_LDRSH_r_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: Rt=0, P=0, W=0, cond=12, Rn=0, Rm=0, U=0
    let encoding: u32 = 0xC01000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_r_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_ldrsh_r_a1_a_special_cond_13_condition_le_240_d01000f0() {
    // Encoding: 0xD01000F0
    // Test aarch32_LDRSH_r_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: cond=13, P=0, Rt=0, U=0, Rn=0, W=0, Rm=0
    let encoding: u32 = 0xD01000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_r_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_ldrsh_r_a1_a_special_cond_14_condition_al_240_e01000f0() {
    // Encoding: 0xE01000F0
    // Test aarch32_LDRSH_r_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: cond=14, W=0, Rn=0, Rm=0, U=0, Rt=0, P=0
    let encoding: u32 = 0xE01000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_r_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_ldrsh_r_a1_a_special_cond_15_condition_nv_240_f01000f0() {
    // Encoding: 0xF01000F0
    // Test aarch32_LDRSH_r_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: P=0, W=0, U=0, cond=15, Rt=0, Rn=0, Rm=0
    let encoding: u32 = 0xF01000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSH_r_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrsh_r_a1_a_invalid_0_f0_001000f0() {
    // Encoding: 0x001000F0
    // Test aarch32_LDRSH_r_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }
    // ISET: A32
    // Fields: Rm=0, Rt=0, cond=0, P=0, W=0, Rn=0, U=0
    let encoding: u32 = 0x001000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRSH_r_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrsh_r_a1_a_invalid_1_f0_001000f0() {
    // Encoding: 0x001000F0
    // Test aarch32_LDRSH_r_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Rn=0, P=0, U=0, Rm=0, Rt=0, cond=0, W=0
    let encoding: u32 = 0x001000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRSH_r_A1_A
/// ASL: `Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"wback\" }), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }) } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrsh_r_a1_a_invalid_2_f0_001000f0() {
    // Encoding: 0x001000F0
    // Test aarch32_LDRSH_r_A1_A invalid encoding: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) } }
    // ISET: A32
    // Fields: W=0, U=0, cond=0, Rn=0, Rt=0, Rm=0, P=0
    let encoding: u32 = 0x001000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRSH_r_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrsh_r_a1_a_invalid_3_f0_001000f0() {
    // Encoding: 0x001000F0
    // Test aarch32_LDRSH_r_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Rt=0, Rm=0, cond=0, U=0, W=0, P=0, Rn=0
    let encoding: u32 = 0x001000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRSH_r_T1_A
/// ASL: `field Rm 22 +: 3`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrsh_r_t1_a_field_rm_0_min_0_5e000000() {
    // Thumb encoding (32): 0x5E000000
    // Test aarch32_LDRSH_r_T1_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: Rt=0, Rn=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x5E000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_r_T1_A
/// ASL: `field Rm 22 +: 3`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrsh_r_t1_a_field_rm_1_poweroftwo_0_5e400000() {
    // Thumb encoding (32): 0x5E400000
    // Test aarch32_LDRSH_r_T1_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, Rm=1, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x5E400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_r_T1_A
/// ASL: `field Rn 19 +: 3`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrsh_r_t1_a_field_rn_0_min_0_5e000000() {
    // Thumb encoding (32): 0x5E000000
    // Test aarch32_LDRSH_r_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rm=0, Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x5E000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_r_T1_A
/// ASL: `field Rn 19 +: 3`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrsh_r_t1_a_field_rn_1_poweroftwo_0_5e080000() {
    // Thumb encoding (32): 0x5E080000
    // Test aarch32_LDRSH_r_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=0, Rn=1, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x5E080000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_r_T1_A
/// ASL: `field Rt 16 +: 3`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrsh_r_t1_a_field_rt_0_min_0_5e000000() {
    // Thumb encoding (32): 0x5E000000
    // Test aarch32_LDRSH_r_T1_A field Rt = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rt=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x5E000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_r_T1_A
/// ASL: `field Rt 16 +: 3`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrsh_r_t1_a_field_rt_1_poweroftwo_0_5e010000() {
    // Thumb encoding (32): 0x5E010000
    // Test aarch32_LDRSH_r_T1_A field Rt = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=1, Rm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x5E010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_r_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch32_ldrsh_r_t1_a_combo_0_0_5e000000() {
    // Thumb encoding (32): 0x5E000000
    // Test aarch32_LDRSH_r_T1_A field combination: Rm=0, Rn=0, Rt=0
    // ISET: T32
    // Fields: Rn=0, Rt=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x5E000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_r_T2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrsh_r_t2_a_field_rn_0_min_0_f9300000() {
    // Thumb encoding (32): 0xF9300000
    // Test aarch32_LDRSH_r_T2_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm2=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9300000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_r_T2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrsh_r_t2_a_field_rn_1_poweroftwo_0_f9310000() {
    // Thumb encoding (32): 0xF9310000
    // Test aarch32_LDRSH_r_T2_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=1, Rm=0, imm2=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9310000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_r_T2_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrsh_r_t2_a_field_rt_0_min_0_f9300000() {
    // Thumb encoding (32): 0xF9300000
    // Test aarch32_LDRSH_r_T2_A field Rt = 0 (Min)
    // ISET: T32
    // Fields: Rt=0, imm2=0, Rn=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9300000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_r_T2_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrsh_r_t2_a_field_rt_1_poweroftwo_0_f9301000() {
    // Thumb encoding (32): 0xF9301000
    // Test aarch32_LDRSH_r_T2_A field Rt = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm2=0, Rm=0, Rn=0, Rt=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9301000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_r_T2_A
/// ASL: `field imm2 4 +: 2`
/// Requirement: FieldBoundary { field: "imm2", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_ldrsh_r_t2_a_field_imm2_0_zero_0_f9300000() {
    // Thumb encoding (32): 0xF9300000
    // Test aarch32_LDRSH_r_T2_A field imm2 = 0 (Zero)
    // ISET: T32
    // Fields: Rn=0, Rm=0, Rt=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9300000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_r_T2_A
/// ASL: `field imm2 4 +: 2`
/// Requirement: FieldBoundary { field: "imm2", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_ldrsh_r_t2_a_field_imm2_1_poweroftwo_0_f9300010() {
    // Thumb encoding (32): 0xF9300010
    // Test aarch32_LDRSH_r_T2_A field imm2 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm2=1, Rt=0, Rn=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9300010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_r_T2_A
/// ASL: `field imm2 4 +: 2`
/// Requirement: FieldBoundary { field: "imm2", value: 3, boundary: Max }
/// maximum immediate (3)
#[test]
fn test_aarch32_ldrsh_r_t2_a_field_imm2_3_max_0_f9300030() {
    // Thumb encoding (32): 0xF9300030
    // Test aarch32_LDRSH_r_T2_A field imm2 = 3 (Max)
    // ISET: T32
    // Fields: Rt=0, imm2=3, Rn=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9300030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_r_T2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrsh_r_t2_a_field_rm_0_min_0_f9300000() {
    // Thumb encoding (32): 0xF9300000
    // Test aarch32_LDRSH_r_T2_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: imm2=0, Rm=0, Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9300000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_r_T2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrsh_r_t2_a_field_rm_1_poweroftwo_0_f9300001() {
    // Thumb encoding (32): 0xF9300001
    // Test aarch32_LDRSH_r_T2_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=1, imm2=0, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9300001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_r_T2_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_ldrsh_r_t2_a_combo_0_0_f9300000() {
    // Thumb encoding (32): 0xF9300000
    // Test aarch32_LDRSH_r_T2_A field combination: Rn=0, Rt=0, imm2=0, Rm=0
    // ISET: T32
    // Fields: Rt=0, Rn=0, Rm=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9300000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSH_r_T2_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }), rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }), rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrsh_r_t2_a_invalid_0_0_f9300000() {
    // Thumb encoding (32): 0xF9300000
    // Test aarch32_LDRSH_r_T2_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }), rhs: LitInt(15) }
    // ISET: T32
    // Fields: Rt=0, Rm=0, imm2=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9300000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRSH_r_T2_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrsh_r_t2_a_invalid_1_0_f9300000() {
    // Thumb encoding (32): 0xF9300000
    // Test aarch32_LDRSH_r_T2_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm2=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9300000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRSH_r_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple multiply (32)
#[test]
fn test_aarch32_ldrsh_r_a1_a_mul_oracle_32_0_1b027c20() {
    // Test MUL 32-bit: simple multiply (oracle)
    // Encoding: 0x1B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x2);
    set_w(&mut cpu, 2, 0x3);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6, "W0 should be 0x00000006");
}

/// Provenance: aarch32_LDRSH_r_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple multiply (64)
#[test]
fn test_aarch32_ldrsh_r_a1_a_mul_oracle_64_0_9b027c20() {
    // Test MUL 64-bit: simple multiply (oracle)
    // Encoding: 0x9B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x2);
    set_w(&mut cpu, 2, 0x3);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6, "X0 should be 0x0000000000000006");
}

/// Provenance: aarch32_LDRSH_r_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// multiply by zero (32)
#[test]
fn test_aarch32_ldrsh_r_a1_a_mul_oracle_32_1_1b027c20() {
    // Test MUL 32-bit: multiply by zero (oracle)
    // Encoding: 0x1B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x64);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_LDRSH_r_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// multiply by zero (64)
#[test]
fn test_aarch32_ldrsh_r_a1_a_mul_oracle_64_1_9b027c20() {
    // Test MUL 64-bit: multiply by zero (oracle)
    // Encoding: 0x9B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x64);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_LDRSH_r_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// multiply by one (32)
#[test]
fn test_aarch32_ldrsh_r_a1_a_mul_oracle_32_2_1b027c20() {
    // Test MUL 32-bit: multiply by one (oracle)
    // Encoding: 0x1B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_LDRSH_r_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// multiply by one (64)
#[test]
fn test_aarch32_ldrsh_r_a1_a_mul_oracle_64_2_9b027c20() {
    // Test MUL 64-bit: multiply by one (oracle)
    // Encoding: 0x9B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x0000000000000001");
}

/// Provenance: aarch32_LDRSH_r_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// 16-bit max * 16-bit max (32)
#[test]
fn test_aarch32_ldrsh_r_a1_a_mul_oracle_32_3_1b027c20() {
    // Test MUL 32-bit: 16-bit max * 16-bit max (oracle)
    // Encoding: 0x1B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFF);
    set_w(&mut cpu, 2, 0xFFFF);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFE0001, "W0 should be 0xFFFE0001");
}

/// Provenance: aarch32_LDRSH_r_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// 16-bit max * 16-bit max (64)
#[test]
fn test_aarch32_ldrsh_r_a1_a_mul_oracle_64_3_9b027c20() {
    // Test MUL 64-bit: 16-bit max * 16-bit max (oracle)
    // Encoding: 0x9B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFF);
    set_w(&mut cpu, 1, 0xFFFF);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFE0001,
        "X0 should be 0x00000000FFFE0001"
    );
}

/// Provenance: aarch32_LDRSH_r_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift-like multiply (32)
#[test]
fn test_aarch32_ldrsh_r_a1_a_mul_oracle_32_4_1b027c20() {
    // Test MUL 32-bit: shift-like multiply (oracle)
    // Encoding: 0x1B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x2468ACF0, "W0 should be 0x2468ACF0");
}

/// Provenance: aarch32_LDRSH_r_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift-like multiply (64)
#[test]
fn test_aarch32_ldrsh_r_a1_a_mul_oracle_64_4_9b027c20() {
    // Test MUL 64-bit: shift-like multiply (oracle)
    // Encoding: 0x9B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x2468ACF0,
        "X0 should be 0x000000002468ACF0"
    );
}

/// Provenance: aarch32_LDRSH_r_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// larger values (32)
#[test]
fn test_aarch32_ldrsh_r_a1_a_mul_oracle_32_5_1b027c20() {
    // Test MUL 32-bit: larger values (oracle)
    // Encoding: 0x1B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0xC8);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4E20, "W0 should be 0x00004E20");
}

/// Provenance: aarch32_LDRSH_r_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// larger values (64)
#[test]
fn test_aarch32_ldrsh_r_a1_a_mul_oracle_64_5_9b027c20() {
    // Test MUL 64-bit: larger values (oracle)
    // Encoding: 0x9B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0xC8);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4E20, "X0 should be 0x0000000000004E20");
}

/// Provenance: aarch32_LDRSH_r_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// 32-bit overflow (32)
#[test]
fn test_aarch32_ldrsh_r_a1_a_mul_oracle_32_6_1b027c20() {
    // Test MUL 32-bit: 32-bit overflow (oracle)
    // Encoding: 0x1B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_LDRSH_r_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// 32-bit overflow (64)
#[test]
fn test_aarch32_ldrsh_r_a1_a_mul_oracle_64_6_9b027c20() {
    // Test MUL 64-bit: 32-bit overflow (oracle)
    // Encoding: 0x9B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0xFFFFFFFE00000001");
}

/// Provenance: aarch32_LDRSH_r_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// prime numbers (32)
#[test]
fn test_aarch32_ldrsh_r_a1_a_mul_oracle_32_7_1b027c20() {
    // Test MUL 32-bit: prime numbers (oracle)
    // Encoding: 0x1B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7);
    set_w(&mut cpu, 2, 0xB);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4D, "W0 should be 0x0000004D");
}

/// Provenance: aarch32_LDRSH_r_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// prime numbers (64)
#[test]
fn test_aarch32_ldrsh_r_a1_a_mul_oracle_64_7_9b027c20() {
    // Test MUL 64-bit: prime numbers (oracle)
    // Encoding: 0x9B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7);
    set_w(&mut cpu, 2, 0xB);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4D, "X0 should be 0x000000000000004D");
}

/// Provenance: aarch32_LDRSH_r_A1_A
/// ASL: `MUL R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple values
#[test]
fn test_aarch32_ldrsh_r_a1_a_a32_mul_0_0000f291() {
    // Test A32 MUL: simple values (oracle)
    // Encoding: 0x0000F291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x32);
    let encoding: u32 = 0x0000F291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1388, "R0 should be 0x00001388");
}

/// Provenance: aarch32_LDRSH_r_A1_A
/// ASL: `MUL R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero values
#[test]
fn test_aarch32_ldrsh_r_a1_a_a32_mul_1_0000f291() {
    // Test A32 MUL: zero values (oracle)
    // Encoding: 0x0000F291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x0000F291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_LDRSH_r_A1_A
/// ASL: `MUL R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max value
#[test]
fn test_aarch32_ldrsh_r_a1_a_a32_mul_2_0000f291() {
    // Test A32 MUL: max value (oracle)
    // Encoding: 0x0000F291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x0000F291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "R0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_LDRSH_r_A1_A
/// ASL: `MUL R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set
#[test]
fn test_aarch32_ldrsh_r_a1_a_a32_mul_3_0000f291() {
    // Test A32 MUL: MSB set (oracle)
    // Encoding: 0x0000F291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    set_w(&mut cpu, 2, 0x80000000);
    let encoding: u32 = 0x0000F291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_LDRSH_r_A1_A
/// ASL: `MUL R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// mixed pattern
#[test]
fn test_aarch32_ldrsh_r_a1_a_a32_mul_4_0000f291() {
    // Test A32 MUL: mixed pattern (oracle)
    // Encoding: 0x0000F291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x9ABCDEF0);
    let encoding: u32 = 0x0000F291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x242D2080, "R0 should be 0x242D2080");
}

/// Provenance: aarch32_LDRSH_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 0 (32)
#[test]
fn test_aarch32_ldrsh_r_t1_a_lslv_oracle_32_0_5e020020() {
    // Test LSLV 32-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x12345678, "W0 should be 0x12345678");
}

/// Provenance: aarch32_LDRSH_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 0 (64)
#[test]
fn test_aarch32_ldrsh_r_t1_a_lslv_oracle_64_0_de020020() {
    // Test LSLV 64-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x12345678,
        "X0 should be 0x0000000012345678"
    );
}

/// Provenance: aarch32_LDRSH_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4 (32)
#[test]
fn test_aarch32_ldrsh_r_t1_a_lslv_oracle_32_1_5e020020() {
    // Test LSLV 32-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x4);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x23456780, "W0 should be 0x23456780");
}

/// Provenance: aarch32_LDRSH_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 4 (64)
#[test]
fn test_aarch32_ldrsh_r_t1_a_lslv_oracle_64_1_de020020() {
    // Test LSLV 64-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x4);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x23456780,
        "X0 should be 0x0000000123456780"
    );
}

/// Provenance: aarch32_LDRSH_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 8 (32)
#[test]
fn test_aarch32_ldrsh_r_t1_a_lslv_oracle_32_2_5e020020() {
    // Test LSLV 32-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x8);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x34567800, "W0 should be 0x34567800");
}

/// Provenance: aarch32_LDRSH_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 8 (64)
#[test]
fn test_aarch32_ldrsh_r_t1_a_lslv_oracle_64_2_de020020() {
    // Test LSLV 64-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x8);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x34567800,
        "X0 should be 0x0000001234567800"
    );
}

/// Provenance: aarch32_LDRSH_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1 (32)
#[test]
fn test_aarch32_ldrsh_r_t1_a_lslv_oracle_32_3_5e020020() {
    // Test LSLV 32-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_LDRSH_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// MSB set, shift 1 (64)
#[test]
fn test_aarch32_ldrsh_r_t1_a_lslv_oracle_64_3_de020020() {
    // Test LSLV 64-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_LDRSH_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// LSB set, max shift (32)
#[test]
fn test_aarch32_ldrsh_r_t1_a_lslv_oracle_32_4_5e020020() {
    // Test LSLV 32-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x3F);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "W0 should be 0x80000000");
}

/// Provenance: aarch32_LDRSH_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// LSB set, max shift (64)
#[test]
fn test_aarch32_ldrsh_r_t1_a_lslv_oracle_64_4_de020020() {
    // Test LSLV 64-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x3F);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x8000000000000000");
}

/// Provenance: aarch32_LDRSH_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// all ones, shift 32 (32)
#[test]
fn test_aarch32_ldrsh_r_t1_a_lslv_oracle_32_5_5e020020() {
    // Test LSLV 32-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x20);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "W0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_LDRSH_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// all ones, shift 32 (64)
#[test]
fn test_aarch32_ldrsh_r_t1_a_lslv_oracle_64_5_de020020() {
    // Test LSLV 64-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x20);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0xFFFFFFFF00000000");
}

/// Provenance: aarch32_LDRSH_r_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// no shift
#[test]
fn test_aarch32_ldrsh_r_t1_a_t16_oracle_0_5e880000() {
    // Test T16 LSLS: no shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_LDRSH_r_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4
#[test]
fn test_aarch32_ldrsh_r_t1_a_t16_oracle_1_5e880000() {
    // Test T16 LSLS: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    set_w(&mut cpu, 2, 0x4);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF0, "R0 should be 0x00000FF0");
}

/// Provenance: aarch32_LDRSH_r_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1
#[test]
fn test_aarch32_ldrsh_r_t1_a_t16_oracle_2_5e880000() {
    // Test T16 LSLS: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_LDRSH_r_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift to MSB
#[test]
fn test_aarch32_ldrsh_r_t1_a_t16_oracle_3_5e880000() {
    // Test T16 LSLS: shift to MSB (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x1F);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "R0 should be 0x80000000");
}

// ============================================================================
// aarch32_LDM_e_AS Tests
// ============================================================================

/// Provenance: aarch32_LDM_e_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_ldm_e_a1_as_field_cond_0_min_8000_08508000() {
    // Encoding: 0x08508000
    // Test aarch32_LDM_e_A1_AS field cond = 0 (Min)
    // ISET: A32
    // Fields: U=0, P=0, Rn=0, W=0, register_list=0, cond=0
    let encoding: u32 = 0x08508000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_e_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_ldm_e_a1_as_field_cond_1_poweroftwo_8000_18508000() {
    // Encoding: 0x18508000
    // Test aarch32_LDM_e_A1_AS field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=1, Rn=0, W=0, P=0, register_list=0, U=0
    let encoding: u32 = 0x18508000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_e_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_ldm_e_a1_as_field_cond_2_poweroftwo_8000_28508000() {
    // Encoding: 0x28508000
    // Test aarch32_LDM_e_A1_AS field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=2, U=0, Rn=0, P=0, W=0, register_list=0
    let encoding: u32 = 0x28508000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_e_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_ldm_e_a1_as_field_cond_3_poweroftwo_8000_38508000() {
    // Encoding: 0x38508000
    // Test aarch32_LDM_e_A1_AS field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, cond=3, U=0, W=0, register_list=0, Rn=0
    let encoding: u32 = 0x38508000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_e_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_ldm_e_a1_as_field_cond_4_poweroftwo_8000_48508000() {
    // Encoding: 0x48508000
    // Test aarch32_LDM_e_A1_AS field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, P=0, Rn=0, cond=4, W=0, register_list=0
    let encoding: u32 = 0x48508000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_e_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_ldm_e_a1_as_field_cond_5_poweroftwo_8000_58508000() {
    // Encoding: 0x58508000
    // Test aarch32_LDM_e_A1_AS field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=5, P=0, U=0, W=0, Rn=0, register_list=0
    let encoding: u32 = 0x58508000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_e_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_ldm_e_a1_as_field_cond_6_poweroftwo_8000_68508000() {
    // Encoding: 0x68508000
    // Test aarch32_LDM_e_A1_AS field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, cond=6, P=0, W=0, Rn=0, register_list=0
    let encoding: u32 = 0x68508000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_e_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_ldm_e_a1_as_field_cond_7_poweroftwo_8000_78508000() {
    // Encoding: 0x78508000
    // Test aarch32_LDM_e_A1_AS field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=7, W=0, U=0, register_list=0, Rn=0, P=0
    let encoding: u32 = 0x78508000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_e_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_ldm_e_a1_as_field_cond_8_poweroftwo_8000_88508000() {
    // Encoding: 0x88508000
    // Test aarch32_LDM_e_A1_AS field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, U=0, register_list=0, cond=8, W=0, Rn=0
    let encoding: u32 = 0x88508000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_e_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_ldm_e_a1_as_field_cond_9_poweroftwo_8000_98508000() {
    // Encoding: 0x98508000
    // Test aarch32_LDM_e_A1_AS field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, U=0, Rn=0, register_list=0, W=0, cond=9
    let encoding: u32 = 0x98508000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_e_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_ldm_e_a1_as_field_cond_10_poweroftwo_8000_a8508000() {
    // Encoding: 0xA8508000
    // Test aarch32_LDM_e_A1_AS field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, cond=10, W=0, Rn=0, register_list=0, U=0
    let encoding: u32 = 0xA8508000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_e_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_ldm_e_a1_as_field_cond_11_poweroftwo_8000_b8508000() {
    // Encoding: 0xB8508000
    // Test aarch32_LDM_e_A1_AS field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: register_list=0, P=0, cond=11, W=0, U=0, Rn=0
    let encoding: u32 = 0xB8508000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_e_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_ldm_e_a1_as_field_cond_12_poweroftwo_8000_c8508000() {
    // Encoding: 0xC8508000
    // Test aarch32_LDM_e_A1_AS field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, register_list=0, P=0, W=0, cond=12, U=0
    let encoding: u32 = 0xC8508000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_e_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_ldm_e_a1_as_field_cond_13_poweroftwo_8000_d8508000() {
    // Encoding: 0xD8508000
    // Test aarch32_LDM_e_A1_AS field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, register_list=0, W=0, cond=13, U=0, Rn=0
    let encoding: u32 = 0xD8508000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_e_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_ldm_e_a1_as_field_cond_14_poweroftwo_8000_e8508000() {
    // Encoding: 0xE8508000
    // Test aarch32_LDM_e_A1_AS field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, U=0, Rn=0, cond=14, W=0, register_list=0
    let encoding: u32 = 0xE8508000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_e_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_ldm_e_a1_as_field_cond_15_max_8000_f8508000() {
    // Encoding: 0xF8508000
    // Test aarch32_LDM_e_A1_AS field cond = 15 (Max)
    // ISET: A32
    // Fields: cond=15, P=0, W=0, U=0, Rn=0, register_list=0
    let encoding: u32 = 0xF8508000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_e_A1_AS
/// ASL: `field P 24 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldm_e_a1_as_field_p_0_min_8000_08508000() {
    // Encoding: 0x08508000
    // Test aarch32_LDM_e_A1_AS field P = 0 (Min)
    // ISET: A32
    // Fields: W=0, P=0, Rn=0, register_list=0, cond=0, U=0
    let encoding: u32 = 0x08508000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_e_A1_AS
/// ASL: `field P 24 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldm_e_a1_as_field_p_1_max_8000_09508000() {
    // Encoding: 0x09508000
    // Test aarch32_LDM_e_A1_AS field P = 1 (Max)
    // ISET: A32
    // Fields: cond=0, U=0, Rn=0, W=0, P=1, register_list=0
    let encoding: u32 = 0x09508000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_e_A1_AS
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldm_e_a1_as_field_u_0_min_8000_08508000() {
    // Encoding: 0x08508000
    // Test aarch32_LDM_e_A1_AS field U = 0 (Min)
    // ISET: A32
    // Fields: P=0, W=0, register_list=0, Rn=0, U=0, cond=0
    let encoding: u32 = 0x08508000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_e_A1_AS
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldm_e_a1_as_field_u_1_max_8000_08d08000() {
    // Encoding: 0x08D08000
    // Test aarch32_LDM_e_A1_AS field U = 1 (Max)
    // ISET: A32
    // Fields: W=0, U=1, Rn=0, cond=0, P=0, register_list=0
    let encoding: u32 = 0x08D08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_e_A1_AS
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldm_e_a1_as_field_w_0_min_8000_08508000() {
    // Encoding: 0x08508000
    // Test aarch32_LDM_e_A1_AS field W = 0 (Min)
    // ISET: A32
    // Fields: W=0, register_list=0, U=0, cond=0, Rn=0, P=0
    let encoding: u32 = 0x08508000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_e_A1_AS
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldm_e_a1_as_field_w_1_max_8000_08708000() {
    // Encoding: 0x08708000
    // Test aarch32_LDM_e_A1_AS field W = 1 (Max)
    // ISET: A32
    // Fields: register_list=0, Rn=0, cond=0, P=0, U=0, W=1
    let encoding: u32 = 0x08708000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_e_A1_AS
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldm_e_a1_as_field_rn_0_min_8000_08508000() {
    // Encoding: 0x08508000
    // Test aarch32_LDM_e_A1_AS field Rn = 0 (Min)
    // ISET: A32
    // Fields: register_list=0, cond=0, P=0, U=0, W=0, Rn=0
    let encoding: u32 = 0x08508000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_e_A1_AS
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldm_e_a1_as_field_rn_1_poweroftwo_8000_08518000() {
    // Encoding: 0x08518000
    // Test aarch32_LDM_e_A1_AS field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: register_list=0, P=0, W=0, cond=0, Rn=1, U=0
    let encoding: u32 = 0x08518000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_e_A1_AS
/// ASL: `field register_list 0 +: 15`
/// Requirement: FieldBoundary { field: "register_list", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldm_e_a1_as_field_register_list_0_min_8000_08508000() {
    // Encoding: 0x08508000
    // Test aarch32_LDM_e_A1_AS field register_list = 0 (Min)
    // ISET: A32
    // Fields: W=0, register_list=0, Rn=0, P=0, cond=0, U=0
    let encoding: u32 = 0x08508000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_e_A1_AS
/// ASL: `field register_list 0 +: 15`
/// Requirement: FieldBoundary { field: "register_list", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_ldm_e_a1_as_field_register_list_1_poweroftwo_8000_08508001() {
    // Encoding: 0x08508001
    // Test aarch32_LDM_e_A1_AS field register_list = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=0, U=0, register_list=1, W=0, P=0
    let encoding: u32 = 0x08508001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_e_A1_AS
/// ASL: `field register_list 0 +: 15`
/// Requirement: FieldBoundary { field: "register_list", value: 16383, boundary: PowerOfTwoMinusOne }
/// midpoint (16383)
#[test]
fn test_aarch32_ldm_e_a1_as_field_register_list_16383_poweroftwominusone_8000_0850bfff() {
    // Encoding: 0x0850BFFF
    // Test aarch32_LDM_e_A1_AS field register_list = 16383 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, W=0, P=0, U=0, Rn=0, register_list=16383
    let encoding: u32 = 0x0850BFFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_e_A1_AS
/// ASL: `field register_list 0 +: 15`
/// Requirement: FieldBoundary { field: "register_list", value: 32767, boundary: Max }
/// maximum value (32767)
#[test]
fn test_aarch32_ldm_e_a1_as_field_register_list_32767_max_8000_0850ffff() {
    // Encoding: 0x0850FFFF
    // Test aarch32_LDM_e_A1_AS field register_list = 32767 (Max)
    // ISET: A32
    // Fields: register_list=32767, U=0, W=0, cond=0, P=0, Rn=0
    let encoding: u32 = 0x0850FFFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_e_A1_AS
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_ldm_e_a1_as_combo_0_8000_08508000() {
    // Encoding: 0x08508000
    // Test aarch32_LDM_e_A1_AS field combination: cond=0, P=0, U=0, W=0, Rn=0, register_list=0
    // ISET: A32
    // Fields: P=0, Rn=0, register_list=0, cond=0, U=0, W=0
    let encoding: u32 = 0x08508000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_e_A1_AS
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_ldm_e_a1_as_special_cond_0_condition_eq_32768_08508000() {
    // Encoding: 0x08508000
    // Test aarch32_LDM_e_A1_AS special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: register_list=0, cond=0, W=0, Rn=0, U=0, P=0
    let encoding: u32 = 0x08508000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_e_A1_AS
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_ldm_e_a1_as_special_cond_1_condition_ne_32768_18508000() {
    // Encoding: 0x18508000
    // Test aarch32_LDM_e_A1_AS special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: U=0, cond=1, P=0, W=0, register_list=0, Rn=0
    let encoding: u32 = 0x18508000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_e_A1_AS
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_ldm_e_a1_as_special_cond_2_condition_cs_hs_32768_28508000() {
    // Encoding: 0x28508000
    // Test aarch32_LDM_e_A1_AS special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: cond=2, Rn=0, register_list=0, U=0, W=0, P=0
    let encoding: u32 = 0x28508000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_e_A1_AS
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_ldm_e_a1_as_special_cond_3_condition_cc_lo_32768_38508000() {
    // Encoding: 0x38508000
    // Test aarch32_LDM_e_A1_AS special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: P=0, register_list=0, Rn=0, cond=3, U=0, W=0
    let encoding: u32 = 0x38508000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_e_A1_AS
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_ldm_e_a1_as_special_cond_4_condition_mi_32768_48508000() {
    // Encoding: 0x48508000
    // Test aarch32_LDM_e_A1_AS special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: W=0, P=0, cond=4, U=0, register_list=0, Rn=0
    let encoding: u32 = 0x48508000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_e_A1_AS
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_ldm_e_a1_as_special_cond_5_condition_pl_32768_58508000() {
    // Encoding: 0x58508000
    // Test aarch32_LDM_e_A1_AS special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: cond=5, U=0, W=0, register_list=0, Rn=0, P=0
    let encoding: u32 = 0x58508000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_e_A1_AS
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_ldm_e_a1_as_special_cond_6_condition_vs_32768_68508000() {
    // Encoding: 0x68508000
    // Test aarch32_LDM_e_A1_AS special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: P=0, register_list=0, Rn=0, cond=6, W=0, U=0
    let encoding: u32 = 0x68508000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_e_A1_AS
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_ldm_e_a1_as_special_cond_7_condition_vc_32768_78508000() {
    // Encoding: 0x78508000
    // Test aarch32_LDM_e_A1_AS special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: Rn=0, register_list=0, cond=7, P=0, U=0, W=0
    let encoding: u32 = 0x78508000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_e_A1_AS
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_ldm_e_a1_as_special_cond_8_condition_hi_32768_88508000() {
    // Encoding: 0x88508000
    // Test aarch32_LDM_e_A1_AS special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: U=0, cond=8, P=0, W=0, register_list=0, Rn=0
    let encoding: u32 = 0x88508000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_e_A1_AS
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_ldm_e_a1_as_special_cond_9_condition_ls_32768_98508000() {
    // Encoding: 0x98508000
    // Test aarch32_LDM_e_A1_AS special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: W=0, Rn=0, register_list=0, U=0, cond=9, P=0
    let encoding: u32 = 0x98508000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_e_A1_AS
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_ldm_e_a1_as_special_cond_10_condition_ge_32768_a8508000() {
    // Encoding: 0xA8508000
    // Test aarch32_LDM_e_A1_AS special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: cond=10, P=0, U=0, Rn=0, register_list=0, W=0
    let encoding: u32 = 0xA8508000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_e_A1_AS
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_ldm_e_a1_as_special_cond_11_condition_lt_32768_b8508000() {
    // Encoding: 0xB8508000
    // Test aarch32_LDM_e_A1_AS special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: W=0, Rn=0, P=0, register_list=0, U=0, cond=11
    let encoding: u32 = 0xB8508000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_e_A1_AS
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_ldm_e_a1_as_special_cond_12_condition_gt_32768_c8508000() {
    // Encoding: 0xC8508000
    // Test aarch32_LDM_e_A1_AS special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: U=0, Rn=0, P=0, register_list=0, W=0, cond=12
    let encoding: u32 = 0xC8508000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_e_A1_AS
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_ldm_e_a1_as_special_cond_13_condition_le_32768_d8508000() {
    // Encoding: 0xD8508000
    // Test aarch32_LDM_e_A1_AS special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: U=0, cond=13, P=0, W=0, Rn=0, register_list=0
    let encoding: u32 = 0xD8508000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_e_A1_AS
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_ldm_e_a1_as_special_cond_14_condition_al_32768_e8508000() {
    // Encoding: 0xE8508000
    // Test aarch32_LDM_e_A1_AS special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: register_list=0, P=0, cond=14, Rn=0, W=0, U=0
    let encoding: u32 = 0xE8508000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_e_A1_AS
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_ldm_e_a1_as_special_cond_15_condition_nv_32768_f8508000() {
    // Encoding: 0xF8508000
    // Test aarch32_LDM_e_A1_AS special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: register_list=0, P=0, cond=15, Rn=0, W=0, U=0
    let encoding: u32 = 0xF8508000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_e_A1_AS
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldm_e_a1_as_invalid_0_8000_08508000() {
    // Encoding: 0x08508000
    // Test aarch32_LDM_e_A1_AS invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: LitInt(15) }
    // ISET: A32
    // Fields: W=0, register_list=0, U=0, cond=0, Rn=0, P=0
    let encoding: u32 = 0x08508000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDM_e_A1_AS
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldm_e_a1_as_invalid_1_8000_08508000() {
    // Encoding: 0x08508000
    // Test aarch32_LDM_e_A1_AS invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Rn=0, register_list=0, cond=0, P=0, U=0, W=0
    let encoding: u32 = 0x08508000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDM_e_A1_AS
/// ASL: `Binary { op: Eq, lhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "registers" }), indices: [Single(Var(QualifiedIdentifier { qualifier: Any, name: "n" }))] } }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"wback\" }), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"registers\" }), indices: [Single(Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }))] } }, rhs: LitBits([true]) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldm_e_a1_as_invalid_2_8000_08508000() {
    // Encoding: 0x08508000
    // Test aarch32_LDM_e_A1_AS invalid encoding: Binary { op: Eq, lhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "registers" }), indices: [Single(Var(QualifiedIdentifier { qualifier: Any, name: "n" }))] } }, rhs: LitBits([true]) }
    // ISET: A32
    // Fields: U=0, register_list=0, cond=0, Rn=0, P=0, W=0
    let encoding: u32 = 0x08508000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDM_e_A1_AS
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldm_e_a1_as_invalid_3_8000_08508000() {
    // Encoding: 0x08508000
    // Test aarch32_LDM_e_A1_AS invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: register_list=0, Rn=0, U=0, cond=0, P=0, W=0
    let encoding: u32 = 0x08508000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDM_e_A1_AS
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Undefined
#[test]
fn test_aarch32_ldm_e_a1_as_exception_0_08508000() {
    // Test aarch32_LDM_e_A1_AS exception: Undefined
    // Encoding: 0x08508000
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x08508000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_LDM_e_A1_AS
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldm_e_a1_as_exception_1_08508000() {
    // Test aarch32_LDM_e_A1_AS exception: Unpredictable
    // Encoding: 0x08508000
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x08508000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// aarch32_LDMDA_A Tests
// ============================================================================

/// Provenance: aarch32_LDMDA_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_ldmda_a1_a_field_cond_0_min_0_08100000() {
    // Encoding: 0x08100000
    // Test aarch32_LDMDA_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: W=0, register_list=0, Rn=0, cond=0
    let encoding: u32 = 0x08100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMDA_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_ldmda_a1_a_field_cond_1_poweroftwo_0_18100000() {
    // Encoding: 0x18100000
    // Test aarch32_LDMDA_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, register_list=0, Rn=0, cond=1
    let encoding: u32 = 0x18100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMDA_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_ldmda_a1_a_field_cond_2_poweroftwo_0_28100000() {
    // Encoding: 0x28100000
    // Test aarch32_LDMDA_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: register_list=0, cond=2, Rn=0, W=0
    let encoding: u32 = 0x28100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMDA_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_ldmda_a1_a_field_cond_3_poweroftwo_0_38100000() {
    // Encoding: 0x38100000
    // Test aarch32_LDMDA_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=3, Rn=0, W=0, register_list=0
    let encoding: u32 = 0x38100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMDA_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_ldmda_a1_a_field_cond_4_poweroftwo_0_48100000() {
    // Encoding: 0x48100000
    // Test aarch32_LDMDA_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, Rn=0, cond=4, register_list=0
    let encoding: u32 = 0x48100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMDA_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_ldmda_a1_a_field_cond_5_poweroftwo_0_58100000() {
    // Encoding: 0x58100000
    // Test aarch32_LDMDA_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=5, W=0, register_list=0
    let encoding: u32 = 0x58100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMDA_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_ldmda_a1_a_field_cond_6_poweroftwo_0_68100000() {
    // Encoding: 0x68100000
    // Test aarch32_LDMDA_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, W=0, register_list=0, cond=6
    let encoding: u32 = 0x68100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMDA_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_ldmda_a1_a_field_cond_7_poweroftwo_0_78100000() {
    // Encoding: 0x78100000
    // Test aarch32_LDMDA_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, register_list=0, cond=7, Rn=0
    let encoding: u32 = 0x78100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMDA_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_ldmda_a1_a_field_cond_8_poweroftwo_0_88100000() {
    // Encoding: 0x88100000
    // Test aarch32_LDMDA_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=8, register_list=0, W=0, Rn=0
    let encoding: u32 = 0x88100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMDA_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_ldmda_a1_a_field_cond_9_poweroftwo_0_98100000() {
    // Encoding: 0x98100000
    // Test aarch32_LDMDA_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, W=0, cond=9, register_list=0
    let encoding: u32 = 0x98100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMDA_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_ldmda_a1_a_field_cond_10_poweroftwo_0_a8100000() {
    // Encoding: 0xA8100000
    // Test aarch32_LDMDA_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: register_list=0, Rn=0, cond=10, W=0
    let encoding: u32 = 0xA8100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMDA_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_ldmda_a1_a_field_cond_11_poweroftwo_0_b8100000() {
    // Encoding: 0xB8100000
    // Test aarch32_LDMDA_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, cond=11, Rn=0, register_list=0
    let encoding: u32 = 0xB8100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMDA_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_ldmda_a1_a_field_cond_12_poweroftwo_0_c8100000() {
    // Encoding: 0xC8100000
    // Test aarch32_LDMDA_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=12, W=0, Rn=0, register_list=0
    let encoding: u32 = 0xC8100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMDA_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_ldmda_a1_a_field_cond_13_poweroftwo_0_d8100000() {
    // Encoding: 0xD8100000
    // Test aarch32_LDMDA_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=13, register_list=0, W=0, Rn=0
    let encoding: u32 = 0xD8100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMDA_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_ldmda_a1_a_field_cond_14_poweroftwo_0_e8100000() {
    // Encoding: 0xE8100000
    // Test aarch32_LDMDA_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=14, register_list=0, W=0, Rn=0
    let encoding: u32 = 0xE8100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMDA_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_ldmda_a1_a_field_cond_15_max_0_f8100000() {
    // Encoding: 0xF8100000
    // Test aarch32_LDMDA_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: register_list=0, Rn=0, cond=15, W=0
    let encoding: u32 = 0xF8100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMDA_A1_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldmda_a1_a_field_w_0_min_0_08100000() {
    // Encoding: 0x08100000
    // Test aarch32_LDMDA_A1_A field W = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, register_list=0, cond=0, W=0
    let encoding: u32 = 0x08100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMDA_A1_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldmda_a1_a_field_w_1_max_0_08300000() {
    // Encoding: 0x08300000
    // Test aarch32_LDMDA_A1_A field W = 1 (Max)
    // ISET: A32
    // Fields: Rn=0, W=1, register_list=0, cond=0
    let encoding: u32 = 0x08300000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMDA_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldmda_a1_a_field_rn_0_min_0_08100000() {
    // Encoding: 0x08100000
    // Test aarch32_LDMDA_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rn=0, register_list=0, W=0
    let encoding: u32 = 0x08100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMDA_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldmda_a1_a_field_rn_1_poweroftwo_0_08110000() {
    // Encoding: 0x08110000
    // Test aarch32_LDMDA_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, cond=0, register_list=0, Rn=1
    let encoding: u32 = 0x08110000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMDA_A1_A
/// ASL: `field register_list 0 +: 16`
/// Requirement: FieldBoundary { field: "register_list", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldmda_a1_a_field_register_list_0_min_0_08100000() {
    // Encoding: 0x08100000
    // Test aarch32_LDMDA_A1_A field register_list = 0 (Min)
    // ISET: A32
    // Fields: register_list=0, cond=0, W=0, Rn=0
    let encoding: u32 = 0x08100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMDA_A1_A
/// ASL: `field register_list 0 +: 16`
/// Requirement: FieldBoundary { field: "register_list", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_ldmda_a1_a_field_register_list_1_poweroftwo_0_08100001() {
    // Encoding: 0x08100001
    // Test aarch32_LDMDA_A1_A field register_list = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=0, W=0, register_list=1
    let encoding: u32 = 0x08100001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMDA_A1_A
/// ASL: `field register_list 0 +: 16`
/// Requirement: FieldBoundary { field: "register_list", value: 32767, boundary: PowerOfTwoMinusOne }
/// midpoint (32767)
#[test]
fn test_aarch32_ldmda_a1_a_field_register_list_32767_poweroftwominusone_0_08107fff() {
    // Encoding: 0x08107FFF
    // Test aarch32_LDMDA_A1_A field register_list = 32767 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, register_list=32767, Rn=0, W=0
    let encoding: u32 = 0x08107FFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMDA_A1_A
/// ASL: `field register_list 0 +: 16`
/// Requirement: FieldBoundary { field: "register_list", value: 65535, boundary: Max }
/// maximum value (65535)
#[test]
fn test_aarch32_ldmda_a1_a_field_register_list_65535_max_0_0810ffff() {
    // Encoding: 0x0810FFFF
    // Test aarch32_LDMDA_A1_A field register_list = 65535 (Max)
    // ISET: A32
    // Fields: register_list=65535, Rn=0, cond=0, W=0
    let encoding: u32 = 0x0810FFFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMDA_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_ldmda_a1_a_combo_0_0_08100000() {
    // Encoding: 0x08100000
    // Test aarch32_LDMDA_A1_A field combination: cond=0, W=0, Rn=0, register_list=0
    // ISET: A32
    // Fields: cond=0, Rn=0, register_list=0, W=0
    let encoding: u32 = 0x08100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMDA_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_ldmda_a1_a_special_cond_0_condition_eq_0_08100000() {
    // Encoding: 0x08100000
    // Test aarch32_LDMDA_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: W=0, Rn=0, register_list=0, cond=0
    let encoding: u32 = 0x08100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMDA_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_ldmda_a1_a_special_cond_1_condition_ne_0_18100000() {
    // Encoding: 0x18100000
    // Test aarch32_LDMDA_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: register_list=0, cond=1, Rn=0, W=0
    let encoding: u32 = 0x18100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMDA_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_ldmda_a1_a_special_cond_2_condition_cs_hs_0_28100000() {
    // Encoding: 0x28100000
    // Test aarch32_LDMDA_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: W=0, Rn=0, cond=2, register_list=0
    let encoding: u32 = 0x28100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMDA_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_ldmda_a1_a_special_cond_3_condition_cc_lo_0_38100000() {
    // Encoding: 0x38100000
    // Test aarch32_LDMDA_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: W=0, register_list=0, Rn=0, cond=3
    let encoding: u32 = 0x38100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMDA_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_ldmda_a1_a_special_cond_4_condition_mi_0_48100000() {
    // Encoding: 0x48100000
    // Test aarch32_LDMDA_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: cond=4, register_list=0, Rn=0, W=0
    let encoding: u32 = 0x48100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMDA_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_ldmda_a1_a_special_cond_5_condition_pl_0_58100000() {
    // Encoding: 0x58100000
    // Test aarch32_LDMDA_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: Rn=0, cond=5, register_list=0, W=0
    let encoding: u32 = 0x58100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMDA_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_ldmda_a1_a_special_cond_6_condition_vs_0_68100000() {
    // Encoding: 0x68100000
    // Test aarch32_LDMDA_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: register_list=0, cond=6, Rn=0, W=0
    let encoding: u32 = 0x68100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMDA_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_ldmda_a1_a_special_cond_7_condition_vc_0_78100000() {
    // Encoding: 0x78100000
    // Test aarch32_LDMDA_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: Rn=0, register_list=0, W=0, cond=7
    let encoding: u32 = 0x78100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMDA_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_ldmda_a1_a_special_cond_8_condition_hi_0_88100000() {
    // Encoding: 0x88100000
    // Test aarch32_LDMDA_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: W=0, cond=8, register_list=0, Rn=0
    let encoding: u32 = 0x88100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMDA_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_ldmda_a1_a_special_cond_9_condition_ls_0_98100000() {
    // Encoding: 0x98100000
    // Test aarch32_LDMDA_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: W=0, cond=9, register_list=0, Rn=0
    let encoding: u32 = 0x98100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMDA_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_ldmda_a1_a_special_cond_10_condition_ge_0_a8100000() {
    // Encoding: 0xA8100000
    // Test aarch32_LDMDA_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: cond=10, Rn=0, W=0, register_list=0
    let encoding: u32 = 0xA8100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMDA_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_ldmda_a1_a_special_cond_11_condition_lt_0_b8100000() {
    // Encoding: 0xB8100000
    // Test aarch32_LDMDA_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: register_list=0, cond=11, W=0, Rn=0
    let encoding: u32 = 0xB8100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMDA_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_ldmda_a1_a_special_cond_12_condition_gt_0_c8100000() {
    // Encoding: 0xC8100000
    // Test aarch32_LDMDA_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: W=0, cond=12, register_list=0, Rn=0
    let encoding: u32 = 0xC8100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMDA_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_ldmda_a1_a_special_cond_13_condition_le_0_d8100000() {
    // Encoding: 0xD8100000
    // Test aarch32_LDMDA_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: register_list=0, Rn=0, cond=13, W=0
    let encoding: u32 = 0xD8100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMDA_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_ldmda_a1_a_special_cond_14_condition_al_0_e8100000() {
    // Encoding: 0xE8100000
    // Test aarch32_LDMDA_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: cond=14, W=0, register_list=0, Rn=0
    let encoding: u32 = 0xE8100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMDA_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_ldmda_a1_a_special_cond_15_condition_nv_0_f8100000() {
    // Encoding: 0xF8100000
    // Test aarch32_LDMDA_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: W=0, register_list=0, Rn=0, cond=15
    let encoding: u32 = 0xF8100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMDA_A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Binary { op: Lt, lhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "BitCount" }, args: [Var(QualifiedIdentifier { qualifier: Any, name: "registers" })] }, rhs: LitInt(1) } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Binary { op: Lt, lhs: Call { name: QualifiedIdentifier { qualifier: Any, name: \"BitCount\" }, args: [Var(QualifiedIdentifier { qualifier: Any, name: \"registers\" })] }, rhs: LitInt(1) } } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldmda_a1_a_invalid_0_0_08100000() {
    // Encoding: 0x08100000
    // Test aarch32_LDMDA_A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Binary { op: Lt, lhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "BitCount" }, args: [Var(QualifiedIdentifier { qualifier: Any, name: "registers" })] }, rhs: LitInt(1) } } }
    // ISET: A32
    // Fields: register_list=0, W=0, Rn=0, cond=0
    let encoding: u32 = 0x08100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDMDA_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldmda_a1_a_invalid_1_0_08100000() {
    // Encoding: 0x08100000
    // Test aarch32_LDMDA_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: register_list=0, Rn=0, cond=0, W=0
    let encoding: u32 = 0x08100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDMDA_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "registers" }), indices: [Single(Var(QualifiedIdentifier { qualifier: Any, name: "n" }))] } }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"wback\" }), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"registers\" }), indices: [Single(Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }))] } }, rhs: LitBits([true]) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldmda_a1_a_invalid_2_0_08100000() {
    // Encoding: 0x08100000
    // Test aarch32_LDMDA_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "registers" }), indices: [Single(Var(QualifiedIdentifier { qualifier: Any, name: "n" }))] } }, rhs: LitBits([true]) }
    // ISET: A32
    // Fields: W=0, Rn=0, cond=0, register_list=0
    let encoding: u32 = 0x08100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDMDA_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldmda_a1_a_invalid_3_0_08100000() {
    // Encoding: 0x08100000
    // Test aarch32_LDMDA_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: cond=0, register_list=0, Rn=0, W=0
    let encoding: u32 = 0x08100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

// ============================================================================
// aarch32_LDRSB_l_A Tests
// ============================================================================

/// Provenance: aarch32_LDRSB_l_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_ldrsb_l_a1_a_field_cond_0_min_d0_005f00d0() {
    // Encoding: 0x005F00D0
    // Test aarch32_LDRSB_l_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: imm4L=0, P=0, W=0, imm4H=0, cond=0, U=0, Rt=0
    let encoding: u32 = 0x005F00D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_l_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_ldrsb_l_a1_a_field_cond_1_poweroftwo_d0_105f00d0() {
    // Encoding: 0x105F00D0
    // Test aarch32_LDRSB_l_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, Rt=0, imm4L=0, U=0, imm4H=0, cond=1, W=0
    let encoding: u32 = 0x105F00D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_l_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_ldrsb_l_a1_a_field_cond_2_poweroftwo_d0_205f00d0() {
    // Encoding: 0x205F00D0
    // Test aarch32_LDRSB_l_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4L=0, P=0, Rt=0, imm4H=0, cond=2, U=0, W=0
    let encoding: u32 = 0x205F00D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_l_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_ldrsb_l_a1_a_field_cond_3_poweroftwo_d0_305f00d0() {
    // Encoding: 0x305F00D0
    // Test aarch32_LDRSB_l_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4L=0, P=0, cond=3, U=0, Rt=0, W=0, imm4H=0
    let encoding: u32 = 0x305F00D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_l_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_ldrsb_l_a1_a_field_cond_4_poweroftwo_d0_405f00d0() {
    // Encoding: 0x405F00D0
    // Test aarch32_LDRSB_l_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, imm4L=0, Rt=0, U=0, imm4H=0, cond=4, P=0
    let encoding: u32 = 0x405F00D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_l_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_ldrsb_l_a1_a_field_cond_5_poweroftwo_d0_505f00d0() {
    // Encoding: 0x505F00D0
    // Test aarch32_LDRSB_l_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, W=0, imm4H=0, U=0, cond=5, P=0, imm4L=0
    let encoding: u32 = 0x505F00D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_l_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_ldrsb_l_a1_a_field_cond_6_poweroftwo_d0_605f00d0() {
    // Encoding: 0x605F00D0
    // Test aarch32_LDRSB_l_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, U=0, P=0, W=0, imm4H=0, imm4L=0, cond=6
    let encoding: u32 = 0x605F00D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_l_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_ldrsb_l_a1_a_field_cond_7_poweroftwo_d0_705f00d0() {
    // Encoding: 0x705F00D0
    // Test aarch32_LDRSB_l_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4L=0, U=0, cond=7, imm4H=0, P=0, W=0, Rt=0
    let encoding: u32 = 0x705F00D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_l_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_ldrsb_l_a1_a_field_cond_8_poweroftwo_d0_805f00d0() {
    // Encoding: 0x805F00D0
    // Test aarch32_LDRSB_l_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, U=0, W=0, P=0, imm4L=0, cond=8, imm4H=0
    let encoding: u32 = 0x805F00D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_l_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_ldrsb_l_a1_a_field_cond_9_poweroftwo_d0_905f00d0() {
    // Encoding: 0x905F00D0
    // Test aarch32_LDRSB_l_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, U=0, W=0, imm4H=0, cond=9, P=0, imm4L=0
    let encoding: u32 = 0x905F00D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_l_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_ldrsb_l_a1_a_field_cond_10_poweroftwo_d0_a05f00d0() {
    // Encoding: 0xA05F00D0
    // Test aarch32_LDRSB_l_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, W=0, imm4L=0, imm4H=0, cond=10, P=0, U=0
    let encoding: u32 = 0xA05F00D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_l_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_ldrsb_l_a1_a_field_cond_11_poweroftwo_d0_b05f00d0() {
    // Encoding: 0xB05F00D0
    // Test aarch32_LDRSB_l_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4L=0, cond=11, P=0, Rt=0, imm4H=0, U=0, W=0
    let encoding: u32 = 0xB05F00D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_l_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_ldrsb_l_a1_a_field_cond_12_poweroftwo_d0_c05f00d0() {
    // Encoding: 0xC05F00D0
    // Test aarch32_LDRSB_l_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, cond=12, Rt=0, P=0, W=0, imm4L=0, imm4H=0
    let encoding: u32 = 0xC05F00D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_l_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_ldrsb_l_a1_a_field_cond_13_poweroftwo_d0_d05f00d0() {
    // Encoding: 0xD05F00D0
    // Test aarch32_LDRSB_l_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, U=0, Rt=0, cond=13, imm4L=0, W=0, imm4H=0
    let encoding: u32 = 0xD05F00D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_l_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_ldrsb_l_a1_a_field_cond_14_poweroftwo_d0_e05f00d0() {
    // Encoding: 0xE05F00D0
    // Test aarch32_LDRSB_l_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, cond=14, W=0, imm4L=0, P=0, U=0, imm4H=0
    let encoding: u32 = 0xE05F00D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_l_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_ldrsb_l_a1_a_field_cond_15_max_d0_f05f00d0() {
    // Encoding: 0xF05F00D0
    // Test aarch32_LDRSB_l_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: W=0, cond=15, P=0, imm4H=0, Rt=0, U=0, imm4L=0
    let encoding: u32 = 0xF05F00D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_l_A1_A
/// ASL: `field P 24 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldrsb_l_a1_a_field_p_0_min_d0_005f00d0() {
    // Encoding: 0x005F00D0
    // Test aarch32_LDRSB_l_A1_A field P = 0 (Min)
    // ISET: A32
    // Fields: Rt=0, imm4H=0, imm4L=0, cond=0, P=0, W=0, U=0
    let encoding: u32 = 0x005F00D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_l_A1_A
/// ASL: `field P 24 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldrsb_l_a1_a_field_p_1_max_d0_015f00d0() {
    // Encoding: 0x015F00D0
    // Test aarch32_LDRSB_l_A1_A field P = 1 (Max)
    // ISET: A32
    // Fields: Rt=0, P=1, imm4L=0, U=0, W=0, cond=0, imm4H=0
    let encoding: u32 = 0x015F00D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_l_A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldrsb_l_a1_a_field_u_0_min_d0_005f00d0() {
    // Encoding: 0x005F00D0
    // Test aarch32_LDRSB_l_A1_A field U = 0 (Min)
    // ISET: A32
    // Fields: imm4H=0, U=0, imm4L=0, W=0, cond=0, P=0, Rt=0
    let encoding: u32 = 0x005F00D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_l_A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldrsb_l_a1_a_field_u_1_max_d0_00df00d0() {
    // Encoding: 0x00DF00D0
    // Test aarch32_LDRSB_l_A1_A field U = 1 (Max)
    // ISET: A32
    // Fields: P=0, cond=0, U=1, W=0, Rt=0, imm4H=0, imm4L=0
    let encoding: u32 = 0x00DF00D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_l_A1_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldrsb_l_a1_a_field_w_0_min_d0_005f00d0() {
    // Encoding: 0x005F00D0
    // Test aarch32_LDRSB_l_A1_A field W = 0 (Min)
    // ISET: A32
    // Fields: imm4H=0, U=0, cond=0, W=0, Rt=0, imm4L=0, P=0
    let encoding: u32 = 0x005F00D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_l_A1_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldrsb_l_a1_a_field_w_1_max_d0_007f00d0() {
    // Encoding: 0x007F00D0
    // Test aarch32_LDRSB_l_A1_A field W = 1 (Max)
    // ISET: A32
    // Fields: imm4H=0, imm4L=0, W=1, cond=0, U=0, P=0, Rt=0
    let encoding: u32 = 0x007F00D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_l_A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrsb_l_a1_a_field_rt_0_min_d0_005f00d0() {
    // Encoding: 0x005F00D0
    // Test aarch32_LDRSB_l_A1_A field Rt = 0 (Min)
    // ISET: A32
    // Fields: W=0, imm4L=0, U=0, P=0, cond=0, imm4H=0, Rt=0
    let encoding: u32 = 0x005F00D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_l_A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrsb_l_a1_a_field_rt_1_poweroftwo_d0_005f10d0() {
    // Encoding: 0x005F10D0
    // Test aarch32_LDRSB_l_A1_A field Rt = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, Rt=1, P=0, imm4L=0, cond=0, W=0, imm4H=0
    let encoding: u32 = 0x005F10D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_l_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_ldrsb_l_a1_a_field_imm4h_0_zero_d0_005f00d0() {
    // Encoding: 0x005F00D0
    // Test aarch32_LDRSB_l_A1_A field imm4H = 0 (Zero)
    // ISET: A32
    // Fields: W=0, imm4H=0, imm4L=0, Rt=0, cond=0, P=0, U=0
    let encoding: u32 = 0x005F00D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_l_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_ldrsb_l_a1_a_field_imm4h_1_poweroftwo_d0_005f01d0() {
    // Encoding: 0x005F01D0
    // Test aarch32_LDRSB_l_A1_A field imm4H = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, imm4L=0, U=0, W=0, cond=0, P=0, imm4H=1
    let encoding: u32 = 0x005F01D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_l_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_ldrsb_l_a1_a_field_imm4h_3_poweroftwominusone_d0_005f03d0() {
    // Encoding: 0x005F03D0
    // Test aarch32_LDRSB_l_A1_A field imm4H = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm4H=3, Rt=0, P=0, W=0, U=0, imm4L=0, cond=0
    let encoding: u32 = 0x005F03D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_l_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_ldrsb_l_a1_a_field_imm4h_4_poweroftwo_d0_005f04d0() {
    // Encoding: 0x005F04D0
    // Test aarch32_LDRSB_l_A1_A field imm4H = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, W=0, P=0, Rt=0, imm4H=4, cond=0, imm4L=0
    let encoding: u32 = 0x005F04D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_l_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_aarch32_ldrsb_l_a1_a_field_imm4h_7_poweroftwominusone_d0_005f07d0() {
    // Encoding: 0x005F07D0
    // Test aarch32_LDRSB_l_A1_A field imm4H = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm4L=0, P=0, W=0, Rt=0, imm4H=7, cond=0, U=0
    let encoding: u32 = 0x005F07D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_l_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_ldrsb_l_a1_a_field_imm4h_8_poweroftwo_d0_005f08d0() {
    // Encoding: 0x005F08D0
    // Test aarch32_LDRSB_l_A1_A field imm4H = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, U=0, imm4L=0, W=0, imm4H=8, P=0, Rt=0
    let encoding: u32 = 0x005F08D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_l_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_aarch32_ldrsb_l_a1_a_field_imm4h_15_max_d0_005f0fd0() {
    // Encoding: 0x005F0FD0
    // Test aarch32_LDRSB_l_A1_A field imm4H = 15 (Max)
    // ISET: A32
    // Fields: Rt=0, imm4L=0, U=0, W=0, imm4H=15, cond=0, P=0
    let encoding: u32 = 0x005F0FD0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_l_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_ldrsb_l_a1_a_field_imm4l_0_zero_d0_005f00d0() {
    // Encoding: 0x005F00D0
    // Test aarch32_LDRSB_l_A1_A field imm4L = 0 (Zero)
    // ISET: A32
    // Fields: cond=0, Rt=0, imm4H=0, imm4L=0, W=0, P=0, U=0
    let encoding: u32 = 0x005F00D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_l_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_ldrsb_l_a1_a_field_imm4l_1_poweroftwo_d0_005f00d1() {
    // Encoding: 0x005F00D1
    // Test aarch32_LDRSB_l_A1_A field imm4L = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4H=0, imm4L=1, U=0, W=0, Rt=0, P=0, cond=0
    let encoding: u32 = 0x005F00D1;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_l_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_ldrsb_l_a1_a_field_imm4l_3_poweroftwominusone_d0_005f00d3() {
    // Encoding: 0x005F00D3
    // Test aarch32_LDRSB_l_A1_A field imm4L = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm4L=3, P=0, W=0, U=0, Rt=0, imm4H=0, cond=0
    let encoding: u32 = 0x005F00D3;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_l_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_ldrsb_l_a1_a_field_imm4l_4_poweroftwo_d0_005f00d4() {
    // Encoding: 0x005F00D4
    // Test aarch32_LDRSB_l_A1_A field imm4L = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, P=0, imm4H=0, U=0, imm4L=4, W=0, cond=0
    let encoding: u32 = 0x005F00D4;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_l_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_aarch32_ldrsb_l_a1_a_field_imm4l_7_poweroftwominusone_d0_005f00d7() {
    // Encoding: 0x005F00D7
    // Test aarch32_LDRSB_l_A1_A field imm4L = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm4H=0, imm4L=7, U=0, W=0, P=0, cond=0, Rt=0
    let encoding: u32 = 0x005F00D7;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_l_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_ldrsb_l_a1_a_field_imm4l_8_poweroftwo_d0_005f00d8() {
    // Encoding: 0x005F00D8
    // Test aarch32_LDRSB_l_A1_A field imm4L = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, imm4H=0, W=0, Rt=0, imm4L=8, cond=0, U=0
    let encoding: u32 = 0x005F00D8;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_l_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_aarch32_ldrsb_l_a1_a_field_imm4l_15_max_d0_005f00df() {
    // Encoding: 0x005F00DF
    // Test aarch32_LDRSB_l_A1_A field imm4L = 15 (Max)
    // ISET: A32
    // Fields: imm4H=0, imm4L=15, Rt=0, P=0, U=0, cond=0, W=0
    let encoding: u32 = 0x005F00DF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_l_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_ldrsb_l_a1_a_combo_0_d0_005f00d0() {
    // Encoding: 0x005F00D0
    // Test aarch32_LDRSB_l_A1_A field combination: cond=0, P=0, U=0, W=0, Rt=0, imm4H=0, imm4L=0
    // ISET: A32
    // Fields: imm4H=0, imm4L=0, U=0, P=0, W=0, cond=0, Rt=0
    let encoding: u32 = 0x005F00D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_l_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_ldrsb_l_a1_a_special_cond_0_condition_eq_208_005f00d0() {
    // Encoding: 0x005F00D0
    // Test aarch32_LDRSB_l_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: imm4L=0, U=0, cond=0, Rt=0, P=0, imm4H=0, W=0
    let encoding: u32 = 0x005F00D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_l_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_ldrsb_l_a1_a_special_cond_1_condition_ne_208_105f00d0() {
    // Encoding: 0x105F00D0
    // Test aarch32_LDRSB_l_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: Rt=0, imm4L=0, imm4H=0, P=0, cond=1, W=0, U=0
    let encoding: u32 = 0x105F00D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_l_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_ldrsb_l_a1_a_special_cond_2_condition_cs_hs_208_205f00d0() {
    // Encoding: 0x205F00D0
    // Test aarch32_LDRSB_l_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: P=0, U=0, cond=2, W=0, imm4H=0, Rt=0, imm4L=0
    let encoding: u32 = 0x205F00D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_l_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_ldrsb_l_a1_a_special_cond_3_condition_cc_lo_208_305f00d0() {
    // Encoding: 0x305F00D0
    // Test aarch32_LDRSB_l_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: Rt=0, imm4H=0, imm4L=0, U=0, cond=3, W=0, P=0
    let encoding: u32 = 0x305F00D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_l_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_ldrsb_l_a1_a_special_cond_4_condition_mi_208_405f00d0() {
    // Encoding: 0x405F00D0
    // Test aarch32_LDRSB_l_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: imm4L=0, U=0, imm4H=0, cond=4, W=0, Rt=0, P=0
    let encoding: u32 = 0x405F00D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_l_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_ldrsb_l_a1_a_special_cond_5_condition_pl_208_505f00d0() {
    // Encoding: 0x505F00D0
    // Test aarch32_LDRSB_l_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: imm4H=0, Rt=0, P=0, imm4L=0, W=0, U=0, cond=5
    let encoding: u32 = 0x505F00D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_l_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_ldrsb_l_a1_a_special_cond_6_condition_vs_208_605f00d0() {
    // Encoding: 0x605F00D0
    // Test aarch32_LDRSB_l_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: imm4H=0, imm4L=0, cond=6, U=0, W=0, Rt=0, P=0
    let encoding: u32 = 0x605F00D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_l_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_ldrsb_l_a1_a_special_cond_7_condition_vc_208_705f00d0() {
    // Encoding: 0x705F00D0
    // Test aarch32_LDRSB_l_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: U=0, imm4H=0, W=0, Rt=0, P=0, imm4L=0, cond=7
    let encoding: u32 = 0x705F00D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_l_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_ldrsb_l_a1_a_special_cond_8_condition_hi_208_805f00d0() {
    // Encoding: 0x805F00D0
    // Test aarch32_LDRSB_l_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: imm4L=0, W=0, U=0, cond=8, P=0, Rt=0, imm4H=0
    let encoding: u32 = 0x805F00D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_l_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_ldrsb_l_a1_a_special_cond_9_condition_ls_208_905f00d0() {
    // Encoding: 0x905F00D0
    // Test aarch32_LDRSB_l_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: U=0, Rt=0, imm4H=0, P=0, imm4L=0, W=0, cond=9
    let encoding: u32 = 0x905F00D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_l_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_ldrsb_l_a1_a_special_cond_10_condition_ge_208_a05f00d0() {
    // Encoding: 0xA05F00D0
    // Test aarch32_LDRSB_l_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: imm4H=0, imm4L=0, P=0, cond=10, Rt=0, U=0, W=0
    let encoding: u32 = 0xA05F00D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_l_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_ldrsb_l_a1_a_special_cond_11_condition_lt_208_b05f00d0() {
    // Encoding: 0xB05F00D0
    // Test aarch32_LDRSB_l_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: W=0, Rt=0, imm4H=0, cond=11, P=0, U=0, imm4L=0
    let encoding: u32 = 0xB05F00D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_l_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_ldrsb_l_a1_a_special_cond_12_condition_gt_208_c05f00d0() {
    // Encoding: 0xC05F00D0
    // Test aarch32_LDRSB_l_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: Rt=0, P=0, cond=12, imm4H=0, W=0, imm4L=0, U=0
    let encoding: u32 = 0xC05F00D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_l_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_ldrsb_l_a1_a_special_cond_13_condition_le_208_d05f00d0() {
    // Encoding: 0xD05F00D0
    // Test aarch32_LDRSB_l_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: P=0, cond=13, U=0, W=0, Rt=0, imm4H=0, imm4L=0
    let encoding: u32 = 0xD05F00D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_l_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_ldrsb_l_a1_a_special_cond_14_condition_al_208_e05f00d0() {
    // Encoding: 0xE05F00D0
    // Test aarch32_LDRSB_l_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: U=0, P=0, imm4H=0, Rt=0, imm4L=0, W=0, cond=14
    let encoding: u32 = 0xE05F00D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_l_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_ldrsb_l_a1_a_special_cond_15_condition_nv_208_f05f00d0() {
    // Encoding: 0xF05F00D0
    // Test aarch32_LDRSB_l_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: imm4H=0, imm4L=0, P=0, cond=15, Rt=0, W=0, U=0
    let encoding: u32 = 0xF05F00D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_l_A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }) } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"wback\" }) } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrsb_l_a1_a_invalid_0_d0_005f00d0() {
    // Encoding: 0x005F00D0
    // Test aarch32_LDRSB_l_A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }) } }
    // ISET: A32
    // Fields: cond=0, imm4H=0, U=0, W=0, P=0, Rt=0, imm4L=0
    let encoding: u32 = 0x005F00D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRSB_l_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrsb_l_a1_a_invalid_1_d0_005f00d0() {
    // Encoding: 0x005F00D0
    // Test aarch32_LDRSB_l_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: cond=0, imm4H=0, imm4L=0, P=0, W=0, U=0, Rt=0
    let encoding: u32 = 0x005F00D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRSB_l_T1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldrsb_l_t1_a_field_u_0_min_0_f91f0000() {
    // Thumb encoding (32): 0xF91F0000
    // Test aarch32_LDRSB_l_T1_A field U = 0 (Min)
    // ISET: T32
    // Fields: U=0, Rt=0, imm12=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF91F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_l_T1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldrsb_l_t1_a_field_u_1_max_0_f99f0000() {
    // Thumb encoding (32): 0xF99F0000
    // Test aarch32_LDRSB_l_T1_A field U = 1 (Max)
    // ISET: T32
    // Fields: Rt=0, imm12=0, U=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF99F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_l_T1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrsb_l_t1_a_field_rt_0_min_0_f91f0000() {
    // Thumb encoding (32): 0xF91F0000
    // Test aarch32_LDRSB_l_T1_A field Rt = 0 (Min)
    // ISET: T32
    // Fields: U=0, Rt=0, imm12=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF91F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_l_T1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrsb_l_t1_a_field_rt_1_poweroftwo_0_f91f1000() {
    // Thumb encoding (32): 0xF91F1000
    // Test aarch32_LDRSB_l_T1_A field Rt = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=1, U=0, imm12=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF91F1000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_ldrsb_l_t1_a_field_imm12_0_zero_0_f91f0000() {
    // Thumb encoding (32): 0xF91F0000
    // Test aarch32_LDRSB_l_T1_A field imm12 = 0 (Zero)
    // ISET: T32
    // Fields: U=0, Rt=0, imm12=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF91F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_ldrsb_l_t1_a_field_imm12_1_poweroftwo_0_f91f0001() {
    // Thumb encoding (32): 0xF91F0001
    // Test aarch32_LDRSB_l_T1_A field imm12 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, imm12=1, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF91F0001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_ldrsb_l_t1_a_field_imm12_3_poweroftwominusone_0_f91f0003() {
    // Thumb encoding (32): 0xF91F0003
    // Test aarch32_LDRSB_l_T1_A field imm12 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: U=0, imm12=3, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF91F0003;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_ldrsb_l_t1_a_field_imm12_4_poweroftwo_0_f91f0004() {
    // Thumb encoding (32): 0xF91F0004
    // Test aarch32_LDRSB_l_T1_A field imm12 = 4 (PowerOfTwo)
    // ISET: T32
    // Fields: U=0, Rt=0, imm12=4
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF91F0004;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_ldrsb_l_t1_a_field_imm12_7_poweroftwominusone_0_f91f0007() {
    // Thumb encoding (32): 0xF91F0007
    // Test aarch32_LDRSB_l_T1_A field imm12 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: U=0, Rt=0, imm12=7
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF91F0007;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_ldrsb_l_t1_a_field_imm12_8_poweroftwo_0_f91f0008() {
    // Thumb encoding (32): 0xF91F0008
    // Test aarch32_LDRSB_l_T1_A field imm12 = 8 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, U=0, imm12=8
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF91F0008;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_ldrsb_l_t1_a_field_imm12_15_poweroftwominusone_0_f91f000f() {
    // Thumb encoding (32): 0xF91F000F
    // Test aarch32_LDRSB_l_T1_A field imm12 = 15 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm12=15, U=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF91F000F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_ldrsb_l_t1_a_field_imm12_16_poweroftwo_0_f91f0010() {
    // Thumb encoding (32): 0xF91F0010
    // Test aarch32_LDRSB_l_T1_A field imm12 = 16 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, imm12=16, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF91F0010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_ldrsb_l_t1_a_field_imm12_31_poweroftwominusone_0_f91f001f() {
    // Thumb encoding (32): 0xF91F001F
    // Test aarch32_LDRSB_l_T1_A field imm12 = 31 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, imm12=31, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF91F001F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_ldrsb_l_t1_a_field_imm12_32_poweroftwo_0_f91f0020() {
    // Thumb encoding (32): 0xF91F0020
    // Test aarch32_LDRSB_l_T1_A field imm12 = 32 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, imm12=32, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF91F0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_ldrsb_l_t1_a_field_imm12_63_poweroftwominusone_0_f91f003f() {
    // Thumb encoding (32): 0xF91F003F
    // Test aarch32_LDRSB_l_T1_A field imm12 = 63 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, imm12=63, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF91F003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_ldrsb_l_t1_a_field_imm12_64_poweroftwo_0_f91f0040() {
    // Thumb encoding (32): 0xF91F0040
    // Test aarch32_LDRSB_l_T1_A field imm12 = 64 (PowerOfTwo)
    // ISET: T32
    // Fields: imm12=64, Rt=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF91F0040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 127, boundary: PowerOfTwoMinusOne }
/// 2^7 - 1 = 127
#[test]
fn test_aarch32_ldrsb_l_t1_a_field_imm12_127_poweroftwominusone_0_f91f007f() {
    // Thumb encoding (32): 0xF91F007F
    // Test aarch32_LDRSB_l_T1_A field imm12 = 127 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: U=0, imm12=127, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF91F007F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_ldrsb_l_t1_a_field_imm12_128_poweroftwo_0_f91f0080() {
    // Thumb encoding (32): 0xF91F0080
    // Test aarch32_LDRSB_l_T1_A field imm12 = 128 (PowerOfTwo)
    // ISET: T32
    // Fields: U=0, Rt=0, imm12=128
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF91F0080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 255, boundary: PowerOfTwoMinusOne }
/// 2^8 - 1 = 255
#[test]
fn test_aarch32_ldrsb_l_t1_a_field_imm12_255_poweroftwominusone_0_f91f00ff() {
    // Thumb encoding (32): 0xF91F00FF
    // Test aarch32_LDRSB_l_T1_A field imm12 = 255 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, U=0, imm12=255
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF91F00FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 256, boundary: PowerOfTwo }
/// power of 2 (2^8 = 256)
#[test]
fn test_aarch32_ldrsb_l_t1_a_field_imm12_256_poweroftwo_0_f91f0100() {
    // Thumb encoding (32): 0xF91F0100
    // Test aarch32_LDRSB_l_T1_A field imm12 = 256 (PowerOfTwo)
    // ISET: T32
    // Fields: imm12=256, Rt=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF91F0100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 511, boundary: PowerOfTwoMinusOne }
/// 2^9 - 1 = 511
#[test]
fn test_aarch32_ldrsb_l_t1_a_field_imm12_511_poweroftwominusone_0_f91f01ff() {
    // Thumb encoding (32): 0xF91F01FF
    // Test aarch32_LDRSB_l_T1_A field imm12 = 511 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: U=0, Rt=0, imm12=511
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF91F01FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 512, boundary: PowerOfTwo }
/// power of 2 (2^9 = 512)
#[test]
fn test_aarch32_ldrsb_l_t1_a_field_imm12_512_poweroftwo_0_f91f0200() {
    // Thumb encoding (32): 0xF91F0200
    // Test aarch32_LDRSB_l_T1_A field imm12 = 512 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, imm12=512, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF91F0200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1023, boundary: PowerOfTwoMinusOne }
/// 2^10 - 1 = 1023
#[test]
fn test_aarch32_ldrsb_l_t1_a_field_imm12_1023_poweroftwominusone_0_f91f03ff() {
    // Thumb encoding (32): 0xF91F03FF
    // Test aarch32_LDRSB_l_T1_A field imm12 = 1023 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm12=1023, U=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF91F03FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1024, boundary: PowerOfTwo }
/// power of 2 (2^10 = 1024)
#[test]
fn test_aarch32_ldrsb_l_t1_a_field_imm12_1024_poweroftwo_0_f91f0400() {
    // Thumb encoding (32): 0xF91F0400
    // Test aarch32_LDRSB_l_T1_A field imm12 = 1024 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, imm12=1024, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF91F0400;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2047, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (2047)
#[test]
fn test_aarch32_ldrsb_l_t1_a_field_imm12_2047_poweroftwominusone_0_f91f07ff() {
    // Thumb encoding (32): 0xF91F07FF
    // Test aarch32_LDRSB_l_T1_A field imm12 = 2047 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm12=2047, Rt=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF91F07FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2048, boundary: PowerOfTwo }
/// power of 2 (2^11 = 2048)
#[test]
fn test_aarch32_ldrsb_l_t1_a_field_imm12_2048_poweroftwo_0_f91f0800() {
    // Thumb encoding (32): 0xF91F0800
    // Test aarch32_LDRSB_l_T1_A field imm12 = 2048 (PowerOfTwo)
    // ISET: T32
    // Fields: imm12=2048, Rt=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF91F0800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_l_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4095, boundary: Max }
/// maximum immediate (4095)
#[test]
fn test_aarch32_ldrsb_l_t1_a_field_imm12_4095_max_0_f91f0fff() {
    // Thumb encoding (32): 0xF91F0FFF
    // Test aarch32_LDRSB_l_T1_A field imm12 = 4095 (Max)
    // ISET: T32
    // Fields: Rt=0, imm12=4095, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF91F0FFF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_l_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=0 (minimum value)
#[test]
fn test_aarch32_ldrsb_l_t1_a_combo_0_0_f91f0000() {
    // Thumb encoding (32): 0xF91F0000
    // Test aarch32_LDRSB_l_T1_A field combination: U=0, Rt=0, imm12=0
    // ISET: T32
    // Fields: U=0, Rt=0, imm12=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF91F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_l_A1_A
/// ASL: `UMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple multiply
#[test]
fn test_aarch32_ldrsb_l_a1_a_umull_oracle_0_9ba27c20() {
    // Test UMULL: simple multiply (oracle)
    // Encoding: 0x9BA27C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x2);
    set_w(&mut cpu, 2, 0x3);
    let encoding: u32 = 0x9BA27C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6, "X0 should be 0x0000000000000006");
}

/// Provenance: aarch32_LDRSB_l_A1_A
/// ASL: `UMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max 32-bit * 2
#[test]
fn test_aarch32_ldrsb_l_a1_a_umull_oracle_1_9ba27c20() {
    // Test UMULL: max 32-bit * 2 (oracle)
    // Encoding: 0x9BA27C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x9BA27C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0x00000001FFFFFFFE"
    );
}

/// Provenance: aarch32_LDRSB_l_A1_A
/// ASL: `UMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// large positive * large positive
#[test]
fn test_aarch32_ldrsb_l_a1_a_umull_oracle_2_9ba27c20() {
    // Test UMULL: large positive * large positive (oracle)
    // Encoding: 0x9BA27C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x7FFFFFFF);
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x9BA27C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x3FFFFFFF00000001");
}

/// Provenance: aarch32_LDRSB_l_A1_A
/// ASL: `UMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max unsigned * max unsigned
#[test]
fn test_aarch32_ldrsb_l_a1_a_umull_oracle_3_9ba27c20() {
    // Test UMULL: max unsigned * max unsigned (oracle)
    // Encoding: 0x9BA27C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x9BA27C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0xFFFFFFFE00000001");
}

/// Provenance: aarch32_LDRSB_l_A1_A
/// ASL: `UMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// medium values
#[test]
fn test_aarch32_ldrsb_l_a1_a_umull_oracle_4_9ba27c20() {
    // Test UMULL: medium values (oracle)
    // Encoding: 0x9BA27C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xC8);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x9BA27C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4E20, "X0 should be 0x0000000000004E20");
}

/// Provenance: aarch32_LDRSB_l_A1_A
/// ASL: `UMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// 16-bit values
#[test]
fn test_aarch32_ldrsb_l_a1_a_umull_oracle_5_9ba27c20() {
    // Test UMULL: 16-bit values (oracle)
    // Encoding: 0x9BA27C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1234);
    set_w(&mut cpu, 2, 0x5678);
    let encoding: u32 = 0x9BA27C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6260060, "X0 should be 0x0000000006260060");
}

/// Provenance: aarch32_LDRSB_l_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple division (32)
#[test]
fn test_aarch32_ldrsb_l_t1_a_udiv_oracle_32_0_1ac20820() {
    // Test UDIV 32-bit: simple division (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xA);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA, "W0 should be 0x0000000A");
}

/// Provenance: aarch32_LDRSB_l_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple division (64)
#[test]
fn test_aarch32_ldrsb_l_t1_a_udiv_oracle_64_0_9ac20820() {
    // Test UDIV 64-bit: simple division (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xA);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA, "X0 should be 0x000000000000000A");
}

/// Provenance: aarch32_LDRSB_l_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// division with remainder (32)
#[test]
fn test_aarch32_ldrsb_l_t1_a_udiv_oracle_32_1_1ac20820() {
    // Test UDIV 32-bit: division with remainder (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x3);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x21, "W0 should be 0x00000021");
}

/// Provenance: aarch32_LDRSB_l_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// division with remainder (64)
#[test]
fn test_aarch32_ldrsb_l_t1_a_udiv_oracle_64_1_9ac20820() {
    // Test UDIV 64-bit: division with remainder (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x3);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x21, "X0 should be 0x0000000000000021");
}

/// Provenance: aarch32_LDRSB_l_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero dividend (32)
#[test]
fn test_aarch32_ldrsb_l_t1_a_udiv_oracle_32_2_1ac20820() {
    // Test UDIV 32-bit: zero dividend (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xA);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_LDRSB_l_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero dividend (64)
#[test]
fn test_aarch32_ldrsb_l_t1_a_udiv_oracle_64_2_9ac20820() {
    // Test UDIV 64-bit: zero dividend (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xA);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_LDRSB_l_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// divide by zero - result is 0 (32)
#[test]
fn test_aarch32_ldrsb_l_t1_a_udiv_oracle_32_3_1ac20820() {
    // Test UDIV 32-bit: divide by zero - result is 0 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xA);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_LDRSB_l_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// divide by zero - result is 0 (64)
#[test]
fn test_aarch32_ldrsb_l_t1_a_udiv_oracle_64_3_9ac20820() {
    // Test UDIV 64-bit: divide by zero - result is 0 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xA);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_LDRSB_l_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max value / 2 (32)
#[test]
fn test_aarch32_ldrsb_l_t1_a_udiv_oracle_32_4_1ac20820() {
    // Test UDIV 32-bit: max value / 2 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FFFFFFF, "W0 should be 0x7FFFFFFF");
}

/// Provenance: aarch32_LDRSB_l_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max value / 2 (64)
#[test]
fn test_aarch32_ldrsb_l_t1_a_udiv_oracle_64_4_9ac20820() {
    // Test UDIV 64-bit: max value / 2 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0x7FFFFFFFFFFFFFFF"
    );
}

/// Provenance: aarch32_LDRSB_l_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set / 2 (32)
#[test]
fn test_aarch32_ldrsb_l_t1_a_udiv_oracle_32_5_1ac20820() {
    // Test UDIV 32-bit: MSB set / 2 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_LDRSB_l_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// MSB set / 2 (64)
#[test]
fn test_aarch32_ldrsb_l_t1_a_udiv_oracle_64_5_9ac20820() {
    // Test UDIV 64-bit: MSB set / 2 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x4000000000000000");
}

/// Provenance: aarch32_LDRSB_l_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// self-division (32)
#[test]
fn test_aarch32_ldrsb_l_t1_a_udiv_oracle_32_6_1ac20820() {
    // Test UDIV 32-bit: self-division (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7);
    set_w(&mut cpu, 2, 0x7);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_LDRSB_l_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// self-division (64)
#[test]
fn test_aarch32_ldrsb_l_t1_a_udiv_oracle_64_6_9ac20820() {
    // Test UDIV 64-bit: self-division (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7);
    set_w(&mut cpu, 2, 0x7);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x0000000000000001");
}

/// Provenance: aarch32_LDRSB_l_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// one / one (32)
#[test]
fn test_aarch32_ldrsb_l_t1_a_udiv_oracle_32_7_1ac20820() {
    // Test UDIV 32-bit: one / one (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_LDRSB_l_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// one / one (64)
#[test]
fn test_aarch32_ldrsb_l_t1_a_udiv_oracle_64_7_9ac20820() {
    // Test UDIV 64-bit: one / one (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x0000000000000001");
}

/// Provenance: aarch32_LDRSB_l_T1_A
/// ASL: `UDIV R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// exact division
#[test]
fn test_aarch32_ldrsb_l_t1_a_t32_oracle_0_f91f0000() {
    // Test T32 UDIV: exact division (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0xA);
    let encoding: u32 = 0xF91F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA, "R0 should be 0x0000000A");
}

/// Provenance: aarch32_LDRSB_l_T1_A
/// ASL: `UDIV R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// with remainder
#[test]
fn test_aarch32_ldrsb_l_t1_a_t32_oracle_1_f91f0000() {
    // Test T32 UDIV: with remainder (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF91F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x21, "R0 should be 0x00000021");
}

/// Provenance: aarch32_LDRSB_l_T1_A
/// ASL: `UDIV R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero dividend
#[test]
fn test_aarch32_ldrsb_l_t1_a_t32_oracle_2_f91f0000() {
    // Test T32 UDIV: zero dividend (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xA);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF91F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_LDRSB_l_T1_A
/// ASL: `UDIV R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// divide by zero
#[test]
fn test_aarch32_ldrsb_l_t1_a_t32_oracle_3_f91f0000() {
    // Test T32 UDIV: divide by zero (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0xA);
    let encoding: u32 = 0xF91F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

// ============================================================================
// aarch32_LDMDB_A Tests
// ============================================================================

/// Provenance: aarch32_LDMDB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_ldmdb_a1_a_field_cond_0_min_0_09100000() {
    // Encoding: 0x09100000
    // Test aarch32_LDMDB_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rn=0, register_list=0, W=0
    let encoding: u32 = 0x09100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMDB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_ldmdb_a1_a_field_cond_1_poweroftwo_0_19100000() {
    // Encoding: 0x19100000
    // Test aarch32_LDMDB_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=1, W=0, register_list=0
    let encoding: u32 = 0x19100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMDB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_ldmdb_a1_a_field_cond_2_poweroftwo_0_29100000() {
    // Encoding: 0x29100000
    // Test aarch32_LDMDB_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=2, W=0, register_list=0
    let encoding: u32 = 0x29100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMDB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_ldmdb_a1_a_field_cond_3_poweroftwo_0_39100000() {
    // Encoding: 0x39100000
    // Test aarch32_LDMDB_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, register_list=0, cond=3, Rn=0
    let encoding: u32 = 0x39100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMDB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_ldmdb_a1_a_field_cond_4_poweroftwo_0_49100000() {
    // Encoding: 0x49100000
    // Test aarch32_LDMDB_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=4, Rn=0, register_list=0, W=0
    let encoding: u32 = 0x49100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMDB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_ldmdb_a1_a_field_cond_5_poweroftwo_0_59100000() {
    // Encoding: 0x59100000
    // Test aarch32_LDMDB_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, register_list=0, cond=5, Rn=0
    let encoding: u32 = 0x59100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMDB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_ldmdb_a1_a_field_cond_6_poweroftwo_0_69100000() {
    // Encoding: 0x69100000
    // Test aarch32_LDMDB_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=6, Rn=0, register_list=0, W=0
    let encoding: u32 = 0x69100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMDB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_ldmdb_a1_a_field_cond_7_poweroftwo_0_79100000() {
    // Encoding: 0x79100000
    // Test aarch32_LDMDB_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: register_list=0, Rn=0, cond=7, W=0
    let encoding: u32 = 0x79100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMDB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_ldmdb_a1_a_field_cond_8_poweroftwo_0_89100000() {
    // Encoding: 0x89100000
    // Test aarch32_LDMDB_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: register_list=0, W=0, cond=8, Rn=0
    let encoding: u32 = 0x89100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMDB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_ldmdb_a1_a_field_cond_9_poweroftwo_0_99100000() {
    // Encoding: 0x99100000
    // Test aarch32_LDMDB_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, register_list=0, cond=9, W=0
    let encoding: u32 = 0x99100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMDB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_ldmdb_a1_a_field_cond_10_poweroftwo_0_a9100000() {
    // Encoding: 0xA9100000
    // Test aarch32_LDMDB_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=10, W=0, Rn=0, register_list=0
    let encoding: u32 = 0xA9100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMDB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_ldmdb_a1_a_field_cond_11_poweroftwo_0_b9100000() {
    // Encoding: 0xB9100000
    // Test aarch32_LDMDB_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=11, Rn=0, register_list=0, W=0
    let encoding: u32 = 0xB9100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMDB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_ldmdb_a1_a_field_cond_12_poweroftwo_0_c9100000() {
    // Encoding: 0xC9100000
    // Test aarch32_LDMDB_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: register_list=0, W=0, Rn=0, cond=12
    let encoding: u32 = 0xC9100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMDB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_ldmdb_a1_a_field_cond_13_poweroftwo_0_d9100000() {
    // Encoding: 0xD9100000
    // Test aarch32_LDMDB_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=13, register_list=0, W=0
    let encoding: u32 = 0xD9100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMDB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_ldmdb_a1_a_field_cond_14_poweroftwo_0_e9100000() {
    // Encoding: 0xE9100000
    // Test aarch32_LDMDB_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=14, Rn=0, register_list=0, W=0
    let encoding: u32 = 0xE9100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMDB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_ldmdb_a1_a_field_cond_15_max_0_f9100000() {
    // Encoding: 0xF9100000
    // Test aarch32_LDMDB_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: register_list=0, Rn=0, cond=15, W=0
    let encoding: u32 = 0xF9100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMDB_A1_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldmdb_a1_a_field_w_0_min_0_09100000() {
    // Encoding: 0x09100000
    // Test aarch32_LDMDB_A1_A field W = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rn=0, register_list=0, W=0
    let encoding: u32 = 0x09100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMDB_A1_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldmdb_a1_a_field_w_1_max_0_09300000() {
    // Encoding: 0x09300000
    // Test aarch32_LDMDB_A1_A field W = 1 (Max)
    // ISET: A32
    // Fields: cond=0, W=1, Rn=0, register_list=0
    let encoding: u32 = 0x09300000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMDB_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldmdb_a1_a_field_rn_0_min_0_09100000() {
    // Encoding: 0x09100000
    // Test aarch32_LDMDB_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, W=0, register_list=0, cond=0
    let encoding: u32 = 0x09100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMDB_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldmdb_a1_a_field_rn_1_poweroftwo_0_09110000() {
    // Encoding: 0x09110000
    // Test aarch32_LDMDB_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=1, register_list=0, W=0, cond=0
    let encoding: u32 = 0x09110000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMDB_A1_A
/// ASL: `field register_list 0 +: 16`
/// Requirement: FieldBoundary { field: "register_list", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldmdb_a1_a_field_register_list_0_min_0_09100000() {
    // Encoding: 0x09100000
    // Test aarch32_LDMDB_A1_A field register_list = 0 (Min)
    // ISET: A32
    // Fields: cond=0, W=0, Rn=0, register_list=0
    let encoding: u32 = 0x09100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMDB_A1_A
/// ASL: `field register_list 0 +: 16`
/// Requirement: FieldBoundary { field: "register_list", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_ldmdb_a1_a_field_register_list_1_poweroftwo_0_09100001() {
    // Encoding: 0x09100001
    // Test aarch32_LDMDB_A1_A field register_list = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, W=0, register_list=1, cond=0
    let encoding: u32 = 0x09100001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMDB_A1_A
/// ASL: `field register_list 0 +: 16`
/// Requirement: FieldBoundary { field: "register_list", value: 32767, boundary: PowerOfTwoMinusOne }
/// midpoint (32767)
#[test]
fn test_aarch32_ldmdb_a1_a_field_register_list_32767_poweroftwominusone_0_09107fff() {
    // Encoding: 0x09107FFF
    // Test aarch32_LDMDB_A1_A field register_list = 32767 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rn=0, W=0, register_list=32767, cond=0
    let encoding: u32 = 0x09107FFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMDB_A1_A
/// ASL: `field register_list 0 +: 16`
/// Requirement: FieldBoundary { field: "register_list", value: 65535, boundary: Max }
/// maximum value (65535)
#[test]
fn test_aarch32_ldmdb_a1_a_field_register_list_65535_max_0_0910ffff() {
    // Encoding: 0x0910FFFF
    // Test aarch32_LDMDB_A1_A field register_list = 65535 (Max)
    // ISET: A32
    // Fields: W=0, cond=0, Rn=0, register_list=65535
    let encoding: u32 = 0x0910FFFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMDB_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_ldmdb_a1_a_combo_0_0_09100000() {
    // Encoding: 0x09100000
    // Test aarch32_LDMDB_A1_A field combination: cond=0, W=0, Rn=0, register_list=0
    // ISET: A32
    // Fields: Rn=0, cond=0, register_list=0, W=0
    let encoding: u32 = 0x09100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMDB_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_ldmdb_a1_a_special_cond_0_condition_eq_0_09100000() {
    // Encoding: 0x09100000
    // Test aarch32_LDMDB_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: Rn=0, W=0, register_list=0, cond=0
    let encoding: u32 = 0x09100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMDB_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_ldmdb_a1_a_special_cond_1_condition_ne_0_19100000() {
    // Encoding: 0x19100000
    // Test aarch32_LDMDB_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: cond=1, W=0, Rn=0, register_list=0
    let encoding: u32 = 0x19100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMDB_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_ldmdb_a1_a_special_cond_2_condition_cs_hs_0_29100000() {
    // Encoding: 0x29100000
    // Test aarch32_LDMDB_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: W=0, register_list=0, Rn=0, cond=2
    let encoding: u32 = 0x29100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMDB_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_ldmdb_a1_a_special_cond_3_condition_cc_lo_0_39100000() {
    // Encoding: 0x39100000
    // Test aarch32_LDMDB_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: cond=3, W=0, Rn=0, register_list=0
    let encoding: u32 = 0x39100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMDB_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_ldmdb_a1_a_special_cond_4_condition_mi_0_49100000() {
    // Encoding: 0x49100000
    // Test aarch32_LDMDB_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: cond=4, Rn=0, W=0, register_list=0
    let encoding: u32 = 0x49100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMDB_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_ldmdb_a1_a_special_cond_5_condition_pl_0_59100000() {
    // Encoding: 0x59100000
    // Test aarch32_LDMDB_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: cond=5, Rn=0, W=0, register_list=0
    let encoding: u32 = 0x59100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMDB_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_ldmdb_a1_a_special_cond_6_condition_vs_0_69100000() {
    // Encoding: 0x69100000
    // Test aarch32_LDMDB_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: Rn=0, cond=6, W=0, register_list=0
    let encoding: u32 = 0x69100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMDB_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_ldmdb_a1_a_special_cond_7_condition_vc_0_79100000() {
    // Encoding: 0x79100000
    // Test aarch32_LDMDB_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: W=0, Rn=0, cond=7, register_list=0
    let encoding: u32 = 0x79100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMDB_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_ldmdb_a1_a_special_cond_8_condition_hi_0_89100000() {
    // Encoding: 0x89100000
    // Test aarch32_LDMDB_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: cond=8, W=0, register_list=0, Rn=0
    let encoding: u32 = 0x89100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMDB_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_ldmdb_a1_a_special_cond_9_condition_ls_0_99100000() {
    // Encoding: 0x99100000
    // Test aarch32_LDMDB_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: cond=9, Rn=0, W=0, register_list=0
    let encoding: u32 = 0x99100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMDB_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_ldmdb_a1_a_special_cond_10_condition_ge_0_a9100000() {
    // Encoding: 0xA9100000
    // Test aarch32_LDMDB_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: cond=10, W=0, Rn=0, register_list=0
    let encoding: u32 = 0xA9100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMDB_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_ldmdb_a1_a_special_cond_11_condition_lt_0_b9100000() {
    // Encoding: 0xB9100000
    // Test aarch32_LDMDB_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: cond=11, W=0, Rn=0, register_list=0
    let encoding: u32 = 0xB9100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMDB_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_ldmdb_a1_a_special_cond_12_condition_gt_0_c9100000() {
    // Encoding: 0xC9100000
    // Test aarch32_LDMDB_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: W=0, Rn=0, cond=12, register_list=0
    let encoding: u32 = 0xC9100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMDB_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_ldmdb_a1_a_special_cond_13_condition_le_0_d9100000() {
    // Encoding: 0xD9100000
    // Test aarch32_LDMDB_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: cond=13, Rn=0, W=0, register_list=0
    let encoding: u32 = 0xD9100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMDB_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_ldmdb_a1_a_special_cond_14_condition_al_0_e9100000() {
    // Encoding: 0xE9100000
    // Test aarch32_LDMDB_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: W=0, cond=14, register_list=0, Rn=0
    let encoding: u32 = 0xE9100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMDB_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_ldmdb_a1_a_special_cond_15_condition_nv_0_f9100000() {
    // Encoding: 0xF9100000
    // Test aarch32_LDMDB_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: Rn=0, cond=15, W=0, register_list=0
    let encoding: u32 = 0xF9100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMDB_A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Binary { op: Lt, lhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "BitCount" }, args: [Var(QualifiedIdentifier { qualifier: Any, name: "registers" })] }, rhs: LitInt(1) } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Binary { op: Lt, lhs: Call { name: QualifiedIdentifier { qualifier: Any, name: \"BitCount\" }, args: [Var(QualifiedIdentifier { qualifier: Any, name: \"registers\" })] }, rhs: LitInt(1) } } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldmdb_a1_a_invalid_0_0_09100000() {
    // Encoding: 0x09100000
    // Test aarch32_LDMDB_A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Binary { op: Lt, lhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "BitCount" }, args: [Var(QualifiedIdentifier { qualifier: Any, name: "registers" })] }, rhs: LitInt(1) } } }
    // ISET: A32
    // Fields: W=0, cond=0, register_list=0, Rn=0
    let encoding: u32 = 0x09100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDMDB_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldmdb_a1_a_invalid_1_0_09100000() {
    // Encoding: 0x09100000
    // Test aarch32_LDMDB_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: cond=0, W=0, register_list=0, Rn=0
    let encoding: u32 = 0x09100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDMDB_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "registers" }), indices: [Single(Var(QualifiedIdentifier { qualifier: Any, name: "n" }))] } }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"wback\" }), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"registers\" }), indices: [Single(Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }))] } }, rhs: LitBits([true]) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldmdb_a1_a_invalid_2_0_09100000() {
    // Encoding: 0x09100000
    // Test aarch32_LDMDB_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "registers" }), indices: [Single(Var(QualifiedIdentifier { qualifier: Any, name: "n" }))] } }, rhs: LitBits([true]) }
    // ISET: A32
    // Fields: W=0, register_list=0, Rn=0, cond=0
    let encoding: u32 = 0x09100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDMDB_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldmdb_a1_a_invalid_3_0_09100000() {
    // Encoding: 0x09100000
    // Test aarch32_LDMDB_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: cond=0, W=0, Rn=0, register_list=0
    let encoding: u32 = 0x09100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDMDB_T1_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldmdb_t1_a_field_w_0_min_0_e9100000() {
    // Thumb encoding (32): 0xE9100000
    // Test aarch32_LDMDB_T1_A field W = 0 (Min)
    // ISET: T32
    // Fields: M=0, register_list=0, P=0, W=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE9100000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDMDB_T1_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldmdb_t1_a_field_w_1_max_0_e9300000() {
    // Thumb encoding (32): 0xE9300000
    // Test aarch32_LDMDB_T1_A field W = 1 (Max)
    // ISET: T32
    // Fields: register_list=0, W=1, Rn=0, P=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE9300000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDMDB_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldmdb_t1_a_field_rn_0_min_0_e9100000() {
    // Thumb encoding (32): 0xE9100000
    // Test aarch32_LDMDB_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: M=0, P=0, Rn=0, W=0, register_list=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE9100000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDMDB_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldmdb_t1_a_field_rn_1_poweroftwo_0_e9110000() {
    // Thumb encoding (32): 0xE9110000
    // Test aarch32_LDMDB_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=1, P=0, register_list=0, W=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE9110000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDMDB_T1_A
/// ASL: `field P 15 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldmdb_t1_a_field_p_0_min_0_e9100000() {
    // Thumb encoding (32): 0xE9100000
    // Test aarch32_LDMDB_T1_A field P = 0 (Min)
    // ISET: T32
    // Fields: P=0, register_list=0, W=0, Rn=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE9100000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDMDB_T1_A
/// ASL: `field P 15 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldmdb_t1_a_field_p_1_max_0_e9108000() {
    // Thumb encoding (32): 0xE9108000
    // Test aarch32_LDMDB_T1_A field P = 1 (Max)
    // ISET: T32
    // Fields: M=0, register_list=0, P=1, W=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE9108000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDMDB_T1_A
/// ASL: `field M 14 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldmdb_t1_a_field_m_0_min_0_e9100000() {
    // Thumb encoding (32): 0xE9100000
    // Test aarch32_LDMDB_T1_A field M = 0 (Min)
    // ISET: T32
    // Fields: M=0, register_list=0, Rn=0, W=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE9100000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDMDB_T1_A
/// ASL: `field M 14 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldmdb_t1_a_field_m_1_max_0_e9104000() {
    // Thumb encoding (32): 0xE9104000
    // Test aarch32_LDMDB_T1_A field M = 1 (Max)
    // ISET: T32
    // Fields: M=1, W=0, P=0, Rn=0, register_list=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE9104000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDMDB_T1_A
/// ASL: `field register_list 0 +: 14`
/// Requirement: FieldBoundary { field: "register_list", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldmdb_t1_a_field_register_list_0_min_0_e9100000() {
    // Thumb encoding (32): 0xE9100000
    // Test aarch32_LDMDB_T1_A field register_list = 0 (Min)
    // ISET: T32
    // Fields: P=0, M=0, register_list=0, Rn=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE9100000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDMDB_T1_A
/// ASL: `field register_list 0 +: 14`
/// Requirement: FieldBoundary { field: "register_list", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_ldmdb_t1_a_field_register_list_1_poweroftwo_0_e9100001() {
    // Thumb encoding (32): 0xE9100001
    // Test aarch32_LDMDB_T1_A field register_list = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: W=0, M=0, register_list=1, Rn=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE9100001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDMDB_T1_A
/// ASL: `field register_list 0 +: 14`
/// Requirement: FieldBoundary { field: "register_list", value: 8191, boundary: PowerOfTwoMinusOne }
/// midpoint (8191)
#[test]
fn test_aarch32_ldmdb_t1_a_field_register_list_8191_poweroftwominusone_0_e9101fff() {
    // Thumb encoding (32): 0xE9101FFF
    // Test aarch32_LDMDB_T1_A field register_list = 8191 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: P=0, register_list=8191, Rn=0, W=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE9101FFF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDMDB_T1_A
/// ASL: `field register_list 0 +: 14`
/// Requirement: FieldBoundary { field: "register_list", value: 16383, boundary: Max }
/// maximum value (16383)
#[test]
fn test_aarch32_ldmdb_t1_a_field_register_list_16383_max_0_e9103fff() {
    // Thumb encoding (32): 0xE9103FFF
    // Test aarch32_LDMDB_T1_A field register_list = 16383 (Max)
    // ISET: T32
    // Fields: M=0, register_list=16383, Rn=0, W=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE9103FFF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDMDB_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// W=0 (minimum value)
#[test]
fn test_aarch32_ldmdb_t1_a_combo_0_0_e9100000() {
    // Thumb encoding (32): 0xE9100000
    // Test aarch32_LDMDB_T1_A field combination: W=0, Rn=0, P=0, M=0, register_list=0
    // ISET: T32
    // Fields: M=0, register_list=0, W=0, Rn=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE9100000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDMDB_T1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: Binary { op: Or, lhs: LitInt(15), rhs: Binary { op: Lt, lhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "BitCount" }, args: [Var(QualifiedIdentifier { qualifier: Any, name: "registers" })] }, rhs: LitInt(2) } }, rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "P" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "M" }) } }, rhs: LitBits([true]) } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: Binary { op: Or, lhs: LitInt(15), rhs: Binary { op: Lt, lhs: Call { name: QualifiedIdentifier { qualifier: Any, name: \"BitCount\" }, args: [Var(QualifiedIdentifier { qualifier: Any, name: \"registers\" })] }, rhs: LitInt(2) } }, rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"P\" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"M\" }) } }, rhs: LitBits([true]) } } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldmdb_t1_a_invalid_0_0_e9100000() {
    // Thumb encoding (32): 0xE9100000
    // Test aarch32_LDMDB_T1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: Binary { op: Or, lhs: LitInt(15), rhs: Binary { op: Lt, lhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "BitCount" }, args: [Var(QualifiedIdentifier { qualifier: Any, name: "registers" })] }, rhs: LitInt(2) } }, rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "P" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "M" }) } }, rhs: LitBits([true]) } } }
    // ISET: T32
    // Fields: Rn=0, W=0, P=0, M=0, register_list=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE9100000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_LDMDB_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldmdb_t1_a_invalid_1_0_e9100000() {
    // Thumb encoding (32): 0xE9100000
    // Test aarch32_LDMDB_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: P=0, register_list=0, W=0, Rn=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE9100000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_LDMDB_T1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "registers" }), indices: [Single(Var(QualifiedIdentifier { qualifier: Any, name: "n" }))] } }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"wback\" }), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"registers\" }), indices: [Single(Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }))] } }, rhs: LitBits([true]) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldmdb_t1_a_invalid_2_0_e9100000() {
    // Thumb encoding (32): 0xE9100000
    // Test aarch32_LDMDB_T1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "registers" }), indices: [Single(Var(QualifiedIdentifier { qualifier: Any, name: "n" }))] } }, rhs: LitBits([true]) }
    // ISET: T32
    // Fields: M=0, Rn=0, P=0, register_list=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE9100000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_LDMDB_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldmdb_t1_a_invalid_3_0_e9100000() {
    // Thumb encoding (32): 0xE9100000
    // Test aarch32_LDMDB_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rn=0, P=0, W=0, M=0, register_list=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE9100000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_LDMDB_T1_A
/// ASL: `Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "registers" }), indices: [Single(LitInt(13))] }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"registers\" }), indices: [Single(LitInt(13))] }, rhs: LitBits([true]) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldmdb_t1_a_invalid_4_0_e9100000() {
    // Thumb encoding (32): 0xE9100000
    // Test aarch32_LDMDB_T1_A invalid encoding: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "registers" }), indices: [Single(LitInt(13))] }, rhs: LitBits([true]) }
    // ISET: T32
    // Fields: P=0, W=0, M=0, register_list=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE9100000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_LDMDB_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldmdb_t1_a_invalid_5_0_e9100000() {
    // Thumb encoding (32): 0xE9100000
    // Test aarch32_LDMDB_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: P=0, W=0, Rn=0, M=0, register_list=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE9100000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_LDMDB_T1_A
/// ASL: `Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "registers" }), indices: [Single(LitInt(15))] }, rhs: Binary { op: And, lhs: Binary { op: And, lhs: LitBits([true]), rhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] } }, rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "LastInITBlock" }, args: [] } } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"registers\" }), indices: [Single(LitInt(15))] }, rhs: Binary { op: And, lhs: Binary { op: And, lhs: LitBits([true]), rhs: Call { name: QualifiedIdentifier { qualifier: Any, name: \"InITBlock\" }, args: [] } }, rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"LastInITBlock\" }, args: [] } } } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldmdb_t1_a_invalid_6_0_e9100000() {
    // Thumb encoding (32): 0xE9100000
    // Test aarch32_LDMDB_T1_A invalid encoding: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "registers" }), indices: [Single(LitInt(15))] }, rhs: Binary { op: And, lhs: Binary { op: And, lhs: LitBits([true]), rhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] } }, rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "LastInITBlock" }, args: [] } } } }
    // ISET: T32
    // Fields: P=0, Rn=0, M=0, W=0, register_list=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE9100000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_LDMDB_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldmdb_t1_a_invalid_7_0_e9100000() {
    // Thumb encoding (32): 0xE9100000
    // Test aarch32_LDMDB_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rn=0, W=0, P=0, register_list=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE9100000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

// ============================================================================
// aarch32_LDAEX_A Tests
// ============================================================================

/// Provenance: aarch32_LDAEX_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_ldaex_a1_a_field_cond_0_min_290_01900290() {
    // Encoding: 0x01900290
    // Test aarch32_LDAEX_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: Rt=0, Rn=0, cond=0
    let encoding: u32 = 0x01900290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEX_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_ldaex_a1_a_field_cond_1_poweroftwo_290_11900290() {
    // Encoding: 0x11900290
    // Test aarch32_LDAEX_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=1, Rn=0, Rt=0
    let encoding: u32 = 0x11900290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEX_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_ldaex_a1_a_field_cond_2_poweroftwo_290_21900290() {
    // Encoding: 0x21900290
    // Test aarch32_LDAEX_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=2, Rn=0, Rt=0
    let encoding: u32 = 0x21900290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEX_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_ldaex_a1_a_field_cond_3_poweroftwo_290_31900290() {
    // Encoding: 0x31900290
    // Test aarch32_LDAEX_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, cond=3, Rn=0
    let encoding: u32 = 0x31900290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEX_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_ldaex_a1_a_field_cond_4_poweroftwo_290_41900290() {
    // Encoding: 0x41900290
    // Test aarch32_LDAEX_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=4, Rt=0
    let encoding: u32 = 0x41900290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEX_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_ldaex_a1_a_field_cond_5_poweroftwo_290_51900290() {
    // Encoding: 0x51900290
    // Test aarch32_LDAEX_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=5
    let encoding: u32 = 0x51900290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEX_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_ldaex_a1_a_field_cond_6_poweroftwo_290_61900290() {
    // Encoding: 0x61900290
    // Test aarch32_LDAEX_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=6
    let encoding: u32 = 0x61900290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEX_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_ldaex_a1_a_field_cond_7_poweroftwo_290_71900290() {
    // Encoding: 0x71900290
    // Test aarch32_LDAEX_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=7, Rn=0, Rt=0
    let encoding: u32 = 0x71900290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEX_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_ldaex_a1_a_field_cond_8_poweroftwo_290_81900290() {
    // Encoding: 0x81900290
    // Test aarch32_LDAEX_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, cond=8, Rn=0
    let encoding: u32 = 0x81900290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEX_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_ldaex_a1_a_field_cond_9_poweroftwo_290_91900290() {
    // Encoding: 0x91900290
    // Test aarch32_LDAEX_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=9, Rt=0
    let encoding: u32 = 0x91900290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEX_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_ldaex_a1_a_field_cond_10_poweroftwo_290_a1900290() {
    // Encoding: 0xA1900290
    // Test aarch32_LDAEX_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, Rn=0, cond=10
    let encoding: u32 = 0xA1900290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEX_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_ldaex_a1_a_field_cond_11_poweroftwo_290_b1900290() {
    // Encoding: 0xB1900290
    // Test aarch32_LDAEX_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=11, Rn=0, Rt=0
    let encoding: u32 = 0xB1900290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEX_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_ldaex_a1_a_field_cond_12_poweroftwo_290_c1900290() {
    // Encoding: 0xC1900290
    // Test aarch32_LDAEX_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=12, Rn=0, Rt=0
    let encoding: u32 = 0xC1900290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEX_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_ldaex_a1_a_field_cond_13_poweroftwo_290_d1900290() {
    // Encoding: 0xD1900290
    // Test aarch32_LDAEX_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=13
    let encoding: u32 = 0xD1900290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEX_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_ldaex_a1_a_field_cond_14_poweroftwo_290_e1900290() {
    // Encoding: 0xE1900290
    // Test aarch32_LDAEX_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=14, Rn=0, Rt=0
    let encoding: u32 = 0xE1900290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEX_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_ldaex_a1_a_field_cond_15_max_290_f1900290() {
    // Encoding: 0xF1900290
    // Test aarch32_LDAEX_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=15
    let encoding: u32 = 0xF1900290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEX_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldaex_a1_a_field_rn_0_min_290_01900290() {
    // Encoding: 0x01900290
    // Test aarch32_LDAEX_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=0
    let encoding: u32 = 0x01900290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEX_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldaex_a1_a_field_rn_1_poweroftwo_290_01910290() {
    // Encoding: 0x01910290
    // Test aarch32_LDAEX_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Rt=0, Rn=1
    let encoding: u32 = 0x01910290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEX_A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldaex_a1_a_field_rt_0_min_290_01900290() {
    // Encoding: 0x01900290
    // Test aarch32_LDAEX_A1_A field Rt = 0 (Min)
    // ISET: A32
    // Fields: Rt=0, cond=0, Rn=0
    let encoding: u32 = 0x01900290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEX_A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldaex_a1_a_field_rt_1_poweroftwo_290_01901290() {
    // Encoding: 0x01901290
    // Test aarch32_LDAEX_A1_A field Rt = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Rn=0, Rt=1
    let encoding: u32 = 0x01901290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEX_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_ldaex_a1_a_combo_0_290_01900290() {
    // Encoding: 0x01900290
    // Test aarch32_LDAEX_A1_A field combination: cond=0, Rn=0, Rt=0
    // ISET: A32
    // Fields: cond=0, Rn=0, Rt=0
    let encoding: u32 = 0x01900290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEX_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_ldaex_a1_a_special_cond_0_condition_eq_656_01900290() {
    // Encoding: 0x01900290
    // Test aarch32_LDAEX_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: cond=0, Rn=0, Rt=0
    let encoding: u32 = 0x01900290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEX_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_ldaex_a1_a_special_cond_1_condition_ne_656_11900290() {
    // Encoding: 0x11900290
    // Test aarch32_LDAEX_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: Rn=0, cond=1, Rt=0
    let encoding: u32 = 0x11900290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEX_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_ldaex_a1_a_special_cond_2_condition_cs_hs_656_21900290() {
    // Encoding: 0x21900290
    // Test aarch32_LDAEX_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: Rt=0, Rn=0, cond=2
    let encoding: u32 = 0x21900290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEX_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_ldaex_a1_a_special_cond_3_condition_cc_lo_656_31900290() {
    // Encoding: 0x31900290
    // Test aarch32_LDAEX_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: cond=3, Rn=0, Rt=0
    let encoding: u32 = 0x31900290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEX_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_ldaex_a1_a_special_cond_4_condition_mi_656_41900290() {
    // Encoding: 0x41900290
    // Test aarch32_LDAEX_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: Rt=0, cond=4, Rn=0
    let encoding: u32 = 0x41900290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEX_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_ldaex_a1_a_special_cond_5_condition_pl_656_51900290() {
    // Encoding: 0x51900290
    // Test aarch32_LDAEX_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: Rn=0, cond=5, Rt=0
    let encoding: u32 = 0x51900290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEX_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_ldaex_a1_a_special_cond_6_condition_vs_656_61900290() {
    // Encoding: 0x61900290
    // Test aarch32_LDAEX_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: Rn=0, cond=6, Rt=0
    let encoding: u32 = 0x61900290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEX_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_ldaex_a1_a_special_cond_7_condition_vc_656_71900290() {
    // Encoding: 0x71900290
    // Test aarch32_LDAEX_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=7
    let encoding: u32 = 0x71900290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEX_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_ldaex_a1_a_special_cond_8_condition_hi_656_81900290() {
    // Encoding: 0x81900290
    // Test aarch32_LDAEX_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: cond=8, Rt=0, Rn=0
    let encoding: u32 = 0x81900290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEX_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_ldaex_a1_a_special_cond_9_condition_ls_656_91900290() {
    // Encoding: 0x91900290
    // Test aarch32_LDAEX_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: Rn=0, cond=9, Rt=0
    let encoding: u32 = 0x91900290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEX_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_ldaex_a1_a_special_cond_10_condition_ge_656_a1900290() {
    // Encoding: 0xA1900290
    // Test aarch32_LDAEX_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: cond=10, Rt=0, Rn=0
    let encoding: u32 = 0xA1900290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEX_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_ldaex_a1_a_special_cond_11_condition_lt_656_b1900290() {
    // Encoding: 0xB1900290
    // Test aarch32_LDAEX_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: cond=11, Rt=0, Rn=0
    let encoding: u32 = 0xB1900290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEX_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_ldaex_a1_a_special_cond_12_condition_gt_656_c1900290() {
    // Encoding: 0xC1900290
    // Test aarch32_LDAEX_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=12
    let encoding: u32 = 0xC1900290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEX_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_ldaex_a1_a_special_cond_13_condition_le_656_d1900290() {
    // Encoding: 0xD1900290
    // Test aarch32_LDAEX_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: cond=13, Rn=0, Rt=0
    let encoding: u32 = 0xD1900290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEX_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_ldaex_a1_a_special_cond_14_condition_al_656_e1900290() {
    // Encoding: 0xE1900290
    // Test aarch32_LDAEX_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: Rt=0, cond=14, Rn=0
    let encoding: u32 = 0xE1900290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEX_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_ldaex_a1_a_special_cond_15_condition_nv_656_f1900290() {
    // Encoding: 0xF1900290
    // Test aarch32_LDAEX_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: cond=15, Rn=0, Rt=0
    let encoding: u32 = 0xF1900290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDAEX_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldaex_a1_a_invalid_0_290_01900290() {
    // Encoding: 0x01900290
    // Test aarch32_LDAEX_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }
    // ISET: A32
    // Fields: Rt=0, cond=0, Rn=0
    let encoding: u32 = 0x01900290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDAEX_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldaex_a1_a_invalid_1_290_01900290() {
    // Encoding: 0x01900290
    // Test aarch32_LDAEX_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: cond=0, Rn=0, Rt=0
    let encoding: u32 = 0x01900290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDAEX_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldaex_t1_a_field_rn_0_min_e0_e8d000e0() {
    // Thumb encoding (32): 0xE8D000E0
    // Test aarch32_LDAEX_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8D000E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDAEX_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldaex_t1_a_field_rn_1_poweroftwo_e0_e8d100e0() {
    // Thumb encoding (32): 0xE8D100E0
    // Test aarch32_LDAEX_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, Rn=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8D100E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDAEX_T1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldaex_t1_a_field_rt_0_min_e0_e8d000e0() {
    // Thumb encoding (32): 0xE8D000E0
    // Test aarch32_LDAEX_T1_A field Rt = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8D000E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDAEX_T1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldaex_t1_a_field_rt_1_poweroftwo_e0_e8d010e0() {
    // Thumb encoding (32): 0xE8D010E0
    // Test aarch32_LDAEX_T1_A field Rt = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=1, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8D010E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDAEX_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_ldaex_t1_a_combo_0_e0_e8d000e0() {
    // Thumb encoding (32): 0xE8D000E0
    // Test aarch32_LDAEX_T1_A field combination: Rn=0, Rt=0
    // ISET: T32
    // Fields: Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8D000E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDAEX_T1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldaex_t1_a_invalid_0_e0_e8d000e0() {
    // Thumb encoding (32): 0xE8D000E0
    // Test aarch32_LDAEX_T1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }
    // ISET: T32
    // Fields: Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8D000E0;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_LDAEX_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldaex_t1_a_invalid_1_e0_e8d000e0() {
    // Thumb encoding (32): 0xE8D000E0
    // Test aarch32_LDAEX_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8D000E0;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

// ============================================================================
// aarch32_LDM_u_AS Tests
// ============================================================================

/// Provenance: aarch32_LDM_u_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_ldm_u_a1_as_field_cond_0_min_0_08500000() {
    // Encoding: 0x08500000
    // Test aarch32_LDM_u_A1_AS field cond = 0 (Min)
    // ISET: A32
    // Fields: U=0, Rn=0, register_list=0, cond=0, P=0
    let encoding: u32 = 0x08500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_u_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_ldm_u_a1_as_field_cond_1_poweroftwo_0_18500000() {
    // Encoding: 0x18500000
    // Test aarch32_LDM_u_A1_AS field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: register_list=0, U=0, P=0, cond=1, Rn=0
    let encoding: u32 = 0x18500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_u_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_ldm_u_a1_as_field_cond_2_poweroftwo_0_28500000() {
    // Encoding: 0x28500000
    // Test aarch32_LDM_u_A1_AS field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, register_list=0, cond=2, P=0, U=0
    let encoding: u32 = 0x28500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_u_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_ldm_u_a1_as_field_cond_3_poweroftwo_0_38500000() {
    // Encoding: 0x38500000
    // Test aarch32_LDM_u_A1_AS field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, P=0, register_list=0, cond=3, Rn=0
    let encoding: u32 = 0x38500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_u_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_ldm_u_a1_as_field_cond_4_poweroftwo_0_48500000() {
    // Encoding: 0x48500000
    // Test aarch32_LDM_u_A1_AS field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: register_list=0, Rn=0, cond=4, U=0, P=0
    let encoding: u32 = 0x48500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_u_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_ldm_u_a1_as_field_cond_5_poweroftwo_0_58500000() {
    // Encoding: 0x58500000
    // Test aarch32_LDM_u_A1_AS field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: register_list=0, U=0, cond=5, Rn=0, P=0
    let encoding: u32 = 0x58500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_u_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_ldm_u_a1_as_field_cond_6_poweroftwo_0_68500000() {
    // Encoding: 0x68500000
    // Test aarch32_LDM_u_A1_AS field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=6, register_list=0, U=0, P=0
    let encoding: u32 = 0x68500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_u_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_ldm_u_a1_as_field_cond_7_poweroftwo_0_78500000() {
    // Encoding: 0x78500000
    // Test aarch32_LDM_u_A1_AS field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=7, Rn=0, P=0, register_list=0, U=0
    let encoding: u32 = 0x78500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_u_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_ldm_u_a1_as_field_cond_8_poweroftwo_0_88500000() {
    // Encoding: 0x88500000
    // Test aarch32_LDM_u_A1_AS field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=8, U=0, Rn=0, register_list=0, P=0
    let encoding: u32 = 0x88500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_u_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_ldm_u_a1_as_field_cond_9_poweroftwo_0_98500000() {
    // Encoding: 0x98500000
    // Test aarch32_LDM_u_A1_AS field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=9, P=0, Rn=0, register_list=0, U=0
    let encoding: u32 = 0x98500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_u_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_ldm_u_a1_as_field_cond_10_poweroftwo_0_a8500000() {
    // Encoding: 0xA8500000
    // Test aarch32_LDM_u_A1_AS field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, U=0, cond=10, Rn=0, register_list=0
    let encoding: u32 = 0xA8500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_u_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_ldm_u_a1_as_field_cond_11_poweroftwo_0_b8500000() {
    // Encoding: 0xB8500000
    // Test aarch32_LDM_u_A1_AS field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=11, Rn=0, register_list=0, U=0, P=0
    let encoding: u32 = 0xB8500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_u_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_ldm_u_a1_as_field_cond_12_poweroftwo_0_c8500000() {
    // Encoding: 0xC8500000
    // Test aarch32_LDM_u_A1_AS field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=12, P=0, Rn=0, register_list=0, U=0
    let encoding: u32 = 0xC8500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_u_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_ldm_u_a1_as_field_cond_13_poweroftwo_0_d8500000() {
    // Encoding: 0xD8500000
    // Test aarch32_LDM_u_A1_AS field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: register_list=0, U=0, cond=13, P=0, Rn=0
    let encoding: u32 = 0xD8500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_u_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_ldm_u_a1_as_field_cond_14_poweroftwo_0_e8500000() {
    // Encoding: 0xE8500000
    // Test aarch32_LDM_u_A1_AS field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: register_list=0, P=0, U=0, cond=14, Rn=0
    let encoding: u32 = 0xE8500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_u_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_ldm_u_a1_as_field_cond_15_max_0_f8500000() {
    // Encoding: 0xF8500000
    // Test aarch32_LDM_u_A1_AS field cond = 15 (Max)
    // ISET: A32
    // Fields: register_list=0, cond=15, U=0, Rn=0, P=0
    let encoding: u32 = 0xF8500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_u_A1_AS
/// ASL: `field P 24 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldm_u_a1_as_field_p_0_min_0_08500000() {
    // Encoding: 0x08500000
    // Test aarch32_LDM_u_A1_AS field P = 0 (Min)
    // ISET: A32
    // Fields: P=0, cond=0, Rn=0, register_list=0, U=0
    let encoding: u32 = 0x08500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_u_A1_AS
/// ASL: `field P 24 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldm_u_a1_as_field_p_1_max_0_09500000() {
    // Encoding: 0x09500000
    // Test aarch32_LDM_u_A1_AS field P = 1 (Max)
    // ISET: A32
    // Fields: register_list=0, cond=0, U=0, P=1, Rn=0
    let encoding: u32 = 0x09500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_u_A1_AS
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldm_u_a1_as_field_u_0_min_0_08500000() {
    // Encoding: 0x08500000
    // Test aarch32_LDM_u_A1_AS field U = 0 (Min)
    // ISET: A32
    // Fields: cond=0, P=0, Rn=0, U=0, register_list=0
    let encoding: u32 = 0x08500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_u_A1_AS
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldm_u_a1_as_field_u_1_max_0_08d00000() {
    // Encoding: 0x08D00000
    // Test aarch32_LDM_u_A1_AS field U = 1 (Max)
    // ISET: A32
    // Fields: cond=0, register_list=0, P=0, U=1, Rn=0
    let encoding: u32 = 0x08D00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_u_A1_AS
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldm_u_a1_as_field_rn_0_min_0_08500000() {
    // Encoding: 0x08500000
    // Test aarch32_LDM_u_A1_AS field Rn = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, U=0, cond=0, P=0, register_list=0
    let encoding: u32 = 0x08500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_u_A1_AS
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldm_u_a1_as_field_rn_1_poweroftwo_0_08510000() {
    // Encoding: 0x08510000
    // Test aarch32_LDM_u_A1_AS field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, P=0, Rn=1, cond=0, register_list=0
    let encoding: u32 = 0x08510000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_u_A1_AS
/// ASL: `field register_list 0 +: 15`
/// Requirement: FieldBoundary { field: "register_list", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldm_u_a1_as_field_register_list_0_min_0_08500000() {
    // Encoding: 0x08500000
    // Test aarch32_LDM_u_A1_AS field register_list = 0 (Min)
    // ISET: A32
    // Fields: P=0, U=0, cond=0, Rn=0, register_list=0
    let encoding: u32 = 0x08500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_u_A1_AS
/// ASL: `field register_list 0 +: 15`
/// Requirement: FieldBoundary { field: "register_list", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_ldm_u_a1_as_field_register_list_1_poweroftwo_0_08500001() {
    // Encoding: 0x08500001
    // Test aarch32_LDM_u_A1_AS field register_list = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Rn=0, P=0, U=0, register_list=1
    let encoding: u32 = 0x08500001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_u_A1_AS
/// ASL: `field register_list 0 +: 15`
/// Requirement: FieldBoundary { field: "register_list", value: 16383, boundary: PowerOfTwoMinusOne }
/// midpoint (16383)
#[test]
fn test_aarch32_ldm_u_a1_as_field_register_list_16383_poweroftwominusone_0_08503fff() {
    // Encoding: 0x08503FFF
    // Test aarch32_LDM_u_A1_AS field register_list = 16383 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: U=0, P=0, cond=0, Rn=0, register_list=16383
    let encoding: u32 = 0x08503FFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_u_A1_AS
/// ASL: `field register_list 0 +: 15`
/// Requirement: FieldBoundary { field: "register_list", value: 32767, boundary: Max }
/// maximum value (32767)
#[test]
fn test_aarch32_ldm_u_a1_as_field_register_list_32767_max_0_08507fff() {
    // Encoding: 0x08507FFF
    // Test aarch32_LDM_u_A1_AS field register_list = 32767 (Max)
    // ISET: A32
    // Fields: cond=0, Rn=0, U=0, register_list=32767, P=0
    let encoding: u32 = 0x08507FFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_u_A1_AS
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_ldm_u_a1_as_combo_0_0_08500000() {
    // Encoding: 0x08500000
    // Test aarch32_LDM_u_A1_AS field combination: cond=0, P=0, U=0, Rn=0, register_list=0
    // ISET: A32
    // Fields: register_list=0, U=0, Rn=0, cond=0, P=0
    let encoding: u32 = 0x08500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_u_A1_AS
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_ldm_u_a1_as_special_cond_0_condition_eq_0_08500000() {
    // Encoding: 0x08500000
    // Test aarch32_LDM_u_A1_AS special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: P=0, cond=0, register_list=0, Rn=0, U=0
    let encoding: u32 = 0x08500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_u_A1_AS
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_ldm_u_a1_as_special_cond_1_condition_ne_0_18500000() {
    // Encoding: 0x18500000
    // Test aarch32_LDM_u_A1_AS special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: U=0, register_list=0, P=0, cond=1, Rn=0
    let encoding: u32 = 0x18500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_u_A1_AS
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_ldm_u_a1_as_special_cond_2_condition_cs_hs_0_28500000() {
    // Encoding: 0x28500000
    // Test aarch32_LDM_u_A1_AS special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: Rn=0, U=0, register_list=0, cond=2, P=0
    let encoding: u32 = 0x28500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_u_A1_AS
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_ldm_u_a1_as_special_cond_3_condition_cc_lo_0_38500000() {
    // Encoding: 0x38500000
    // Test aarch32_LDM_u_A1_AS special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: U=0, register_list=0, cond=3, P=0, Rn=0
    let encoding: u32 = 0x38500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_u_A1_AS
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_ldm_u_a1_as_special_cond_4_condition_mi_0_48500000() {
    // Encoding: 0x48500000
    // Test aarch32_LDM_u_A1_AS special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: Rn=0, register_list=0, cond=4, U=0, P=0
    let encoding: u32 = 0x48500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_u_A1_AS
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_ldm_u_a1_as_special_cond_5_condition_pl_0_58500000() {
    // Encoding: 0x58500000
    // Test aarch32_LDM_u_A1_AS special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: Rn=0, P=0, cond=5, register_list=0, U=0
    let encoding: u32 = 0x58500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_u_A1_AS
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_ldm_u_a1_as_special_cond_6_condition_vs_0_68500000() {
    // Encoding: 0x68500000
    // Test aarch32_LDM_u_A1_AS special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: cond=6, register_list=0, U=0, P=0, Rn=0
    let encoding: u32 = 0x68500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_u_A1_AS
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_ldm_u_a1_as_special_cond_7_condition_vc_0_78500000() {
    // Encoding: 0x78500000
    // Test aarch32_LDM_u_A1_AS special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: register_list=0, U=0, P=0, cond=7, Rn=0
    let encoding: u32 = 0x78500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_u_A1_AS
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_ldm_u_a1_as_special_cond_8_condition_hi_0_88500000() {
    // Encoding: 0x88500000
    // Test aarch32_LDM_u_A1_AS special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: register_list=0, cond=8, U=0, P=0, Rn=0
    let encoding: u32 = 0x88500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_u_A1_AS
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_ldm_u_a1_as_special_cond_9_condition_ls_0_98500000() {
    // Encoding: 0x98500000
    // Test aarch32_LDM_u_A1_AS special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: register_list=0, cond=9, Rn=0, U=0, P=0
    let encoding: u32 = 0x98500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_u_A1_AS
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_ldm_u_a1_as_special_cond_10_condition_ge_0_a8500000() {
    // Encoding: 0xA8500000
    // Test aarch32_LDM_u_A1_AS special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: P=0, U=0, cond=10, Rn=0, register_list=0
    let encoding: u32 = 0xA8500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_u_A1_AS
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_ldm_u_a1_as_special_cond_11_condition_lt_0_b8500000() {
    // Encoding: 0xB8500000
    // Test aarch32_LDM_u_A1_AS special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: P=0, register_list=0, cond=11, U=0, Rn=0
    let encoding: u32 = 0xB8500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_u_A1_AS
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_ldm_u_a1_as_special_cond_12_condition_gt_0_c8500000() {
    // Encoding: 0xC8500000
    // Test aarch32_LDM_u_A1_AS special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: cond=12, Rn=0, register_list=0, U=0, P=0
    let encoding: u32 = 0xC8500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_u_A1_AS
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_ldm_u_a1_as_special_cond_13_condition_le_0_d8500000() {
    // Encoding: 0xD8500000
    // Test aarch32_LDM_u_A1_AS special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: register_list=0, Rn=0, cond=13, U=0, P=0
    let encoding: u32 = 0xD8500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_u_A1_AS
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_ldm_u_a1_as_special_cond_14_condition_al_0_e8500000() {
    // Encoding: 0xE8500000
    // Test aarch32_LDM_u_A1_AS special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: Rn=0, U=0, cond=14, P=0, register_list=0
    let encoding: u32 = 0xE8500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_u_A1_AS
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_ldm_u_a1_as_special_cond_15_condition_nv_0_f8500000() {
    // Encoding: 0xF8500000
    // Test aarch32_LDM_u_A1_AS special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: cond=15, P=0, Rn=0, register_list=0, U=0
    let encoding: u32 = 0xF8500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDM_u_A1_AS
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Binary { op: Lt, lhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "BitCount" }, args: [Var(QualifiedIdentifier { qualifier: Any, name: "registers" })] }, rhs: LitInt(1) } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Binary { op: Lt, lhs: Call { name: QualifiedIdentifier { qualifier: Any, name: \"BitCount\" }, args: [Var(QualifiedIdentifier { qualifier: Any, name: \"registers\" })] }, rhs: LitInt(1) } } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldm_u_a1_as_invalid_0_0_08500000() {
    // Encoding: 0x08500000
    // Test aarch32_LDM_u_A1_AS invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Binary { op: Lt, lhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "BitCount" }, args: [Var(QualifiedIdentifier { qualifier: Any, name: "registers" })] }, rhs: LitInt(1) } } }
    // ISET: A32
    // Fields: U=0, cond=0, Rn=0, register_list=0, P=0
    let encoding: u32 = 0x08500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDM_u_A1_AS
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldm_u_a1_as_invalid_1_0_08500000() {
    // Encoding: 0x08500000
    // Test aarch32_LDM_u_A1_AS invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: cond=0, P=0, Rn=0, register_list=0, U=0
    let encoding: u32 = 0x08500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDM_u_A1_AS
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Undefined
#[test]
fn test_aarch32_ldm_u_a1_as_exception_0_08500000() {
    // Test aarch32_LDM_u_A1_AS exception: Undefined
    // Encoding: 0x08500000
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x08500000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_LDM_u_A1_AS
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldm_u_a1_as_exception_1_08500000() {
    // Test aarch32_LDM_u_A1_AS exception: Unpredictable
    // Encoding: 0x08500000
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x08500000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// aarch32_LDRT_A Tests
// ============================================================================

/// Provenance: aarch32_LDRT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_ldrt_a1_a_field_cond_0_min_0_04300000() {
    // Encoding: 0x04300000
    // Test aarch32_LDRT_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: Rt=0, cond=0, U=0, Rn=0, imm12=0
    let encoding: u32 = 0x04300000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_ldrt_a1_a_field_cond_1_poweroftwo_0_14300000() {
    // Encoding: 0x14300000
    // Test aarch32_LDRT_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, U=0, imm12=0, Rn=0, cond=1
    let encoding: u32 = 0x14300000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_ldrt_a1_a_field_cond_2_poweroftwo_0_24300000() {
    // Encoding: 0x24300000
    // Test aarch32_LDRT_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=0, U=0, Rn=0, Rt=0, cond=2
    let encoding: u32 = 0x24300000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_ldrt_a1_a_field_cond_3_poweroftwo_0_34300000() {
    // Encoding: 0x34300000
    // Test aarch32_LDRT_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, imm12=0, cond=3, Rn=0, U=0
    let encoding: u32 = 0x34300000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_ldrt_a1_a_field_cond_4_poweroftwo_0_44300000() {
    // Encoding: 0x44300000
    // Test aarch32_LDRT_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, imm12=0, Rt=0, cond=4, Rn=0
    let encoding: u32 = 0x44300000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_ldrt_a1_a_field_cond_5_poweroftwo_0_54300000() {
    // Encoding: 0x54300000
    // Test aarch32_LDRT_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, U=0, imm12=0, Rn=0, cond=5
    let encoding: u32 = 0x54300000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_ldrt_a1_a_field_cond_6_poweroftwo_0_64300000() {
    // Encoding: 0x64300000
    // Test aarch32_LDRT_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=6, Rt=0, imm12=0, U=0, Rn=0
    let encoding: u32 = 0x64300000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_ldrt_a1_a_field_cond_7_poweroftwo_0_74300000() {
    // Encoding: 0x74300000
    // Test aarch32_LDRT_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, Rt=0, imm12=0, cond=7, Rn=0
    let encoding: u32 = 0x74300000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_ldrt_a1_a_field_cond_8_poweroftwo_0_84300000() {
    // Encoding: 0x84300000
    // Test aarch32_LDRT_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=0, cond=8, U=0, Rn=0, Rt=0
    let encoding: u32 = 0x84300000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_ldrt_a1_a_field_cond_9_poweroftwo_0_94300000() {
    // Encoding: 0x94300000
    // Test aarch32_LDRT_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, cond=9, U=0, imm12=0, Rn=0
    let encoding: u32 = 0x94300000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_ldrt_a1_a_field_cond_10_poweroftwo_0_a4300000() {
    // Encoding: 0xA4300000
    // Test aarch32_LDRT_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=0, U=0, Rt=0, Rn=0, cond=10
    let encoding: u32 = 0xA4300000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_ldrt_a1_a_field_cond_11_poweroftwo_0_b4300000() {
    // Encoding: 0xB4300000
    // Test aarch32_LDRT_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=11, U=0, imm12=0, Rt=0, Rn=0
    let encoding: u32 = 0xB4300000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_ldrt_a1_a_field_cond_12_poweroftwo_0_c4300000() {
    // Encoding: 0xC4300000
    // Test aarch32_LDRT_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=12, U=0, Rt=0, Rn=0, imm12=0
    let encoding: u32 = 0xC4300000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_ldrt_a1_a_field_cond_13_poweroftwo_0_d4300000() {
    // Encoding: 0xD4300000
    // Test aarch32_LDRT_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, cond=13, Rt=0, Rn=0, imm12=0
    let encoding: u32 = 0xD4300000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_ldrt_a1_a_field_cond_14_poweroftwo_0_e4300000() {
    // Encoding: 0xE4300000
    // Test aarch32_LDRT_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, cond=14, Rn=0, imm12=0, Rt=0
    let encoding: u32 = 0xE4300000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_ldrt_a1_a_field_cond_15_max_0_f4300000() {
    // Encoding: 0xF4300000
    // Test aarch32_LDRT_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: Rt=0, imm12=0, Rn=0, U=0, cond=15
    let encoding: u32 = 0xF4300000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldrt_a1_a_field_u_0_min_0_04300000() {
    // Encoding: 0x04300000
    // Test aarch32_LDRT_A1_A field U = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rt=0, U=0, Rn=0, imm12=0
    let encoding: u32 = 0x04300000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldrt_a1_a_field_u_1_max_0_04b00000() {
    // Encoding: 0x04B00000
    // Test aarch32_LDRT_A1_A field U = 1 (Max)
    // ISET: A32
    // Fields: cond=0, Rn=0, imm12=0, U=1, Rt=0
    let encoding: u32 = 0x04B00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrt_a1_a_field_rn_0_min_0_04300000() {
    // Encoding: 0x04300000
    // Test aarch32_LDRT_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, imm12=0, cond=0, Rt=0, U=0
    let encoding: u32 = 0x04300000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrt_a1_a_field_rn_1_poweroftwo_0_04310000() {
    // Encoding: 0x04310000
    // Test aarch32_LDRT_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=1, Rt=0, imm12=0, cond=0, U=0
    let encoding: u32 = 0x04310000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrt_a1_a_field_rt_0_min_0_04300000() {
    // Encoding: 0x04300000
    // Test aarch32_LDRT_A1_A field Rt = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, imm12=0, Rt=0, cond=0, U=0
    let encoding: u32 = 0x04300000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrt_a1_a_field_rt_1_poweroftwo_0_04301000() {
    // Encoding: 0x04301000
    // Test aarch32_LDRT_A1_A field Rt = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=0, Rn=0, U=0, cond=0, Rt=1
    let encoding: u32 = 0x04301000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_ldrt_a1_a_field_imm12_0_zero_0_04300000() {
    // Encoding: 0x04300000
    // Test aarch32_LDRT_A1_A field imm12 = 0 (Zero)
    // ISET: A32
    // Fields: cond=0, Rn=0, U=0, Rt=0, imm12=0
    let encoding: u32 = 0x04300000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_ldrt_a1_a_field_imm12_1_poweroftwo_0_04300001() {
    // Encoding: 0x04300001
    // Test aarch32_LDRT_A1_A field imm12 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=1, Rt=0, cond=0, U=0, Rn=0
    let encoding: u32 = 0x04300001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_ldrt_a1_a_field_imm12_3_poweroftwominusone_0_04300003() {
    // Encoding: 0x04300003
    // Test aarch32_LDRT_A1_A field imm12 = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rt=0, imm12=3, cond=0, U=0, Rn=0
    let encoding: u32 = 0x04300003;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_ldrt_a1_a_field_imm12_4_poweroftwo_0_04300004() {
    // Encoding: 0x04300004
    // Test aarch32_LDRT_A1_A field imm12 = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, Rn=0, imm12=4, cond=0, U=0
    let encoding: u32 = 0x04300004;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_ldrt_a1_a_field_imm12_7_poweroftwominusone_0_04300007() {
    // Encoding: 0x04300007
    // Test aarch32_LDRT_A1_A field imm12 = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, Rn=0, imm12=7, Rt=0, U=0
    let encoding: u32 = 0x04300007;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_ldrt_a1_a_field_imm12_8_poweroftwo_0_04300008() {
    // Encoding: 0x04300008
    // Test aarch32_LDRT_A1_A field imm12 = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=0, imm12=8, U=0
    let encoding: u32 = 0x04300008;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_ldrt_a1_a_field_imm12_15_poweroftwominusone_0_0430000f() {
    // Encoding: 0x0430000F
    // Test aarch32_LDRT_A1_A field imm12 = 15 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rt=0, Rn=0, cond=0, U=0, imm12=15
    let encoding: u32 = 0x0430000F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_ldrt_a1_a_field_imm12_16_poweroftwo_0_04300010() {
    // Encoding: 0x04300010
    // Test aarch32_LDRT_A1_A field imm12 = 16 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=16, Rn=0, Rt=0, U=0, cond=0
    let encoding: u32 = 0x04300010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_ldrt_a1_a_field_imm12_31_poweroftwominusone_0_0430001f() {
    // Encoding: 0x0430001F
    // Test aarch32_LDRT_A1_A field imm12 = 31 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: U=0, imm12=31, cond=0, Rn=0, Rt=0
    let encoding: u32 = 0x0430001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_ldrt_a1_a_field_imm12_32_poweroftwo_0_04300020() {
    // Encoding: 0x04300020
    // Test aarch32_LDRT_A1_A field imm12 = 32 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, cond=0, Rn=0, Rt=0, imm12=32
    let encoding: u32 = 0x04300020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_ldrt_a1_a_field_imm12_63_poweroftwominusone_0_0430003f() {
    // Encoding: 0x0430003F
    // Test aarch32_LDRT_A1_A field imm12 = 63 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, U=0, imm12=63, Rt=0, Rn=0
    let encoding: u32 = 0x0430003F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_ldrt_a1_a_field_imm12_64_poweroftwo_0_04300040() {
    // Encoding: 0x04300040
    // Test aarch32_LDRT_A1_A field imm12 = 64 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, cond=0, imm12=64, U=0, Rn=0
    let encoding: u32 = 0x04300040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 127, boundary: PowerOfTwoMinusOne }
/// 2^7 - 1 = 127
#[test]
fn test_aarch32_ldrt_a1_a_field_imm12_127_poweroftwominusone_0_0430007f() {
    // Encoding: 0x0430007F
    // Test aarch32_LDRT_A1_A field imm12 = 127 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, Rn=0, imm12=127, Rt=0, U=0
    let encoding: u32 = 0x0430007F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_ldrt_a1_a_field_imm12_128_poweroftwo_0_04300080() {
    // Encoding: 0x04300080
    // Test aarch32_LDRT_A1_A field imm12 = 128 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Rn=0, imm12=128, Rt=0, U=0
    let encoding: u32 = 0x04300080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 255, boundary: PowerOfTwoMinusOne }
/// 2^8 - 1 = 255
#[test]
fn test_aarch32_ldrt_a1_a_field_imm12_255_poweroftwominusone_0_043000ff() {
    // Encoding: 0x043000FF
    // Test aarch32_LDRT_A1_A field imm12 = 255 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, Rt=0, imm12=255, Rn=0, U=0
    let encoding: u32 = 0x043000FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 256, boundary: PowerOfTwo }
/// power of 2 (2^8 = 256)
#[test]
fn test_aarch32_ldrt_a1_a_field_imm12_256_poweroftwo_0_04300100() {
    // Encoding: 0x04300100
    // Test aarch32_LDRT_A1_A field imm12 = 256 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, U=0, imm12=256, cond=0, Rn=0
    let encoding: u32 = 0x04300100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 511, boundary: PowerOfTwoMinusOne }
/// 2^9 - 1 = 511
#[test]
fn test_aarch32_ldrt_a1_a_field_imm12_511_poweroftwominusone_0_043001ff() {
    // Encoding: 0x043001FF
    // Test aarch32_LDRT_A1_A field imm12 = 511 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, Rt=0, imm12=511, Rn=0, U=0
    let encoding: u32 = 0x043001FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 512, boundary: PowerOfTwo }
/// power of 2 (2^9 = 512)
#[test]
fn test_aarch32_ldrt_a1_a_field_imm12_512_poweroftwo_0_04300200() {
    // Encoding: 0x04300200
    // Test aarch32_LDRT_A1_A field imm12 = 512 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, U=0, cond=0, Rt=0, imm12=512
    let encoding: u32 = 0x04300200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1023, boundary: PowerOfTwoMinusOne }
/// 2^10 - 1 = 1023
#[test]
fn test_aarch32_ldrt_a1_a_field_imm12_1023_poweroftwominusone_0_043003ff() {
    // Encoding: 0x043003FF
    // Test aarch32_LDRT_A1_A field imm12 = 1023 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm12=1023, U=0, cond=0, Rn=0, Rt=0
    let encoding: u32 = 0x043003FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1024, boundary: PowerOfTwo }
/// power of 2 (2^10 = 1024)
#[test]
fn test_aarch32_ldrt_a1_a_field_imm12_1024_poweroftwo_0_04300400() {
    // Encoding: 0x04300400
    // Test aarch32_LDRT_A1_A field imm12 = 1024 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, Rn=0, Rt=0, imm12=1024, cond=0
    let encoding: u32 = 0x04300400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2047, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (2047)
#[test]
fn test_aarch32_ldrt_a1_a_field_imm12_2047_poweroftwominusone_0_043007ff() {
    // Encoding: 0x043007FF
    // Test aarch32_LDRT_A1_A field imm12 = 2047 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, Rt=0, imm12=2047, Rn=0, U=0
    let encoding: u32 = 0x043007FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2048, boundary: PowerOfTwo }
/// power of 2 (2^11 = 2048)
#[test]
fn test_aarch32_ldrt_a1_a_field_imm12_2048_poweroftwo_0_04300800() {
    // Encoding: 0x04300800
    // Test aarch32_LDRT_A1_A field imm12 = 2048 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, U=0, imm12=2048, Rn=0, cond=0
    let encoding: u32 = 0x04300800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4095, boundary: Max }
/// maximum immediate (4095)
#[test]
fn test_aarch32_ldrt_a1_a_field_imm12_4095_max_0_04300fff() {
    // Encoding: 0x04300FFF
    // Test aarch32_LDRT_A1_A field imm12 = 4095 (Max)
    // ISET: A32
    // Fields: U=0, imm12=4095, cond=0, Rt=0, Rn=0
    let encoding: u32 = 0x04300FFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_ldrt_a1_a_combo_0_0_04300000() {
    // Encoding: 0x04300000
    // Test aarch32_LDRT_A1_A field combination: cond=0, U=0, Rn=0, Rt=0, imm12=0
    // ISET: A32
    // Fields: cond=0, U=0, Rt=0, imm12=0, Rn=0
    let encoding: u32 = 0x04300000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_ldrt_a1_a_special_cond_0_condition_eq_0_04300000() {
    // Encoding: 0x04300000
    // Test aarch32_LDRT_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: Rt=0, imm12=0, cond=0, U=0, Rn=0
    let encoding: u32 = 0x04300000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_ldrt_a1_a_special_cond_1_condition_ne_0_14300000() {
    // Encoding: 0x14300000
    // Test aarch32_LDRT_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: Rt=0, U=0, imm12=0, Rn=0, cond=1
    let encoding: u32 = 0x14300000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_ldrt_a1_a_special_cond_2_condition_cs_hs_0_24300000() {
    // Encoding: 0x24300000
    // Test aarch32_LDRT_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: imm12=0, U=0, Rn=0, cond=2, Rt=0
    let encoding: u32 = 0x24300000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_ldrt_a1_a_special_cond_3_condition_cc_lo_0_34300000() {
    // Encoding: 0x34300000
    // Test aarch32_LDRT_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: Rt=0, Rn=0, cond=3, U=0, imm12=0
    let encoding: u32 = 0x34300000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_ldrt_a1_a_special_cond_4_condition_mi_0_44300000() {
    // Encoding: 0x44300000
    // Test aarch32_LDRT_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: Rn=0, imm12=0, U=0, Rt=0, cond=4
    let encoding: u32 = 0x44300000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_ldrt_a1_a_special_cond_5_condition_pl_0_54300000() {
    // Encoding: 0x54300000
    // Test aarch32_LDRT_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: Rt=0, Rn=0, imm12=0, cond=5, U=0
    let encoding: u32 = 0x54300000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_ldrt_a1_a_special_cond_6_condition_vs_0_64300000() {
    // Encoding: 0x64300000
    // Test aarch32_LDRT_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: cond=6, U=0, Rt=0, Rn=0, imm12=0
    let encoding: u32 = 0x64300000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_ldrt_a1_a_special_cond_7_condition_vc_0_74300000() {
    // Encoding: 0x74300000
    // Test aarch32_LDRT_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: Rn=0, Rt=0, imm12=0, cond=7, U=0
    let encoding: u32 = 0x74300000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_ldrt_a1_a_special_cond_8_condition_hi_0_84300000() {
    // Encoding: 0x84300000
    // Test aarch32_LDRT_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: Rn=0, imm12=0, U=0, cond=8, Rt=0
    let encoding: u32 = 0x84300000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_ldrt_a1_a_special_cond_9_condition_ls_0_94300000() {
    // Encoding: 0x94300000
    // Test aarch32_LDRT_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: Rt=0, imm12=0, U=0, Rn=0, cond=9
    let encoding: u32 = 0x94300000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_ldrt_a1_a_special_cond_10_condition_ge_0_a4300000() {
    // Encoding: 0xA4300000
    // Test aarch32_LDRT_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: cond=10, Rn=0, U=0, Rt=0, imm12=0
    let encoding: u32 = 0xA4300000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_ldrt_a1_a_special_cond_11_condition_lt_0_b4300000() {
    // Encoding: 0xB4300000
    // Test aarch32_LDRT_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: U=0, Rn=0, imm12=0, Rt=0, cond=11
    let encoding: u32 = 0xB4300000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_ldrt_a1_a_special_cond_12_condition_gt_0_c4300000() {
    // Encoding: 0xC4300000
    // Test aarch32_LDRT_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: Rt=0, Rn=0, cond=12, imm12=0, U=0
    let encoding: u32 = 0xC4300000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_ldrt_a1_a_special_cond_13_condition_le_0_d4300000() {
    // Encoding: 0xD4300000
    // Test aarch32_LDRT_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: cond=13, U=0, Rt=0, Rn=0, imm12=0
    let encoding: u32 = 0xD4300000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_ldrt_a1_a_special_cond_14_condition_al_0_e4300000() {
    // Encoding: 0xE4300000
    // Test aarch32_LDRT_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: Rt=0, U=0, Rn=0, imm12=0, cond=14
    let encoding: u32 = 0xE4300000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_ldrt_a1_a_special_cond_15_condition_nv_0_f4300000() {
    // Encoding: 0xF4300000
    // Test aarch32_LDRT_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: cond=15, Rn=0, U=0, imm12=0, Rt=0
    let encoding: u32 = 0xF4300000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrt_a1_a_invalid_0_0_04300000() {
    // Encoding: 0x04300000
    // Test aarch32_LDRT_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) }
    // ISET: A32
    // Fields: U=0, imm12=0, Rt=0, cond=0, Rn=0
    let encoding: u32 = 0x04300000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRT_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrt_a1_a_invalid_1_0_04300000() {
    // Encoding: 0x04300000
    // Test aarch32_LDRT_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: imm12=0, U=0, cond=0, Rn=0, Rt=0
    let encoding: u32 = 0x04300000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_ldrt_a2_a_field_cond_0_min_0_06300000() {
    // Encoding: 0x06300000
    // Test aarch32_LDRT_A2_A field cond = 0 (Min)
    // ISET: A32
    // Fields: U=0, Rt=0, imm5=0, type1=0, Rm=0, Rn=0, cond=0
    let encoding: u32 = 0x06300000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_ldrt_a2_a_field_cond_1_poweroftwo_0_16300000() {
    // Encoding: 0x16300000
    // Test aarch32_LDRT_A2_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: type1=0, Rn=0, cond=1, Rt=0, Rm=0, imm5=0, U=0
    let encoding: u32 = 0x16300000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_ldrt_a2_a_field_cond_2_poweroftwo_0_26300000() {
    // Encoding: 0x26300000
    // Test aarch32_LDRT_A2_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, Rm=0, type1=0, imm5=0, cond=2, U=0, Rn=0
    let encoding: u32 = 0x26300000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_ldrt_a2_a_field_cond_3_poweroftwo_0_36300000() {
    // Encoding: 0x36300000
    // Test aarch32_LDRT_A2_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=3, type1=0, Rm=0, imm5=0, U=0, Rt=0
    let encoding: u32 = 0x36300000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_ldrt_a2_a_field_cond_4_poweroftwo_0_46300000() {
    // Encoding: 0x46300000
    // Test aarch32_LDRT_A2_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, U=0, imm5=0, Rn=0, type1=0, Rt=0, cond=4
    let encoding: u32 = 0x46300000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_ldrt_a2_a_field_cond_5_poweroftwo_0_56300000() {
    // Encoding: 0x56300000
    // Test aarch32_LDRT_A2_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, Rn=0, imm5=0, cond=5, Rt=0, type1=0, Rm=0
    let encoding: u32 = 0x56300000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_ldrt_a2_a_field_cond_6_poweroftwo_0_66300000() {
    // Encoding: 0x66300000
    // Test aarch32_LDRT_A2_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: type1=0, Rm=0, Rt=0, imm5=0, cond=6, U=0, Rn=0
    let encoding: u32 = 0x66300000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_ldrt_a2_a_field_cond_7_poweroftwo_0_76300000() {
    // Encoding: 0x76300000
    // Test aarch32_LDRT_A2_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=7, U=0, Rt=0, Rn=0, type1=0, Rm=0, imm5=0
    let encoding: u32 = 0x76300000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_ldrt_a2_a_field_cond_8_poweroftwo_0_86300000() {
    // Encoding: 0x86300000
    // Test aarch32_LDRT_A2_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=8, Rn=0, U=0, Rt=0, imm5=0, type1=0, Rm=0
    let encoding: u32 = 0x86300000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_ldrt_a2_a_field_cond_9_poweroftwo_0_96300000() {
    // Encoding: 0x96300000
    // Test aarch32_LDRT_A2_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, Rt=0, cond=9, Rn=0, type1=0, Rm=0, imm5=0
    let encoding: u32 = 0x96300000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_ldrt_a2_a_field_cond_10_poweroftwo_0_a6300000() {
    // Encoding: 0xA6300000
    // Test aarch32_LDRT_A2_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rt=0, imm5=0, type1=0, Rm=0, cond=10, U=0
    let encoding: u32 = 0xA6300000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_ldrt_a2_a_field_cond_11_poweroftwo_0_b6300000() {
    // Encoding: 0xB6300000
    // Test aarch32_LDRT_A2_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Rt=0, imm5=0, Rn=0, type1=0, cond=11, U=0
    let encoding: u32 = 0xB6300000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_ldrt_a2_a_field_cond_12_poweroftwo_0_c6300000() {
    // Encoding: 0xC6300000
    // Test aarch32_LDRT_A2_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Rn=0, type1=0, Rt=0, U=0, cond=12, imm5=0
    let encoding: u32 = 0xC6300000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_ldrt_a2_a_field_cond_13_poweroftwo_0_d6300000() {
    // Encoding: 0xD6300000
    // Test aarch32_LDRT_A2_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, imm5=0, type1=0, Rm=0, Rt=0, U=0, cond=13
    let encoding: u32 = 0xD6300000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_ldrt_a2_a_field_cond_14_poweroftwo_0_e6300000() {
    // Encoding: 0xE6300000
    // Test aarch32_LDRT_A2_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=14, Rt=0, imm5=0, U=0, type1=0, Rm=0
    let encoding: u32 = 0xE6300000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_ldrt_a2_a_field_cond_15_max_0_f6300000() {
    // Encoding: 0xF6300000
    // Test aarch32_LDRT_A2_A field cond = 15 (Max)
    // ISET: A32
    // Fields: cond=15, U=0, Rt=0, Rm=0, imm5=0, type1=0, Rn=0
    let encoding: u32 = 0xF6300000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A2_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldrt_a2_a_field_u_0_min_0_06300000() {
    // Encoding: 0x06300000
    // Test aarch32_LDRT_A2_A field U = 0 (Min)
    // ISET: A32
    // Fields: type1=0, cond=0, Rm=0, imm5=0, U=0, Rn=0, Rt=0
    let encoding: u32 = 0x06300000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A2_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldrt_a2_a_field_u_1_max_0_06b00000() {
    // Encoding: 0x06B00000
    // Test aarch32_LDRT_A2_A field U = 1 (Max)
    // ISET: A32
    // Fields: U=1, Rn=0, Rt=0, type1=0, cond=0, imm5=0, Rm=0
    let encoding: u32 = 0x06B00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrt_a2_a_field_rn_0_min_0_06300000() {
    // Encoding: 0x06300000
    // Test aarch32_LDRT_A2_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: cond=0, U=0, Rt=0, Rn=0, imm5=0, type1=0, Rm=0
    let encoding: u32 = 0x06300000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrt_a2_a_field_rn_1_poweroftwo_0_06310000() {
    // Encoding: 0x06310000
    // Test aarch32_LDRT_A2_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, Rn=1, type1=0, U=0, Rm=0, cond=0, imm5=0
    let encoding: u32 = 0x06310000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A2_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrt_a2_a_field_rt_0_min_0_06300000() {
    // Encoding: 0x06300000
    // Test aarch32_LDRT_A2_A field Rt = 0 (Min)
    // ISET: A32
    // Fields: Rt=0, imm5=0, type1=0, cond=0, Rm=0, Rn=0, U=0
    let encoding: u32 = 0x06300000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A2_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrt_a2_a_field_rt_1_poweroftwo_0_06301000() {
    // Encoding: 0x06301000
    // Test aarch32_LDRT_A2_A field Rt = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, type1=0, Rt=1, U=0, Rn=0, imm5=0, Rm=0
    let encoding: u32 = 0x06301000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A2_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_ldrt_a2_a_field_imm5_0_zero_0_06300000() {
    // Encoding: 0x06300000
    // Test aarch32_LDRT_A2_A field imm5 = 0 (Zero)
    // ISET: A32
    // Fields: cond=0, U=0, Rn=0, imm5=0, type1=0, Rm=0, Rt=0
    let encoding: u32 = 0x06300000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A2_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_ldrt_a2_a_field_imm5_1_poweroftwo_0_06300080() {
    // Encoding: 0x06300080
    // Test aarch32_LDRT_A2_A field imm5 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, cond=0, imm5=1, U=0, Rm=0, type1=0, Rn=0
    let encoding: u32 = 0x06300080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A2_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_ldrt_a2_a_field_imm5_3_poweroftwominusone_0_06300180() {
    // Encoding: 0x06300180
    // Test aarch32_LDRT_A2_A field imm5 = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: type1=0, cond=0, Rm=0, U=0, Rt=0, Rn=0, imm5=3
    let encoding: u32 = 0x06300180;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A2_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_ldrt_a2_a_field_imm5_4_poweroftwo_0_06300200() {
    // Encoding: 0x06300200
    // Test aarch32_LDRT_A2_A field imm5 = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: type1=0, Rn=0, U=0, Rt=0, imm5=4, cond=0, Rm=0
    let encoding: u32 = 0x06300200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A2_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_ldrt_a2_a_field_imm5_7_poweroftwominusone_0_06300380() {
    // Encoding: 0x06300380
    // Test aarch32_LDRT_A2_A field imm5 = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rn=0, Rt=0, type1=0, Rm=0, imm5=7, cond=0, U=0
    let encoding: u32 = 0x06300380;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A2_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_ldrt_a2_a_field_imm5_8_poweroftwo_0_06300400() {
    // Encoding: 0x06300400
    // Test aarch32_LDRT_A2_A field imm5 = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, cond=0, imm5=8, type1=0, Rn=0, U=0, Rt=0
    let encoding: u32 = 0x06300400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A2_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 15, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (15)
#[test]
fn test_aarch32_ldrt_a2_a_field_imm5_15_poweroftwominusone_0_06300780() {
    // Encoding: 0x06300780
    // Test aarch32_LDRT_A2_A field imm5 = 15 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm5=15, Rm=0, type1=0, cond=0, Rt=0, Rn=0, U=0
    let encoding: u32 = 0x06300780;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A2_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_ldrt_a2_a_field_imm5_16_poweroftwo_0_06300800() {
    // Encoding: 0x06300800
    // Test aarch32_LDRT_A2_A field imm5 = 16 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=0, imm5=16, Rm=0, Rt=0, type1=0, U=0
    let encoding: u32 = 0x06300800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A2_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 31, boundary: Max }
/// maximum immediate (31)
#[test]
fn test_aarch32_ldrt_a2_a_field_imm5_31_max_0_06300f80() {
    // Encoding: 0x06300F80
    // Test aarch32_LDRT_A2_A field imm5 = 31 (Max)
    // ISET: A32
    // Fields: cond=0, U=0, Rm=0, Rt=0, imm5=31, type1=0, Rn=0
    let encoding: u32 = 0x06300F80;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A2_A
/// ASL: `field type1 5 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldrt_a2_a_field_type1_0_min_0_06300000() {
    // Encoding: 0x06300000
    // Test aarch32_LDRT_A2_A field type1 = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, cond=0, U=0, Rt=0, type1=0, imm5=0, Rm=0
    let encoding: u32 = 0x06300000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A2_A
/// ASL: `field type1 5 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_ldrt_a2_a_field_type1_1_poweroftwo_0_06300020() {
    // Encoding: 0x06300020
    // Test aarch32_LDRT_A2_A field type1 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, U=0, type1=1, Rt=0, Rm=0, imm5=0, Rn=0
    let encoding: u32 = 0x06300020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A2_A
/// ASL: `field type1 5 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_aarch32_ldrt_a2_a_field_type1_3_max_0_06300060() {
    // Encoding: 0x06300060
    // Test aarch32_LDRT_A2_A field type1 = 3 (Max)
    // ISET: A32
    // Fields: U=0, Rt=0, imm5=0, type1=3, Rm=0, cond=0, Rn=0
    let encoding: u32 = 0x06300060;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrt_a2_a_field_rm_0_min_0_06300000() {
    // Encoding: 0x06300000
    // Test aarch32_LDRT_A2_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: type1=0, Rt=0, Rn=0, Rm=0, cond=0, imm5=0, U=0
    let encoding: u32 = 0x06300000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrt_a2_a_field_rm_1_poweroftwo_0_06300001() {
    // Encoding: 0x06300001
    // Test aarch32_LDRT_A2_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, type1=0, Rm=1, cond=0, U=0, Rn=0, imm5=0
    let encoding: u32 = 0x06300001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A2_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_ldrt_a2_a_combo_0_0_06300000() {
    // Encoding: 0x06300000
    // Test aarch32_LDRT_A2_A field combination: cond=0, U=0, Rn=0, Rt=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: U=0, Rm=0, Rn=0, imm5=0, cond=0, Rt=0, type1=0
    let encoding: u32 = 0x06300000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A2_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_ldrt_a2_a_special_cond_0_condition_eq_0_06300000() {
    // Encoding: 0x06300000
    // Test aarch32_LDRT_A2_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: Rm=0, cond=0, U=0, Rt=0, type1=0, Rn=0, imm5=0
    let encoding: u32 = 0x06300000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A2_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_ldrt_a2_a_special_cond_1_condition_ne_0_16300000() {
    // Encoding: 0x16300000
    // Test aarch32_LDRT_A2_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: U=0, Rt=0, Rm=0, imm5=0, cond=1, type1=0, Rn=0
    let encoding: u32 = 0x16300000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A2_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_ldrt_a2_a_special_cond_2_condition_cs_hs_0_26300000() {
    // Encoding: 0x26300000
    // Test aarch32_LDRT_A2_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: Rn=0, Rt=0, type1=0, Rm=0, cond=2, imm5=0, U=0
    let encoding: u32 = 0x26300000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A2_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_ldrt_a2_a_special_cond_3_condition_cc_lo_0_36300000() {
    // Encoding: 0x36300000
    // Test aarch32_LDRT_A2_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: cond=3, U=0, Rn=0, Rt=0, imm5=0, type1=0, Rm=0
    let encoding: u32 = 0x36300000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A2_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_ldrt_a2_a_special_cond_4_condition_mi_0_46300000() {
    // Encoding: 0x46300000
    // Test aarch32_LDRT_A2_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: type1=0, Rt=0, U=0, Rm=0, cond=4, Rn=0, imm5=0
    let encoding: u32 = 0x46300000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A2_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_ldrt_a2_a_special_cond_5_condition_pl_0_56300000() {
    // Encoding: 0x56300000
    // Test aarch32_LDRT_A2_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: U=0, imm5=0, type1=0, Rm=0, Rt=0, cond=5, Rn=0
    let encoding: u32 = 0x56300000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A2_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_ldrt_a2_a_special_cond_6_condition_vs_0_66300000() {
    // Encoding: 0x66300000
    // Test aarch32_LDRT_A2_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: Rt=0, imm5=0, cond=6, U=0, type1=0, Rm=0, Rn=0
    let encoding: u32 = 0x66300000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A2_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_ldrt_a2_a_special_cond_7_condition_vc_0_76300000() {
    // Encoding: 0x76300000
    // Test aarch32_LDRT_A2_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: Rm=0, U=0, Rt=0, imm5=0, type1=0, cond=7, Rn=0
    let encoding: u32 = 0x76300000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A2_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_ldrt_a2_a_special_cond_8_condition_hi_0_86300000() {
    // Encoding: 0x86300000
    // Test aarch32_LDRT_A2_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: imm5=0, cond=8, Rt=0, Rm=0, type1=0, Rn=0, U=0
    let encoding: u32 = 0x86300000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A2_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_ldrt_a2_a_special_cond_9_condition_ls_0_96300000() {
    // Encoding: 0x96300000
    // Test aarch32_LDRT_A2_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: Rn=0, U=0, imm5=0, cond=9, Rt=0, type1=0, Rm=0
    let encoding: u32 = 0x96300000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A2_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_ldrt_a2_a_special_cond_10_condition_ge_0_a6300000() {
    // Encoding: 0xA6300000
    // Test aarch32_LDRT_A2_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: Rn=0, cond=10, imm5=0, Rm=0, type1=0, Rt=0, U=0
    let encoding: u32 = 0xA6300000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A2_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_ldrt_a2_a_special_cond_11_condition_lt_0_b6300000() {
    // Encoding: 0xB6300000
    // Test aarch32_LDRT_A2_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: U=0, Rt=0, cond=11, type1=0, Rm=0, imm5=0, Rn=0
    let encoding: u32 = 0xB6300000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A2_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_ldrt_a2_a_special_cond_12_condition_gt_0_c6300000() {
    // Encoding: 0xC6300000
    // Test aarch32_LDRT_A2_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: U=0, type1=0, Rt=0, imm5=0, cond=12, Rm=0, Rn=0
    let encoding: u32 = 0xC6300000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A2_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_ldrt_a2_a_special_cond_13_condition_le_0_d6300000() {
    // Encoding: 0xD6300000
    // Test aarch32_LDRT_A2_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: cond=13, Rt=0, type1=0, Rm=0, imm5=0, U=0, Rn=0
    let encoding: u32 = 0xD6300000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A2_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_ldrt_a2_a_special_cond_14_condition_al_0_e6300000() {
    // Encoding: 0xE6300000
    // Test aarch32_LDRT_A2_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: cond=14, U=0, type1=0, imm5=0, Rm=0, Rt=0, Rn=0
    let encoding: u32 = 0xE6300000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A2_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_ldrt_a2_a_special_cond_15_condition_nv_0_f6300000() {
    // Encoding: 0xF6300000
    // Test aarch32_LDRT_A2_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: Rt=0, cond=15, type1=0, Rn=0, U=0, imm5=0, Rm=0
    let encoding: u32 = 0xF6300000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRT_A2_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrt_a2_a_invalid_0_0_06300000() {
    // Encoding: 0x06300000
    // Test aarch32_LDRT_A2_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }
    // ISET: A32
    // Fields: type1=0, Rn=0, imm5=0, cond=0, U=0, Rt=0, Rm=0
    let encoding: u32 = 0x06300000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRT_A2_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrt_a2_a_invalid_1_0_06300000() {
    // Encoding: 0x06300000
    // Test aarch32_LDRT_A2_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: cond=0, Rm=0, Rn=0, U=0, Rt=0, imm5=0, type1=0
    let encoding: u32 = 0x06300000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRT_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrt_t1_a_field_rn_0_min_e00_f8500e00() {
    // Thumb encoding (32): 0xF8500E00
    // Test aarch32_LDRT_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, imm8=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8500E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRT_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrt_t1_a_field_rn_1_poweroftwo_e00_f8510e00() {
    // Thumb encoding (32): 0xF8510E00
    // Test aarch32_LDRT_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, Rn=1, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8510E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRT_T1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrt_t1_a_field_rt_0_min_e00_f8500e00() {
    // Thumb encoding (32): 0xF8500E00
    // Test aarch32_LDRT_T1_A field Rt = 0 (Min)
    // ISET: T32
    // Fields: imm8=0, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8500E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRT_T1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrt_t1_a_field_rt_1_poweroftwo_e00_f8501e00() {
    // Thumb encoding (32): 0xF8501E00
    // Test aarch32_LDRT_T1_A field Rt = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Rt=1, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8501E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_ldrt_t1_a_field_imm8_0_zero_e00_f8500e00() {
    // Thumb encoding (32): 0xF8500E00
    // Test aarch32_LDRT_T1_A field imm8 = 0 (Zero)
    // ISET: T32
    // Fields: Rt=0, imm8=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8500E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_ldrt_t1_a_field_imm8_1_poweroftwo_e00_f8500e01() {
    // Thumb encoding (32): 0xF8500E01
    // Test aarch32_LDRT_T1_A field imm8 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm8=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8500E01;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_ldrt_t1_a_field_imm8_3_poweroftwominusone_e00_f8500e03() {
    // Thumb encoding (32): 0xF8500E03
    // Test aarch32_LDRT_T1_A field imm8 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, Rn=0, imm8=3
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8500E03;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_ldrt_t1_a_field_imm8_4_poweroftwo_e00_f8500e04() {
    // Thumb encoding (32): 0xF8500E04
    // Test aarch32_LDRT_T1_A field imm8 = 4 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, imm8=4, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8500E04;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_ldrt_t1_a_field_imm8_7_poweroftwominusone_e00_f8500e07() {
    // Thumb encoding (32): 0xF8500E07
    // Test aarch32_LDRT_T1_A field imm8 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm8=7
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8500E07;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_ldrt_t1_a_field_imm8_8_poweroftwo_e00_f8500e08() {
    // Thumb encoding (32): 0xF8500E08
    // Test aarch32_LDRT_T1_A field imm8 = 8 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=8, Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8500E08;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_ldrt_t1_a_field_imm8_15_poweroftwominusone_e00_f8500e0f() {
    // Thumb encoding (32): 0xF8500E0F
    // Test aarch32_LDRT_T1_A field imm8 = 15 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm8=15
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8500E0F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_ldrt_t1_a_field_imm8_16_poweroftwo_e00_f8500e10() {
    // Thumb encoding (32): 0xF8500E10
    // Test aarch32_LDRT_T1_A field imm8 = 16 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=16, Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8500E10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_ldrt_t1_a_field_imm8_31_poweroftwominusone_e00_f8500e1f() {
    // Thumb encoding (32): 0xF8500E1F
    // Test aarch32_LDRT_T1_A field imm8 = 31 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, imm8=31, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8500E1F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_ldrt_t1_a_field_imm8_32_poweroftwo_e00_f8500e20() {
    // Thumb encoding (32): 0xF8500E20
    // Test aarch32_LDRT_T1_A field imm8 = 32 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, Rn=0, imm8=32
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8500E20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_ldrt_t1_a_field_imm8_63_poweroftwominusone_e00_f8500e3f() {
    // Thumb encoding (32): 0xF8500E3F
    // Test aarch32_LDRT_T1_A field imm8 = 63 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, imm8=63, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8500E3F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_ldrt_t1_a_field_imm8_64_poweroftwo_e00_f8500e40() {
    // Thumb encoding (32): 0xF8500E40
    // Test aarch32_LDRT_T1_A field imm8 = 64 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm8=64
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8500E40;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 127, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (127)
#[test]
fn test_aarch32_ldrt_t1_a_field_imm8_127_poweroftwominusone_e00_f8500e7f() {
    // Thumb encoding (32): 0xF8500E7F
    // Test aarch32_LDRT_T1_A field imm8 = 127 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, Rn=0, imm8=127
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8500E7F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_ldrt_t1_a_field_imm8_128_poweroftwo_e00_f8500e80() {
    // Thumb encoding (32): 0xF8500E80
    // Test aarch32_LDRT_T1_A field imm8 = 128 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, Rn=0, imm8=128
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8500E80;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 255, boundary: Max }
/// maximum immediate (255)
#[test]
fn test_aarch32_ldrt_t1_a_field_imm8_255_max_e00_f8500eff() {
    // Thumb encoding (32): 0xF8500EFF
    // Test aarch32_LDRT_T1_A field imm8 = 255 (Max)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm8=255
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8500EFF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRT_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_ldrt_t1_a_combo_0_e00_f8500e00() {
    // Thumb encoding (32): 0xF8500E00
    // Test aarch32_LDRT_T1_A field combination: Rn=0, Rt=0, imm8=0
    // ISET: T32
    // Fields: Rn=0, imm8=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8500E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRT_T1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrt_t1_a_invalid_0_e00_f8500e00() {
    // Thumb encoding (32): 0xF8500E00
    // Test aarch32_LDRT_T1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: LitInt(15) }
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8500E00;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRT_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrt_t1_a_invalid_1_e00_f8500e00() {
    // Thumb encoding (32): 0xF8500E00
    // Test aarch32_LDRT_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: imm8=0, Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8500E00;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRT_A1_A
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrt_a1_a_exception_0_04300000() {
    // Test aarch32_LDRT_A1_A exception: Unpredictable
    // Encoding: 0x04300000
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04300000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_LDRT_A2_A
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrt_a2_a_exception_0_06300000() {
    // Test aarch32_LDRT_A2_A exception: Unpredictable
    // Encoding: 0x06300000
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x06300000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_LDRT_T1_A
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrt_t1_a_exception_0_f8500e00() {
    // Test aarch32_LDRT_T1_A exception: Unpredictable
    // ISET: T32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF8500E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// aarch32_LDRSB_i_A Tests
// ============================================================================

/// Provenance: aarch32_LDRSB_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_ldrsb_i_a1_a_field_cond_0_min_d0_005000d0() {
    // Encoding: 0x005000D0
    // Test aarch32_LDRSB_i_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: W=0, imm4L=0, P=0, U=0, Rn=0, imm4H=0, Rt=0, cond=0
    let encoding: u32 = 0x005000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_ldrsb_i_a1_a_field_cond_1_poweroftwo_d0_105000d0() {
    // Encoding: 0x105000D0
    // Test aarch32_LDRSB_i_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=1, P=0, W=0, Rt=0, U=0, Rn=0, imm4L=0, imm4H=0
    let encoding: u32 = 0x105000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_ldrsb_i_a1_a_field_cond_2_poweroftwo_d0_205000d0() {
    // Encoding: 0x205000D0
    // Test aarch32_LDRSB_i_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=2, P=0, W=0, U=0, imm4L=0, Rn=0, Rt=0, imm4H=0
    let encoding: u32 = 0x205000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_ldrsb_i_a1_a_field_cond_3_poweroftwo_d0_305000d0() {
    // Encoding: 0x305000D0
    // Test aarch32_LDRSB_i_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=3, imm4H=0, P=0, Rt=0, Rn=0, W=0, imm4L=0, U=0
    let encoding: u32 = 0x305000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_ldrsb_i_a1_a_field_cond_4_poweroftwo_d0_405000d0() {
    // Encoding: 0x405000D0
    // Test aarch32_LDRSB_i_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4L=0, Rn=0, P=0, W=0, imm4H=0, U=0, cond=4, Rt=0
    let encoding: u32 = 0x405000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_ldrsb_i_a1_a_field_cond_5_poweroftwo_d0_505000d0() {
    // Encoding: 0x505000D0
    // Test aarch32_LDRSB_i_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4L=0, U=0, W=0, Rt=0, cond=5, Rn=0, imm4H=0, P=0
    let encoding: u32 = 0x505000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_ldrsb_i_a1_a_field_cond_6_poweroftwo_d0_605000d0() {
    // Encoding: 0x605000D0
    // Test aarch32_LDRSB_i_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, imm4H=0, W=0, imm4L=0, P=0, cond=6, U=0, Rn=0
    let encoding: u32 = 0x605000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_ldrsb_i_a1_a_field_cond_7_poweroftwo_d0_705000d0() {
    // Encoding: 0x705000D0
    // Test aarch32_LDRSB_i_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4L=0, Rn=0, W=0, imm4H=0, U=0, cond=7, P=0, Rt=0
    let encoding: u32 = 0x705000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_ldrsb_i_a1_a_field_cond_8_poweroftwo_d0_805000d0() {
    // Encoding: 0x805000D0
    // Test aarch32_LDRSB_i_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, Rn=0, cond=8, W=0, imm4L=0, imm4H=0, P=0, U=0
    let encoding: u32 = 0x805000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_ldrsb_i_a1_a_field_cond_9_poweroftwo_d0_905000d0() {
    // Encoding: 0x905000D0
    // Test aarch32_LDRSB_i_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, cond=9, W=0, P=0, Rn=0, Rt=0, imm4L=0, imm4H=0
    let encoding: u32 = 0x905000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_ldrsb_i_a1_a_field_cond_10_poweroftwo_d0_a05000d0() {
    // Encoding: 0xA05000D0
    // Test aarch32_LDRSB_i_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, imm4H=0, Rn=0, imm4L=0, cond=10, U=0, W=0, Rt=0
    let encoding: u32 = 0xA05000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_ldrsb_i_a1_a_field_cond_11_poweroftwo_d0_b05000d0() {
    // Encoding: 0xB05000D0
    // Test aarch32_LDRSB_i_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, imm4L=0, Rt=0, P=0, cond=11, imm4H=0, U=0, W=0
    let encoding: u32 = 0xB05000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_ldrsb_i_a1_a_field_cond_12_poweroftwo_d0_c05000d0() {
    // Encoding: 0xC05000D0
    // Test aarch32_LDRSB_i_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rt=0, W=0, P=0, cond=12, U=0, imm4H=0, imm4L=0
    let encoding: u32 = 0xC05000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_ldrsb_i_a1_a_field_cond_13_poweroftwo_d0_d05000d0() {
    // Encoding: 0xD05000D0
    // Test aarch32_LDRSB_i_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, U=0, imm4H=0, Rn=0, cond=13, Rt=0, imm4L=0, P=0
    let encoding: u32 = 0xD05000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_ldrsb_i_a1_a_field_cond_14_poweroftwo_d0_e05000d0() {
    // Encoding: 0xE05000D0
    // Test aarch32_LDRSB_i_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4L=0, Rt=0, imm4H=0, Rn=0, U=0, P=0, cond=14, W=0
    let encoding: u32 = 0xE05000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_ldrsb_i_a1_a_field_cond_15_max_d0_f05000d0() {
    // Encoding: 0xF05000D0
    // Test aarch32_LDRSB_i_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: Rn=0, Rt=0, imm4L=0, U=0, W=0, P=0, cond=15, imm4H=0
    let encoding: u32 = 0xF05000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_i_A1_A
/// ASL: `field P 24 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldrsb_i_a1_a_field_p_0_min_d0_005000d0() {
    // Encoding: 0x005000D0
    // Test aarch32_LDRSB_i_A1_A field P = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, P=0, Rt=0, imm4L=0, cond=0, U=0, W=0, imm4H=0
    let encoding: u32 = 0x005000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_i_A1_A
/// ASL: `field P 24 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldrsb_i_a1_a_field_p_1_max_d0_015000d0() {
    // Encoding: 0x015000D0
    // Test aarch32_LDRSB_i_A1_A field P = 1 (Max)
    // ISET: A32
    // Fields: imm4L=0, imm4H=0, U=0, Rt=0, W=0, Rn=0, P=1, cond=0
    let encoding: u32 = 0x015000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_i_A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldrsb_i_a1_a_field_u_0_min_d0_005000d0() {
    // Encoding: 0x005000D0
    // Test aarch32_LDRSB_i_A1_A field U = 0 (Min)
    // ISET: A32
    // Fields: cond=0, P=0, Rn=0, U=0, Rt=0, imm4H=0, W=0, imm4L=0
    let encoding: u32 = 0x005000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_i_A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldrsb_i_a1_a_field_u_1_max_d0_00d000d0() {
    // Encoding: 0x00D000D0
    // Test aarch32_LDRSB_i_A1_A field U = 1 (Max)
    // ISET: A32
    // Fields: Rt=0, imm4L=0, Rn=0, imm4H=0, cond=0, P=0, W=0, U=1
    let encoding: u32 = 0x00D000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_i_A1_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldrsb_i_a1_a_field_w_0_min_d0_005000d0() {
    // Encoding: 0x005000D0
    // Test aarch32_LDRSB_i_A1_A field W = 0 (Min)
    // ISET: A32
    // Fields: U=0, imm4L=0, Rn=0, P=0, Rt=0, W=0, cond=0, imm4H=0
    let encoding: u32 = 0x005000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_i_A1_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldrsb_i_a1_a_field_w_1_max_d0_007000d0() {
    // Encoding: 0x007000D0
    // Test aarch32_LDRSB_i_A1_A field W = 1 (Max)
    // ISET: A32
    // Fields: U=0, imm4L=0, Rn=0, P=0, cond=0, W=1, imm4H=0, Rt=0
    let encoding: u32 = 0x007000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_i_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrsb_i_a1_a_field_rn_0_min_d0_005000d0() {
    // Encoding: 0x005000D0
    // Test aarch32_LDRSB_i_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: W=0, U=0, imm4H=0, Rt=0, Rn=0, cond=0, imm4L=0, P=0
    let encoding: u32 = 0x005000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_i_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrsb_i_a1_a_field_rn_1_poweroftwo_d0_005100d0() {
    // Encoding: 0x005100D0
    // Test aarch32_LDRSB_i_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, Rt=0, Rn=1, imm4H=0, imm4L=0, cond=0, P=0, W=0
    let encoding: u32 = 0x005100D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_i_A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrsb_i_a1_a_field_rt_0_min_d0_005000d0() {
    // Encoding: 0x005000D0
    // Test aarch32_LDRSB_i_A1_A field Rt = 0 (Min)
    // ISET: A32
    // Fields: U=0, P=0, imm4H=0, cond=0, Rn=0, imm4L=0, W=0, Rt=0
    let encoding: u32 = 0x005000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_i_A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrsb_i_a1_a_field_rt_1_poweroftwo_d0_005010d0() {
    // Encoding: 0x005010D0
    // Test aarch32_LDRSB_i_A1_A field Rt = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4L=0, P=0, imm4H=0, cond=0, W=0, U=0, Rn=0, Rt=1
    let encoding: u32 = 0x005010D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_i_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_ldrsb_i_a1_a_field_imm4h_0_zero_d0_005000d0() {
    // Encoding: 0x005000D0
    // Test aarch32_LDRSB_i_A1_A field imm4H = 0 (Zero)
    // ISET: A32
    // Fields: W=0, imm4H=0, cond=0, U=0, P=0, imm4L=0, Rt=0, Rn=0
    let encoding: u32 = 0x005000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_i_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_ldrsb_i_a1_a_field_imm4h_1_poweroftwo_d0_005001d0() {
    // Encoding: 0x005001D0
    // Test aarch32_LDRSB_i_A1_A field imm4H = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4H=1, Rt=0, U=0, imm4L=0, cond=0, W=0, Rn=0, P=0
    let encoding: u32 = 0x005001D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_i_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_ldrsb_i_a1_a_field_imm4h_3_poweroftwominusone_d0_005003d0() {
    // Encoding: 0x005003D0
    // Test aarch32_LDRSB_i_A1_A field imm4H = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: P=0, Rt=0, W=0, imm4H=3, Rn=0, U=0, cond=0, imm4L=0
    let encoding: u32 = 0x005003D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_i_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_ldrsb_i_a1_a_field_imm4h_4_poweroftwo_d0_005004d0() {
    // Encoding: 0x005004D0
    // Test aarch32_LDRSB_i_A1_A field imm4H = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, imm4L=0, U=0, cond=0, Rt=0, Rn=0, W=0, imm4H=4
    let encoding: u32 = 0x005004D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_i_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_aarch32_ldrsb_i_a1_a_field_imm4h_7_poweroftwominusone_d0_005007d0() {
    // Encoding: 0x005007D0
    // Test aarch32_LDRSB_i_A1_A field imm4H = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: W=0, P=0, imm4L=0, U=0, Rn=0, cond=0, Rt=0, imm4H=7
    let encoding: u32 = 0x005007D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_i_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_ldrsb_i_a1_a_field_imm4h_8_poweroftwo_d0_005008d0() {
    // Encoding: 0x005008D0
    // Test aarch32_LDRSB_i_A1_A field imm4H = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4L=0, Rn=0, U=0, cond=0, imm4H=8, W=0, Rt=0, P=0
    let encoding: u32 = 0x005008D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_i_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_aarch32_ldrsb_i_a1_a_field_imm4h_15_max_d0_00500fd0() {
    // Encoding: 0x00500FD0
    // Test aarch32_LDRSB_i_A1_A field imm4H = 15 (Max)
    // ISET: A32
    // Fields: Rt=0, Rn=0, U=0, P=0, imm4H=15, imm4L=0, W=0, cond=0
    let encoding: u32 = 0x00500FD0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_i_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_ldrsb_i_a1_a_field_imm4l_0_zero_d0_005000d0() {
    // Encoding: 0x005000D0
    // Test aarch32_LDRSB_i_A1_A field imm4L = 0 (Zero)
    // ISET: A32
    // Fields: cond=0, imm4H=0, imm4L=0, P=0, Rn=0, U=0, W=0, Rt=0
    let encoding: u32 = 0x005000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_i_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_ldrsb_i_a1_a_field_imm4l_1_poweroftwo_d0_005000d1() {
    // Encoding: 0x005000D1
    // Test aarch32_LDRSB_i_A1_A field imm4L = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, P=0, Rn=0, cond=0, U=0, imm4L=1, imm4H=0, Rt=0
    let encoding: u32 = 0x005000D1;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_i_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_ldrsb_i_a1_a_field_imm4l_3_poweroftwominusone_d0_005000d3() {
    // Encoding: 0x005000D3
    // Test aarch32_LDRSB_i_A1_A field imm4L = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rt=0, cond=0, Rn=0, imm4L=3, P=0, imm4H=0, U=0, W=0
    let encoding: u32 = 0x005000D3;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_i_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_ldrsb_i_a1_a_field_imm4l_4_poweroftwo_d0_005000d4() {
    // Encoding: 0x005000D4
    // Test aarch32_LDRSB_i_A1_A field imm4L = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4H=0, P=0, cond=0, U=0, W=0, Rn=0, Rt=0, imm4L=4
    let encoding: u32 = 0x005000D4;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_i_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_aarch32_ldrsb_i_a1_a_field_imm4l_7_poweroftwominusone_d0_005000d7() {
    // Encoding: 0x005000D7
    // Test aarch32_LDRSB_i_A1_A field imm4L = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rt=0, P=0, cond=0, imm4H=0, imm4L=7, Rn=0, W=0, U=0
    let encoding: u32 = 0x005000D7;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_i_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_ldrsb_i_a1_a_field_imm4l_8_poweroftwo_d0_005000d8() {
    // Encoding: 0x005000D8
    // Test aarch32_LDRSB_i_A1_A field imm4L = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, imm4L=8, P=0, W=0, imm4H=0, Rt=0, cond=0, U=0
    let encoding: u32 = 0x005000D8;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_i_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_aarch32_ldrsb_i_a1_a_field_imm4l_15_max_d0_005000df() {
    // Encoding: 0x005000DF
    // Test aarch32_LDRSB_i_A1_A field imm4L = 15 (Max)
    // ISET: A32
    // Fields: cond=0, U=0, W=0, Rn=0, imm4H=0, Rt=0, imm4L=15, P=0
    let encoding: u32 = 0x005000DF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_i_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_ldrsb_i_a1_a_combo_0_d0_005000d0() {
    // Encoding: 0x005000D0
    // Test aarch32_LDRSB_i_A1_A field combination: cond=0, P=0, U=0, W=0, Rn=0, Rt=0, imm4H=0, imm4L=0
    // ISET: A32
    // Fields: W=0, imm4L=0, cond=0, U=0, P=0, Rn=0, Rt=0, imm4H=0
    let encoding: u32 = 0x005000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_i_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_ldrsb_i_a1_a_special_cond_0_condition_eq_208_005000d0() {
    // Encoding: 0x005000D0
    // Test aarch32_LDRSB_i_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: Rt=0, W=0, imm4L=0, Rn=0, P=0, cond=0, imm4H=0, U=0
    let encoding: u32 = 0x005000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_i_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_ldrsb_i_a1_a_special_cond_1_condition_ne_208_105000d0() {
    // Encoding: 0x105000D0
    // Test aarch32_LDRSB_i_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: cond=1, Rn=0, Rt=0, W=0, U=0, imm4L=0, imm4H=0, P=0
    let encoding: u32 = 0x105000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_i_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_ldrsb_i_a1_a_special_cond_2_condition_cs_hs_208_205000d0() {
    // Encoding: 0x205000D0
    // Test aarch32_LDRSB_i_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: P=0, U=0, imm4H=0, imm4L=0, W=0, cond=2, Rt=0, Rn=0
    let encoding: u32 = 0x205000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_i_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_ldrsb_i_a1_a_special_cond_3_condition_cc_lo_208_305000d0() {
    // Encoding: 0x305000D0
    // Test aarch32_LDRSB_i_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: Rt=0, cond=3, U=0, P=0, imm4L=0, imm4H=0, W=0, Rn=0
    let encoding: u32 = 0x305000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_i_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_ldrsb_i_a1_a_special_cond_4_condition_mi_208_405000d0() {
    // Encoding: 0x405000D0
    // Test aarch32_LDRSB_i_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: Rt=0, P=0, imm4H=0, imm4L=0, W=0, cond=4, Rn=0, U=0
    let encoding: u32 = 0x405000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_i_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_ldrsb_i_a1_a_special_cond_5_condition_pl_208_505000d0() {
    // Encoding: 0x505000D0
    // Test aarch32_LDRSB_i_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: imm4H=0, P=0, Rn=0, Rt=0, cond=5, W=0, U=0, imm4L=0
    let encoding: u32 = 0x505000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_i_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_ldrsb_i_a1_a_special_cond_6_condition_vs_208_605000d0() {
    // Encoding: 0x605000D0
    // Test aarch32_LDRSB_i_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: W=0, Rn=0, imm4L=0, P=0, Rt=0, U=0, imm4H=0, cond=6
    let encoding: u32 = 0x605000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_i_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_ldrsb_i_a1_a_special_cond_7_condition_vc_208_705000d0() {
    // Encoding: 0x705000D0
    // Test aarch32_LDRSB_i_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: Rt=0, U=0, W=0, Rn=0, cond=7, P=0, imm4H=0, imm4L=0
    let encoding: u32 = 0x705000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_i_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_ldrsb_i_a1_a_special_cond_8_condition_hi_208_805000d0() {
    // Encoding: 0x805000D0
    // Test aarch32_LDRSB_i_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: imm4H=0, U=0, P=0, imm4L=0, cond=8, Rn=0, W=0, Rt=0
    let encoding: u32 = 0x805000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_i_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_ldrsb_i_a1_a_special_cond_9_condition_ls_208_905000d0() {
    // Encoding: 0x905000D0
    // Test aarch32_LDRSB_i_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: cond=9, W=0, Rt=0, imm4H=0, imm4L=0, P=0, Rn=0, U=0
    let encoding: u32 = 0x905000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_i_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_ldrsb_i_a1_a_special_cond_10_condition_ge_208_a05000d0() {
    // Encoding: 0xA05000D0
    // Test aarch32_LDRSB_i_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: cond=10, U=0, imm4H=0, imm4L=0, Rt=0, Rn=0, W=0, P=0
    let encoding: u32 = 0xA05000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_i_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_ldrsb_i_a1_a_special_cond_11_condition_lt_208_b05000d0() {
    // Encoding: 0xB05000D0
    // Test aarch32_LDRSB_i_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: imm4H=0, cond=11, W=0, Rn=0, Rt=0, U=0, imm4L=0, P=0
    let encoding: u32 = 0xB05000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_i_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_ldrsb_i_a1_a_special_cond_12_condition_gt_208_c05000d0() {
    // Encoding: 0xC05000D0
    // Test aarch32_LDRSB_i_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: U=0, imm4H=0, W=0, Rt=0, imm4L=0, P=0, cond=12, Rn=0
    let encoding: u32 = 0xC05000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_i_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_ldrsb_i_a1_a_special_cond_13_condition_le_208_d05000d0() {
    // Encoding: 0xD05000D0
    // Test aarch32_LDRSB_i_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: cond=13, imm4H=0, imm4L=0, U=0, W=0, Rn=0, P=0, Rt=0
    let encoding: u32 = 0xD05000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_i_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_ldrsb_i_a1_a_special_cond_14_condition_al_208_e05000d0() {
    // Encoding: 0xE05000D0
    // Test aarch32_LDRSB_i_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: U=0, W=0, imm4L=0, Rn=0, cond=14, P=0, imm4H=0, Rt=0
    let encoding: u32 = 0xE05000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_i_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_ldrsb_i_a1_a_special_cond_15_condition_nv_208_f05000d0() {
    // Encoding: 0xF05000D0
    // Test aarch32_LDRSB_i_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: cond=15, imm4H=0, imm4L=0, W=0, P=0, Rn=0, Rt=0, U=0
    let encoding: u32 = 0xF05000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRSB_i_A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Binary { op: Eq, lhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Binary { op: Eq, lhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"wback\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }) } } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrsb_i_a1_a_invalid_0_d0_005000d0() {
    // Encoding: 0x005000D0
    // Test aarch32_LDRSB_i_A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Binary { op: Eq, lhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) } } }
    // ISET: A32
    // Fields: W=0, cond=0, U=0, imm4L=0, Rt=0, imm4H=0, P=0, Rn=0
    let encoding: u32 = 0x005000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRSB_i_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrsb_i_a1_a_invalid_1_d0_005000d0() {
    // Encoding: 0x005000D0
    // Test aarch32_LDRSB_i_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: imm4L=0, P=0, Rt=0, imm4H=0, Rn=0, cond=0, W=0, U=0
    let encoding: u32 = 0x005000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRSB_i_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrsb_i_t1_a_field_rn_0_min_0_f9900000() {
    // Thumb encoding (32): 0xF9900000
    // Test aarch32_LDRSB_i_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm12=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9900000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_i_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrsb_i_t1_a_field_rn_1_poweroftwo_0_f9910000() {
    // Thumb encoding (32): 0xF9910000
    // Test aarch32_LDRSB_i_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm12=0, Rt=0, Rn=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9910000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_i_T1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrsb_i_t1_a_field_rt_0_min_0_f9900000() {
    // Thumb encoding (32): 0xF9900000
    // Test aarch32_LDRSB_i_T1_A field Rt = 0 (Min)
    // ISET: T32
    // Fields: imm12=0, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9900000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_i_T1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrsb_i_t1_a_field_rt_1_poweroftwo_0_f9901000() {
    // Thumb encoding (32): 0xF9901000
    // Test aarch32_LDRSB_i_T1_A field Rt = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Rt=1, imm12=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9901000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_i_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_ldrsb_i_t1_a_field_imm12_0_zero_0_f9900000() {
    // Thumb encoding (32): 0xF9900000
    // Test aarch32_LDRSB_i_T1_A field imm12 = 0 (Zero)
    // ISET: T32
    // Fields: Rt=0, Rn=0, imm12=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9900000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_i_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_ldrsb_i_t1_a_field_imm12_1_poweroftwo_0_f9900001() {
    // Thumb encoding (32): 0xF9900001
    // Test aarch32_LDRSB_i_T1_A field imm12 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, imm12=1, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9900001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_i_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_ldrsb_i_t1_a_field_imm12_3_poweroftwominusone_0_f9900003() {
    // Thumb encoding (32): 0xF9900003
    // Test aarch32_LDRSB_i_T1_A field imm12 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, imm12=3, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9900003;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_i_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_ldrsb_i_t1_a_field_imm12_4_poweroftwo_0_f9900004() {
    // Thumb encoding (32): 0xF9900004
    // Test aarch32_LDRSB_i_T1_A field imm12 = 4 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, imm12=4, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9900004;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_i_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_ldrsb_i_t1_a_field_imm12_7_poweroftwominusone_0_f9900007() {
    // Thumb encoding (32): 0xF9900007
    // Test aarch32_LDRSB_i_T1_A field imm12 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, imm12=7, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9900007;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_i_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_ldrsb_i_t1_a_field_imm12_8_poweroftwo_0_f9900008() {
    // Thumb encoding (32): 0xF9900008
    // Test aarch32_LDRSB_i_T1_A field imm12 = 8 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, Rn=0, imm12=8
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9900008;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_i_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_ldrsb_i_t1_a_field_imm12_15_poweroftwominusone_0_f990000f() {
    // Thumb encoding (32): 0xF990000F
    // Test aarch32_LDRSB_i_T1_A field imm12 = 15 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm12=15, Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF990000F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_i_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_ldrsb_i_t1_a_field_imm12_16_poweroftwo_0_f9900010() {
    // Thumb encoding (32): 0xF9900010
    // Test aarch32_LDRSB_i_T1_A field imm12 = 16 (PowerOfTwo)
    // ISET: T32
    // Fields: imm12=16, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9900010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_i_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_ldrsb_i_t1_a_field_imm12_31_poweroftwominusone_0_f990001f() {
    // Thumb encoding (32): 0xF990001F
    // Test aarch32_LDRSB_i_T1_A field imm12 = 31 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, imm12=31, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF990001F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_i_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_ldrsb_i_t1_a_field_imm12_32_poweroftwo_0_f9900020() {
    // Thumb encoding (32): 0xF9900020
    // Test aarch32_LDRSB_i_T1_A field imm12 = 32 (PowerOfTwo)
    // ISET: T32
    // Fields: imm12=32, Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9900020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_i_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_ldrsb_i_t1_a_field_imm12_63_poweroftwominusone_0_f990003f() {
    // Thumb encoding (32): 0xF990003F
    // Test aarch32_LDRSB_i_T1_A field imm12 = 63 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm12=63
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF990003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_i_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_ldrsb_i_t1_a_field_imm12_64_poweroftwo_0_f9900040() {
    // Thumb encoding (32): 0xF9900040
    // Test aarch32_LDRSB_i_T1_A field imm12 = 64 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, Rn=0, imm12=64
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9900040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_i_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 127, boundary: PowerOfTwoMinusOne }
/// 2^7 - 1 = 127
#[test]
fn test_aarch32_ldrsb_i_t1_a_field_imm12_127_poweroftwominusone_0_f990007f() {
    // Thumb encoding (32): 0xF990007F
    // Test aarch32_LDRSB_i_T1_A field imm12 = 127 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm12=127
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF990007F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_i_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_ldrsb_i_t1_a_field_imm12_128_poweroftwo_0_f9900080() {
    // Thumb encoding (32): 0xF9900080
    // Test aarch32_LDRSB_i_T1_A field imm12 = 128 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm12=128
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9900080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_i_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 255, boundary: PowerOfTwoMinusOne }
/// 2^8 - 1 = 255
#[test]
fn test_aarch32_ldrsb_i_t1_a_field_imm12_255_poweroftwominusone_0_f99000ff() {
    // Thumb encoding (32): 0xF99000FF
    // Test aarch32_LDRSB_i_T1_A field imm12 = 255 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm12=255
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF99000FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_i_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 256, boundary: PowerOfTwo }
/// power of 2 (2^8 = 256)
#[test]
fn test_aarch32_ldrsb_i_t1_a_field_imm12_256_poweroftwo_0_f9900100() {
    // Thumb encoding (32): 0xF9900100
    // Test aarch32_LDRSB_i_T1_A field imm12 = 256 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm12=256
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9900100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_i_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 511, boundary: PowerOfTwoMinusOne }
/// 2^9 - 1 = 511
#[test]
fn test_aarch32_ldrsb_i_t1_a_field_imm12_511_poweroftwominusone_0_f99001ff() {
    // Thumb encoding (32): 0xF99001FF
    // Test aarch32_LDRSB_i_T1_A field imm12 = 511 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm12=511
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF99001FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_i_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 512, boundary: PowerOfTwo }
/// power of 2 (2^9 = 512)
#[test]
fn test_aarch32_ldrsb_i_t1_a_field_imm12_512_poweroftwo_0_f9900200() {
    // Thumb encoding (32): 0xF9900200
    // Test aarch32_LDRSB_i_T1_A field imm12 = 512 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm12=512
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9900200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_i_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1023, boundary: PowerOfTwoMinusOne }
/// 2^10 - 1 = 1023
#[test]
fn test_aarch32_ldrsb_i_t1_a_field_imm12_1023_poweroftwominusone_0_f99003ff() {
    // Thumb encoding (32): 0xF99003FF
    // Test aarch32_LDRSB_i_T1_A field imm12 = 1023 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm12=1023
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF99003FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_i_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1024, boundary: PowerOfTwo }
/// power of 2 (2^10 = 1024)
#[test]
fn test_aarch32_ldrsb_i_t1_a_field_imm12_1024_poweroftwo_0_f9900400() {
    // Thumb encoding (32): 0xF9900400
    // Test aarch32_LDRSB_i_T1_A field imm12 = 1024 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, Rn=0, imm12=1024
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9900400;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_i_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2047, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (2047)
#[test]
fn test_aarch32_ldrsb_i_t1_a_field_imm12_2047_poweroftwominusone_0_f99007ff() {
    // Thumb encoding (32): 0xF99007FF
    // Test aarch32_LDRSB_i_T1_A field imm12 = 2047 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, Rn=0, imm12=2047
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF99007FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_i_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2048, boundary: PowerOfTwo }
/// power of 2 (2^11 = 2048)
#[test]
fn test_aarch32_ldrsb_i_t1_a_field_imm12_2048_poweroftwo_0_f9900800() {
    // Thumb encoding (32): 0xF9900800
    // Test aarch32_LDRSB_i_T1_A field imm12 = 2048 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm12=2048
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9900800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_i_T1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4095, boundary: Max }
/// maximum immediate (4095)
#[test]
fn test_aarch32_ldrsb_i_t1_a_field_imm12_4095_max_0_f9900fff() {
    // Thumb encoding (32): 0xF9900FFF
    // Test aarch32_LDRSB_i_T1_A field imm12 = 4095 (Max)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm12=4095
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9900FFF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_i_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_ldrsb_i_t1_a_combo_0_0_f9900000() {
    // Thumb encoding (32): 0xF9900000
    // Test aarch32_LDRSB_i_T1_A field combination: Rn=0, Rt=0, imm12=0
    // ISET: T32
    // Fields: imm12=0, Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9900000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_i_T2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrsb_i_t2_a_field_rn_0_min_800_f9100800() {
    // Thumb encoding (32): 0xF9100800
    // Test aarch32_LDRSB_i_T2_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, U=0, Rt=0, W=0, imm8=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9100800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_i_T2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrsb_i_t2_a_field_rn_1_poweroftwo_800_f9110800() {
    // Thumb encoding (32): 0xF9110800
    // Test aarch32_LDRSB_i_T2_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=0, Rt=0, W=0, Rn=1, P=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9110800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_i_T2_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrsb_i_t2_a_field_rt_0_min_800_f9100800() {
    // Thumb encoding (32): 0xF9100800
    // Test aarch32_LDRSB_i_T2_A field Rt = 0 (Min)
    // ISET: T32
    // Fields: W=0, U=0, Rn=0, imm8=0, Rt=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9100800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_i_T2_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrsb_i_t2_a_field_rt_1_poweroftwo_800_f9101800() {
    // Thumb encoding (32): 0xF9101800
    // Test aarch32_LDRSB_i_T2_A field Rt = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: W=0, Rn=0, U=0, P=0, imm8=0, Rt=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9101800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_i_T2_A
/// ASL: `field P 10 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldrsb_i_t2_a_field_p_0_min_800_f9100800() {
    // Thumb encoding (32): 0xF9100800
    // Test aarch32_LDRSB_i_T2_A field P = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, U=0, W=0, imm8=0, P=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9100800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_i_T2_A
/// ASL: `field P 10 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldrsb_i_t2_a_field_p_1_max_800_f9100c00() {
    // Thumb encoding (32): 0xF9100C00
    // Test aarch32_LDRSB_i_T2_A field P = 1 (Max)
    // ISET: T32
    // Fields: Rt=0, P=1, U=0, W=0, imm8=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9100C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_i_T2_A
/// ASL: `field U 9 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldrsb_i_t2_a_field_u_0_min_800_f9100800() {
    // Thumb encoding (32): 0xF9100800
    // Test aarch32_LDRSB_i_T2_A field U = 0 (Min)
    // ISET: T32
    // Fields: U=0, W=0, Rt=0, P=0, imm8=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9100800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_i_T2_A
/// ASL: `field U 9 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldrsb_i_t2_a_field_u_1_max_800_f9100a00() {
    // Thumb encoding (32): 0xF9100A00
    // Test aarch32_LDRSB_i_T2_A field U = 1 (Max)
    // ISET: T32
    // Fields: U=1, W=0, P=0, Rt=0, Rn=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9100A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_i_T2_A
/// ASL: `field W 8 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldrsb_i_t2_a_field_w_0_min_800_f9100800() {
    // Thumb encoding (32): 0xF9100800
    // Test aarch32_LDRSB_i_T2_A field W = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, P=0, Rt=0, U=0, imm8=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9100800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_i_T2_A
/// ASL: `field W 8 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldrsb_i_t2_a_field_w_1_max_800_f9100900() {
    // Thumb encoding (32): 0xF9100900
    // Test aarch32_LDRSB_i_T2_A field W = 1 (Max)
    // ISET: T32
    // Fields: W=1, imm8=0, U=0, Rn=0, Rt=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9100900;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_i_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_ldrsb_i_t2_a_field_imm8_0_zero_800_f9100800() {
    // Thumb encoding (32): 0xF9100800
    // Test aarch32_LDRSB_i_T2_A field imm8 = 0 (Zero)
    // ISET: T32
    // Fields: Rn=0, imm8=0, U=0, Rt=0, P=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9100800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_i_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_ldrsb_i_t2_a_field_imm8_1_poweroftwo_800_f9100801() {
    // Thumb encoding (32): 0xF9100801
    // Test aarch32_LDRSB_i_T2_A field imm8 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, W=0, imm8=1, U=0, Rn=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9100801;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_i_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_ldrsb_i_t2_a_field_imm8_3_poweroftwominusone_800_f9100803() {
    // Thumb encoding (32): 0xF9100803
    // Test aarch32_LDRSB_i_T2_A field imm8 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, imm8=3, P=0, U=0, W=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9100803;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_i_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_ldrsb_i_t2_a_field_imm8_4_poweroftwo_800_f9100804() {
    // Thumb encoding (32): 0xF9100804
    // Test aarch32_LDRSB_i_T2_A field imm8 = 4 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=4, P=0, Rt=0, Rn=0, U=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9100804;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_i_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_ldrsb_i_t2_a_field_imm8_7_poweroftwominusone_800_f9100807() {
    // Thumb encoding (32): 0xF9100807
    // Test aarch32_LDRSB_i_T2_A field imm8 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, imm8=7, Rn=0, P=0, U=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9100807;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_i_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_ldrsb_i_t2_a_field_imm8_8_poweroftwo_800_f9100808() {
    // Thumb encoding (32): 0xF9100808
    // Test aarch32_LDRSB_i_T2_A field imm8 = 8 (PowerOfTwo)
    // ISET: T32
    // Fields: P=0, Rt=0, U=0, W=0, Rn=0, imm8=8
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9100808;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_i_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_ldrsb_i_t2_a_field_imm8_15_poweroftwominusone_800_f910080f() {
    // Thumb encoding (32): 0xF910080F
    // Test aarch32_LDRSB_i_T2_A field imm8 = 15 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: P=0, imm8=15, W=0, U=0, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF910080F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_i_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_ldrsb_i_t2_a_field_imm8_16_poweroftwo_800_f9100810() {
    // Thumb encoding (32): 0xF9100810
    // Test aarch32_LDRSB_i_T2_A field imm8 = 16 (PowerOfTwo)
    // ISET: T32
    // Fields: W=0, imm8=16, P=0, Rn=0, U=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9100810;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_i_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_ldrsb_i_t2_a_field_imm8_31_poweroftwominusone_800_f910081f() {
    // Thumb encoding (32): 0xF910081F
    // Test aarch32_LDRSB_i_T2_A field imm8 = 31 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: W=0, Rn=0, U=0, P=0, imm8=31, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF910081F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_i_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_ldrsb_i_t2_a_field_imm8_32_poweroftwo_800_f9100820() {
    // Thumb encoding (32): 0xF9100820
    // Test aarch32_LDRSB_i_T2_A field imm8 = 32 (PowerOfTwo)
    // ISET: T32
    // Fields: W=0, Rn=0, U=0, imm8=32, Rt=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9100820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_i_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_ldrsb_i_t2_a_field_imm8_63_poweroftwominusone_800_f910083f() {
    // Thumb encoding (32): 0xF910083F
    // Test aarch32_LDRSB_i_T2_A field imm8 = 63 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: W=0, Rn=0, P=0, U=0, imm8=63, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF910083F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_i_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_ldrsb_i_t2_a_field_imm8_64_poweroftwo_800_f9100840() {
    // Thumb encoding (32): 0xF9100840
    // Test aarch32_LDRSB_i_T2_A field imm8 = 64 (PowerOfTwo)
    // ISET: T32
    // Fields: W=0, P=0, U=0, imm8=64, Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9100840;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_i_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 127, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (127)
#[test]
fn test_aarch32_ldrsb_i_t2_a_field_imm8_127_poweroftwominusone_800_f910087f() {
    // Thumb encoding (32): 0xF910087F
    // Test aarch32_LDRSB_i_T2_A field imm8 = 127 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm8=127, U=0, Rn=0, Rt=0, P=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF910087F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_i_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_ldrsb_i_t2_a_field_imm8_128_poweroftwo_800_f9100880() {
    // Thumb encoding (32): 0xF9100880
    // Test aarch32_LDRSB_i_T2_A field imm8 = 128 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, W=0, P=0, U=0, Rn=0, imm8=128
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9100880;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_i_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 255, boundary: Max }
/// maximum immediate (255)
#[test]
fn test_aarch32_ldrsb_i_t2_a_field_imm8_255_max_800_f91008ff() {
    // Thumb encoding (32): 0xF91008FF
    // Test aarch32_LDRSB_i_T2_A field imm8 = 255 (Max)
    // ISET: T32
    // Fields: Rt=0, Rn=0, W=0, P=0, U=0, imm8=255
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF91008FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_i_T2_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_ldrsb_i_t2_a_combo_0_800_f9100800() {
    // Thumb encoding (32): 0xF9100800
    // Test aarch32_LDRSB_i_T2_A field combination: Rn=0, Rt=0, P=0, U=0, W=0, imm8=0
    // ISET: T32
    // Fields: W=0, Rt=0, imm8=0, Rn=0, P=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9100800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRSB_i_T2_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "P" }), rhs: Binary { op: And, lhs: LitBits([false]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "W" }) } }, rhs: LitBits([false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"P\" }), rhs: Binary { op: And, lhs: LitBits([false]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"W\" }) } }, rhs: LitBits([false]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_ldrsb_i_t2_a_invalid_0_800_f9100800() {
    // Thumb encoding (32): 0xF9100800
    // Test aarch32_LDRSB_i_T2_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "P" }), rhs: Binary { op: And, lhs: LitBits([false]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "W" }) } }, rhs: LitBits([false]) }
    // ISET: T32
    // Fields: Rn=0, W=0, P=0, imm8=0, Rt=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9100800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_LDRSB_i_T2_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_ldrsb_i_t2_a_invalid_1_800_f9100800() {
    // Thumb encoding (32): 0xF9100800
    // Test aarch32_LDRSB_i_T2_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: W=0, Rt=0, U=0, imm8=0, P=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9100800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for T32 encoding"
    );
}

/// Provenance: aarch32_LDRSB_i_T2_A
/// ASL: `Binary { op: Or, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: And, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "W" }) } }, rhs: LitBits([true]) }, rhs: Binary { op: Eq, lhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Or, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: Binary { op: And, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"W\" }) } }, rhs: LitBits([true]) }, rhs: Binary { op: Eq, lhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"wback\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }) } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrsb_i_t2_a_invalid_2_800_f9100800() {
    // Thumb encoding (32): 0xF9100800
    // Test aarch32_LDRSB_i_T2_A invalid encoding: Binary { op: Or, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: And, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "W" }) } }, rhs: LitBits([true]) }, rhs: Binary { op: Eq, lhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) } }
    // ISET: T32
    // Fields: P=0, W=0, Rt=0, imm8=0, U=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9100800;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRSB_i_T2_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrsb_i_t2_a_invalid_3_800_f9100800() {
    // Thumb encoding (32): 0xF9100800
    // Test aarch32_LDRSB_i_T2_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: U=0, imm8=0, W=0, Rt=0, Rn=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF9100800;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRSB_i_A1_A
/// ASL: `UMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple multiply
#[test]
fn test_aarch32_ldrsb_i_a1_a_umull_oracle_0_9ba27c20() {
    // Test UMULL: simple multiply (oracle)
    // Encoding: 0x9BA27C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x2);
    set_w(&mut cpu, 2, 0x3);
    let encoding: u32 = 0x9BA27C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6, "X0 should be 0x0000000000000006");
}

/// Provenance: aarch32_LDRSB_i_A1_A
/// ASL: `UMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max 32-bit * 2
#[test]
fn test_aarch32_ldrsb_i_a1_a_umull_oracle_1_9ba27c20() {
    // Test UMULL: max 32-bit * 2 (oracle)
    // Encoding: 0x9BA27C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x9BA27C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0x00000001FFFFFFFE"
    );
}

/// Provenance: aarch32_LDRSB_i_A1_A
/// ASL: `UMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// large positive * large positive
#[test]
fn test_aarch32_ldrsb_i_a1_a_umull_oracle_2_9ba27c20() {
    // Test UMULL: large positive * large positive (oracle)
    // Encoding: 0x9BA27C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    set_w(&mut cpu, 2, 0x7FFFFFFF);
    let encoding: u32 = 0x9BA27C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x3FFFFFFF00000001");
}

/// Provenance: aarch32_LDRSB_i_A1_A
/// ASL: `UMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max unsigned * max unsigned
#[test]
fn test_aarch32_ldrsb_i_a1_a_umull_oracle_3_9ba27c20() {
    // Test UMULL: max unsigned * max unsigned (oracle)
    // Encoding: 0x9BA27C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x9BA27C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0xFFFFFFFE00000001");
}

/// Provenance: aarch32_LDRSB_i_A1_A
/// ASL: `UMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// medium values
#[test]
fn test_aarch32_ldrsb_i_a1_a_umull_oracle_4_9ba27c20() {
    // Test UMULL: medium values (oracle)
    // Encoding: 0x9BA27C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0xC8);
    let encoding: u32 = 0x9BA27C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4E20, "X0 should be 0x0000000000004E20");
}

/// Provenance: aarch32_LDRSB_i_A1_A
/// ASL: `UMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// 16-bit values
#[test]
fn test_aarch32_ldrsb_i_a1_a_umull_oracle_5_9ba27c20() {
    // Test UMULL: 16-bit values (oracle)
    // Encoding: 0x9BA27C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1234);
    set_w(&mut cpu, 2, 0x5678);
    let encoding: u32 = 0x9BA27C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6260060, "X0 should be 0x0000000006260060");
}

/// Provenance: aarch32_LDRSB_i_T2_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple division (32)
#[test]
fn test_aarch32_ldrsb_i_t2_a_udiv_oracle_32_0_1ac20820() {
    // Test UDIV 32-bit: simple division (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xA);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA, "W0 should be 0x0000000A");
}

/// Provenance: aarch32_LDRSB_i_T2_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple division (64)
#[test]
fn test_aarch32_ldrsb_i_t2_a_udiv_oracle_64_0_9ac20820() {
    // Test UDIV 64-bit: simple division (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0xA);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA, "X0 should be 0x000000000000000A");
}

/// Provenance: aarch32_LDRSB_i_T2_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// division with remainder (32)
#[test]
fn test_aarch32_ldrsb_i_t2_a_udiv_oracle_32_1_1ac20820() {
    // Test UDIV 32-bit: division with remainder (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x21, "W0 should be 0x00000021");
}

/// Provenance: aarch32_LDRSB_i_T2_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// division with remainder (64)
#[test]
fn test_aarch32_ldrsb_i_t2_a_udiv_oracle_64_1_9ac20820() {
    // Test UDIV 64-bit: division with remainder (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x21, "X0 should be 0x0000000000000021");
}

/// Provenance: aarch32_LDRSB_i_T2_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero dividend (32)
#[test]
fn test_aarch32_ldrsb_i_t2_a_udiv_oracle_32_2_1ac20820() {
    // Test UDIV 32-bit: zero dividend (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xA);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_LDRSB_i_T2_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero dividend (64)
#[test]
fn test_aarch32_ldrsb_i_t2_a_udiv_oracle_64_2_9ac20820() {
    // Test UDIV 64-bit: zero dividend (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xA);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_LDRSB_i_T2_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// divide by zero - result is 0 (32)
#[test]
fn test_aarch32_ldrsb_i_t2_a_udiv_oracle_32_3_1ac20820() {
    // Test UDIV 32-bit: divide by zero - result is 0 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xA);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_LDRSB_i_T2_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// divide by zero - result is 0 (64)
#[test]
fn test_aarch32_ldrsb_i_t2_a_udiv_oracle_64_3_9ac20820() {
    // Test UDIV 64-bit: divide by zero - result is 0 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0xA);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_LDRSB_i_T2_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max value / 2 (32)
#[test]
fn test_aarch32_ldrsb_i_t2_a_udiv_oracle_32_4_1ac20820() {
    // Test UDIV 32-bit: max value / 2 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FFFFFFF, "W0 should be 0x7FFFFFFF");
}

/// Provenance: aarch32_LDRSB_i_T2_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max value / 2 (64)
#[test]
fn test_aarch32_ldrsb_i_t2_a_udiv_oracle_64_4_9ac20820() {
    // Test UDIV 64-bit: max value / 2 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0x7FFFFFFFFFFFFFFF"
    );
}

/// Provenance: aarch32_LDRSB_i_T2_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set / 2 (32)
#[test]
fn test_aarch32_ldrsb_i_t2_a_udiv_oracle_32_5_1ac20820() {
    // Test UDIV 32-bit: MSB set / 2 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_LDRSB_i_T2_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// MSB set / 2 (64)
#[test]
fn test_aarch32_ldrsb_i_t2_a_udiv_oracle_64_5_9ac20820() {
    // Test UDIV 64-bit: MSB set / 2 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x4000000000000000");
}

/// Provenance: aarch32_LDRSB_i_T2_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// self-division (32)
#[test]
fn test_aarch32_ldrsb_i_t2_a_udiv_oracle_32_6_1ac20820() {
    // Test UDIV 32-bit: self-division (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7);
    set_w(&mut cpu, 2, 0x7);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_LDRSB_i_T2_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// self-division (64)
#[test]
fn test_aarch32_ldrsb_i_t2_a_udiv_oracle_64_6_9ac20820() {
    // Test UDIV 64-bit: self-division (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7);
    set_w(&mut cpu, 2, 0x7);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x0000000000000001");
}

/// Provenance: aarch32_LDRSB_i_T2_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// one / one (32)
#[test]
fn test_aarch32_ldrsb_i_t2_a_udiv_oracle_32_7_1ac20820() {
    // Test UDIV 32-bit: one / one (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_LDRSB_i_T2_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// one / one (64)
#[test]
fn test_aarch32_ldrsb_i_t2_a_udiv_oracle_64_7_9ac20820() {
    // Test UDIV 64-bit: one / one (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x0000000000000001");
}

/// Provenance: aarch32_LDRSB_i_T2_A
/// ASL: `UDIV R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// exact division
#[test]
fn test_aarch32_ldrsb_i_t2_a_t32_oracle_0_f9110800() {
    // Test T32 UDIV: exact division (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xA);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF9110800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA, "R0 should be 0x0000000A");
}

/// Provenance: aarch32_LDRSB_i_T2_A
/// ASL: `UDIV R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// with remainder
#[test]
fn test_aarch32_ldrsb_i_t2_a_t32_oracle_1_f9110800() {
    // Test T32 UDIV: with remainder (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF9110800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x21, "R0 should be 0x00000021");
}

/// Provenance: aarch32_LDRSB_i_T2_A
/// ASL: `UDIV R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero dividend
#[test]
fn test_aarch32_ldrsb_i_t2_a_t32_oracle_2_f9110800() {
    // Test T32 UDIV: zero dividend (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xA);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF9110800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_LDRSB_i_T2_A
/// ASL: `UDIV R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// divide by zero
#[test]
fn test_aarch32_ldrsb_i_t2_a_t32_oracle_3_f9110800() {
    // Test T32 UDIV: divide by zero (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xA);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xF9110800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

// ============================================================================
// aarch32_LDMIB_A Tests
// ============================================================================

/// Provenance: aarch32_LDMIB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_ldmib_a1_a_field_cond_0_min_0_09900000() {
    // Encoding: 0x09900000
    // Test aarch32_LDMIB_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: register_list=0, Rn=0, W=0, cond=0
    let encoding: u32 = 0x09900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMIB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_ldmib_a1_a_field_cond_1_poweroftwo_0_19900000() {
    // Encoding: 0x19900000
    // Test aarch32_LDMIB_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=1, W=0, register_list=0
    let encoding: u32 = 0x19900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMIB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_ldmib_a1_a_field_cond_2_poweroftwo_0_29900000() {
    // Encoding: 0x29900000
    // Test aarch32_LDMIB_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, Rn=0, cond=2, register_list=0
    let encoding: u32 = 0x29900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMIB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_ldmib_a1_a_field_cond_3_poweroftwo_0_39900000() {
    // Encoding: 0x39900000
    // Test aarch32_LDMIB_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: register_list=0, cond=3, Rn=0, W=0
    let encoding: u32 = 0x39900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMIB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_ldmib_a1_a_field_cond_4_poweroftwo_0_49900000() {
    // Encoding: 0x49900000
    // Test aarch32_LDMIB_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=4, W=0, Rn=0, register_list=0
    let encoding: u32 = 0x49900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMIB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_ldmib_a1_a_field_cond_5_poweroftwo_0_59900000() {
    // Encoding: 0x59900000
    // Test aarch32_LDMIB_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, Rn=0, register_list=0, cond=5
    let encoding: u32 = 0x59900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMIB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_ldmib_a1_a_field_cond_6_poweroftwo_0_69900000() {
    // Encoding: 0x69900000
    // Test aarch32_LDMIB_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, W=0, cond=6, register_list=0
    let encoding: u32 = 0x69900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMIB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_ldmib_a1_a_field_cond_7_poweroftwo_0_79900000() {
    // Encoding: 0x79900000
    // Test aarch32_LDMIB_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=7, Rn=0, register_list=0, W=0
    let encoding: u32 = 0x79900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMIB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_ldmib_a1_a_field_cond_8_poweroftwo_0_89900000() {
    // Encoding: 0x89900000
    // Test aarch32_LDMIB_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, Rn=0, cond=8, register_list=0
    let encoding: u32 = 0x89900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMIB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_ldmib_a1_a_field_cond_9_poweroftwo_0_99900000() {
    // Encoding: 0x99900000
    // Test aarch32_LDMIB_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, W=0, register_list=0, cond=9
    let encoding: u32 = 0x99900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMIB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_ldmib_a1_a_field_cond_10_poweroftwo_0_a9900000() {
    // Encoding: 0xA9900000
    // Test aarch32_LDMIB_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: register_list=0, W=0, cond=10, Rn=0
    let encoding: u32 = 0xA9900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMIB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_ldmib_a1_a_field_cond_11_poweroftwo_0_b9900000() {
    // Encoding: 0xB9900000
    // Test aarch32_LDMIB_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: register_list=0, cond=11, W=0, Rn=0
    let encoding: u32 = 0xB9900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMIB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_ldmib_a1_a_field_cond_12_poweroftwo_0_c9900000() {
    // Encoding: 0xC9900000
    // Test aarch32_LDMIB_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=12, W=0, register_list=0
    let encoding: u32 = 0xC9900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMIB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_ldmib_a1_a_field_cond_13_poweroftwo_0_d9900000() {
    // Encoding: 0xD9900000
    // Test aarch32_LDMIB_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: register_list=0, W=0, Rn=0, cond=13
    let encoding: u32 = 0xD9900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMIB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_ldmib_a1_a_field_cond_14_poweroftwo_0_e9900000() {
    // Encoding: 0xE9900000
    // Test aarch32_LDMIB_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: register_list=0, cond=14, Rn=0, W=0
    let encoding: u32 = 0xE9900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMIB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_ldmib_a1_a_field_cond_15_max_0_f9900000() {
    // Encoding: 0xF9900000
    // Test aarch32_LDMIB_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: cond=15, W=0, Rn=0, register_list=0
    let encoding: u32 = 0xF9900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMIB_A1_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldmib_a1_a_field_w_0_min_0_09900000() {
    // Encoding: 0x09900000
    // Test aarch32_LDMIB_A1_A field W = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, W=0, register_list=0, cond=0
    let encoding: u32 = 0x09900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMIB_A1_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldmib_a1_a_field_w_1_max_0_09b00000() {
    // Encoding: 0x09B00000
    // Test aarch32_LDMIB_A1_A field W = 1 (Max)
    // ISET: A32
    // Fields: cond=0, Rn=0, register_list=0, W=1
    let encoding: u32 = 0x09B00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMIB_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldmib_a1_a_field_rn_0_min_0_09900000() {
    // Encoding: 0x09900000
    // Test aarch32_LDMIB_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: W=0, Rn=0, register_list=0, cond=0
    let encoding: u32 = 0x09900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMIB_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldmib_a1_a_field_rn_1_poweroftwo_0_09910000() {
    // Encoding: 0x09910000
    // Test aarch32_LDMIB_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, cond=0, Rn=1, register_list=0
    let encoding: u32 = 0x09910000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMIB_A1_A
/// ASL: `field register_list 0 +: 16`
/// Requirement: FieldBoundary { field: "register_list", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldmib_a1_a_field_register_list_0_min_0_09900000() {
    // Encoding: 0x09900000
    // Test aarch32_LDMIB_A1_A field register_list = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rn=0, W=0, register_list=0
    let encoding: u32 = 0x09900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMIB_A1_A
/// ASL: `field register_list 0 +: 16`
/// Requirement: FieldBoundary { field: "register_list", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_ldmib_a1_a_field_register_list_1_poweroftwo_0_09900001() {
    // Encoding: 0x09900001
    // Test aarch32_LDMIB_A1_A field register_list = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Rn=0, register_list=1, W=0
    let encoding: u32 = 0x09900001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMIB_A1_A
/// ASL: `field register_list 0 +: 16`
/// Requirement: FieldBoundary { field: "register_list", value: 32767, boundary: PowerOfTwoMinusOne }
/// midpoint (32767)
#[test]
fn test_aarch32_ldmib_a1_a_field_register_list_32767_poweroftwominusone_0_09907fff() {
    // Encoding: 0x09907FFF
    // Test aarch32_LDMIB_A1_A field register_list = 32767 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, Rn=0, register_list=32767, W=0
    let encoding: u32 = 0x09907FFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMIB_A1_A
/// ASL: `field register_list 0 +: 16`
/// Requirement: FieldBoundary { field: "register_list", value: 65535, boundary: Max }
/// maximum value (65535)
#[test]
fn test_aarch32_ldmib_a1_a_field_register_list_65535_max_0_0990ffff() {
    // Encoding: 0x0990FFFF
    // Test aarch32_LDMIB_A1_A field register_list = 65535 (Max)
    // ISET: A32
    // Fields: register_list=65535, cond=0, W=0, Rn=0
    let encoding: u32 = 0x0990FFFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMIB_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_ldmib_a1_a_combo_0_0_09900000() {
    // Encoding: 0x09900000
    // Test aarch32_LDMIB_A1_A field combination: cond=0, W=0, Rn=0, register_list=0
    // ISET: A32
    // Fields: cond=0, register_list=0, Rn=0, W=0
    let encoding: u32 = 0x09900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMIB_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_ldmib_a1_a_special_cond_0_condition_eq_0_09900000() {
    // Encoding: 0x09900000
    // Test aarch32_LDMIB_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: cond=0, register_list=0, Rn=0, W=0
    let encoding: u32 = 0x09900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMIB_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_ldmib_a1_a_special_cond_1_condition_ne_0_19900000() {
    // Encoding: 0x19900000
    // Test aarch32_LDMIB_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: Rn=0, cond=1, register_list=0, W=0
    let encoding: u32 = 0x19900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMIB_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_ldmib_a1_a_special_cond_2_condition_cs_hs_0_29900000() {
    // Encoding: 0x29900000
    // Test aarch32_LDMIB_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: register_list=0, W=0, Rn=0, cond=2
    let encoding: u32 = 0x29900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMIB_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_ldmib_a1_a_special_cond_3_condition_cc_lo_0_39900000() {
    // Encoding: 0x39900000
    // Test aarch32_LDMIB_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: W=0, register_list=0, cond=3, Rn=0
    let encoding: u32 = 0x39900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMIB_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_ldmib_a1_a_special_cond_4_condition_mi_0_49900000() {
    // Encoding: 0x49900000
    // Test aarch32_LDMIB_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: Rn=0, cond=4, register_list=0, W=0
    let encoding: u32 = 0x49900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMIB_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_ldmib_a1_a_special_cond_5_condition_pl_0_59900000() {
    // Encoding: 0x59900000
    // Test aarch32_LDMIB_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: cond=5, W=0, register_list=0, Rn=0
    let encoding: u32 = 0x59900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMIB_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_ldmib_a1_a_special_cond_6_condition_vs_0_69900000() {
    // Encoding: 0x69900000
    // Test aarch32_LDMIB_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: cond=6, W=0, Rn=0, register_list=0
    let encoding: u32 = 0x69900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMIB_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_ldmib_a1_a_special_cond_7_condition_vc_0_79900000() {
    // Encoding: 0x79900000
    // Test aarch32_LDMIB_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: W=0, cond=7, Rn=0, register_list=0
    let encoding: u32 = 0x79900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMIB_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_ldmib_a1_a_special_cond_8_condition_hi_0_89900000() {
    // Encoding: 0x89900000
    // Test aarch32_LDMIB_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: Rn=0, cond=8, register_list=0, W=0
    let encoding: u32 = 0x89900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMIB_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_ldmib_a1_a_special_cond_9_condition_ls_0_99900000() {
    // Encoding: 0x99900000
    // Test aarch32_LDMIB_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: register_list=0, Rn=0, W=0, cond=9
    let encoding: u32 = 0x99900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMIB_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_ldmib_a1_a_special_cond_10_condition_ge_0_a9900000() {
    // Encoding: 0xA9900000
    // Test aarch32_LDMIB_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: cond=10, W=0, Rn=0, register_list=0
    let encoding: u32 = 0xA9900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMIB_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_ldmib_a1_a_special_cond_11_condition_lt_0_b9900000() {
    // Encoding: 0xB9900000
    // Test aarch32_LDMIB_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: cond=11, W=0, Rn=0, register_list=0
    let encoding: u32 = 0xB9900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMIB_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_ldmib_a1_a_special_cond_12_condition_gt_0_c9900000() {
    // Encoding: 0xC9900000
    // Test aarch32_LDMIB_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: cond=12, Rn=0, register_list=0, W=0
    let encoding: u32 = 0xC9900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMIB_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_ldmib_a1_a_special_cond_13_condition_le_0_d9900000() {
    // Encoding: 0xD9900000
    // Test aarch32_LDMIB_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: register_list=0, Rn=0, cond=13, W=0
    let encoding: u32 = 0xD9900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMIB_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_ldmib_a1_a_special_cond_14_condition_al_0_e9900000() {
    // Encoding: 0xE9900000
    // Test aarch32_LDMIB_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: cond=14, W=0, register_list=0, Rn=0
    let encoding: u32 = 0xE9900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMIB_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_ldmib_a1_a_special_cond_15_condition_nv_0_f9900000() {
    // Encoding: 0xF9900000
    // Test aarch32_LDMIB_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: register_list=0, W=0, cond=15, Rn=0
    let encoding: u32 = 0xF9900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDMIB_A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Binary { op: Lt, lhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "BitCount" }, args: [Var(QualifiedIdentifier { qualifier: Any, name: "registers" })] }, rhs: LitInt(1) } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Binary { op: Lt, lhs: Call { name: QualifiedIdentifier { qualifier: Any, name: \"BitCount\" }, args: [Var(QualifiedIdentifier { qualifier: Any, name: \"registers\" })] }, rhs: LitInt(1) } } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldmib_a1_a_invalid_0_0_09900000() {
    // Encoding: 0x09900000
    // Test aarch32_LDMIB_A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Binary { op: Lt, lhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "BitCount" }, args: [Var(QualifiedIdentifier { qualifier: Any, name: "registers" })] }, rhs: LitInt(1) } } }
    // ISET: A32
    // Fields: W=0, Rn=0, cond=0, register_list=0
    let encoding: u32 = 0x09900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDMIB_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldmib_a1_a_invalid_1_0_09900000() {
    // Encoding: 0x09900000
    // Test aarch32_LDMIB_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: register_list=0, W=0, Rn=0, cond=0
    let encoding: u32 = 0x09900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDMIB_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "registers" }), indices: [Single(Var(QualifiedIdentifier { qualifier: Any, name: "n" }))] } }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"wback\" }), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"registers\" }), indices: [Single(Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }))] } }, rhs: LitBits([true]) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldmib_a1_a_invalid_2_0_09900000() {
    // Encoding: 0x09900000
    // Test aarch32_LDMIB_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "registers" }), indices: [Single(Var(QualifiedIdentifier { qualifier: Any, name: "n" }))] } }, rhs: LitBits([true]) }
    // ISET: A32
    // Fields: W=0, Rn=0, cond=0, register_list=0
    let encoding: u32 = 0x09900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDMIB_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldmib_a1_a_invalid_3_0_09900000() {
    // Encoding: 0x09900000
    // Test aarch32_LDMIB_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: cond=0, Rn=0, W=0, register_list=0
    let encoding: u32 = 0x09900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

// ============================================================================
// aarch32_LDR_r_A Tests
// ============================================================================

/// Provenance: aarch32_LDR_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_ldr_r_a1_a_field_cond_0_min_0_06100000() {
    // Encoding: 0x06100000
    // Test aarch32_LDR_r_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: cond=0, type1=0, imm5=0, P=0, Rn=0, W=0, U=0, Rm=0, Rt=0
    let encoding: u32 = 0x06100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_ldr_r_a1_a_field_cond_1_poweroftwo_0_16100000() {
    // Encoding: 0x16100000
    // Test aarch32_LDR_r_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, W=0, Rt=0, cond=1, Rn=0, imm5=0, type1=0, Rm=0, P=0
    let encoding: u32 = 0x16100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_ldr_r_a1_a_field_cond_2_poweroftwo_0_26100000() {
    // Encoding: 0x26100000
    // Test aarch32_LDR_r_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=2, W=0, P=0, type1=0, Rt=0, Rn=0, U=0, imm5=0, Rm=0
    let encoding: u32 = 0x26100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_ldr_r_a1_a_field_cond_3_poweroftwo_0_36100000() {
    // Encoding: 0x36100000
    // Test aarch32_LDR_r_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=3, W=0, P=0, Rn=0, type1=0, U=0, Rt=0, imm5=0, Rm=0
    let encoding: u32 = 0x36100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_ldr_r_a1_a_field_cond_4_poweroftwo_0_46100000() {
    // Encoding: 0x46100000
    // Test aarch32_LDR_r_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, Rn=0, Rt=0, W=0, cond=4, P=0, type1=0, Rm=0, imm5=0
    let encoding: u32 = 0x46100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_ldr_r_a1_a_field_cond_5_poweroftwo_0_56100000() {
    // Encoding: 0x56100000
    // Test aarch32_LDR_r_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rt=0, imm5=0, W=0, P=0, cond=5, U=0, type1=0, Rm=0
    let encoding: u32 = 0x56100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_ldr_r_a1_a_field_cond_6_poweroftwo_0_66100000() {
    // Encoding: 0x66100000
    // Test aarch32_LDR_r_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=6, Rn=0, W=0, P=0, type1=0, Rm=0, Rt=0, U=0, imm5=0
    let encoding: u32 = 0x66100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_ldr_r_a1_a_field_cond_7_poweroftwo_0_76100000() {
    // Encoding: 0x76100000
    // Test aarch32_LDR_r_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, U=0, Rn=0, imm5=0, W=0, type1=0, Rm=0, P=0, cond=7
    let encoding: u32 = 0x76100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_ldr_r_a1_a_field_cond_8_poweroftwo_0_86100000() {
    // Encoding: 0x86100000
    // Test aarch32_LDR_r_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, U=0, Rm=0, cond=8, type1=0, P=0, Rt=0, imm5=0, Rn=0
    let encoding: u32 = 0x86100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_ldr_r_a1_a_field_cond_9_poweroftwo_0_96100000() {
    // Encoding: 0x96100000
    // Test aarch32_LDR_r_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rt=0, Rm=0, type1=0, cond=9, U=0, P=0, imm5=0, W=0
    let encoding: u32 = 0x96100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_ldr_r_a1_a_field_cond_10_poweroftwo_0_a6100000() {
    // Encoding: 0xA6100000
    // Test aarch32_LDR_r_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, Rm=0, cond=10, Rt=0, W=0, P=0, Rn=0, imm5=0, type1=0
    let encoding: u32 = 0xA6100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_ldr_r_a1_a_field_cond_11_poweroftwo_0_b6100000() {
    // Encoding: 0xB6100000
    // Test aarch32_LDR_r_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, Rn=0, U=0, Rt=0, type1=0, cond=11, W=0, imm5=0, Rm=0
    let encoding: u32 = 0xB6100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_ldr_r_a1_a_field_cond_12_poweroftwo_0_c6100000() {
    // Encoding: 0xC6100000
    // Test aarch32_LDR_r_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, imm5=0, Rt=0, Rn=0, cond=12, W=0, U=0, type1=0, Rm=0
    let encoding: u32 = 0xC6100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_ldr_r_a1_a_field_cond_13_poweroftwo_0_d6100000() {
    // Encoding: 0xD6100000
    // Test aarch32_LDR_r_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: type1=0, W=0, P=0, Rn=0, imm5=0, Rt=0, Rm=0, cond=13, U=0
    let encoding: u32 = 0xD6100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_ldr_r_a1_a_field_cond_14_poweroftwo_0_e6100000() {
    // Encoding: 0xE6100000
    // Test aarch32_LDR_r_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, Rt=0, cond=14, imm5=0, U=0, type1=0, Rm=0, P=0, Rn=0
    let encoding: u32 = 0xE6100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_ldr_r_a1_a_field_cond_15_max_0_f6100000() {
    // Encoding: 0xF6100000
    // Test aarch32_LDR_r_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: imm5=0, Rn=0, P=0, Rt=0, W=0, cond=15, type1=0, Rm=0, U=0
    let encoding: u32 = 0xF6100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_r_A1_A
/// ASL: `field P 24 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldr_r_a1_a_field_p_0_min_0_06100000() {
    // Encoding: 0x06100000
    // Test aarch32_LDR_r_A1_A field P = 0 (Min)
    // ISET: A32
    // Fields: cond=0, type1=0, W=0, Rt=0, Rm=0, U=0, Rn=0, P=0, imm5=0
    let encoding: u32 = 0x06100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_r_A1_A
/// ASL: `field P 24 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldr_r_a1_a_field_p_1_max_0_07100000() {
    // Encoding: 0x07100000
    // Test aarch32_LDR_r_A1_A field P = 1 (Max)
    // ISET: A32
    // Fields: imm5=0, Rn=0, Rt=0, U=0, W=0, P=1, type1=0, Rm=0, cond=0
    let encoding: u32 = 0x07100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_r_A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldr_r_a1_a_field_u_0_min_0_06100000() {
    // Encoding: 0x06100000
    // Test aarch32_LDR_r_A1_A field U = 0 (Min)
    // ISET: A32
    // Fields: U=0, cond=0, type1=0, Rm=0, Rt=0, imm5=0, Rn=0, P=0, W=0
    let encoding: u32 = 0x06100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_r_A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldr_r_a1_a_field_u_1_max_0_06900000() {
    // Encoding: 0x06900000
    // Test aarch32_LDR_r_A1_A field U = 1 (Max)
    // ISET: A32
    // Fields: Rm=0, U=1, cond=0, P=0, W=0, Rt=0, Rn=0, imm5=0, type1=0
    let encoding: u32 = 0x06900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_r_A1_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldr_r_a1_a_field_w_0_min_0_06100000() {
    // Encoding: 0x06100000
    // Test aarch32_LDR_r_A1_A field W = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, Rn=0, Rt=0, P=0, imm5=0, cond=0, U=0, W=0, type1=0
    let encoding: u32 = 0x06100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_r_A1_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldr_r_a1_a_field_w_1_max_0_06300000() {
    // Encoding: 0x06300000
    // Test aarch32_LDR_r_A1_A field W = 1 (Max)
    // ISET: A32
    // Fields: W=1, P=0, Rm=0, U=0, cond=0, Rt=0, type1=0, imm5=0, Rn=0
    let encoding: u32 = 0x06300000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_r_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldr_r_a1_a_field_rn_0_min_0_06100000() {
    // Encoding: 0x06100000
    // Test aarch32_LDR_r_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: type1=0, cond=0, Rt=0, imm5=0, U=0, Rm=0, P=0, W=0, Rn=0
    let encoding: u32 = 0x06100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_r_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldr_r_a1_a_field_rn_1_poweroftwo_0_06110000() {
    // Encoding: 0x06110000
    // Test aarch32_LDR_r_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: imm5=0, W=0, P=0, cond=0, Rn=1, type1=0, Rt=0, Rm=0, U=0
    let encoding: u32 = 0x06110000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_r_A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldr_r_a1_a_field_rt_0_min_0_06100000() {
    // Encoding: 0x06100000
    // Test aarch32_LDR_r_A1_A field Rt = 0 (Min)
    // ISET: A32
    // Fields: imm5=0, Rm=0, cond=0, Rt=0, type1=0, U=0, P=0, W=0, Rn=0
    let encoding: u32 = 0x06100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_r_A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldr_r_a1_a_field_rt_1_poweroftwo_0_06101000() {
    // Encoding: 0x06101000
    // Test aarch32_LDR_r_A1_A field Rt = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, W=0, type1=0, Rt=1, Rm=0, cond=0, Rn=0, P=0, imm5=0
    let encoding: u32 = 0x06101000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_ldr_r_a1_a_field_imm5_0_zero_0_06100000() {
    // Encoding: 0x06100000
    // Test aarch32_LDR_r_A1_A field imm5 = 0 (Zero)
    // ISET: A32
    // Fields: Rn=0, type1=0, imm5=0, Rt=0, U=0, Rm=0, cond=0, P=0, W=0
    let encoding: u32 = 0x06100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_ldr_r_a1_a_field_imm5_1_poweroftwo_0_06100080() {
    // Encoding: 0x06100080
    // Test aarch32_LDR_r_A1_A field imm5 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Rt=0, U=0, Rn=0, type1=0, Rm=0, P=0, W=0, imm5=1
    let encoding: u32 = 0x06100080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_ldr_r_a1_a_field_imm5_3_poweroftwominusone_0_06100180() {
    // Encoding: 0x06100180
    // Test aarch32_LDR_r_A1_A field imm5 = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, W=0, Rm=0, P=0, imm5=3, U=0, type1=0, Rt=0, Rn=0
    let encoding: u32 = 0x06100180;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_ldr_r_a1_a_field_imm5_4_poweroftwo_0_06100200() {
    // Encoding: 0x06100200
    // Test aarch32_LDR_r_A1_A field imm5 = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, U=0, cond=0, W=0, type1=0, P=0, Rt=0, imm5=4, Rm=0
    let encoding: u32 = 0x06100200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_ldr_r_a1_a_field_imm5_7_poweroftwominusone_0_06100380() {
    // Encoding: 0x06100380
    // Test aarch32_LDR_r_A1_A field imm5 = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm5=7, type1=0, W=0, Rm=0, P=0, Rn=0, cond=0, Rt=0, U=0
    let encoding: u32 = 0x06100380;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_ldr_r_a1_a_field_imm5_8_poweroftwo_0_06100400() {
    // Encoding: 0x06100400
    // Test aarch32_LDR_r_A1_A field imm5 = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, type1=0, Rm=0, Rt=0, P=0, W=0, Rn=0, imm5=8, cond=0
    let encoding: u32 = 0x06100400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 15, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (15)
#[test]
fn test_aarch32_ldr_r_a1_a_field_imm5_15_poweroftwominusone_0_06100780() {
    // Encoding: 0x06100780
    // Test aarch32_LDR_r_A1_A field imm5 = 15 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, Rn=0, imm5=15, type1=0, Rt=0, P=0, Rm=0, W=0, U=0
    let encoding: u32 = 0x06100780;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_ldr_r_a1_a_field_imm5_16_poweroftwo_0_06100800() {
    // Encoding: 0x06100800
    // Test aarch32_LDR_r_A1_A field imm5 = 16 (PowerOfTwo)
    // ISET: A32
    // Fields: imm5=16, P=0, U=0, Rn=0, Rm=0, type1=0, cond=0, W=0, Rt=0
    let encoding: u32 = 0x06100800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 31, boundary: Max }
/// maximum immediate (31)
#[test]
fn test_aarch32_ldr_r_a1_a_field_imm5_31_max_0_06100f80() {
    // Encoding: 0x06100F80
    // Test aarch32_LDR_r_A1_A field imm5 = 31 (Max)
    // ISET: A32
    // Fields: Rn=0, imm5=31, cond=0, Rt=0, P=0, U=0, type1=0, W=0, Rm=0
    let encoding: u32 = 0x06100F80;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_r_A1_A
/// ASL: `field type1 5 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldr_r_a1_a_field_type1_0_min_0_06100000() {
    // Encoding: 0x06100000
    // Test aarch32_LDR_r_A1_A field type1 = 0 (Min)
    // ISET: A32
    // Fields: P=0, Rm=0, cond=0, Rt=0, type1=0, U=0, W=0, imm5=0, Rn=0
    let encoding: u32 = 0x06100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_r_A1_A
/// ASL: `field type1 5 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_ldr_r_a1_a_field_type1_1_poweroftwo_0_06100020() {
    // Encoding: 0x06100020
    // Test aarch32_LDR_r_A1_A field type1 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Rn=0, cond=0, Rt=0, U=0, P=0, W=0, imm5=0, type1=1
    let encoding: u32 = 0x06100020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_r_A1_A
/// ASL: `field type1 5 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_aarch32_ldr_r_a1_a_field_type1_3_max_0_06100060() {
    // Encoding: 0x06100060
    // Test aarch32_LDR_r_A1_A field type1 = 3 (Max)
    // ISET: A32
    // Fields: U=0, P=0, Rn=0, type1=3, cond=0, Rt=0, Rm=0, W=0, imm5=0
    let encoding: u32 = 0x06100060;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_r_A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldr_r_a1_a_field_rm_0_min_0_06100000() {
    // Encoding: 0x06100000
    // Test aarch32_LDR_r_A1_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, Rt=0, imm5=0, W=0, Rm=0, P=0, type1=0, cond=0, U=0
    let encoding: u32 = 0x06100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_r_A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldr_r_a1_a_field_rm_1_poweroftwo_0_06100001() {
    // Encoding: 0x06100001
    // Test aarch32_LDR_r_A1_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, imm5=0, Rt=0, U=0, P=0, Rm=1, type1=0, cond=0, W=0
    let encoding: u32 = 0x06100001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_r_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_ldr_r_a1_a_combo_0_0_06100000() {
    // Encoding: 0x06100000
    // Test aarch32_LDR_r_A1_A field combination: cond=0, P=0, U=0, W=0, Rn=0, Rt=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: imm5=0, U=0, P=0, cond=0, W=0, Rn=0, Rt=0, Rm=0, type1=0
    let encoding: u32 = 0x06100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_r_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_ldr_r_a1_a_special_cond_0_condition_eq_0_06100000() {
    // Encoding: 0x06100000
    // Test aarch32_LDR_r_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: Rm=0, cond=0, P=0, imm5=0, Rn=0, Rt=0, type1=0, W=0, U=0
    let encoding: u32 = 0x06100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_r_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_ldr_r_a1_a_special_cond_1_condition_ne_0_16100000() {
    // Encoding: 0x16100000
    // Test aarch32_LDR_r_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: P=0, Rn=0, Rt=0, U=0, cond=1, Rm=0, W=0, imm5=0, type1=0
    let encoding: u32 = 0x16100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_r_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_ldr_r_a1_a_special_cond_2_condition_cs_hs_0_26100000() {
    // Encoding: 0x26100000
    // Test aarch32_LDR_r_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: U=0, Rt=0, Rm=0, cond=2, P=0, imm5=0, Rn=0, W=0, type1=0
    let encoding: u32 = 0x26100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_r_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_ldr_r_a1_a_special_cond_3_condition_cc_lo_0_36100000() {
    // Encoding: 0x36100000
    // Test aarch32_LDR_r_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: P=0, W=0, type1=0, U=0, cond=3, Rt=0, imm5=0, Rm=0, Rn=0
    let encoding: u32 = 0x36100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_r_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_ldr_r_a1_a_special_cond_4_condition_mi_0_46100000() {
    // Encoding: 0x46100000
    // Test aarch32_LDR_r_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: Rm=0, P=0, imm5=0, Rn=0, U=0, W=0, Rt=0, cond=4, type1=0
    let encoding: u32 = 0x46100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_r_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_ldr_r_a1_a_special_cond_5_condition_pl_0_56100000() {
    // Encoding: 0x56100000
    // Test aarch32_LDR_r_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: Rn=0, W=0, U=0, Rt=0, type1=0, Rm=0, cond=5, imm5=0, P=0
    let encoding: u32 = 0x56100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_r_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_ldr_r_a1_a_special_cond_6_condition_vs_0_66100000() {
    // Encoding: 0x66100000
    // Test aarch32_LDR_r_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: U=0, W=0, Rm=0, Rn=0, cond=6, P=0, type1=0, Rt=0, imm5=0
    let encoding: u32 = 0x66100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_r_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_ldr_r_a1_a_special_cond_7_condition_vc_0_76100000() {
    // Encoding: 0x76100000
    // Test aarch32_LDR_r_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: Rt=0, W=0, P=0, Rm=0, U=0, imm5=0, Rn=0, cond=7, type1=0
    let encoding: u32 = 0x76100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_r_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_ldr_r_a1_a_special_cond_8_condition_hi_0_86100000() {
    // Encoding: 0x86100000
    // Test aarch32_LDR_r_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: Rt=0, W=0, Rn=0, cond=8, imm5=0, U=0, Rm=0, P=0, type1=0
    let encoding: u32 = 0x86100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_r_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_ldr_r_a1_a_special_cond_9_condition_ls_0_96100000() {
    // Encoding: 0x96100000
    // Test aarch32_LDR_r_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: P=0, U=0, type1=0, cond=9, imm5=0, Rm=0, Rt=0, W=0, Rn=0
    let encoding: u32 = 0x96100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_r_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_ldr_r_a1_a_special_cond_10_condition_ge_0_a6100000() {
    // Encoding: 0xA6100000
    // Test aarch32_LDR_r_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: W=0, Rm=0, imm5=0, P=0, Rn=0, Rt=0, U=0, cond=10, type1=0
    let encoding: u32 = 0xA6100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_r_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_ldr_r_a1_a_special_cond_11_condition_lt_0_b6100000() {
    // Encoding: 0xB6100000
    // Test aarch32_LDR_r_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: W=0, Rm=0, U=0, imm5=0, Rt=0, cond=11, P=0, type1=0, Rn=0
    let encoding: u32 = 0xB6100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_r_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_ldr_r_a1_a_special_cond_12_condition_gt_0_c6100000() {
    // Encoding: 0xC6100000
    // Test aarch32_LDR_r_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: cond=12, type1=0, U=0, Rm=0, Rn=0, Rt=0, imm5=0, P=0, W=0
    let encoding: u32 = 0xC6100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_r_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_ldr_r_a1_a_special_cond_13_condition_le_0_d6100000() {
    // Encoding: 0xD6100000
    // Test aarch32_LDR_r_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: cond=13, P=0, Rt=0, U=0, type1=0, Rm=0, W=0, imm5=0, Rn=0
    let encoding: u32 = 0xD6100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_r_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_ldr_r_a1_a_special_cond_14_condition_al_0_e6100000() {
    // Encoding: 0xE6100000
    // Test aarch32_LDR_r_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: U=0, Rn=0, W=0, Rm=0, Rt=0, imm5=0, P=0, type1=0, cond=14
    let encoding: u32 = 0xE6100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_r_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_ldr_r_a1_a_special_cond_15_condition_nv_0_f6100000() {
    // Encoding: 0xF6100000
    // Test aarch32_LDR_r_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: U=0, W=0, type1=0, P=0, cond=15, imm5=0, Rn=0, Rt=0, Rm=0
    let encoding: u32 = 0xF6100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDR_r_A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }), rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }), rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldr_r_a1_a_invalid_0_0_06100000() {
    // Encoding: 0x06100000
    // Test aarch32_LDR_r_A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }), rhs: LitInt(15) }
    // ISET: A32
    // Fields: Rn=0, imm5=0, P=0, cond=0, U=0, W=0, type1=0, Rt=0, Rm=0
    let encoding: u32 = 0x06100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDR_r_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldr_r_a1_a_invalid_1_0_06100000() {
    // Encoding: 0x06100000
    // Test aarch32_LDR_r_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: type1=0, imm5=0, U=0, cond=0, Rn=0, Rt=0, P=0, W=0, Rm=0
    let encoding: u32 = 0x06100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDR_r_A1_A
/// ASL: `Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"wback\" }), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }) } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldr_r_a1_a_invalid_2_0_06100000() {
    // Encoding: 0x06100000
    // Test aarch32_LDR_r_A1_A invalid encoding: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) } }
    // ISET: A32
    // Fields: U=0, P=0, W=0, cond=0, Rn=0, type1=0, imm5=0, Rt=0, Rm=0
    let encoding: u32 = 0x06100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDR_r_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldr_r_a1_a_invalid_3_0_06100000() {
    // Encoding: 0x06100000
    // Test aarch32_LDR_r_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: W=0, Rn=0, cond=0, imm5=0, U=0, Rt=0, Rm=0, P=0, type1=0
    let encoding: u32 = 0x06100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDR_r_T1_A
/// ASL: `field Rm 22 +: 3`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldr_r_t1_a_field_rm_0_min_0_58000000() {
    // Thumb encoding (32): 0x58000000
    // Test aarch32_LDR_r_T1_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: Rm=0, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x58000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_r_T1_A
/// ASL: `field Rm 22 +: 3`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldr_r_t1_a_field_rm_1_poweroftwo_0_58400000() {
    // Thumb encoding (32): 0x58400000
    // Test aarch32_LDR_r_T1_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=1, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x58400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_r_T1_A
/// ASL: `field Rn 19 +: 3`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldr_r_t1_a_field_rn_0_min_0_58000000() {
    // Thumb encoding (32): 0x58000000
    // Test aarch32_LDR_r_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rt=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x58000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_r_T1_A
/// ASL: `field Rn 19 +: 3`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldr_r_t1_a_field_rn_1_poweroftwo_0_58080000() {
    // Thumb encoding (32): 0x58080000
    // Test aarch32_LDR_r_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=1, Rt=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x58080000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_r_T1_A
/// ASL: `field Rt 16 +: 3`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldr_r_t1_a_field_rt_0_min_0_58000000() {
    // Thumb encoding (32): 0x58000000
    // Test aarch32_LDR_r_T1_A field Rt = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rt=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x58000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_r_T1_A
/// ASL: `field Rt 16 +: 3`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldr_r_t1_a_field_rt_1_poweroftwo_0_58010000() {
    // Thumb encoding (32): 0x58010000
    // Test aarch32_LDR_r_T1_A field Rt = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Rt=1, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x58010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_r_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch32_ldr_r_t1_a_combo_0_0_58000000() {
    // Thumb encoding (32): 0x58000000
    // Test aarch32_LDR_r_T1_A field combination: Rm=0, Rn=0, Rt=0
    // ISET: T32
    // Fields: Rm=0, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x58000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_r_T2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldr_r_t2_a_field_rn_0_min_0_f8500000() {
    // Thumb encoding (32): 0xF8500000
    // Test aarch32_LDR_r_T2_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rm=0, Rn=0, Rt=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8500000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_r_T2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldr_r_t2_a_field_rn_1_poweroftwo_0_f8510000() {
    // Thumb encoding (32): 0xF8510000
    // Test aarch32_LDR_r_T2_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=1, Rt=0, imm2=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8510000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_r_T2_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldr_r_t2_a_field_rt_0_min_0_f8500000() {
    // Thumb encoding (32): 0xF8500000
    // Test aarch32_LDR_r_T2_A field Rt = 0 (Min)
    // ISET: T32
    // Fields: imm2=0, Rn=0, Rm=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8500000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_r_T2_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldr_r_t2_a_field_rt_1_poweroftwo_0_f8501000() {
    // Thumb encoding (32): 0xF8501000
    // Test aarch32_LDR_r_T2_A field Rt = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=1, Rn=0, imm2=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8501000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_r_T2_A
/// ASL: `field imm2 4 +: 2`
/// Requirement: FieldBoundary { field: "imm2", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_ldr_r_t2_a_field_imm2_0_zero_0_f8500000() {
    // Thumb encoding (32): 0xF8500000
    // Test aarch32_LDR_r_T2_A field imm2 = 0 (Zero)
    // ISET: T32
    // Fields: Rm=0, Rt=0, imm2=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8500000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_r_T2_A
/// ASL: `field imm2 4 +: 2`
/// Requirement: FieldBoundary { field: "imm2", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_ldr_r_t2_a_field_imm2_1_poweroftwo_0_f8500010() {
    // Thumb encoding (32): 0xF8500010
    // Test aarch32_LDR_r_T2_A field imm2 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm2=1, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8500010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_r_T2_A
/// ASL: `field imm2 4 +: 2`
/// Requirement: FieldBoundary { field: "imm2", value: 3, boundary: Max }
/// maximum immediate (3)
#[test]
fn test_aarch32_ldr_r_t2_a_field_imm2_3_max_0_f8500030() {
    // Thumb encoding (32): 0xF8500030
    // Test aarch32_LDR_r_T2_A field imm2 = 3 (Max)
    // ISET: T32
    // Fields: Rt=0, imm2=3, Rn=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8500030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_r_T2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldr_r_t2_a_field_rm_0_min_0_f8500000() {
    // Thumb encoding (32): 0xF8500000
    // Test aarch32_LDR_r_T2_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: Rt=0, imm2=0, Rm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8500000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_r_T2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldr_r_t2_a_field_rm_1_poweroftwo_0_f8500001() {
    // Thumb encoding (32): 0xF8500001
    // Test aarch32_LDR_r_T2_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Rm=1, imm2=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8500001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_r_T2_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_ldr_r_t2_a_combo_0_0_f8500000() {
    // Thumb encoding (32): 0xF8500000
    // Test aarch32_LDR_r_T2_A field combination: Rn=0, Rt=0, imm2=0, Rm=0
    // ISET: T32
    // Fields: Rm=0, Rn=0, Rt=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8500000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDR_r_T2_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }), rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }), rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldr_r_t2_a_invalid_0_0_f8500000() {
    // Thumb encoding (32): 0xF8500000
    // Test aarch32_LDR_r_T2_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }), rhs: LitInt(15) }
    // ISET: T32
    // Fields: Rt=0, Rm=0, Rn=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8500000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_LDR_r_T2_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldr_r_t2_a_invalid_1_0_f8500000() {
    // Thumb encoding (32): 0xF8500000
    // Test aarch32_LDR_r_T2_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rt=0, Rn=0, Rm=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8500000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_LDR_r_T2_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: And, lhs: Binary { op: And, lhs: LitInt(15), rhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] } }, rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "LastInITBlock" }, args: [] } } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: Binary { op: And, lhs: Binary { op: And, lhs: LitInt(15), rhs: Call { name: QualifiedIdentifier { qualifier: Any, name: \"InITBlock\" }, args: [] } }, rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"LastInITBlock\" }, args: [] } } } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldr_r_t2_a_invalid_2_0_f8500000() {
    // Thumb encoding (32): 0xF8500000
    // Test aarch32_LDR_r_T2_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: And, lhs: Binary { op: And, lhs: LitInt(15), rhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] } }, rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "LastInITBlock" }, args: [] } } } }
    // ISET: T32
    // Fields: Rm=0, Rn=0, Rt=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8500000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_LDR_r_T2_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldr_r_t2_a_invalid_3_0_f8500000() {
    // Thumb encoding (32): 0xF8500000
    // Test aarch32_LDR_r_T2_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: imm2=0, Rt=0, Rn=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8500000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_LDR_r_A1_A
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldr_r_a1_a_exception_0_06100000() {
    // Test aarch32_LDR_r_A1_A exception: Unpredictable
    // Encoding: 0x06100000
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x06100000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_LDR_r_A1_A
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldr_r_a1_a_exception_1_06100000() {
    // Test aarch32_LDR_r_A1_A exception: Unpredictable
    // Encoding: 0x06100000
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x06100000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_LDR_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 0 (32)
#[test]
fn test_aarch32_ldr_r_t1_a_lslv_oracle_32_0_58020020() {
    // Test LSLV 32-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x12345678, "W0 should be 0x12345678");
}

/// Provenance: aarch32_LDR_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 0 (64)
#[test]
fn test_aarch32_ldr_r_t1_a_lslv_oracle_64_0_d8020020() {
    // Test LSLV 64-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x12345678,
        "X0 should be 0x0000000012345678"
    );
}

/// Provenance: aarch32_LDR_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4 (32)
#[test]
fn test_aarch32_ldr_r_t1_a_lslv_oracle_32_1_58020020() {
    // Test LSLV 32-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x4);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x23456780, "W0 should be 0x23456780");
}

/// Provenance: aarch32_LDR_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 4 (64)
#[test]
fn test_aarch32_ldr_r_t1_a_lslv_oracle_64_1_d8020020() {
    // Test LSLV 64-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x4);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x23456780,
        "X0 should be 0x0000000123456780"
    );
}

/// Provenance: aarch32_LDR_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 8 (32)
#[test]
fn test_aarch32_ldr_r_t1_a_lslv_oracle_32_2_58020020() {
    // Test LSLV 32-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x8);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x34567800, "W0 should be 0x34567800");
}

/// Provenance: aarch32_LDR_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 8 (64)
#[test]
fn test_aarch32_ldr_r_t1_a_lslv_oracle_64_2_d8020020() {
    // Test LSLV 64-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x8);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x34567800,
        "X0 should be 0x0000001234567800"
    );
}

/// Provenance: aarch32_LDR_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1 (32)
#[test]
fn test_aarch32_ldr_r_t1_a_lslv_oracle_32_3_58020020() {
    // Test LSLV 32-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_LDR_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// MSB set, shift 1 (64)
#[test]
fn test_aarch32_ldr_r_t1_a_lslv_oracle_64_3_d8020020() {
    // Test LSLV 64-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_LDR_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// LSB set, max shift (32)
#[test]
fn test_aarch32_ldr_r_t1_a_lslv_oracle_32_4_58020020() {
    // Test LSLV 32-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x3F);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "W0 should be 0x80000000");
}

/// Provenance: aarch32_LDR_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// LSB set, max shift (64)
#[test]
fn test_aarch32_ldr_r_t1_a_lslv_oracle_64_4_d8020020() {
    // Test LSLV 64-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3F);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x8000000000000000");
}

/// Provenance: aarch32_LDR_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// all ones, shift 32 (32)
#[test]
fn test_aarch32_ldr_r_t1_a_lslv_oracle_32_5_58020020() {
    // Test LSLV 32-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x20);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "W0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_LDR_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// all ones, shift 32 (64)
#[test]
fn test_aarch32_ldr_r_t1_a_lslv_oracle_64_5_d8020020() {
    // Test LSLV 64-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x20);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0xFFFFFFFF00000000");
}

/// Provenance: aarch32_LDR_r_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// no shift
#[test]
fn test_aarch32_ldr_r_t1_a_t16_oracle_0_58880000() {
    // Test T16 LSLS: no shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_LDR_r_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4
#[test]
fn test_aarch32_ldr_r_t1_a_t16_oracle_1_58880000() {
    // Test T16 LSLS: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x4);
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF0, "R0 should be 0x00000FF0");
}

/// Provenance: aarch32_LDR_r_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1
#[test]
fn test_aarch32_ldr_r_t1_a_t16_oracle_2_58880000() {
    // Test T16 LSLS: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_LDR_r_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift to MSB
#[test]
fn test_aarch32_ldr_r_t1_a_t16_oracle_3_58880000() {
    // Test T16 LSLS: shift to MSB (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x1F);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "R0 should be 0x80000000");
}

/// Provenance: aarch32_LDR_r_T1_A
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldr_r_t1_a_exception_0_58000000() {
    // Test aarch32_LDR_r_T1_A exception: Unpredictable
    // ISET: T16
    let mut cpu = create_test_cpu();
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_LDR_r_T1_A
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldr_r_t1_a_exception_1_58000000() {
    // Test aarch32_LDR_r_T1_A exception: Unpredictable
    // ISET: T16
    let mut cpu = create_test_cpu();
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_LDR_r_T2_A
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldr_r_t2_a_exception_0_f8500000() {
    // Test aarch32_LDR_r_T2_A exception: Unpredictable
    // ISET: T32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF8500000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_LDR_r_T2_A
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldr_r_t2_a_exception_1_f8500000() {
    // Test aarch32_LDR_r_T2_A exception: Unpredictable
    // ISET: T32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF8500000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// aarch32_LDRHT_A Tests
// ============================================================================

/// Provenance: aarch32_LDRHT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_ldrht_a1_a_field_cond_0_min_b0_007000b0() {
    // Encoding: 0x007000B0
    // Test aarch32_LDRHT_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, cond=0, imm4L=0, U=0, imm4H=0, Rt=0
    let encoding: u32 = 0x007000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRHT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_ldrht_a1_a_field_cond_1_poweroftwo_b0_107000b0() {
    // Encoding: 0x107000B0
    // Test aarch32_LDRHT_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, U=0, Rn=0, imm4L=0, imm4H=0, cond=1
    let encoding: u32 = 0x107000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRHT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_ldrht_a1_a_field_cond_2_poweroftwo_b0_207000b0() {
    // Encoding: 0x207000B0
    // Test aarch32_LDRHT_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, imm4H=0, Rn=0, imm4L=0, cond=2, Rt=0
    let encoding: u32 = 0x207000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRHT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_ldrht_a1_a_field_cond_3_poweroftwo_b0_307000b0() {
    // Encoding: 0x307000B0
    // Test aarch32_LDRHT_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, imm4L=0, imm4H=0, cond=3, U=0, Rt=0
    let encoding: u32 = 0x307000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRHT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_ldrht_a1_a_field_cond_4_poweroftwo_b0_407000b0() {
    // Encoding: 0x407000B0
    // Test aarch32_LDRHT_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=4, U=0, imm4L=0, Rn=0, imm4H=0, Rt=0
    let encoding: u32 = 0x407000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRHT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_ldrht_a1_a_field_cond_5_poweroftwo_b0_507000b0() {
    // Encoding: 0x507000B0
    // Test aarch32_LDRHT_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, Rt=0, cond=5, Rn=0, imm4H=0, imm4L=0
    let encoding: u32 = 0x507000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRHT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_ldrht_a1_a_field_cond_6_poweroftwo_b0_607000b0() {
    // Encoding: 0x607000B0
    // Test aarch32_LDRHT_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4H=0, cond=6, U=0, Rn=0, imm4L=0, Rt=0
    let encoding: u32 = 0x607000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRHT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_ldrht_a1_a_field_cond_7_poweroftwo_b0_707000b0() {
    // Encoding: 0x707000B0
    // Test aarch32_LDRHT_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4L=0, U=0, Rn=0, cond=7, Rt=0, imm4H=0
    let encoding: u32 = 0x707000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRHT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_ldrht_a1_a_field_cond_8_poweroftwo_b0_807000b0() {
    // Encoding: 0x807000B0
    // Test aarch32_LDRHT_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, U=0, Rt=0, cond=8, imm4H=0, imm4L=0
    let encoding: u32 = 0x807000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRHT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_ldrht_a1_a_field_cond_9_poweroftwo_b0_907000b0() {
    // Encoding: 0x907000B0
    // Test aarch32_LDRHT_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4H=0, Rn=0, Rt=0, imm4L=0, cond=9, U=0
    let encoding: u32 = 0x907000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRHT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_ldrht_a1_a_field_cond_10_poweroftwo_b0_a07000b0() {
    // Encoding: 0xA07000B0
    // Test aarch32_LDRHT_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4H=0, Rn=0, U=0, cond=10, imm4L=0, Rt=0
    let encoding: u32 = 0xA07000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRHT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_ldrht_a1_a_field_cond_11_poweroftwo_b0_b07000b0() {
    // Encoding: 0xB07000B0
    // Test aarch32_LDRHT_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, Rn=0, U=0, imm4H=0, imm4L=0, cond=11
    let encoding: u32 = 0xB07000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRHT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_ldrht_a1_a_field_cond_12_poweroftwo_b0_c07000b0() {
    // Encoding: 0xC07000B0
    // Test aarch32_LDRHT_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rt=0, imm4H=0, imm4L=0, cond=12, U=0
    let encoding: u32 = 0xC07000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRHT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_ldrht_a1_a_field_cond_13_poweroftwo_b0_d07000b0() {
    // Encoding: 0xD07000B0
    // Test aarch32_LDRHT_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4L=0, cond=13, Rt=0, Rn=0, U=0, imm4H=0
    let encoding: u32 = 0xD07000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRHT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_ldrht_a1_a_field_cond_14_poweroftwo_b0_e07000b0() {
    // Encoding: 0xE07000B0
    // Test aarch32_LDRHT_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=14, Rt=0, imm4L=0, imm4H=0, U=0, Rn=0
    let encoding: u32 = 0xE07000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRHT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_ldrht_a1_a_field_cond_15_max_b0_f07000b0() {
    // Encoding: 0xF07000B0
    // Test aarch32_LDRHT_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: U=0, Rt=0, cond=15, imm4L=0, Rn=0, imm4H=0
    let encoding: u32 = 0xF07000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRHT_A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldrht_a1_a_field_u_0_min_b0_007000b0() {
    // Encoding: 0x007000B0
    // Test aarch32_LDRHT_A1_A field U = 0 (Min)
    // ISET: A32
    // Fields: imm4L=0, U=0, cond=0, Rn=0, Rt=0, imm4H=0
    let encoding: u32 = 0x007000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRHT_A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldrht_a1_a_field_u_1_max_b0_00f000b0() {
    // Encoding: 0x00F000B0
    // Test aarch32_LDRHT_A1_A field U = 1 (Max)
    // ISET: A32
    // Fields: cond=0, Rt=0, U=1, Rn=0, imm4H=0, imm4L=0
    let encoding: u32 = 0x00F000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRHT_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrht_a1_a_field_rn_0_min_b0_007000b0() {
    // Encoding: 0x007000B0
    // Test aarch32_LDRHT_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: U=0, imm4L=0, imm4H=0, Rt=0, Rn=0, cond=0
    let encoding: u32 = 0x007000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRHT_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrht_a1_a_field_rn_1_poweroftwo_b0_007100b0() {
    // Encoding: 0x007100B0
    // Test aarch32_LDRHT_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, U=0, cond=0, imm4L=0, Rn=1, imm4H=0
    let encoding: u32 = 0x007100B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRHT_A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrht_a1_a_field_rt_0_min_b0_007000b0() {
    // Encoding: 0x007000B0
    // Test aarch32_LDRHT_A1_A field Rt = 0 (Min)
    // ISET: A32
    // Fields: Rt=0, imm4L=0, Rn=0, cond=0, imm4H=0, U=0
    let encoding: u32 = 0x007000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRHT_A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrht_a1_a_field_rt_1_poweroftwo_b0_007010b0() {
    // Encoding: 0x007010B0
    // Test aarch32_LDRHT_A1_A field Rt = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4H=0, cond=0, Rt=1, imm4L=0, Rn=0, U=0
    let encoding: u32 = 0x007010B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRHT_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_ldrht_a1_a_field_imm4h_0_zero_b0_007000b0() {
    // Encoding: 0x007000B0
    // Test aarch32_LDRHT_A1_A field imm4H = 0 (Zero)
    // ISET: A32
    // Fields: cond=0, Rt=0, U=0, imm4L=0, Rn=0, imm4H=0
    let encoding: u32 = 0x007000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRHT_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_ldrht_a1_a_field_imm4h_1_poweroftwo_b0_007001b0() {
    // Encoding: 0x007001B0
    // Test aarch32_LDRHT_A1_A field imm4H = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, U=0, imm4L=0, Rn=0, imm4H=1, Rt=0
    let encoding: u32 = 0x007001B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRHT_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_ldrht_a1_a_field_imm4h_3_poweroftwominusone_b0_007003b0() {
    // Encoding: 0x007003B0
    // Test aarch32_LDRHT_A1_A field imm4H = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm4H=3, cond=0, imm4L=0, Rt=0, Rn=0, U=0
    let encoding: u32 = 0x007003B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRHT_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_ldrht_a1_a_field_imm4h_4_poweroftwo_b0_007004b0() {
    // Encoding: 0x007004B0
    // Test aarch32_LDRHT_A1_A field imm4H = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4H=4, imm4L=0, Rt=0, cond=0, U=0, Rn=0
    let encoding: u32 = 0x007004B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRHT_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_aarch32_ldrht_a1_a_field_imm4h_7_poweroftwominusone_b0_007007b0() {
    // Encoding: 0x007007B0
    // Test aarch32_LDRHT_A1_A field imm4H = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rt=0, imm4L=0, U=0, cond=0, Rn=0, imm4H=7
    let encoding: u32 = 0x007007B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRHT_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_ldrht_a1_a_field_imm4h_8_poweroftwo_b0_007008b0() {
    // Encoding: 0x007008B0
    // Test aarch32_LDRHT_A1_A field imm4H = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, U=0, Rn=0, Rt=0, imm4H=8, imm4L=0
    let encoding: u32 = 0x007008B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRHT_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_aarch32_ldrht_a1_a_field_imm4h_15_max_b0_00700fb0() {
    // Encoding: 0x00700FB0
    // Test aarch32_LDRHT_A1_A field imm4H = 15 (Max)
    // ISET: A32
    // Fields: cond=0, Rn=0, Rt=0, U=0, imm4H=15, imm4L=0
    let encoding: u32 = 0x00700FB0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRHT_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_ldrht_a1_a_field_imm4l_0_zero_b0_007000b0() {
    // Encoding: 0x007000B0
    // Test aarch32_LDRHT_A1_A field imm4L = 0 (Zero)
    // ISET: A32
    // Fields: imm4L=0, cond=0, Rt=0, Rn=0, U=0, imm4H=0
    let encoding: u32 = 0x007000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRHT_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_ldrht_a1_a_field_imm4l_1_poweroftwo_b0_007000b1() {
    // Encoding: 0x007000B1
    // Test aarch32_LDRHT_A1_A field imm4L = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4H=0, Rn=0, imm4L=1, U=0, cond=0, Rt=0
    let encoding: u32 = 0x007000B1;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRHT_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_ldrht_a1_a_field_imm4l_3_poweroftwominusone_b0_007000b3() {
    // Encoding: 0x007000B3
    // Test aarch32_LDRHT_A1_A field imm4L = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm4H=0, imm4L=3, cond=0, U=0, Rn=0, Rt=0
    let encoding: u32 = 0x007000B3;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRHT_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_ldrht_a1_a_field_imm4l_4_poweroftwo_b0_007000b4() {
    // Encoding: 0x007000B4
    // Test aarch32_LDRHT_A1_A field imm4L = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, imm4H=0, Rn=0, imm4L=4, U=0, cond=0
    let encoding: u32 = 0x007000B4;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRHT_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_aarch32_ldrht_a1_a_field_imm4l_7_poweroftwominusone_b0_007000b7() {
    // Encoding: 0x007000B7
    // Test aarch32_LDRHT_A1_A field imm4L = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, imm4H=0, imm4L=7, Rt=0, U=0, Rn=0
    let encoding: u32 = 0x007000B7;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRHT_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_ldrht_a1_a_field_imm4l_8_poweroftwo_b0_007000b8() {
    // Encoding: 0x007000B8
    // Test aarch32_LDRHT_A1_A field imm4L = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, imm4L=8, Rt=0, cond=0, Rn=0, imm4H=0
    let encoding: u32 = 0x007000B8;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRHT_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_aarch32_ldrht_a1_a_field_imm4l_15_max_b0_007000bf() {
    // Encoding: 0x007000BF
    // Test aarch32_LDRHT_A1_A field imm4L = 15 (Max)
    // ISET: A32
    // Fields: imm4H=0, cond=0, Rt=0, imm4L=15, Rn=0, U=0
    let encoding: u32 = 0x007000BF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRHT_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_ldrht_a1_a_combo_0_b0_007000b0() {
    // Encoding: 0x007000B0
    // Test aarch32_LDRHT_A1_A field combination: cond=0, U=0, Rn=0, Rt=0, imm4H=0, imm4L=0
    // ISET: A32
    // Fields: Rn=0, U=0, Rt=0, imm4H=0, imm4L=0, cond=0
    let encoding: u32 = 0x007000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRHT_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_ldrht_a1_a_special_cond_0_condition_eq_176_007000b0() {
    // Encoding: 0x007000B0
    // Test aarch32_LDRHT_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: imm4L=0, Rn=0, Rt=0, cond=0, U=0, imm4H=0
    let encoding: u32 = 0x007000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRHT_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_ldrht_a1_a_special_cond_1_condition_ne_176_107000b0() {
    // Encoding: 0x107000B0
    // Test aarch32_LDRHT_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: Rn=0, cond=1, U=0, imm4H=0, Rt=0, imm4L=0
    let encoding: u32 = 0x107000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRHT_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_ldrht_a1_a_special_cond_2_condition_cs_hs_176_207000b0() {
    // Encoding: 0x207000B0
    // Test aarch32_LDRHT_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: U=0, Rn=0, cond=2, Rt=0, imm4H=0, imm4L=0
    let encoding: u32 = 0x207000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRHT_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_ldrht_a1_a_special_cond_3_condition_cc_lo_176_307000b0() {
    // Encoding: 0x307000B0
    // Test aarch32_LDRHT_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: cond=3, Rn=0, imm4H=0, imm4L=0, Rt=0, U=0
    let encoding: u32 = 0x307000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRHT_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_ldrht_a1_a_special_cond_4_condition_mi_176_407000b0() {
    // Encoding: 0x407000B0
    // Test aarch32_LDRHT_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: imm4H=0, U=0, Rt=0, cond=4, Rn=0, imm4L=0
    let encoding: u32 = 0x407000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRHT_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_ldrht_a1_a_special_cond_5_condition_pl_176_507000b0() {
    // Encoding: 0x507000B0
    // Test aarch32_LDRHT_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: cond=5, Rt=0, imm4H=0, imm4L=0, Rn=0, U=0
    let encoding: u32 = 0x507000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRHT_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_ldrht_a1_a_special_cond_6_condition_vs_176_607000b0() {
    // Encoding: 0x607000B0
    // Test aarch32_LDRHT_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: Rn=0, cond=6, U=0, imm4L=0, Rt=0, imm4H=0
    let encoding: u32 = 0x607000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRHT_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_ldrht_a1_a_special_cond_7_condition_vc_176_707000b0() {
    // Encoding: 0x707000B0
    // Test aarch32_LDRHT_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: imm4L=0, Rt=0, cond=7, U=0, Rn=0, imm4H=0
    let encoding: u32 = 0x707000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRHT_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_ldrht_a1_a_special_cond_8_condition_hi_176_807000b0() {
    // Encoding: 0x807000B0
    // Test aarch32_LDRHT_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: cond=8, Rn=0, Rt=0, U=0, imm4H=0, imm4L=0
    let encoding: u32 = 0x807000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRHT_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_ldrht_a1_a_special_cond_9_condition_ls_176_907000b0() {
    // Encoding: 0x907000B0
    // Test aarch32_LDRHT_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: imm4H=0, Rt=0, U=0, imm4L=0, Rn=0, cond=9
    let encoding: u32 = 0x907000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRHT_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_ldrht_a1_a_special_cond_10_condition_ge_176_a07000b0() {
    // Encoding: 0xA07000B0
    // Test aarch32_LDRHT_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: cond=10, imm4H=0, Rn=0, U=0, Rt=0, imm4L=0
    let encoding: u32 = 0xA07000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRHT_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_ldrht_a1_a_special_cond_11_condition_lt_176_b07000b0() {
    // Encoding: 0xB07000B0
    // Test aarch32_LDRHT_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: imm4H=0, U=0, Rn=0, cond=11, Rt=0, imm4L=0
    let encoding: u32 = 0xB07000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRHT_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_ldrht_a1_a_special_cond_12_condition_gt_176_c07000b0() {
    // Encoding: 0xC07000B0
    // Test aarch32_LDRHT_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: Rt=0, imm4H=0, U=0, imm4L=0, Rn=0, cond=12
    let encoding: u32 = 0xC07000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRHT_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_ldrht_a1_a_special_cond_13_condition_le_176_d07000b0() {
    // Encoding: 0xD07000B0
    // Test aarch32_LDRHT_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: Rn=0, U=0, imm4H=0, imm4L=0, cond=13, Rt=0
    let encoding: u32 = 0xD07000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRHT_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_ldrht_a1_a_special_cond_14_condition_al_176_e07000b0() {
    // Encoding: 0xE07000B0
    // Test aarch32_LDRHT_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: cond=14, Rt=0, Rn=0, U=0, imm4H=0, imm4L=0
    let encoding: u32 = 0xE07000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRHT_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_ldrht_a1_a_special_cond_15_condition_nv_176_f07000b0() {
    // Encoding: 0xF07000B0
    // Test aarch32_LDRHT_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: U=0, imm4L=0, Rt=0, imm4H=0, cond=15, Rn=0
    let encoding: u32 = 0xF07000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRHT_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrht_a1_a_invalid_0_b0_007000b0() {
    // Encoding: 0x007000B0
    // Test aarch32_LDRHT_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) }
    // ISET: A32
    // Fields: imm4L=0, Rt=0, U=0, Rn=0, imm4H=0, cond=0
    let encoding: u32 = 0x007000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRHT_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrht_a1_a_invalid_1_b0_007000b0() {
    // Encoding: 0x007000B0
    // Test aarch32_LDRHT_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: imm4L=0, U=0, Rn=0, cond=0, Rt=0, imm4H=0
    let encoding: u32 = 0x007000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRHT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_ldrht_a2_a_field_cond_0_min_b0_003000b0() {
    // Encoding: 0x003000B0
    // Test aarch32_LDRHT_A2_A field cond = 0 (Min)
    // ISET: A32
    // Fields: Rt=0, Rn=0, Rm=0, cond=0, U=0
    let encoding: u32 = 0x003000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRHT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_ldrht_a2_a_field_cond_1_poweroftwo_b0_103000b0() {
    // Encoding: 0x103000B0
    // Test aarch32_LDRHT_A2_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, Rn=0, cond=1, Rt=0, Rm=0
    let encoding: u32 = 0x103000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRHT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_ldrht_a2_a_field_cond_2_poweroftwo_b0_203000b0() {
    // Encoding: 0x203000B0
    // Test aarch32_LDRHT_A2_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=2, Rm=0, Rn=0, U=0, Rt=0
    let encoding: u32 = 0x203000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRHT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_ldrht_a2_a_field_cond_3_poweroftwo_b0_303000b0() {
    // Encoding: 0x303000B0
    // Test aarch32_LDRHT_A2_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, Rt=0, Rn=0, Rm=0, cond=3
    let encoding: u32 = 0x303000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRHT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_ldrht_a2_a_field_cond_4_poweroftwo_b0_403000b0() {
    // Encoding: 0x403000B0
    // Test aarch32_LDRHT_A2_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Rt=0, U=0, cond=4, Rn=0
    let encoding: u32 = 0x403000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRHT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_ldrht_a2_a_field_cond_5_poweroftwo_b0_503000b0() {
    // Encoding: 0x503000B0
    // Test aarch32_LDRHT_A2_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=5, Rt=0, Rm=0, U=0, Rn=0
    let encoding: u32 = 0x503000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRHT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_ldrht_a2_a_field_cond_6_poweroftwo_b0_603000b0() {
    // Encoding: 0x603000B0
    // Test aarch32_LDRHT_A2_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=6, U=0, Rn=0, Rm=0, Rt=0
    let encoding: u32 = 0x603000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRHT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_ldrht_a2_a_field_cond_7_poweroftwo_b0_703000b0() {
    // Encoding: 0x703000B0
    // Test aarch32_LDRHT_A2_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=7, Rn=0, Rt=0, Rm=0, U=0
    let encoding: u32 = 0x703000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRHT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_ldrht_a2_a_field_cond_8_poweroftwo_b0_803000b0() {
    // Encoding: 0x803000B0
    // Test aarch32_LDRHT_A2_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, Rm=0, cond=8, U=0, Rn=0
    let encoding: u32 = 0x803000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRHT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_ldrht_a2_a_field_cond_9_poweroftwo_b0_903000b0() {
    // Encoding: 0x903000B0
    // Test aarch32_LDRHT_A2_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, Rn=0, cond=9, Rt=0, Rm=0
    let encoding: u32 = 0x903000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRHT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_ldrht_a2_a_field_cond_10_poweroftwo_b0_a03000b0() {
    // Encoding: 0xA03000B0
    // Test aarch32_LDRHT_A2_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, Rm=0, Rn=0, cond=10, U=0
    let encoding: u32 = 0xA03000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRHT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_ldrht_a2_a_field_cond_11_poweroftwo_b0_b03000b0() {
    // Encoding: 0xB03000B0
    // Test aarch32_LDRHT_A2_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, Rn=0, Rt=0, Rm=0, cond=11
    let encoding: u32 = 0xB03000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRHT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_ldrht_a2_a_field_cond_12_poweroftwo_b0_c03000b0() {
    // Encoding: 0xC03000B0
    // Test aarch32_LDRHT_A2_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, cond=12, U=0, Rn=0, Rt=0
    let encoding: u32 = 0xC03000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRHT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_ldrht_a2_a_field_cond_13_poweroftwo_b0_d03000b0() {
    // Encoding: 0xD03000B0
    // Test aarch32_LDRHT_A2_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=13, Rm=0, Rn=0, U=0, Rt=0
    let encoding: u32 = 0xD03000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRHT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_ldrht_a2_a_field_cond_14_poweroftwo_b0_e03000b0() {
    // Encoding: 0xE03000B0
    // Test aarch32_LDRHT_A2_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, cond=14, Rn=0, Rm=0, Rt=0
    let encoding: u32 = 0xE03000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRHT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_ldrht_a2_a_field_cond_15_max_b0_f03000b0() {
    // Encoding: 0xF03000B0
    // Test aarch32_LDRHT_A2_A field cond = 15 (Max)
    // ISET: A32
    // Fields: Rm=0, cond=15, U=0, Rt=0, Rn=0
    let encoding: u32 = 0xF03000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRHT_A2_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ldrht_a2_a_field_u_0_min_b0_003000b0() {
    // Encoding: 0x003000B0
    // Test aarch32_LDRHT_A2_A field U = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rm=0, Rn=0, Rt=0, U=0
    let encoding: u32 = 0x003000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRHT_A2_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_ldrht_a2_a_field_u_1_max_b0_00b000b0() {
    // Encoding: 0x00B000B0
    // Test aarch32_LDRHT_A2_A field U = 1 (Max)
    // ISET: A32
    // Fields: Rt=0, Rn=0, cond=0, Rm=0, U=1
    let encoding: u32 = 0x00B000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRHT_A2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrht_a2_a_field_rn_0_min_b0_003000b0() {
    // Encoding: 0x003000B0
    // Test aarch32_LDRHT_A2_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, cond=0, Rn=0, U=0, Rt=0
    let encoding: u32 = 0x003000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRHT_A2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrht_a2_a_field_rn_1_poweroftwo_b0_003100b0() {
    // Encoding: 0x003100B0
    // Test aarch32_LDRHT_A2_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=1, cond=0, Rt=0, U=0, Rm=0
    let encoding: u32 = 0x003100B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRHT_A2_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrht_a2_a_field_rt_0_min_b0_003000b0() {
    // Encoding: 0x003000B0
    // Test aarch32_LDRHT_A2_A field Rt = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, U=0, Rt=0, cond=0, Rm=0
    let encoding: u32 = 0x003000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRHT_A2_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrht_a2_a_field_rt_1_poweroftwo_b0_003010b0() {
    // Encoding: 0x003010B0
    // Test aarch32_LDRHT_A2_A field Rt = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, U=0, Rn=0, Rt=1, Rm=0
    let encoding: u32 = 0x003010B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRHT_A2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrht_a2_a_field_rm_0_min_b0_003000b0() {
    // Encoding: 0x003000B0
    // Test aarch32_LDRHT_A2_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, cond=0, Rt=0, Rm=0, U=0
    let encoding: u32 = 0x003000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRHT_A2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrht_a2_a_field_rm_1_poweroftwo_b0_003000b1() {
    // Encoding: 0x003000B1
    // Test aarch32_LDRHT_A2_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, Rn=0, cond=0, Rt=0, Rm=1
    let encoding: u32 = 0x003000B1;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRHT_A2_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_ldrht_a2_a_combo_0_b0_003000b0() {
    // Encoding: 0x003000B0
    // Test aarch32_LDRHT_A2_A field combination: cond=0, U=0, Rn=0, Rt=0, Rm=0
    // ISET: A32
    // Fields: U=0, Rn=0, Rt=0, cond=0, Rm=0
    let encoding: u32 = 0x003000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRHT_A2_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_ldrht_a2_a_special_cond_0_condition_eq_176_003000b0() {
    // Encoding: 0x003000B0
    // Test aarch32_LDRHT_A2_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: cond=0, Rn=0, Rt=0, Rm=0, U=0
    let encoding: u32 = 0x003000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRHT_A2_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_ldrht_a2_a_special_cond_1_condition_ne_176_103000b0() {
    // Encoding: 0x103000B0
    // Test aarch32_LDRHT_A2_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: U=0, Rn=0, Rt=0, Rm=0, cond=1
    let encoding: u32 = 0x103000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRHT_A2_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_ldrht_a2_a_special_cond_2_condition_cs_hs_176_203000b0() {
    // Encoding: 0x203000B0
    // Test aarch32_LDRHT_A2_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: Rn=0, U=0, Rm=0, Rt=0, cond=2
    let encoding: u32 = 0x203000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRHT_A2_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_ldrht_a2_a_special_cond_3_condition_cc_lo_176_303000b0() {
    // Encoding: 0x303000B0
    // Test aarch32_LDRHT_A2_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: Rm=0, U=0, Rn=0, Rt=0, cond=3
    let encoding: u32 = 0x303000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRHT_A2_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_ldrht_a2_a_special_cond_4_condition_mi_176_403000b0() {
    // Encoding: 0x403000B0
    // Test aarch32_LDRHT_A2_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: cond=4, U=0, Rn=0, Rt=0, Rm=0
    let encoding: u32 = 0x403000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRHT_A2_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_ldrht_a2_a_special_cond_5_condition_pl_176_503000b0() {
    // Encoding: 0x503000B0
    // Test aarch32_LDRHT_A2_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: cond=5, U=0, Rt=0, Rn=0, Rm=0
    let encoding: u32 = 0x503000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRHT_A2_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_ldrht_a2_a_special_cond_6_condition_vs_176_603000b0() {
    // Encoding: 0x603000B0
    // Test aarch32_LDRHT_A2_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: U=0, Rt=0, Rn=0, Rm=0, cond=6
    let encoding: u32 = 0x603000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRHT_A2_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_ldrht_a2_a_special_cond_7_condition_vc_176_703000b0() {
    // Encoding: 0x703000B0
    // Test aarch32_LDRHT_A2_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: cond=7, Rn=0, U=0, Rm=0, Rt=0
    let encoding: u32 = 0x703000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRHT_A2_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_ldrht_a2_a_special_cond_8_condition_hi_176_803000b0() {
    // Encoding: 0x803000B0
    // Test aarch32_LDRHT_A2_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: cond=8, Rt=0, Rm=0, U=0, Rn=0
    let encoding: u32 = 0x803000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRHT_A2_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_ldrht_a2_a_special_cond_9_condition_ls_176_903000b0() {
    // Encoding: 0x903000B0
    // Test aarch32_LDRHT_A2_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: Rm=0, Rn=0, U=0, cond=9, Rt=0
    let encoding: u32 = 0x903000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRHT_A2_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_ldrht_a2_a_special_cond_10_condition_ge_176_a03000b0() {
    // Encoding: 0xA03000B0
    // Test aarch32_LDRHT_A2_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: Rm=0, cond=10, Rt=0, Rn=0, U=0
    let encoding: u32 = 0xA03000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRHT_A2_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_ldrht_a2_a_special_cond_11_condition_lt_176_b03000b0() {
    // Encoding: 0xB03000B0
    // Test aarch32_LDRHT_A2_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: Rn=0, cond=11, Rt=0, U=0, Rm=0
    let encoding: u32 = 0xB03000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRHT_A2_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_ldrht_a2_a_special_cond_12_condition_gt_176_c03000b0() {
    // Encoding: 0xC03000B0
    // Test aarch32_LDRHT_A2_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: Rn=0, cond=12, U=0, Rt=0, Rm=0
    let encoding: u32 = 0xC03000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRHT_A2_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_ldrht_a2_a_special_cond_13_condition_le_176_d03000b0() {
    // Encoding: 0xD03000B0
    // Test aarch32_LDRHT_A2_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: Rt=0, cond=13, Rm=0, U=0, Rn=0
    let encoding: u32 = 0xD03000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRHT_A2_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_ldrht_a2_a_special_cond_14_condition_al_176_e03000b0() {
    // Encoding: 0xE03000B0
    // Test aarch32_LDRHT_A2_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: Rt=0, Rm=0, U=0, Rn=0, cond=14
    let encoding: u32 = 0xE03000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRHT_A2_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_ldrht_a2_a_special_cond_15_condition_nv_176_f03000b0() {
    // Encoding: 0xF03000B0
    // Test aarch32_LDRHT_A2_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: Rn=0, cond=15, Rm=0, U=0, Rt=0
    let encoding: u32 = 0xF03000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_LDRHT_A2_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrht_a2_a_invalid_0_b0_003000b0() {
    // Encoding: 0x003000B0
    // Test aarch32_LDRHT_A2_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }
    // ISET: A32
    // Fields: Rt=0, U=0, Rn=0, cond=0, Rm=0
    let encoding: u32 = 0x003000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRHT_A2_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrht_a2_a_invalid_1_b0_003000b0() {
    // Encoding: 0x003000B0
    // Test aarch32_LDRHT_A2_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: U=0, Rn=0, Rm=0, cond=0, Rt=0
    let encoding: u32 = 0x003000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRHT_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrht_t1_a_field_rn_0_min_e00_f8300e00() {
    // Thumb encoding (32): 0xF8300E00
    // Test aarch32_LDRHT_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, imm8=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8300E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRHT_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrht_t1_a_field_rn_1_poweroftwo_e00_f8310e00() {
    // Thumb encoding (32): 0xF8310E00
    // Test aarch32_LDRHT_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, Rn=1, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8310E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRHT_T1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ldrht_t1_a_field_rt_0_min_e00_f8300e00() {
    // Thumb encoding (32): 0xF8300E00
    // Test aarch32_LDRHT_T1_A field Rt = 0 (Min)
    // ISET: T32
    // Fields: Rt=0, imm8=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8300E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRHT_T1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ldrht_t1_a_field_rt_1_poweroftwo_e00_f8301e00() {
    // Thumb encoding (32): 0xF8301E00
    // Test aarch32_LDRHT_T1_A field Rt = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=0, Rn=0, Rt=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8301E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRHT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_ldrht_t1_a_field_imm8_0_zero_e00_f8300e00() {
    // Thumb encoding (32): 0xF8300E00
    // Test aarch32_LDRHT_T1_A field imm8 = 0 (Zero)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8300E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRHT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_ldrht_t1_a_field_imm8_1_poweroftwo_e00_f8300e01() {
    // Thumb encoding (32): 0xF8300E01
    // Test aarch32_LDRHT_T1_A field imm8 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=1, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8300E01;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRHT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_ldrht_t1_a_field_imm8_3_poweroftwominusone_e00_f8300e03() {
    // Thumb encoding (32): 0xF8300E03
    // Test aarch32_LDRHT_T1_A field imm8 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, Rn=0, imm8=3
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8300E03;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRHT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_ldrht_t1_a_field_imm8_4_poweroftwo_e00_f8300e04() {
    // Thumb encoding (32): 0xF8300E04
    // Test aarch32_LDRHT_T1_A field imm8 = 4 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, Rn=0, imm8=4
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8300E04;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRHT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_ldrht_t1_a_field_imm8_7_poweroftwominusone_e00_f8300e07() {
    // Thumb encoding (32): 0xF8300E07
    // Test aarch32_LDRHT_T1_A field imm8 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, imm8=7, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8300E07;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRHT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_ldrht_t1_a_field_imm8_8_poweroftwo_e00_f8300e08() {
    // Thumb encoding (32): 0xF8300E08
    // Test aarch32_LDRHT_T1_A field imm8 = 8 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, imm8=8, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8300E08;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRHT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_ldrht_t1_a_field_imm8_15_poweroftwominusone_e00_f8300e0f() {
    // Thumb encoding (32): 0xF8300E0F
    // Test aarch32_LDRHT_T1_A field imm8 = 15 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm8=15, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8300E0F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRHT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_ldrht_t1_a_field_imm8_16_poweroftwo_e00_f8300e10() {
    // Thumb encoding (32): 0xF8300E10
    // Test aarch32_LDRHT_T1_A field imm8 = 16 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, imm8=16, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8300E10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRHT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_ldrht_t1_a_field_imm8_31_poweroftwominusone_e00_f8300e1f() {
    // Thumb encoding (32): 0xF8300E1F
    // Test aarch32_LDRHT_T1_A field imm8 = 31 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm8=31, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8300E1F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRHT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_ldrht_t1_a_field_imm8_32_poweroftwo_e00_f8300e20() {
    // Thumb encoding (32): 0xF8300E20
    // Test aarch32_LDRHT_T1_A field imm8 = 32 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=32, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8300E20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRHT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_ldrht_t1_a_field_imm8_63_poweroftwominusone_e00_f8300e3f() {
    // Thumb encoding (32): 0xF8300E3F
    // Test aarch32_LDRHT_T1_A field imm8 = 63 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, imm8=63, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8300E3F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRHT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_ldrht_t1_a_field_imm8_64_poweroftwo_e00_f8300e40() {
    // Thumb encoding (32): 0xF8300E40
    // Test aarch32_LDRHT_T1_A field imm8 = 64 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, imm8=64, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8300E40;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRHT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 127, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (127)
#[test]
fn test_aarch32_ldrht_t1_a_field_imm8_127_poweroftwominusone_e00_f8300e7f() {
    // Thumb encoding (32): 0xF8300E7F
    // Test aarch32_LDRHT_T1_A field imm8 = 127 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm8=127
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8300E7F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRHT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_ldrht_t1_a_field_imm8_128_poweroftwo_e00_f8300e80() {
    // Thumb encoding (32): 0xF8300E80
    // Test aarch32_LDRHT_T1_A field imm8 = 128 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm8=128
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8300E80;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRHT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 255, boundary: Max }
/// maximum immediate (255)
#[test]
fn test_aarch32_ldrht_t1_a_field_imm8_255_max_e00_f8300eff() {
    // Thumb encoding (32): 0xF8300EFF
    // Test aarch32_LDRHT_T1_A field imm8 = 255 (Max)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm8=255
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8300EFF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRHT_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_ldrht_t1_a_combo_0_e00_f8300e00() {
    // Thumb encoding (32): 0xF8300E00
    // Test aarch32_LDRHT_T1_A field combination: Rn=0, Rt=0, imm8=0
    // ISET: T32
    // Fields: Rt=0, Rn=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8300E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_LDRHT_T1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrht_t1_a_invalid_0_e00_f8300e00() {
    // Thumb encoding (32): 0xF8300E00
    // Test aarch32_LDRHT_T1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: LitInt(15) }
    // ISET: T32
    // Fields: Rt=0, imm8=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8300E00;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRHT_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrht_t1_a_invalid_1_e00_f8300e00() {
    // Thumb encoding (32): 0xF8300E00
    // Test aarch32_LDRHT_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rn=0, imm8=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8300E00;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_LDRHT_A1_A
/// ASL: `UMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple multiply
#[test]
fn test_aarch32_ldrht_a1_a_umull_oracle_0_9ba27c20() {
    // Test UMULL: simple multiply (oracle)
    // Encoding: 0x9BA27C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x2);
    set_w(&mut cpu, 2, 0x3);
    let encoding: u32 = 0x9BA27C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6, "X0 should be 0x0000000000000006");
}

/// Provenance: aarch32_LDRHT_A1_A
/// ASL: `UMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max 32-bit * 2
#[test]
fn test_aarch32_ldrht_a1_a_umull_oracle_1_9ba27c20() {
    // Test UMULL: max 32-bit * 2 (oracle)
    // Encoding: 0x9BA27C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x9BA27C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0x00000001FFFFFFFE"
    );
}

/// Provenance: aarch32_LDRHT_A1_A
/// ASL: `UMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// large positive * large positive
#[test]
fn test_aarch32_ldrht_a1_a_umull_oracle_2_9ba27c20() {
    // Test UMULL: large positive * large positive (oracle)
    // Encoding: 0x9BA27C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x7FFFFFFF);
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x9BA27C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x3FFFFFFF00000001");
}

/// Provenance: aarch32_LDRHT_A1_A
/// ASL: `UMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max unsigned * max unsigned
#[test]
fn test_aarch32_ldrht_a1_a_umull_oracle_3_9ba27c20() {
    // Test UMULL: max unsigned * max unsigned (oracle)
    // Encoding: 0x9BA27C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x9BA27C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0xFFFFFFFE00000001");
}

/// Provenance: aarch32_LDRHT_A1_A
/// ASL: `UMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// medium values
#[test]
fn test_aarch32_ldrht_a1_a_umull_oracle_4_9ba27c20() {
    // Test UMULL: medium values (oracle)
    // Encoding: 0x9BA27C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xC8);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x9BA27C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4E20, "X0 should be 0x0000000000004E20");
}

/// Provenance: aarch32_LDRHT_A1_A
/// ASL: `UMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// 16-bit values
#[test]
fn test_aarch32_ldrht_a1_a_umull_oracle_5_9ba27c20() {
    // Test UMULL: 16-bit values (oracle)
    // Encoding: 0x9BA27C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1234);
    set_w(&mut cpu, 2, 0x5678);
    let encoding: u32 = 0x9BA27C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6260060, "X0 should be 0x0000000006260060");
}

/// Provenance: aarch32_LDRHT_A1_A
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrht_a1_a_exception_0_007000b0() {
    // Test aarch32_LDRHT_A1_A exception: Unpredictable
    // Encoding: 0x007000B0
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x007000B0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_LDRHT_A2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple multiply (32)
#[test]
fn test_aarch32_ldrht_a2_a_mul_oracle_32_0_1b027c20() {
    // Test MUL 32-bit: simple multiply (oracle)
    // Encoding: 0x1B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x2);
    set_w(&mut cpu, 2, 0x3);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6, "W0 should be 0x00000006");
}

/// Provenance: aarch32_LDRHT_A2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple multiply (64)
#[test]
fn test_aarch32_ldrht_a2_a_mul_oracle_64_0_9b027c20() {
    // Test MUL 64-bit: simple multiply (oracle)
    // Encoding: 0x9B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x2);
    set_w(&mut cpu, 2, 0x3);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6, "X0 should be 0x0000000000000006");
}

/// Provenance: aarch32_LDRHT_A2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// multiply by zero (32)
#[test]
fn test_aarch32_ldrht_a2_a_mul_oracle_32_1_1b027c20() {
    // Test MUL 32-bit: multiply by zero (oracle)
    // Encoding: 0x1B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x64);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_LDRHT_A2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// multiply by zero (64)
#[test]
fn test_aarch32_ldrht_a2_a_mul_oracle_64_1_9b027c20() {
    // Test MUL 64-bit: multiply by zero (oracle)
    // Encoding: 0x9B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x64);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_LDRHT_A2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// multiply by one (32)
#[test]
fn test_aarch32_ldrht_a2_a_mul_oracle_32_2_1b027c20() {
    // Test MUL 32-bit: multiply by one (oracle)
    // Encoding: 0x1B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_LDRHT_A2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// multiply by one (64)
#[test]
fn test_aarch32_ldrht_a2_a_mul_oracle_64_2_9b027c20() {
    // Test MUL 64-bit: multiply by one (oracle)
    // Encoding: 0x9B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x0000000000000001");
}

/// Provenance: aarch32_LDRHT_A2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// 16-bit max * 16-bit max (32)
#[test]
fn test_aarch32_ldrht_a2_a_mul_oracle_32_3_1b027c20() {
    // Test MUL 32-bit: 16-bit max * 16-bit max (oracle)
    // Encoding: 0x1B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFF);
    set_w(&mut cpu, 2, 0xFFFF);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFE0001, "W0 should be 0xFFFE0001");
}

/// Provenance: aarch32_LDRHT_A2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// 16-bit max * 16-bit max (64)
#[test]
fn test_aarch32_ldrht_a2_a_mul_oracle_64_3_9b027c20() {
    // Test MUL 64-bit: 16-bit max * 16-bit max (oracle)
    // Encoding: 0x9B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFF);
    set_w(&mut cpu, 2, 0xFFFF);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFE0001,
        "X0 should be 0x00000000FFFE0001"
    );
}

/// Provenance: aarch32_LDRHT_A2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift-like multiply (32)
#[test]
fn test_aarch32_ldrht_a2_a_mul_oracle_32_4_1b027c20() {
    // Test MUL 32-bit: shift-like multiply (oracle)
    // Encoding: 0x1B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x2468ACF0, "W0 should be 0x2468ACF0");
}

/// Provenance: aarch32_LDRHT_A2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift-like multiply (64)
#[test]
fn test_aarch32_ldrht_a2_a_mul_oracle_64_4_9b027c20() {
    // Test MUL 64-bit: shift-like multiply (oracle)
    // Encoding: 0x9B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x2468ACF0,
        "X0 should be 0x000000002468ACF0"
    );
}

/// Provenance: aarch32_LDRHT_A2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// larger values (32)
#[test]
fn test_aarch32_ldrht_a2_a_mul_oracle_32_5_1b027c20() {
    // Test MUL 32-bit: larger values (oracle)
    // Encoding: 0x1B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xC8);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4E20, "W0 should be 0x00004E20");
}

/// Provenance: aarch32_LDRHT_A2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// larger values (64)
#[test]
fn test_aarch32_ldrht_a2_a_mul_oracle_64_5_9b027c20() {
    // Test MUL 64-bit: larger values (oracle)
    // Encoding: 0x9B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xC8);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4E20, "X0 should be 0x0000000000004E20");
}

/// Provenance: aarch32_LDRHT_A2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// 32-bit overflow (32)
#[test]
fn test_aarch32_ldrht_a2_a_mul_oracle_32_6_1b027c20() {
    // Test MUL 32-bit: 32-bit overflow (oracle)
    // Encoding: 0x1B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_LDRHT_A2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// 32-bit overflow (64)
#[test]
fn test_aarch32_ldrht_a2_a_mul_oracle_64_6_9b027c20() {
    // Test MUL 64-bit: 32-bit overflow (oracle)
    // Encoding: 0x9B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0xFFFFFFFE00000001");
}

/// Provenance: aarch32_LDRHT_A2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// prime numbers (32)
#[test]
fn test_aarch32_ldrht_a2_a_mul_oracle_32_7_1b027c20() {
    // Test MUL 32-bit: prime numbers (oracle)
    // Encoding: 0x1B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xB);
    set_w(&mut cpu, 1, 0x7);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4D, "W0 should be 0x0000004D");
}

/// Provenance: aarch32_LDRHT_A2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// prime numbers (64)
#[test]
fn test_aarch32_ldrht_a2_a_mul_oracle_64_7_9b027c20() {
    // Test MUL 64-bit: prime numbers (oracle)
    // Encoding: 0x9B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7);
    set_w(&mut cpu, 2, 0xB);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4D, "X0 should be 0x000000000000004D");
}

/// Provenance: aarch32_LDRHT_A2_A
/// ASL: `MLA R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple values
#[test]
fn test_aarch32_ldrht_a2_a_a32_mul_0_0020f291() {
    // Test A32 MLA: simple values (oracle)
    // Encoding: 0x0020F291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x32);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x0020F291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1388, "R0 should be 0x00001388");
}

/// Provenance: aarch32_LDRHT_A2_A
/// ASL: `MLA R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero values
#[test]
fn test_aarch32_ldrht_a2_a_a32_mul_1_0020f291() {
    // Test A32 MLA: zero values (oracle)
    // Encoding: 0x0020F291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x0020F291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_LDRHT_A2_A
/// ASL: `MLA R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max value
#[test]
fn test_aarch32_ldrht_a2_a_a32_mul_2_0020f291() {
    // Test A32 MLA: max value (oracle)
    // Encoding: 0x0020F291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x0020F291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "R0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_LDRHT_A2_A
/// ASL: `MLA R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set
#[test]
fn test_aarch32_ldrht_a2_a_a32_mul_3_0020f291() {
    // Test A32 MLA: MSB set (oracle)
    // Encoding: 0x0020F291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    set_w(&mut cpu, 2, 0x80000000);
    let encoding: u32 = 0x0020F291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_LDRHT_A2_A
/// ASL: `MLA R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// mixed pattern
#[test]
fn test_aarch32_ldrht_a2_a_a32_mul_4_0020f291() {
    // Test A32 MLA: mixed pattern (oracle)
    // Encoding: 0x0020F291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x9ABCDEF0);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u32 = 0x0020F291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x242D2080, "R0 should be 0x242D2080");
}

/// Provenance: aarch32_LDRHT_A2_A
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrht_a2_a_exception_0_003000b0() {
    // Test aarch32_LDRHT_A2_A exception: Unpredictable
    // Encoding: 0x003000B0
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x003000B0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_LDRHT_T1_A
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ldrht_t1_a_exception_0_f8300e00() {
    // Test aarch32_LDRHT_T1_A exception: Unpredictable
    // ISET: T32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF8300E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}
