//! A32 memory store tests.
//!
//! Auto-generated from ARM ASL specifications.
//! DO NOT EDIT MANUALLY.

#![allow(unused_imports)]
#![allow(dead_code)]

use crate::generated::test_helpers_32::*;

// ============================================================================
// aarch32_STLH_A Tests
// ============================================================================

/// Provenance: aarch32_STLH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_stlh_a1_a_field_cond_0_min_90_01e00090() {
    // Encoding: 0x01E00090
    // Test aarch32_STLH_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rt=0, Rn=0
    let encoding: u32 = 0x01E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_stlh_a1_a_field_cond_1_poweroftwo_90_11e00090() {
    // Encoding: 0x11E00090
    // Test aarch32_STLH_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=1
    let encoding: u32 = 0x11E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_stlh_a1_a_field_cond_2_poweroftwo_90_21e00090() {
    // Encoding: 0x21E00090
    // Test aarch32_STLH_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=2, Rn=0, Rt=0
    let encoding: u32 = 0x21E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_stlh_a1_a_field_cond_3_poweroftwo_90_31e00090() {
    // Encoding: 0x31E00090
    // Test aarch32_STLH_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=3
    let encoding: u32 = 0x31E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_stlh_a1_a_field_cond_4_poweroftwo_90_41e00090() {
    // Encoding: 0x41E00090
    // Test aarch32_STLH_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=4
    let encoding: u32 = 0x41E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_stlh_a1_a_field_cond_5_poweroftwo_90_51e00090() {
    // Encoding: 0x51E00090
    // Test aarch32_STLH_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=5, Rt=0
    let encoding: u32 = 0x51E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_stlh_a1_a_field_cond_6_poweroftwo_90_61e00090() {
    // Encoding: 0x61E00090
    // Test aarch32_STLH_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=6
    let encoding: u32 = 0x61E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_stlh_a1_a_field_cond_7_poweroftwo_90_71e00090() {
    // Encoding: 0x71E00090
    // Test aarch32_STLH_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=7, Rn=0, Rt=0
    let encoding: u32 = 0x71E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_stlh_a1_a_field_cond_8_poweroftwo_90_81e00090() {
    // Encoding: 0x81E00090
    // Test aarch32_STLH_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=8
    let encoding: u32 = 0x81E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_stlh_a1_a_field_cond_9_poweroftwo_90_91e00090() {
    // Encoding: 0x91E00090
    // Test aarch32_STLH_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=9, Rt=0, Rn=0
    let encoding: u32 = 0x91E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_stlh_a1_a_field_cond_10_poweroftwo_90_a1e00090() {
    // Encoding: 0xA1E00090
    // Test aarch32_STLH_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, Rn=0, cond=10
    let encoding: u32 = 0xA1E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_stlh_a1_a_field_cond_11_poweroftwo_90_b1e00090() {
    // Encoding: 0xB1E00090
    // Test aarch32_STLH_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=11, Rt=0
    let encoding: u32 = 0xB1E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_stlh_a1_a_field_cond_12_poweroftwo_90_c1e00090() {
    // Encoding: 0xC1E00090
    // Test aarch32_STLH_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=12, Rt=0
    let encoding: u32 = 0xC1E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_stlh_a1_a_field_cond_13_poweroftwo_90_d1e00090() {
    // Encoding: 0xD1E00090
    // Test aarch32_STLH_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=13, Rt=0, Rn=0
    let encoding: u32 = 0xD1E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_stlh_a1_a_field_cond_14_poweroftwo_90_e1e00090() {
    // Encoding: 0xE1E00090
    // Test aarch32_STLH_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=14, Rn=0, Rt=0
    let encoding: u32 = 0xE1E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_stlh_a1_a_field_cond_15_max_90_f1e00090() {
    // Encoding: 0xF1E00090
    // Test aarch32_STLH_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: cond=15, Rn=0, Rt=0
    let encoding: u32 = 0xF1E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLH_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_stlh_a1_a_field_rn_0_min_90_01e00090() {
    // Encoding: 0x01E00090
    // Test aarch32_STLH_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rt=0, Rn=0
    let encoding: u32 = 0x01E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLH_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_stlh_a1_a_field_rn_1_poweroftwo_90_01e10090() {
    // Encoding: 0x01E10090
    // Test aarch32_STLH_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Rt=0, Rn=1
    let encoding: u32 = 0x01E10090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLH_A1_A
/// ASL: `field Rt 0 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_stlh_a1_a_field_rt_0_min_90_01e00090() {
    // Encoding: 0x01E00090
    // Test aarch32_STLH_A1_A field Rt = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, cond=0, Rt=0
    let encoding: u32 = 0x01E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLH_A1_A
/// ASL: `field Rt 0 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_stlh_a1_a_field_rt_1_poweroftwo_90_01e00091() {
    // Encoding: 0x01E00091
    // Test aarch32_STLH_A1_A field Rt = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=0, Rt=1
    let encoding: u32 = 0x01E00091;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLH_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_stlh_a1_a_combo_0_90_01e00090() {
    // Encoding: 0x01E00090
    // Test aarch32_STLH_A1_A field combination: cond=0, Rn=0, Rt=0
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=0
    let encoding: u32 = 0x01E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLH_A1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=1 (condition NE (not equal))
#[test]
fn test_aarch32_stlh_a1_a_combo_1_90_11e00090() {
    // Encoding: 0x11E00090
    // Test aarch32_STLH_A1_A field combination: cond=1, Rn=0, Rt=0
    // ISET: A32
    // Fields: cond=1, Rt=0, Rn=0
    let encoding: u32 = 0x11E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLH_A1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=2 (condition CS/HS (carry set))
#[test]
fn test_aarch32_stlh_a1_a_combo_2_90_21e00090() {
    // Encoding: 0x21E00090
    // Test aarch32_STLH_A1_A field combination: cond=2, Rn=0, Rt=0
    // ISET: A32
    // Fields: cond=2, Rn=0, Rt=0
    let encoding: u32 = 0x21E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLH_A1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=3 (condition CC/LO (carry clear))
#[test]
fn test_aarch32_stlh_a1_a_combo_3_90_31e00090() {
    // Encoding: 0x31E00090
    // Test aarch32_STLH_A1_A field combination: cond=3, Rn=0, Rt=0
    // ISET: A32
    // Fields: Rt=0, Rn=0, cond=3
    let encoding: u32 = 0x31E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLH_A1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=4 (condition MI (minus/negative))
#[test]
fn test_aarch32_stlh_a1_a_combo_4_90_41e00090() {
    // Encoding: 0x41E00090
    // Test aarch32_STLH_A1_A field combination: cond=4, Rn=0, Rt=0
    // ISET: A32
    // Fields: Rt=0, cond=4, Rn=0
    let encoding: u32 = 0x41E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLH_A1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=5 (condition PL (plus/positive))
#[test]
fn test_aarch32_stlh_a1_a_combo_5_90_51e00090() {
    // Encoding: 0x51E00090
    // Test aarch32_STLH_A1_A field combination: cond=5, Rn=0, Rt=0
    // ISET: A32
    // Fields: Rt=0, cond=5, Rn=0
    let encoding: u32 = 0x51E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLH_A1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=6 (condition VS (overflow set))
#[test]
fn test_aarch32_stlh_a1_a_combo_6_90_61e00090() {
    // Encoding: 0x61E00090
    // Test aarch32_STLH_A1_A field combination: cond=6, Rn=0, Rt=0
    // ISET: A32
    // Fields: Rn=0, cond=6, Rt=0
    let encoding: u32 = 0x61E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLH_A1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=7 (condition VC (overflow clear))
#[test]
fn test_aarch32_stlh_a1_a_combo_7_90_71e00090() {
    // Encoding: 0x71E00090
    // Test aarch32_STLH_A1_A field combination: cond=7, Rn=0, Rt=0
    // ISET: A32
    // Fields: cond=7, Rn=0, Rt=0
    let encoding: u32 = 0x71E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLH_A1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=8 (condition HI (unsigned higher))
#[test]
fn test_aarch32_stlh_a1_a_combo_8_90_81e00090() {
    // Encoding: 0x81E00090
    // Test aarch32_STLH_A1_A field combination: cond=8, Rn=0, Rt=0
    // ISET: A32
    // Fields: Rt=0, cond=8, Rn=0
    let encoding: u32 = 0x81E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLH_A1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=9 (condition LS (unsigned lower or same))
#[test]
fn test_aarch32_stlh_a1_a_combo_9_90_91e00090() {
    // Encoding: 0x91E00090
    // Test aarch32_STLH_A1_A field combination: cond=9, Rn=0, Rt=0
    // ISET: A32
    // Fields: Rn=0, cond=9, Rt=0
    let encoding: u32 = 0x91E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLH_A1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=10 (condition GE (signed >=))
#[test]
fn test_aarch32_stlh_a1_a_combo_10_90_a1e00090() {
    // Encoding: 0xA1E00090
    // Test aarch32_STLH_A1_A field combination: cond=10, Rn=0, Rt=0
    // ISET: A32
    // Fields: Rt=0, cond=10, Rn=0
    let encoding: u32 = 0xA1E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLH_A1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=11 (condition LT (signed <))
#[test]
fn test_aarch32_stlh_a1_a_combo_11_90_b1e00090() {
    // Encoding: 0xB1E00090
    // Test aarch32_STLH_A1_A field combination: cond=11, Rn=0, Rt=0
    // ISET: A32
    // Fields: cond=11, Rn=0, Rt=0
    let encoding: u32 = 0xB1E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLH_A1_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=12 (condition GT (signed >))
#[test]
fn test_aarch32_stlh_a1_a_combo_12_90_c1e00090() {
    // Encoding: 0xC1E00090
    // Test aarch32_STLH_A1_A field combination: cond=12, Rn=0, Rt=0
    // ISET: A32
    // Fields: cond=12, Rt=0, Rn=0
    let encoding: u32 = 0xC1E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLH_A1_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=13 (condition LE (signed <=))
#[test]
fn test_aarch32_stlh_a1_a_combo_13_90_d1e00090() {
    // Encoding: 0xD1E00090
    // Test aarch32_STLH_A1_A field combination: cond=13, Rn=0, Rt=0
    // ISET: A32
    // Fields: Rt=0, cond=13, Rn=0
    let encoding: u32 = 0xD1E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLH_A1_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=14 (condition AL (always))
#[test]
fn test_aarch32_stlh_a1_a_combo_14_90_e1e00090() {
    // Encoding: 0xE1E00090
    // Test aarch32_STLH_A1_A field combination: cond=14, Rn=0, Rt=0
    // ISET: A32
    // Fields: Rt=0, cond=14, Rn=0
    let encoding: u32 = 0xE1E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLH_A1_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=15 (condition NV (never, reserved))
#[test]
fn test_aarch32_stlh_a1_a_combo_15_90_f1e00090() {
    // Encoding: 0xF1E00090
    // Test aarch32_STLH_A1_A field combination: cond=15, Rn=0, Rt=0
    // ISET: A32
    // Fields: Rt=0, cond=15, Rn=0
    let encoding: u32 = 0xF1E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLH_A1_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_stlh_a1_a_combo_16_90_01e00090() {
    // Encoding: 0x01E00090
    // Test aarch32_STLH_A1_A field combination: cond=0, Rn=0, Rt=0
    // ISET: A32
    // Fields: Rn=0, cond=0, Rt=0
    let encoding: u32 = 0x01E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLH_A1_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_stlh_a1_a_combo_17_90_01e10090() {
    // Encoding: 0x01E10090
    // Test aarch32_STLH_A1_A field combination: cond=0, Rn=1, Rt=0
    // ISET: A32
    // Fields: Rn=1, cond=0, Rt=0
    let encoding: u32 = 0x01E10090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLH_A1_A
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=0 (register index 0 (first register))
#[test]
fn test_aarch32_stlh_a1_a_combo_18_90_01e00090() {
    // Encoding: 0x01E00090
    // Test aarch32_STLH_A1_A field combination: cond=0, Rn=0, Rt=0
    // ISET: A32
    // Fields: cond=0, Rn=0, Rt=0
    let encoding: u32 = 0x01E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLH_A1_A
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=1 (register index 1 (second register))
#[test]
fn test_aarch32_stlh_a1_a_combo_19_90_01e00091() {
    // Encoding: 0x01E00091
    // Test aarch32_STLH_A1_A field combination: cond=0, Rn=0, Rt=1
    // ISET: A32
    // Fields: Rn=0, cond=0, Rt=1
    let encoding: u32 = 0x01E00091;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLH_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_stlh_a1_a_special_cond_0_condition_eq_144_01e00090() {
    // Encoding: 0x01E00090
    // Test aarch32_STLH_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: cond=0, Rt=0, Rn=0
    let encoding: u32 = 0x01E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLH_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_stlh_a1_a_special_cond_1_condition_ne_144_11e00090() {
    // Encoding: 0x11E00090
    // Test aarch32_STLH_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=1
    let encoding: u32 = 0x11E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLH_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_stlh_a1_a_special_cond_2_condition_cs_hs_144_21e00090() {
    // Encoding: 0x21E00090
    // Test aarch32_STLH_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=2
    let encoding: u32 = 0x21E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLH_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_stlh_a1_a_special_cond_3_condition_cc_lo_144_31e00090() {
    // Encoding: 0x31E00090
    // Test aarch32_STLH_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: cond=3, Rn=0, Rt=0
    let encoding: u32 = 0x31E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLH_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_stlh_a1_a_special_cond_4_condition_mi_144_41e00090() {
    // Encoding: 0x41E00090
    // Test aarch32_STLH_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: Rt=0, Rn=0, cond=4
    let encoding: u32 = 0x41E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLH_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_stlh_a1_a_special_cond_5_condition_pl_144_51e00090() {
    // Encoding: 0x51E00090
    // Test aarch32_STLH_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: cond=5, Rn=0, Rt=0
    let encoding: u32 = 0x51E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLH_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_stlh_a1_a_special_cond_6_condition_vs_144_61e00090() {
    // Encoding: 0x61E00090
    // Test aarch32_STLH_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: cond=6, Rt=0, Rn=0
    let encoding: u32 = 0x61E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLH_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_stlh_a1_a_special_cond_7_condition_vc_144_71e00090() {
    // Encoding: 0x71E00090
    // Test aarch32_STLH_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: Rt=0, Rn=0, cond=7
    let encoding: u32 = 0x71E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLH_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_stlh_a1_a_special_cond_8_condition_hi_144_81e00090() {
    // Encoding: 0x81E00090
    // Test aarch32_STLH_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: cond=8, Rt=0, Rn=0
    let encoding: u32 = 0x81E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLH_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_stlh_a1_a_special_cond_9_condition_ls_144_91e00090() {
    // Encoding: 0x91E00090
    // Test aarch32_STLH_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: cond=9, Rn=0, Rt=0
    let encoding: u32 = 0x91E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLH_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_stlh_a1_a_special_cond_10_condition_ge_144_a1e00090() {
    // Encoding: 0xA1E00090
    // Test aarch32_STLH_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: cond=10, Rn=0, Rt=0
    let encoding: u32 = 0xA1E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLH_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_stlh_a1_a_special_cond_11_condition_lt_144_b1e00090() {
    // Encoding: 0xB1E00090
    // Test aarch32_STLH_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=11
    let encoding: u32 = 0xB1E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLH_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_stlh_a1_a_special_cond_12_condition_gt_144_c1e00090() {
    // Encoding: 0xC1E00090
    // Test aarch32_STLH_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: Rt=0, cond=12, Rn=0
    let encoding: u32 = 0xC1E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLH_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_stlh_a1_a_special_cond_13_condition_le_144_d1e00090() {
    // Encoding: 0xD1E00090
    // Test aarch32_STLH_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: Rt=0, Rn=0, cond=13
    let encoding: u32 = 0xD1E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLH_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_stlh_a1_a_special_cond_14_condition_al_144_e1e00090() {
    // Encoding: 0xE1E00090
    // Test aarch32_STLH_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: Rn=0, cond=14, Rt=0
    let encoding: u32 = 0xE1E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLH_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_stlh_a1_a_special_cond_15_condition_nv_144_f1e00090() {
    // Encoding: 0xF1E00090
    // Test aarch32_STLH_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=15
    let encoding: u32 = 0xF1E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLH_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_stlh_a1_a_invalid_0_90_01e00090() {
    // Encoding: 0x01E00090
    // Test aarch32_STLH_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }
    // ISET: A32
    // Fields: Rt=0, Rn=0, cond=0
    let encoding: u32 = 0x01E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STLH_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_stlh_a1_a_invalid_1_90_01e00090() {
    // Encoding: 0x01E00090
    // Test aarch32_STLH_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Rt=0, cond=0, Rn=0
    let encoding: u32 = 0x01E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STLH_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_stlh_t1_a_field_rn_0_min_90_e8c00090() {
    // Thumb encoding (32): 0xE8C00090
    // Test aarch32_STLH_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C00090;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLH_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_stlh_t1_a_field_rn_1_poweroftwo_90_e8c10090() {
    // Thumb encoding (32): 0xE8C10090
    // Test aarch32_STLH_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, Rn=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C10090;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLH_T1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_stlh_t1_a_field_rt_0_min_90_e8c00090() {
    // Thumb encoding (32): 0xE8C00090
    // Test aarch32_STLH_T1_A field Rt = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C00090;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLH_T1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_stlh_t1_a_field_rt_1_poweroftwo_90_e8c01090() {
    // Thumb encoding (32): 0xE8C01090
    // Test aarch32_STLH_T1_A field Rt = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=1, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C01090;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLH_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_stlh_t1_a_combo_0_90_e8c00090() {
    // Thumb encoding (32): 0xE8C00090
    // Test aarch32_STLH_T1_A field combination: Rn=0, Rt=0
    // ISET: T32
    // Fields: Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C00090;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLH_T1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_stlh_t1_a_combo_1_90_e8c10090() {
    // Thumb encoding (32): 0xE8C10090
    // Test aarch32_STLH_T1_A field combination: Rn=1, Rt=0
    // ISET: T32
    // Fields: Rn=1, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C10090;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLH_T1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=0 (register index 0 (first register))
#[test]
fn test_aarch32_stlh_t1_a_combo_2_90_e8c00090() {
    // Thumb encoding (32): 0xE8C00090
    // Test aarch32_STLH_T1_A field combination: Rn=0, Rt=0
    // ISET: T32
    // Fields: Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C00090;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLH_T1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=1 (register index 1 (second register))
#[test]
fn test_aarch32_stlh_t1_a_combo_3_90_e8c01090() {
    // Thumb encoding (32): 0xE8C01090
    // Test aarch32_STLH_T1_A field combination: Rn=0, Rt=1
    // ISET: T32
    // Fields: Rn=0, Rt=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C01090;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLH_T1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rt=1 (same register test (reg=1))
#[test]
fn test_aarch32_stlh_t1_a_combo_4_90_e8c11090() {
    // Thumb encoding (32): 0xE8C11090
    // Test aarch32_STLH_T1_A field combination: Rn=1, Rt=1
    // ISET: T32
    // Fields: Rt=1, Rn=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C11090;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLH_T1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rt=31 (same register test (reg=31))
#[test]
fn test_aarch32_stlh_t1_a_combo_5_90_e8cff090() {
    // Thumb encoding (32): 0xE8CFF090
    // Test aarch32_STLH_T1_A field combination: Rn=31, Rt=31
    // ISET: T32
    // Fields: Rt=31, Rn=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8CFF090;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLH_T1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_stlh_t1_a_invalid_0_90_e8c00090() {
    // Thumb encoding (32): 0xE8C00090
    // Test aarch32_STLH_T1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }
    // ISET: T32
    // Fields: Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C00090;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_STLH_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_stlh_t1_a_invalid_1_90_e8c00090() {
    // Thumb encoding (32): 0xE8C00090
    // Test aarch32_STLH_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C00090;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_STLH_A1_A
/// ASL: `SMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple multiply
#[test]
fn test_aarch32_stlh_a1_a_smull_oracle_0_9b227c20() {
    // Test SMULL: simple multiply (oracle)
    // Encoding: 0x9B227C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x2);
    set_w(&mut cpu, 2, 0x3);
    let encoding: u32 = 0x9B227C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6, "X0 should be 0x0000000000000006");
}

/// Provenance: aarch32_STLH_A1_A
/// ASL: `SMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max 32-bit * 2
#[test]
fn test_aarch32_stlh_a1_a_smull_oracle_1_9b227c20() {
    // Test SMULL: max 32-bit * 2 (oracle)
    // Encoding: 0x9B227C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x9B227C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFE, "X0 should be 0xFFFFFFFFFFFFFFFE");
}

/// Provenance: aarch32_STLH_A1_A
/// ASL: `SMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// large positive * large positive
#[test]
fn test_aarch32_stlh_a1_a_smull_oracle_2_9b227c20() {
    // Test SMULL: large positive * large positive (oracle)
    // Encoding: 0x9B227C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x7FFFFFFF);
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x9B227C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x3FFFFFFF00000001");
}

/// Provenance: aarch32_STLH_A1_A
/// ASL: `SMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max unsigned * max unsigned
#[test]
fn test_aarch32_stlh_a1_a_smull_oracle_3_9b227c20() {
    // Test SMULL: max unsigned * max unsigned (oracle)
    // Encoding: 0x9B227C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x9B227C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x0000000000000001");
}

/// Provenance: aarch32_STLH_A1_A
/// ASL: `SMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// medium values
#[test]
fn test_aarch32_stlh_a1_a_smull_oracle_4_9b227c20() {
    // Test SMULL: medium values (oracle)
    // Encoding: 0x9B227C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0xC8);
    let encoding: u32 = 0x9B227C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4E20, "X0 should be 0x0000000000004E20");
}

/// Provenance: aarch32_STLH_A1_A
/// ASL: `SMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// 16-bit values
#[test]
fn test_aarch32_stlh_a1_a_smull_oracle_5_9b227c20() {
    // Test SMULL: 16-bit values (oracle)
    // Encoding: 0x9B227C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1234);
    set_w(&mut cpu, 2, 0x5678);
    let encoding: u32 = 0x9B227C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6260060, "X0 should be 0x0000000006260060");
}

/// Provenance: aarch32_STLH_A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_stlh_a1_a_store_0_01e10090() {
    // Test aarch32_STLH_A1_A memory store: 8 bytes
    // Encoding: 0x01E10090
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0x01E10090;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_STLH_T1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_stlh_t1_a_store_0_e8c10090() {
    // Test aarch32_STLH_T1_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0xE8C10090;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// aarch32_STLEXH_A Tests
// ============================================================================

/// Provenance: aarch32_STLEXH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_stlexh_a1_a_field_cond_0_min_290_01e00290() {
    // Encoding: 0x01E00290
    // Test aarch32_STLEXH_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: Rd=0, Rn=0, cond=0, Rt=0
    let encoding: u32 = 0x01E00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_stlexh_a1_a_field_cond_1_poweroftwo_290_11e00290() {
    // Encoding: 0x11E00290
    // Test aarch32_STLEXH_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, Rd=0, cond=1, Rn=0
    let encoding: u32 = 0x11E00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_stlexh_a1_a_field_cond_2_poweroftwo_290_21e00290() {
    // Encoding: 0x21E00290
    // Test aarch32_STLEXH_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, Rn=0, Rd=0, cond=2
    let encoding: u32 = 0x21E00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_stlexh_a1_a_field_cond_3_poweroftwo_290_31e00290() {
    // Encoding: 0x31E00290
    // Test aarch32_STLEXH_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rt=0, Rn=0, cond=3
    let encoding: u32 = 0x31E00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_stlexh_a1_a_field_cond_4_poweroftwo_290_41e00290() {
    // Encoding: 0x41E00290
    // Test aarch32_STLEXH_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rt=0, cond=4, Rn=0
    let encoding: u32 = 0x41E00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_stlexh_a1_a_field_cond_5_poweroftwo_290_51e00290() {
    // Encoding: 0x51E00290
    // Test aarch32_STLEXH_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=5, Rt=0, Rn=0, Rd=0
    let encoding: u32 = 0x51E00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_stlexh_a1_a_field_cond_6_poweroftwo_290_61e00290() {
    // Encoding: 0x61E00290
    // Test aarch32_STLEXH_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=6, Rt=0, Rn=0, Rd=0
    let encoding: u32 = 0x61E00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_stlexh_a1_a_field_cond_7_poweroftwo_290_71e00290() {
    // Encoding: 0x71E00290
    // Test aarch32_STLEXH_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, cond=7, Rt=0, Rn=0
    let encoding: u32 = 0x71E00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_stlexh_a1_a_field_cond_8_poweroftwo_290_81e00290() {
    // Encoding: 0x81E00290
    // Test aarch32_STLEXH_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, cond=8, Rt=0, Rn=0
    let encoding: u32 = 0x81E00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_stlexh_a1_a_field_cond_9_poweroftwo_290_91e00290() {
    // Encoding: 0x91E00290
    // Test aarch32_STLEXH_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rt=0, cond=9, Rn=0
    let encoding: u32 = 0x91E00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_stlexh_a1_a_field_cond_10_poweroftwo_290_a1e00290() {
    // Encoding: 0xA1E00290
    // Test aarch32_STLEXH_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=10, Rd=0, Rn=0, Rt=0
    let encoding: u32 = 0xA1E00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_stlexh_a1_a_field_cond_11_poweroftwo_290_b1e00290() {
    // Encoding: 0xB1E00290
    // Test aarch32_STLEXH_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, cond=11, Rn=0, Rd=0
    let encoding: u32 = 0xB1E00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_stlexh_a1_a_field_cond_12_poweroftwo_290_c1e00290() {
    // Encoding: 0xC1E00290
    // Test aarch32_STLEXH_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=12, Rt=0, Rn=0, Rd=0
    let encoding: u32 = 0xC1E00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_stlexh_a1_a_field_cond_13_poweroftwo_290_d1e00290() {
    // Encoding: 0xD1E00290
    // Test aarch32_STLEXH_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rt=0, cond=13, Rn=0
    let encoding: u32 = 0xD1E00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_stlexh_a1_a_field_cond_14_poweroftwo_290_e1e00290() {
    // Encoding: 0xE1E00290
    // Test aarch32_STLEXH_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, cond=14, Rt=0, Rn=0
    let encoding: u32 = 0xE1E00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_stlexh_a1_a_field_cond_15_max_290_f1e00290() {
    // Encoding: 0xF1E00290
    // Test aarch32_STLEXH_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: Rd=0, Rt=0, cond=15, Rn=0
    let encoding: u32 = 0xF1E00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXH_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_stlexh_a1_a_field_rn_0_min_290_01e00290() {
    // Encoding: 0x01E00290
    // Test aarch32_STLEXH_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: Rt=0, Rd=0, Rn=0, cond=0
    let encoding: u32 = 0x01E00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXH_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_stlexh_a1_a_field_rn_1_poweroftwo_290_01e10290() {
    // Encoding: 0x01E10290
    // Test aarch32_STLEXH_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rt=0, cond=0, Rn=1
    let encoding: u32 = 0x01E10290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXH_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_stlexh_a1_a_field_rd_0_min_290_01e00290() {
    // Encoding: 0x01E00290
    // Test aarch32_STLEXH_A1_A field Rd = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rt=0, Rn=0, Rd=0
    let encoding: u32 = 0x01E00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXH_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_stlexh_a1_a_field_rd_1_poweroftwo_290_01e01290() {
    // Encoding: 0x01E01290
    // Test aarch32_STLEXH_A1_A field Rd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rd=1, cond=0, Rt=0
    let encoding: u32 = 0x01E01290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXH_A1_A
/// ASL: `field Rt 0 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_stlexh_a1_a_field_rt_0_min_290_01e00290() {
    // Encoding: 0x01E00290
    // Test aarch32_STLEXH_A1_A field Rt = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rd=0, Rn=0, Rt=0
    let encoding: u32 = 0x01E00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXH_A1_A
/// ASL: `field Rt 0 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_stlexh_a1_a_field_rt_1_poweroftwo_290_01e00291() {
    // Encoding: 0x01E00291
    // Test aarch32_STLEXH_A1_A field Rt = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rd=0, Rt=1, cond=0
    let encoding: u32 = 0x01E00291;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXH_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_stlexh_a1_a_combo_0_290_01e00290() {
    // Encoding: 0x01E00290
    // Test aarch32_STLEXH_A1_A field combination: cond=0, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: cond=0, Rt=0, Rn=0, Rd=0
    let encoding: u32 = 0x01E00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXH_A1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=1 (condition NE (not equal))
#[test]
fn test_aarch32_stlexh_a1_a_combo_1_290_11e00290() {
    // Encoding: 0x11E00290
    // Test aarch32_STLEXH_A1_A field combination: cond=1, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rn=0, cond=1, Rt=0, Rd=0
    let encoding: u32 = 0x11E00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXH_A1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=2 (condition CS/HS (carry set))
#[test]
fn test_aarch32_stlexh_a1_a_combo_2_290_21e00290() {
    // Encoding: 0x21E00290
    // Test aarch32_STLEXH_A1_A field combination: cond=2, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rt=0, Rn=0, cond=2, Rd=0
    let encoding: u32 = 0x21E00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXH_A1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=3 (condition CC/LO (carry clear))
#[test]
fn test_aarch32_stlexh_a1_a_combo_3_290_31e00290() {
    // Encoding: 0x31E00290
    // Test aarch32_STLEXH_A1_A field combination: cond=3, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rt=0, cond=3, Rd=0, Rn=0
    let encoding: u32 = 0x31E00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXH_A1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=4 (condition MI (minus/negative))
#[test]
fn test_aarch32_stlexh_a1_a_combo_4_290_41e00290() {
    // Encoding: 0x41E00290
    // Test aarch32_STLEXH_A1_A field combination: cond=4, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rn=0, cond=4, Rt=0, Rd=0
    let encoding: u32 = 0x41E00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXH_A1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=5 (condition PL (plus/positive))
#[test]
fn test_aarch32_stlexh_a1_a_combo_5_290_51e00290() {
    // Encoding: 0x51E00290
    // Test aarch32_STLEXH_A1_A field combination: cond=5, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rt=0, cond=5, Rd=0, Rn=0
    let encoding: u32 = 0x51E00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXH_A1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=6 (condition VS (overflow set))
#[test]
fn test_aarch32_stlexh_a1_a_combo_6_290_61e00290() {
    // Encoding: 0x61E00290
    // Test aarch32_STLEXH_A1_A field combination: cond=6, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rt=0, Rd=0, cond=6, Rn=0
    let encoding: u32 = 0x61E00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXH_A1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=7 (condition VC (overflow clear))
#[test]
fn test_aarch32_stlexh_a1_a_combo_7_290_71e00290() {
    // Encoding: 0x71E00290
    // Test aarch32_STLEXH_A1_A field combination: cond=7, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=7, Rd=0
    let encoding: u32 = 0x71E00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXH_A1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=8 (condition HI (unsigned higher))
#[test]
fn test_aarch32_stlexh_a1_a_combo_8_290_81e00290() {
    // Encoding: 0x81E00290
    // Test aarch32_STLEXH_A1_A field combination: cond=8, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: cond=8, Rn=0, Rt=0, Rd=0
    let encoding: u32 = 0x81E00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXH_A1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=9 (condition LS (unsigned lower or same))
#[test]
fn test_aarch32_stlexh_a1_a_combo_9_290_91e00290() {
    // Encoding: 0x91E00290
    // Test aarch32_STLEXH_A1_A field combination: cond=9, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rn=0, cond=9, Rt=0, Rd=0
    let encoding: u32 = 0x91E00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXH_A1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=10 (condition GE (signed >=))
#[test]
fn test_aarch32_stlexh_a1_a_combo_10_290_a1e00290() {
    // Encoding: 0xA1E00290
    // Test aarch32_STLEXH_A1_A field combination: cond=10, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rt=0, Rn=0, Rd=0, cond=10
    let encoding: u32 = 0xA1E00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXH_A1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=11 (condition LT (signed <))
#[test]
fn test_aarch32_stlexh_a1_a_combo_11_290_b1e00290() {
    // Encoding: 0xB1E00290
    // Test aarch32_STLEXH_A1_A field combination: cond=11, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rd=0, cond=11, Rt=0, Rn=0
    let encoding: u32 = 0xB1E00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXH_A1_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=12 (condition GT (signed >))
#[test]
fn test_aarch32_stlexh_a1_a_combo_12_290_c1e00290() {
    // Encoding: 0xC1E00290
    // Test aarch32_STLEXH_A1_A field combination: cond=12, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: cond=12, Rd=0, Rt=0, Rn=0
    let encoding: u32 = 0xC1E00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXH_A1_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=13 (condition LE (signed <=))
#[test]
fn test_aarch32_stlexh_a1_a_combo_13_290_d1e00290() {
    // Encoding: 0xD1E00290
    // Test aarch32_STLEXH_A1_A field combination: cond=13, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: cond=13, Rd=0, Rn=0, Rt=0
    let encoding: u32 = 0xD1E00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXH_A1_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=14 (condition AL (always))
#[test]
fn test_aarch32_stlexh_a1_a_combo_14_290_e1e00290() {
    // Encoding: 0xE1E00290
    // Test aarch32_STLEXH_A1_A field combination: cond=14, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rn=0, Rt=0, Rd=0, cond=14
    let encoding: u32 = 0xE1E00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXH_A1_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=15 (condition NV (never, reserved))
#[test]
fn test_aarch32_stlexh_a1_a_combo_15_290_f1e00290() {
    // Encoding: 0xF1E00290
    // Test aarch32_STLEXH_A1_A field combination: cond=15, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rd=0, cond=15, Rt=0, Rn=0
    let encoding: u32 = 0xF1E00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXH_A1_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_stlexh_a1_a_combo_16_290_01e00290() {
    // Encoding: 0x01E00290
    // Test aarch32_STLEXH_A1_A field combination: cond=0, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rn=0, Rd=0, cond=0, Rt=0
    let encoding: u32 = 0x01E00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXH_A1_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_stlexh_a1_a_combo_17_290_01e10290() {
    // Encoding: 0x01E10290
    // Test aarch32_STLEXH_A1_A field combination: cond=0, Rn=1, Rd=0, Rt=0
    // ISET: A32
    // Fields: cond=0, Rn=1, Rd=0, Rt=0
    let encoding: u32 = 0x01E10290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXH_A1_A
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch32_stlexh_a1_a_combo_18_290_01e00290() {
    // Encoding: 0x01E00290
    // Test aarch32_STLEXH_A1_A field combination: cond=0, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rt=0, Rn=0, Rd=0, cond=0
    let encoding: u32 = 0x01E00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXH_A1_A
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch32_stlexh_a1_a_combo_19_290_01e01290() {
    // Encoding: 0x01E01290
    // Test aarch32_STLEXH_A1_A field combination: cond=0, Rn=0, Rd=1, Rt=0
    // ISET: A32
    // Fields: Rt=0, cond=0, Rn=0, Rd=1
    let encoding: u32 = 0x01E01290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXH_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_stlexh_a1_a_special_cond_0_condition_eq_656_01e00290() {
    // Encoding: 0x01E00290
    // Test aarch32_STLEXH_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: cond=0, Rt=0, Rd=0, Rn=0
    let encoding: u32 = 0x01E00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXH_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_stlexh_a1_a_special_cond_1_condition_ne_656_11e00290() {
    // Encoding: 0x11E00290
    // Test aarch32_STLEXH_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: Rn=0, Rd=0, Rt=0, cond=1
    let encoding: u32 = 0x11E00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXH_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_stlexh_a1_a_special_cond_2_condition_cs_hs_656_21e00290() {
    // Encoding: 0x21E00290
    // Test aarch32_STLEXH_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: Rd=0, Rn=0, cond=2, Rt=0
    let encoding: u32 = 0x21E00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXH_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_stlexh_a1_a_special_cond_3_condition_cc_lo_656_31e00290() {
    // Encoding: 0x31E00290
    // Test aarch32_STLEXH_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: cond=3, Rd=0, Rt=0, Rn=0
    let encoding: u32 = 0x31E00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXH_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_stlexh_a1_a_special_cond_4_condition_mi_656_41e00290() {
    // Encoding: 0x41E00290
    // Test aarch32_STLEXH_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: Rt=0, Rd=0, cond=4, Rn=0
    let encoding: u32 = 0x41E00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXH_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_stlexh_a1_a_special_cond_5_condition_pl_656_51e00290() {
    // Encoding: 0x51E00290
    // Test aarch32_STLEXH_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: Rt=0, Rn=0, Rd=0, cond=5
    let encoding: u32 = 0x51E00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXH_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_stlexh_a1_a_special_cond_6_condition_vs_656_61e00290() {
    // Encoding: 0x61E00290
    // Test aarch32_STLEXH_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: Rd=0, cond=6, Rn=0, Rt=0
    let encoding: u32 = 0x61E00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXH_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_stlexh_a1_a_special_cond_7_condition_vc_656_71e00290() {
    // Encoding: 0x71E00290
    // Test aarch32_STLEXH_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: Rd=0, Rn=0, cond=7, Rt=0
    let encoding: u32 = 0x71E00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXH_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_stlexh_a1_a_special_cond_8_condition_hi_656_81e00290() {
    // Encoding: 0x81E00290
    // Test aarch32_STLEXH_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: Rn=0, Rd=0, cond=8, Rt=0
    let encoding: u32 = 0x81E00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXH_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_stlexh_a1_a_special_cond_9_condition_ls_656_91e00290() {
    // Encoding: 0x91E00290
    // Test aarch32_STLEXH_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: Rd=0, cond=9, Rn=0, Rt=0
    let encoding: u32 = 0x91E00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXH_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_stlexh_a1_a_special_cond_10_condition_ge_656_a1e00290() {
    // Encoding: 0xA1E00290
    // Test aarch32_STLEXH_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: cond=10, Rn=0, Rd=0, Rt=0
    let encoding: u32 = 0xA1E00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXH_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_stlexh_a1_a_special_cond_11_condition_lt_656_b1e00290() {
    // Encoding: 0xB1E00290
    // Test aarch32_STLEXH_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: cond=11, Rt=0, Rn=0, Rd=0
    let encoding: u32 = 0xB1E00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXH_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_stlexh_a1_a_special_cond_12_condition_gt_656_c1e00290() {
    // Encoding: 0xC1E00290
    // Test aarch32_STLEXH_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: cond=12, Rt=0, Rd=0, Rn=0
    let encoding: u32 = 0xC1E00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXH_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_stlexh_a1_a_special_cond_13_condition_le_656_d1e00290() {
    // Encoding: 0xD1E00290
    // Test aarch32_STLEXH_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=13, Rd=0
    let encoding: u32 = 0xD1E00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXH_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_stlexh_a1_a_special_cond_14_condition_al_656_e1e00290() {
    // Encoding: 0xE1E00290
    // Test aarch32_STLEXH_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: cond=14, Rd=0, Rt=0, Rn=0
    let encoding: u32 = 0xE1E00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXH_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_stlexh_a1_a_special_cond_15_condition_nv_656_f1e00290() {
    // Encoding: 0xF1E00290
    // Test aarch32_STLEXH_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: cond=15, Rn=0, Rt=0, Rd=0
    let encoding: u32 = 0xF1E00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXH_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_stlexh_a1_a_invalid_0_290_01e00290() {
    // Encoding: 0x01E00290
    // Test aarch32_STLEXH_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }
    // ISET: A32
    // Fields: cond=0, Rt=0, Rn=0, Rd=0
    let encoding: u32 = 0x01E00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STLEXH_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_stlexh_a1_a_invalid_1_290_01e00290() {
    // Encoding: 0x01E00290
    // Test aarch32_STLEXH_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Rn=0, cond=0, Rd=0, Rt=0
    let encoding: u32 = 0x01E00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STLEXH_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_stlexh_a1_a_invalid_2_290_01e00290() {
    // Encoding: 0x01E00290
    // Test aarch32_STLEXH_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) }
    // ISET: A32
    // Fields: Rt=0, Rd=0, cond=0, Rn=0
    let encoding: u32 = 0x01E00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STLEXH_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_stlexh_a1_a_invalid_3_290_01e00290() {
    // Encoding: 0x01E00290
    // Test aarch32_STLEXH_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Rt=0, cond=0, Rn=0, Rd=0
    let encoding: u32 = 0x01E00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STLEXH_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_stlexh_t1_a_field_rn_0_min_d0_e8c000d0() {
    // Thumb encoding (32): 0xE8C000D0
    // Test aarch32_STLEXH_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rt=0, Rn=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C000D0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLEXH_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_stlexh_t1_a_field_rn_1_poweroftwo_d0_e8c100d0() {
    // Thumb encoding (32): 0xE8C100D0
    // Test aarch32_STLEXH_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, Rn=1, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C100D0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLEXH_T1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_stlexh_t1_a_field_rt_0_min_d0_e8c000d0() {
    // Thumb encoding (32): 0xE8C000D0
    // Test aarch32_STLEXH_T1_A field Rt = 0 (Min)
    // ISET: T32
    // Fields: Rd=0, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C000D0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLEXH_T1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_stlexh_t1_a_field_rt_1_poweroftwo_d0_e8c010d0() {
    // Thumb encoding (32): 0xE8C010D0
    // Test aarch32_STLEXH_T1_A field Rt = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Rt=1, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C010D0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLEXH_T1_A
/// ASL: `field Rd 0 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_stlexh_t1_a_field_rd_0_min_d0_e8c000d0() {
    // Thumb encoding (32): 0xE8C000D0
    // Test aarch32_STLEXH_T1_A field Rd = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rt=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C000D0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLEXH_T1_A
/// ASL: `field Rd 0 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_stlexh_t1_a_field_rd_1_poweroftwo_d0_e8c000d1() {
    // Thumb encoding (32): 0xE8C000D1
    // Test aarch32_STLEXH_T1_A field Rd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rd=1, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C000D1;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLEXH_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_stlexh_t1_a_combo_0_d0_e8c000d0() {
    // Thumb encoding (32): 0xE8C000D0
    // Test aarch32_STLEXH_T1_A field combination: Rn=0, Rt=0, Rd=0
    // ISET: T32
    // Fields: Rt=0, Rd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C000D0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLEXH_T1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_stlexh_t1_a_combo_1_d0_e8c100d0() {
    // Thumb encoding (32): 0xE8C100D0
    // Test aarch32_STLEXH_T1_A field combination: Rn=1, Rt=0, Rd=0
    // ISET: T32
    // Fields: Rd=0, Rn=1, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C100D0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLEXH_T1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=0 (register index 0 (first register))
#[test]
fn test_aarch32_stlexh_t1_a_combo_2_d0_e8c000d0() {
    // Thumb encoding (32): 0xE8C000D0
    // Test aarch32_STLEXH_T1_A field combination: Rn=0, Rt=0, Rd=0
    // ISET: T32
    // Fields: Rd=0, Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C000D0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLEXH_T1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=1 (register index 1 (second register))
#[test]
fn test_aarch32_stlexh_t1_a_combo_3_d0_e8c010d0() {
    // Thumb encoding (32): 0xE8C010D0
    // Test aarch32_STLEXH_T1_A field combination: Rn=0, Rt=1, Rd=0
    // ISET: T32
    // Fields: Rn=0, Rd=0, Rt=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C010D0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLEXH_T1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch32_stlexh_t1_a_combo_4_d0_e8c000d0() {
    // Thumb encoding (32): 0xE8C000D0
    // Test aarch32_STLEXH_T1_A field combination: Rn=0, Rt=0, Rd=0
    // ISET: T32
    // Fields: Rd=0, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C000D0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLEXH_T1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch32_stlexh_t1_a_combo_5_d0_e8c000d1() {
    // Thumb encoding (32): 0xE8C000D1
    // Test aarch32_STLEXH_T1_A field combination: Rn=0, Rt=0, Rd=1
    // ISET: T32
    // Fields: Rn=0, Rt=0, Rd=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C000D1;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLEXH_T1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rt=1 (same register test (reg=1))
#[test]
fn test_aarch32_stlexh_t1_a_combo_6_d0_e8c110d0() {
    // Thumb encoding (32): 0xE8C110D0
    // Test aarch32_STLEXH_T1_A field combination: Rn=1, Rt=1, Rd=0
    // ISET: T32
    // Fields: Rt=1, Rd=0, Rn=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C110D0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLEXH_T1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rt=31 (same register test (reg=31))
#[test]
fn test_aarch32_stlexh_t1_a_combo_7_d0_e8cff0d0() {
    // Thumb encoding (32): 0xE8CFF0D0
    // Test aarch32_STLEXH_T1_A field combination: Rn=31, Rt=31, Rd=0
    // ISET: T32
    // Fields: Rn=31, Rd=0, Rt=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8CFF0D0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLEXH_T1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch32_stlexh_t1_a_combo_8_d0_e8c100d1() {
    // Thumb encoding (32): 0xE8C100D1
    // Test aarch32_STLEXH_T1_A field combination: Rn=1, Rt=0, Rd=1
    // ISET: T32
    // Fields: Rd=1, Rn=1, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C100D1;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLEXH_T1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch32_stlexh_t1_a_combo_9_d0_e8cf00df() {
    // Thumb encoding (32): 0xE8CF00DF
    // Test aarch32_STLEXH_T1_A field combination: Rn=31, Rt=0, Rd=31
    // ISET: T32
    // Fields: Rd=31, Rn=31, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8CF00DF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLEXH_T1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch32_stlexh_t1_a_combo_10_d0_e8c010d1() {
    // Thumb encoding (32): 0xE8C010D1
    // Test aarch32_STLEXH_T1_A field combination: Rn=0, Rt=1, Rd=1
    // ISET: T32
    // Fields: Rt=1, Rd=1, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C010D1;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLEXH_T1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch32_stlexh_t1_a_combo_11_d0_e8c0f0df() {
    // Thumb encoding (32): 0xE8C0F0DF
    // Test aarch32_STLEXH_T1_A field combination: Rn=0, Rt=31, Rd=31
    // ISET: T32
    // Fields: Rd=31, Rn=0, Rt=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C0F0DF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLEXH_T1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_stlexh_t1_a_invalid_0_d0_e8c000d0() {
    // Thumb encoding (32): 0xE8C000D0
    // Test aarch32_STLEXH_T1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }
    // ISET: T32
    // Fields: Rd=0, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C000D0;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_STLEXH_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_stlexh_t1_a_invalid_1_d0_e8c000d0() {
    // Thumb encoding (32): 0xE8C000D0
    // Test aarch32_STLEXH_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rn=0, Rd=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C000D0;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_STLEXH_T1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_stlexh_t1_a_invalid_2_d0_e8c000d0() {
    // Thumb encoding (32): 0xE8C000D0
    // Test aarch32_STLEXH_T1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) }
    // ISET: T32
    // Fields: Rn=0, Rt=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C000D0;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_STLEXH_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_stlexh_t1_a_invalid_3_d0_e8c000d0() {
    // Thumb encoding (32): 0xE8C000D0
    // Test aarch32_STLEXH_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rn=0, Rd=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C000D0;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_STLEXH_A1_A
/// ASL: `SMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple multiply
#[test]
fn test_aarch32_stlexh_a1_a_smull_oracle_0_9b227c20() {
    // Test SMULL: simple multiply (oracle)
    // Encoding: 0x9B227C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3);
    set_w(&mut cpu, 1, 0x2);
    let encoding: u32 = 0x9B227C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6, "X0 should be 0x0000000000000006");
}

/// Provenance: aarch32_STLEXH_A1_A
/// ASL: `SMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max 32-bit * 2
#[test]
fn test_aarch32_stlexh_a1_a_smull_oracle_1_9b227c20() {
    // Test SMULL: max 32-bit * 2 (oracle)
    // Encoding: 0x9B227C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x9B227C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFE, "X0 should be 0xFFFFFFFFFFFFFFFE");
}

/// Provenance: aarch32_STLEXH_A1_A
/// ASL: `SMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// large positive * large positive
#[test]
fn test_aarch32_stlexh_a1_a_smull_oracle_2_9b227c20() {
    // Test SMULL: large positive * large positive (oracle)
    // Encoding: 0x9B227C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x7FFFFFFF);
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x9B227C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x3FFFFFFF00000001");
}

/// Provenance: aarch32_STLEXH_A1_A
/// ASL: `SMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max unsigned * max unsigned
#[test]
fn test_aarch32_stlexh_a1_a_smull_oracle_3_9b227c20() {
    // Test SMULL: max unsigned * max unsigned (oracle)
    // Encoding: 0x9B227C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x9B227C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x0000000000000001");
}

/// Provenance: aarch32_STLEXH_A1_A
/// ASL: `SMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// medium values
#[test]
fn test_aarch32_stlexh_a1_a_smull_oracle_4_9b227c20() {
    // Test SMULL: medium values (oracle)
    // Encoding: 0x9B227C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xC8);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x9B227C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4E20, "X0 should be 0x0000000000004E20");
}

/// Provenance: aarch32_STLEXH_A1_A
/// ASL: `SMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// 16-bit values
#[test]
fn test_aarch32_stlexh_a1_a_smull_oracle_5_9b227c20() {
    // Test SMULL: 16-bit values (oracle)
    // Encoding: 0x9B227C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1234);
    set_w(&mut cpu, 2, 0x5678);
    let encoding: u32 = 0x9B227C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6260060, "X0 should be 0x0000000006260060");
}

/// Provenance: aarch32_STLEXH_A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_stlexh_a1_a_store_0_01e10290() {
    // Test aarch32_STLEXH_A1_A memory store: 8 bytes
    // Encoding: 0x01E10290
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x01E10290;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_STLEXH_T1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_stlexh_t1_a_store_0_e8c100d0() {
    // Test aarch32_STLEXH_T1_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xE8C100D0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// aarch32_STREX_A Tests
// ============================================================================

/// Provenance: aarch32_STREX_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_strex_a1_a_field_cond_0_min_390_01800390() {
    // Encoding: 0x01800390
    // Test aarch32_STREX_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: Rt=0, Rn=0, Rd=0, cond=0
    let encoding: u32 = 0x01800390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREX_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_strex_a1_a_field_cond_1_poweroftwo_390_11800390() {
    // Encoding: 0x11800390
    // Test aarch32_STREX_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=1, Rt=0, Rn=0, Rd=0
    let encoding: u32 = 0x11800390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREX_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_strex_a1_a_field_cond_2_poweroftwo_390_21800390() {
    // Encoding: 0x21800390
    // Test aarch32_STREX_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rd=0, cond=2, Rt=0
    let encoding: u32 = 0x21800390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREX_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_strex_a1_a_field_cond_3_poweroftwo_390_31800390() {
    // Encoding: 0x31800390
    // Test aarch32_STREX_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=3, Rn=0, Rt=0, Rd=0
    let encoding: u32 = 0x31800390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREX_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_strex_a1_a_field_cond_4_poweroftwo_390_41800390() {
    // Encoding: 0x41800390
    // Test aarch32_STREX_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=4, Rt=0, Rd=0, Rn=0
    let encoding: u32 = 0x41800390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREX_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_strex_a1_a_field_cond_5_poweroftwo_390_51800390() {
    // Encoding: 0x51800390
    // Test aarch32_STREX_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rd=0, cond=5, Rt=0
    let encoding: u32 = 0x51800390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREX_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_strex_a1_a_field_cond_6_poweroftwo_390_61800390() {
    // Encoding: 0x61800390
    // Test aarch32_STREX_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=6, Rt=0, Rn=0, Rd=0
    let encoding: u32 = 0x61800390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREX_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_strex_a1_a_field_cond_7_poweroftwo_390_71800390() {
    // Encoding: 0x71800390
    // Test aarch32_STREX_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=7, Rn=0, Rd=0, Rt=0
    let encoding: u32 = 0x71800390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREX_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_strex_a1_a_field_cond_8_poweroftwo_390_81800390() {
    // Encoding: 0x81800390
    // Test aarch32_STREX_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, cond=8, Rn=0, Rt=0
    let encoding: u32 = 0x81800390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREX_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_strex_a1_a_field_cond_9_poweroftwo_390_91800390() {
    // Encoding: 0x91800390
    // Test aarch32_STREX_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rt=0, cond=9, Rn=0
    let encoding: u32 = 0x91800390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREX_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_strex_a1_a_field_cond_10_poweroftwo_390_a1800390() {
    // Encoding: 0xA1800390
    // Test aarch32_STREX_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rd=0, Rt=0, cond=10
    let encoding: u32 = 0xA1800390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREX_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_strex_a1_a_field_cond_11_poweroftwo_390_b1800390() {
    // Encoding: 0xB1800390
    // Test aarch32_STREX_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, Rd=0, Rn=0, cond=11
    let encoding: u32 = 0xB1800390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREX_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_strex_a1_a_field_cond_12_poweroftwo_390_c1800390() {
    // Encoding: 0xC1800390
    // Test aarch32_STREX_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, Rd=0, cond=12, Rn=0
    let encoding: u32 = 0xC1800390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREX_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_strex_a1_a_field_cond_13_poweroftwo_390_d1800390() {
    // Encoding: 0xD1800390
    // Test aarch32_STREX_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, cond=13, Rt=0, Rn=0
    let encoding: u32 = 0xD1800390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREX_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_strex_a1_a_field_cond_14_poweroftwo_390_e1800390() {
    // Encoding: 0xE1800390
    // Test aarch32_STREX_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, Rd=0, Rn=0, cond=14
    let encoding: u32 = 0xE1800390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREX_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_strex_a1_a_field_cond_15_max_390_f1800390() {
    // Encoding: 0xF1800390
    // Test aarch32_STREX_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: Rt=0, Rn=0, cond=15, Rd=0
    let encoding: u32 = 0xF1800390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREX_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_strex_a1_a_field_rn_0_min_390_01800390() {
    // Encoding: 0x01800390
    // Test aarch32_STREX_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rt=0, Rn=0, Rd=0
    let encoding: u32 = 0x01800390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREX_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_strex_a1_a_field_rn_1_poweroftwo_390_01810390() {
    // Encoding: 0x01810390
    // Test aarch32_STREX_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Rd=0, Rn=1, Rt=0
    let encoding: u32 = 0x01810390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREX_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_strex_a1_a_field_rd_0_min_390_01800390() {
    // Encoding: 0x01800390
    // Test aarch32_STREX_A1_A field Rd = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rt=0, Rn=0, Rd=0
    let encoding: u32 = 0x01800390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREX_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_strex_a1_a_field_rd_1_poweroftwo_390_01801390() {
    // Encoding: 0x01801390
    // Test aarch32_STREX_A1_A field Rd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Rd=1, Rt=0, Rn=0
    let encoding: u32 = 0x01801390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREX_A1_A
/// ASL: `field Rt 0 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_strex_a1_a_field_rt_0_min_390_01800390() {
    // Encoding: 0x01800390
    // Test aarch32_STREX_A1_A field Rt = 0 (Min)
    // ISET: A32
    // Fields: Rd=0, Rn=0, Rt=0, cond=0
    let encoding: u32 = 0x01800390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREX_A1_A
/// ASL: `field Rt 0 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_strex_a1_a_field_rt_1_poweroftwo_390_01800391() {
    // Encoding: 0x01800391
    // Test aarch32_STREX_A1_A field Rt = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Rn=0, Rt=1, Rd=0
    let encoding: u32 = 0x01800391;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREX_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_strex_a1_a_combo_0_390_01800390() {
    // Encoding: 0x01800390
    // Test aarch32_STREX_A1_A field combination: cond=0, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=0, Rd=0
    let encoding: u32 = 0x01800390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREX_A1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=1 (condition NE (not equal))
#[test]
fn test_aarch32_strex_a1_a_combo_1_390_11800390() {
    // Encoding: 0x11800390
    // Test aarch32_STREX_A1_A field combination: cond=1, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: cond=1, Rd=0, Rn=0, Rt=0
    let encoding: u32 = 0x11800390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREX_A1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=2 (condition CS/HS (carry set))
#[test]
fn test_aarch32_strex_a1_a_combo_2_390_21800390() {
    // Encoding: 0x21800390
    // Test aarch32_STREX_A1_A field combination: cond=2, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rt=0, Rn=0, cond=2, Rd=0
    let encoding: u32 = 0x21800390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREX_A1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=3 (condition CC/LO (carry clear))
#[test]
fn test_aarch32_strex_a1_a_combo_3_390_31800390() {
    // Encoding: 0x31800390
    // Test aarch32_STREX_A1_A field combination: cond=3, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rn=0, cond=3, Rt=0, Rd=0
    let encoding: u32 = 0x31800390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREX_A1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=4 (condition MI (minus/negative))
#[test]
fn test_aarch32_strex_a1_a_combo_4_390_41800390() {
    // Encoding: 0x41800390
    // Test aarch32_STREX_A1_A field combination: cond=4, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rt=0, cond=4, Rn=0, Rd=0
    let encoding: u32 = 0x41800390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREX_A1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=5 (condition PL (plus/positive))
#[test]
fn test_aarch32_strex_a1_a_combo_5_390_51800390() {
    // Encoding: 0x51800390
    // Test aarch32_STREX_A1_A field combination: cond=5, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rd=0, Rt=0, Rn=0, cond=5
    let encoding: u32 = 0x51800390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREX_A1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=6 (condition VS (overflow set))
#[test]
fn test_aarch32_strex_a1_a_combo_6_390_61800390() {
    // Encoding: 0x61800390
    // Test aarch32_STREX_A1_A field combination: cond=6, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rt=0, Rn=0, Rd=0, cond=6
    let encoding: u32 = 0x61800390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREX_A1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=7 (condition VC (overflow clear))
#[test]
fn test_aarch32_strex_a1_a_combo_7_390_71800390() {
    // Encoding: 0x71800390
    // Test aarch32_STREX_A1_A field combination: cond=7, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rn=0, Rd=0, cond=7, Rt=0
    let encoding: u32 = 0x71800390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREX_A1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=8 (condition HI (unsigned higher))
#[test]
fn test_aarch32_strex_a1_a_combo_8_390_81800390() {
    // Encoding: 0x81800390
    // Test aarch32_STREX_A1_A field combination: cond=8, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rn=0, Rt=0, Rd=0, cond=8
    let encoding: u32 = 0x81800390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREX_A1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=9 (condition LS (unsigned lower or same))
#[test]
fn test_aarch32_strex_a1_a_combo_9_390_91800390() {
    // Encoding: 0x91800390
    // Test aarch32_STREX_A1_A field combination: cond=9, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rd=0, Rt=0, cond=9, Rn=0
    let encoding: u32 = 0x91800390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREX_A1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=10 (condition GE (signed >=))
#[test]
fn test_aarch32_strex_a1_a_combo_10_390_a1800390() {
    // Encoding: 0xA1800390
    // Test aarch32_STREX_A1_A field combination: cond=10, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rt=0, Rn=0, Rd=0, cond=10
    let encoding: u32 = 0xA1800390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREX_A1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=11 (condition LT (signed <))
#[test]
fn test_aarch32_strex_a1_a_combo_11_390_b1800390() {
    // Encoding: 0xB1800390
    // Test aarch32_STREX_A1_A field combination: cond=11, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: cond=11, Rt=0, Rd=0, Rn=0
    let encoding: u32 = 0xB1800390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREX_A1_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=12 (condition GT (signed >))
#[test]
fn test_aarch32_strex_a1_a_combo_12_390_c1800390() {
    // Encoding: 0xC1800390
    // Test aarch32_STREX_A1_A field combination: cond=12, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: cond=12, Rt=0, Rd=0, Rn=0
    let encoding: u32 = 0xC1800390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREX_A1_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=13 (condition LE (signed <=))
#[test]
fn test_aarch32_strex_a1_a_combo_13_390_d1800390() {
    // Encoding: 0xD1800390
    // Test aarch32_STREX_A1_A field combination: cond=13, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rn=0, cond=13, Rd=0, Rt=0
    let encoding: u32 = 0xD1800390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREX_A1_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=14 (condition AL (always))
#[test]
fn test_aarch32_strex_a1_a_combo_14_390_e1800390() {
    // Encoding: 0xE1800390
    // Test aarch32_STREX_A1_A field combination: cond=14, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: cond=14, Rn=0, Rd=0, Rt=0
    let encoding: u32 = 0xE1800390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREX_A1_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=15 (condition NV (never, reserved))
#[test]
fn test_aarch32_strex_a1_a_combo_15_390_f1800390() {
    // Encoding: 0xF1800390
    // Test aarch32_STREX_A1_A field combination: cond=15, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rt=0, Rd=0, cond=15, Rn=0
    let encoding: u32 = 0xF1800390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREX_A1_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_strex_a1_a_combo_16_390_01800390() {
    // Encoding: 0x01800390
    // Test aarch32_STREX_A1_A field combination: cond=0, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: cond=0, Rt=0, Rn=0, Rd=0
    let encoding: u32 = 0x01800390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREX_A1_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_strex_a1_a_combo_17_390_01810390() {
    // Encoding: 0x01810390
    // Test aarch32_STREX_A1_A field combination: cond=0, Rn=1, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rn=1, Rt=0, Rd=0, cond=0
    let encoding: u32 = 0x01810390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREX_A1_A
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch32_strex_a1_a_combo_18_390_01800390() {
    // Encoding: 0x01800390
    // Test aarch32_STREX_A1_A field combination: cond=0, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rd=0, Rt=0, cond=0, Rn=0
    let encoding: u32 = 0x01800390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREX_A1_A
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch32_strex_a1_a_combo_19_390_01801390() {
    // Encoding: 0x01801390
    // Test aarch32_STREX_A1_A field combination: cond=0, Rn=0, Rd=1, Rt=0
    // ISET: A32
    // Fields: Rn=0, Rd=1, cond=0, Rt=0
    let encoding: u32 = 0x01801390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREX_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_strex_a1_a_special_cond_0_condition_eq_912_01800390() {
    // Encoding: 0x01800390
    // Test aarch32_STREX_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: Rd=0, Rt=0, Rn=0, cond=0
    let encoding: u32 = 0x01800390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREX_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_strex_a1_a_special_cond_1_condition_ne_912_11800390() {
    // Encoding: 0x11800390
    // Test aarch32_STREX_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: Rt=0, Rn=0, cond=1, Rd=0
    let encoding: u32 = 0x11800390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREX_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_strex_a1_a_special_cond_2_condition_cs_hs_912_21800390() {
    // Encoding: 0x21800390
    // Test aarch32_STREX_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: Rn=0, Rt=0, Rd=0, cond=2
    let encoding: u32 = 0x21800390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREX_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_strex_a1_a_special_cond_3_condition_cc_lo_912_31800390() {
    // Encoding: 0x31800390
    // Test aarch32_STREX_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: Rd=0, Rt=0, Rn=0, cond=3
    let encoding: u32 = 0x31800390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREX_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_strex_a1_a_special_cond_4_condition_mi_912_41800390() {
    // Encoding: 0x41800390
    // Test aarch32_STREX_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: cond=4, Rn=0, Rd=0, Rt=0
    let encoding: u32 = 0x41800390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREX_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_strex_a1_a_special_cond_5_condition_pl_912_51800390() {
    // Encoding: 0x51800390
    // Test aarch32_STREX_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: Rn=0, Rd=0, Rt=0, cond=5
    let encoding: u32 = 0x51800390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREX_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_strex_a1_a_special_cond_6_condition_vs_912_61800390() {
    // Encoding: 0x61800390
    // Test aarch32_STREX_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: Rn=0, Rd=0, Rt=0, cond=6
    let encoding: u32 = 0x61800390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREX_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_strex_a1_a_special_cond_7_condition_vc_912_71800390() {
    // Encoding: 0x71800390
    // Test aarch32_STREX_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: Rt=0, Rd=0, cond=7, Rn=0
    let encoding: u32 = 0x71800390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREX_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_strex_a1_a_special_cond_8_condition_hi_912_81800390() {
    // Encoding: 0x81800390
    // Test aarch32_STREX_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: Rn=0, cond=8, Rd=0, Rt=0
    let encoding: u32 = 0x81800390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREX_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_strex_a1_a_special_cond_9_condition_ls_912_91800390() {
    // Encoding: 0x91800390
    // Test aarch32_STREX_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: Rn=0, Rt=0, Rd=0, cond=9
    let encoding: u32 = 0x91800390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREX_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_strex_a1_a_special_cond_10_condition_ge_912_a1800390() {
    // Encoding: 0xA1800390
    // Test aarch32_STREX_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: Rt=0, Rn=0, Rd=0, cond=10
    let encoding: u32 = 0xA1800390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREX_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_strex_a1_a_special_cond_11_condition_lt_912_b1800390() {
    // Encoding: 0xB1800390
    // Test aarch32_STREX_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: Rd=0, cond=11, Rn=0, Rt=0
    let encoding: u32 = 0xB1800390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREX_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_strex_a1_a_special_cond_12_condition_gt_912_c1800390() {
    // Encoding: 0xC1800390
    // Test aarch32_STREX_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: Rt=0, Rn=0, cond=12, Rd=0
    let encoding: u32 = 0xC1800390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREX_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_strex_a1_a_special_cond_13_condition_le_912_d1800390() {
    // Encoding: 0xD1800390
    // Test aarch32_STREX_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: Rd=0, Rn=0, cond=13, Rt=0
    let encoding: u32 = 0xD1800390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREX_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_strex_a1_a_special_cond_14_condition_al_912_e1800390() {
    // Encoding: 0xE1800390
    // Test aarch32_STREX_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: Rd=0, Rn=0, cond=14, Rt=0
    let encoding: u32 = 0xE1800390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREX_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_strex_a1_a_special_cond_15_condition_nv_912_f1800390() {
    // Encoding: 0xF1800390
    // Test aarch32_STREX_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: cond=15, Rt=0, Rd=0, Rn=0
    let encoding: u32 = 0xF1800390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREX_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strex_a1_a_invalid_0_390_01800390() {
    // Encoding: 0x01800390
    // Test aarch32_STREX_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }
    // ISET: A32
    // Fields: Rn=0, cond=0, Rt=0, Rd=0
    let encoding: u32 = 0x01800390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STREX_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strex_a1_a_invalid_1_390_01800390() {
    // Encoding: 0x01800390
    // Test aarch32_STREX_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Rt=0, Rn=0, Rd=0, cond=0
    let encoding: u32 = 0x01800390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STREX_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strex_a1_a_invalid_2_390_01800390() {
    // Encoding: 0x01800390
    // Test aarch32_STREX_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) }
    // ISET: A32
    // Fields: Rd=0, Rn=0, Rt=0, cond=0
    let encoding: u32 = 0x01800390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STREX_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strex_a1_a_invalid_3_390_01800390() {
    // Encoding: 0x01800390
    // Test aarch32_STREX_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: cond=0, Rt=0, Rn=0, Rd=0
    let encoding: u32 = 0x01800390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STREX_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_strex_t1_a_field_rn_0_min_0_e8400000() {
    // Thumb encoding (32): 0xE8400000
    // Test aarch32_STREX_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rt=0, Rd=0, imm8=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREX_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_strex_t1_a_field_rn_1_poweroftwo_0_e8410000() {
    // Thumb encoding (32): 0xE8410000
    // Test aarch32_STREX_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, imm8=0, Rd=0, Rn=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8410000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREX_T1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_strex_t1_a_field_rt_0_min_0_e8400000() {
    // Thumb encoding (32): 0xE8400000
    // Test aarch32_STREX_T1_A field Rt = 0 (Min)
    // ISET: T32
    // Fields: Rt=0, imm8=0, Rn=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREX_T1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_strex_t1_a_field_rt_1_poweroftwo_0_e8401000() {
    // Thumb encoding (32): 0xE8401000
    // Test aarch32_STREX_T1_A field Rt = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Rd=0, imm8=0, Rt=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8401000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREX_T1_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_strex_t1_a_field_rd_0_min_0_e8400000() {
    // Thumb encoding (32): 0xE8400000
    // Test aarch32_STREX_T1_A field Rd = 0 (Min)
    // ISET: T32
    // Fields: Rt=0, Rn=0, Rd=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREX_T1_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_strex_t1_a_field_rd_1_poweroftwo_0_e8400100() {
    // Thumb encoding (32): 0xE8400100
    // Test aarch32_STREX_T1_A field Rd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rd=1, imm8=0, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8400100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREX_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_strex_t1_a_field_imm8_0_zero_0_e8400000() {
    // Thumb encoding (32): 0xE8400000
    // Test aarch32_STREX_T1_A field imm8 = 0 (Zero)
    // ISET: T32
    // Fields: imm8=0, Rt=0, Rn=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREX_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_strex_t1_a_field_imm8_1_poweroftwo_0_e8400001() {
    // Thumb encoding (32): 0xE8400001
    // Test aarch32_STREX_T1_A field imm8 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rd=0, Rt=0, imm8=1, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8400001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREX_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_strex_t1_a_field_imm8_3_poweroftwominusone_0_e8400003() {
    // Thumb encoding (32): 0xE8400003
    // Test aarch32_STREX_T1_A field imm8 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rd=0, Rn=0, Rt=0, imm8=3
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8400003;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREX_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_strex_t1_a_field_imm8_4_poweroftwo_0_e8400004() {
    // Thumb encoding (32): 0xE8400004
    // Test aarch32_STREX_T1_A field imm8 = 4 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, imm8=4, Rd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8400004;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREX_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_strex_t1_a_field_imm8_7_poweroftwominusone_0_e8400007() {
    // Thumb encoding (32): 0xE8400007
    // Test aarch32_STREX_T1_A field imm8 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, Rd=0, imm8=7, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8400007;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREX_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_strex_t1_a_field_imm8_8_poweroftwo_0_e8400008() {
    // Thumb encoding (32): 0xE8400008
    // Test aarch32_STREX_T1_A field imm8 = 8 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, Rd=0, Rn=0, imm8=8
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8400008;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREX_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_strex_t1_a_field_imm8_15_poweroftwominusone_0_e840000f() {
    // Thumb encoding (32): 0xE840000F
    // Test aarch32_STREX_T1_A field imm8 = 15 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, Rt=0, Rd=0, imm8=15
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE840000F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREX_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_strex_t1_a_field_imm8_16_poweroftwo_0_e8400010() {
    // Thumb encoding (32): 0xE8400010
    // Test aarch32_STREX_T1_A field imm8 = 16 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, Rn=0, Rd=0, imm8=16
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8400010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREX_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_strex_t1_a_field_imm8_31_poweroftwominusone_0_e840001f() {
    // Thumb encoding (32): 0xE840001F
    // Test aarch32_STREX_T1_A field imm8 = 31 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm8=31, Rd=0, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE840001F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREX_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_strex_t1_a_field_imm8_32_poweroftwo_0_e8400020() {
    // Thumb encoding (32): 0xE8400020
    // Test aarch32_STREX_T1_A field imm8 = 32 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=32, Rt=0, Rn=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8400020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREX_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_strex_t1_a_field_imm8_63_poweroftwominusone_0_e840003f() {
    // Thumb encoding (32): 0xE840003F
    // Test aarch32_STREX_T1_A field imm8 = 63 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, Rd=0, imm8=63, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE840003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREX_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_strex_t1_a_field_imm8_64_poweroftwo_0_e8400040() {
    // Thumb encoding (32): 0xE8400040
    // Test aarch32_STREX_T1_A field imm8 = 64 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, imm8=64, Rd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8400040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREX_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 127, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (127)
#[test]
fn test_aarch32_strex_t1_a_field_imm8_127_poweroftwominusone_0_e840007f() {
    // Thumb encoding (32): 0xE840007F
    // Test aarch32_STREX_T1_A field imm8 = 127 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm8=127, Rn=0, Rd=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE840007F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREX_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_strex_t1_a_field_imm8_128_poweroftwo_0_e8400080() {
    // Thumb encoding (32): 0xE8400080
    // Test aarch32_STREX_T1_A field imm8 = 128 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=128, Rt=0, Rd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8400080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREX_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 255, boundary: Max }
/// maximum immediate (255)
#[test]
fn test_aarch32_strex_t1_a_field_imm8_255_max_0_e84000ff() {
    // Thumb encoding (32): 0xE84000FF
    // Test aarch32_STREX_T1_A field imm8 = 255 (Max)
    // ISET: T32
    // Fields: Rn=0, Rt=0, Rd=0, imm8=255
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE84000FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREX_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_strex_t1_a_combo_0_0_e8400000() {
    // Thumb encoding (32): 0xE8400000
    // Test aarch32_STREX_T1_A field combination: Rn=0, Rt=0, Rd=0, imm8=0
    // ISET: T32
    // Fields: Rn=0, Rd=0, Rt=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREX_T1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_strex_t1_a_combo_1_0_e8410000() {
    // Thumb encoding (32): 0xE8410000
    // Test aarch32_STREX_T1_A field combination: Rn=1, Rt=0, Rd=0, imm8=0
    // ISET: T32
    // Fields: Rd=0, Rt=0, imm8=0, Rn=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8410000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREX_T1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=0 (register index 0 (first register))
#[test]
fn test_aarch32_strex_t1_a_combo_2_0_e8400000() {
    // Thumb encoding (32): 0xE8400000
    // Test aarch32_STREX_T1_A field combination: Rn=0, Rt=0, Rd=0, imm8=0
    // ISET: T32
    // Fields: Rn=0, Rd=0, Rt=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREX_T1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=1 (register index 1 (second register))
#[test]
fn test_aarch32_strex_t1_a_combo_3_0_e8401000() {
    // Thumb encoding (32): 0xE8401000
    // Test aarch32_STREX_T1_A field combination: Rn=0, Rt=1, Rd=0, imm8=0
    // ISET: T32
    // Fields: Rn=0, Rt=1, Rd=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8401000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREX_T1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch32_strex_t1_a_combo_4_0_e8400000() {
    // Thumb encoding (32): 0xE8400000
    // Test aarch32_STREX_T1_A field combination: Rn=0, Rt=0, Rd=0, imm8=0
    // ISET: T32
    // Fields: Rd=0, Rn=0, imm8=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREX_T1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch32_strex_t1_a_combo_5_0_e8400100() {
    // Thumb encoding (32): 0xE8400100
    // Test aarch32_STREX_T1_A field combination: Rn=0, Rt=0, Rd=1, imm8=0
    // ISET: T32
    // Fields: Rd=1, Rn=0, Rt=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8400100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREX_T1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=0 (immediate value 0)
#[test]
fn test_aarch32_strex_t1_a_combo_6_0_e8400000() {
    // Thumb encoding (32): 0xE8400000
    // Test aarch32_STREX_T1_A field combination: Rn=0, Rt=0, Rd=0, imm8=0
    // ISET: T32
    // Fields: Rd=0, imm8=0, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREX_T1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=1 (immediate value 1)
#[test]
fn test_aarch32_strex_t1_a_combo_7_0_e8400001() {
    // Thumb encoding (32): 0xE8400001
    // Test aarch32_STREX_T1_A field combination: Rn=0, Rt=0, Rd=0, imm8=1
    // ISET: T32
    // Fields: Rt=0, Rn=0, imm8=1, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8400001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREX_T1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=3 (2^2 - 1 = 3)
#[test]
fn test_aarch32_strex_t1_a_combo_8_0_e8400003() {
    // Thumb encoding (32): 0xE8400003
    // Test aarch32_STREX_T1_A field combination: Rn=0, Rt=0, Rd=0, imm8=3
    // ISET: T32
    // Fields: Rn=0, Rt=0, Rd=0, imm8=3
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8400003;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREX_T1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=4 (power of 2 (2^2 = 4))
#[test]
fn test_aarch32_strex_t1_a_combo_9_0_e8400004() {
    // Thumb encoding (32): 0xE8400004
    // Test aarch32_STREX_T1_A field combination: Rn=0, Rt=0, Rd=0, imm8=4
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm8=4, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8400004;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREX_T1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=7 (2^3 - 1 = 7)
#[test]
fn test_aarch32_strex_t1_a_combo_10_0_e8400007() {
    // Thumb encoding (32): 0xE8400007
    // Test aarch32_STREX_T1_A field combination: Rn=0, Rt=0, Rd=0, imm8=7
    // ISET: T32
    // Fields: Rd=0, Rn=0, imm8=7, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8400007;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREX_T1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=8 (power of 2 (2^3 = 8))
#[test]
fn test_aarch32_strex_t1_a_combo_11_0_e8400008() {
    // Thumb encoding (32): 0xE8400008
    // Test aarch32_STREX_T1_A field combination: Rn=0, Rt=0, Rd=0, imm8=8
    // ISET: T32
    // Fields: Rd=0, Rn=0, Rt=0, imm8=8
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8400008;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREX_T1_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=15 (2^4 - 1 = 15)
#[test]
fn test_aarch32_strex_t1_a_combo_12_0_e840000f() {
    // Thumb encoding (32): 0xE840000F
    // Test aarch32_STREX_T1_A field combination: Rn=0, Rt=0, Rd=0, imm8=15
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm8=15, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE840000F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREX_T1_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=16 (power of 2 (2^4 = 16))
#[test]
fn test_aarch32_strex_t1_a_combo_13_0_e8400010() {
    // Thumb encoding (32): 0xE8400010
    // Test aarch32_STREX_T1_A field combination: Rn=0, Rt=0, Rd=0, imm8=16
    // ISET: T32
    // Fields: Rt=0, Rd=0, Rn=0, imm8=16
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8400010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREX_T1_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=31 (2^5 - 1 = 31)
#[test]
fn test_aarch32_strex_t1_a_combo_14_0_e840001f() {
    // Thumb encoding (32): 0xE840001F
    // Test aarch32_STREX_T1_A field combination: Rn=0, Rt=0, Rd=0, imm8=31
    // ISET: T32
    // Fields: Rn=0, imm8=31, Rd=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE840001F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREX_T1_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=32 (power of 2 (2^5 = 32))
#[test]
fn test_aarch32_strex_t1_a_combo_15_0_e8400020() {
    // Thumb encoding (32): 0xE8400020
    // Test aarch32_STREX_T1_A field combination: Rn=0, Rt=0, Rd=0, imm8=32
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm8=32, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8400020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREX_T1_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=63 (2^6 - 1 = 63)
#[test]
fn test_aarch32_strex_t1_a_combo_16_0_e840003f() {
    // Thumb encoding (32): 0xE840003F
    // Test aarch32_STREX_T1_A field combination: Rn=0, Rt=0, Rd=0, imm8=63
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm8=63, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE840003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREX_T1_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=64 (power of 2 (2^6 = 64))
#[test]
fn test_aarch32_strex_t1_a_combo_17_0_e8400040() {
    // Thumb encoding (32): 0xE8400040
    // Test aarch32_STREX_T1_A field combination: Rn=0, Rt=0, Rd=0, imm8=64
    // ISET: T32
    // Fields: Rn=0, imm8=64, Rd=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8400040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREX_T1_A
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=127 (immediate midpoint (127))
#[test]
fn test_aarch32_strex_t1_a_combo_18_0_e840007f() {
    // Thumb encoding (32): 0xE840007F
    // Test aarch32_STREX_T1_A field combination: Rn=0, Rt=0, Rd=0, imm8=127
    // ISET: T32
    // Fields: Rt=0, Rd=0, imm8=127, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE840007F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREX_T1_A
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=128 (power of 2 (2^7 = 128))
#[test]
fn test_aarch32_strex_t1_a_combo_19_0_e8400080() {
    // Thumb encoding (32): 0xE8400080
    // Test aarch32_STREX_T1_A field combination: Rn=0, Rt=0, Rd=0, imm8=128
    // ISET: T32
    // Fields: Rn=0, imm8=128, Rt=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8400080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREX_T1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strex_t1_a_invalid_0_0_e8400000() {
    // Thumb encoding (32): 0xE8400000
    // Test aarch32_STREX_T1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }
    // ISET: T32
    // Fields: Rd=0, imm8=0, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8400000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_STREX_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strex_t1_a_invalid_1_0_e8400000() {
    // Thumb encoding (32): 0xE8400000
    // Test aarch32_STREX_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rn=0, Rt=0, Rd=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8400000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_STREX_T1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strex_t1_a_invalid_2_0_e8400000() {
    // Thumb encoding (32): 0xE8400000
    // Test aarch32_STREX_T1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) }
    // ISET: T32
    // Fields: imm8=0, Rn=0, Rt=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8400000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_STREX_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strex_t1_a_invalid_3_0_e8400000() {
    // Thumb encoding (32): 0xE8400000
    // Test aarch32_STREX_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rn=0, Rd=0, Rt=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8400000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_STREX_A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_strex_a1_a_store_0_01810390() {
    // Test aarch32_STREX_A1_A memory store: 8 bytes
    // Encoding: 0x01810390
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x01810390;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_STREX_T1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_strex_t1_a_store_0_e8410000() {
    // Test aarch32_STREX_T1_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xE8410000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// aarch32_STR_i_A Tests
// ============================================================================

/// Provenance: aarch32_STR_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_str_i_a1_a_field_cond_0_min_0_04000000() {
    // Encoding: 0x04000000
    // Test aarch32_STR_i_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: cond=0, imm12=0, W=0, U=0, Rt=0, Rn=0, P=0
    let encoding: u32 = 0x04000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_str_i_a1_a_field_cond_1_poweroftwo_0_14000000() {
    // Encoding: 0x14000000
    // Test aarch32_STR_i_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=1, P=0, Rn=0, Rt=0, W=0, imm12=0, U=0
    let encoding: u32 = 0x14000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_str_i_a1_a_field_cond_2_poweroftwo_0_24000000() {
    // Encoding: 0x24000000
    // Test aarch32_STR_i_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=2, U=0, W=0, Rt=0, P=0, imm12=0, Rn=0
    let encoding: u32 = 0x24000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_str_i_a1_a_field_cond_3_poweroftwo_0_34000000() {
    // Encoding: 0x34000000
    // Test aarch32_STR_i_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, imm12=0, W=0, Rt=0, U=0, Rn=0, cond=3
    let encoding: u32 = 0x34000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_str_i_a1_a_field_cond_4_poweroftwo_0_44000000() {
    // Encoding: 0x44000000
    // Test aarch32_STR_i_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=0, cond=4, Rt=0, U=0, W=0, Rn=0, P=0
    let encoding: u32 = 0x44000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_str_i_a1_a_field_cond_5_poweroftwo_0_54000000() {
    // Encoding: 0x54000000
    // Test aarch32_STR_i_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, P=0, cond=5, Rt=0, U=0, imm12=0, W=0
    let encoding: u32 = 0x54000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_str_i_a1_a_field_cond_6_poweroftwo_0_64000000() {
    // Encoding: 0x64000000
    // Test aarch32_STR_i_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, cond=6, W=0, imm12=0, Rt=0, Rn=0, U=0
    let encoding: u32 = 0x64000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_str_i_a1_a_field_cond_7_poweroftwo_0_74000000() {
    // Encoding: 0x74000000
    // Test aarch32_STR_i_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, Rn=0, imm12=0, cond=7, W=0, P=0, Rt=0
    let encoding: u32 = 0x74000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_str_i_a1_a_field_cond_8_poweroftwo_0_84000000() {
    // Encoding: 0x84000000
    // Test aarch32_STR_i_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, cond=8, Rt=0, P=0, imm12=0, W=0, Rn=0
    let encoding: u32 = 0x84000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_str_i_a1_a_field_cond_9_poweroftwo_0_94000000() {
    // Encoding: 0x94000000
    // Test aarch32_STR_i_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, W=0, Rn=0, cond=9, Rt=0, imm12=0, P=0
    let encoding: u32 = 0x94000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_str_i_a1_a_field_cond_10_poweroftwo_0_a4000000() {
    // Encoding: 0xA4000000
    // Test aarch32_STR_i_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, imm12=0, W=0, Rt=0, cond=10, P=0, U=0
    let encoding: u32 = 0xA4000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_str_i_a1_a_field_cond_11_poweroftwo_0_b4000000() {
    // Encoding: 0xB4000000
    // Test aarch32_STR_i_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, P=0, W=0, cond=11, imm12=0, Rn=0, U=0
    let encoding: u32 = 0xB4000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_str_i_a1_a_field_cond_12_poweroftwo_0_c4000000() {
    // Encoding: 0xC4000000
    // Test aarch32_STR_i_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, Rt=0, cond=12, P=0, imm12=0, U=0, Rn=0
    let encoding: u32 = 0xC4000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_str_i_a1_a_field_cond_13_poweroftwo_0_d4000000() {
    // Encoding: 0xD4000000
    // Test aarch32_STR_i_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=13, W=0, U=0, imm12=0, Rn=0, Rt=0, P=0
    let encoding: u32 = 0xD4000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_str_i_a1_a_field_cond_14_poweroftwo_0_e4000000() {
    // Encoding: 0xE4000000
    // Test aarch32_STR_i_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=14, W=0, Rn=0, Rt=0, P=0, imm12=0, U=0
    let encoding: u32 = 0xE4000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_str_i_a1_a_field_cond_15_max_0_f4000000() {
    // Encoding: 0xF4000000
    // Test aarch32_STR_i_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: W=0, Rn=0, cond=15, P=0, Rt=0, U=0, imm12=0
    let encoding: u32 = 0xF4000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_i_A1_A
/// ASL: `field P 24 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_str_i_a1_a_field_p_0_min_0_04000000() {
    // Encoding: 0x04000000
    // Test aarch32_STR_i_A1_A field P = 0 (Min)
    // ISET: A32
    // Fields: W=0, Rn=0, imm12=0, Rt=0, P=0, cond=0, U=0
    let encoding: u32 = 0x04000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_i_A1_A
/// ASL: `field P 24 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_str_i_a1_a_field_p_1_max_0_05000000() {
    // Encoding: 0x05000000
    // Test aarch32_STR_i_A1_A field P = 1 (Max)
    // ISET: A32
    // Fields: Rn=0, P=1, U=0, Rt=0, W=0, imm12=0, cond=0
    let encoding: u32 = 0x05000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_i_A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_str_i_a1_a_field_u_0_min_0_04000000() {
    // Encoding: 0x04000000
    // Test aarch32_STR_i_A1_A field U = 0 (Min)
    // ISET: A32
    // Fields: P=0, cond=0, Rn=0, Rt=0, U=0, W=0, imm12=0
    let encoding: u32 = 0x04000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_i_A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_str_i_a1_a_field_u_1_max_0_04800000() {
    // Encoding: 0x04800000
    // Test aarch32_STR_i_A1_A field U = 1 (Max)
    // ISET: A32
    // Fields: P=0, Rt=0, U=1, imm12=0, Rn=0, W=0, cond=0
    let encoding: u32 = 0x04800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_i_A1_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_str_i_a1_a_field_w_0_min_0_04000000() {
    // Encoding: 0x04000000
    // Test aarch32_STR_i_A1_A field W = 0 (Min)
    // ISET: A32
    // Fields: Rt=0, W=0, imm12=0, U=0, cond=0, P=0, Rn=0
    let encoding: u32 = 0x04000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_i_A1_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_str_i_a1_a_field_w_1_max_0_04200000() {
    // Encoding: 0x04200000
    // Test aarch32_STR_i_A1_A field W = 1 (Max)
    // ISET: A32
    // Fields: U=0, imm12=0, P=0, Rn=0, W=1, Rt=0, cond=0
    let encoding: u32 = 0x04200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_i_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_str_i_a1_a_field_rn_0_min_0_04000000() {
    // Encoding: 0x04000000
    // Test aarch32_STR_i_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: W=0, cond=0, U=0, Rn=0, imm12=0, P=0, Rt=0
    let encoding: u32 = 0x04000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_i_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_str_i_a1_a_field_rn_1_poweroftwo_0_04010000() {
    // Encoding: 0x04010000
    // Test aarch32_STR_i_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, W=0, Rn=1, Rt=0, imm12=0, cond=0, P=0
    let encoding: u32 = 0x04010000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_i_A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_str_i_a1_a_field_rt_0_min_0_04000000() {
    // Encoding: 0x04000000
    // Test aarch32_STR_i_A1_A field Rt = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rn=0, U=0, W=0, P=0, Rt=0, imm12=0
    let encoding: u32 = 0x04000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_i_A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_str_i_a1_a_field_rt_1_poweroftwo_0_04001000() {
    // Encoding: 0x04001000
    // Test aarch32_STR_i_A1_A field Rt = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, U=0, Rn=0, Rt=1, cond=0, imm12=0, P=0
    let encoding: u32 = 0x04001000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_str_i_a1_a_field_imm12_0_zero_0_04000000() {
    // Encoding: 0x04000000
    // Test aarch32_STR_i_A1_A field imm12 = 0 (Zero)
    // ISET: A32
    // Fields: P=0, Rn=0, W=0, Rt=0, U=0, imm12=0, cond=0
    let encoding: u32 = 0x04000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_str_i_a1_a_field_imm12_1_poweroftwo_0_04000001() {
    // Encoding: 0x04000001
    // Test aarch32_STR_i_A1_A field imm12 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, imm12=1, U=0, cond=0, P=0, W=0, Rn=0
    let encoding: u32 = 0x04000001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_str_i_a1_a_field_imm12_3_poweroftwominusone_0_04000003() {
    // Encoding: 0x04000003
    // Test aarch32_STR_i_A1_A field imm12 = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: U=0, imm12=3, W=0, cond=0, P=0, Rn=0, Rt=0
    let encoding: u32 = 0x04000003;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_str_i_a1_a_field_imm12_4_poweroftwo_0_04000004() {
    // Encoding: 0x04000004
    // Test aarch32_STR_i_A1_A field imm12 = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, P=0, U=0, W=0, Rt=0, imm12=4, cond=0
    let encoding: u32 = 0x04000004;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_str_i_a1_a_field_imm12_7_poweroftwominusone_0_04000007() {
    // Encoding: 0x04000007
    // Test aarch32_STR_i_A1_A field imm12 = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rn=0, imm12=7, cond=0, W=0, P=0, Rt=0, U=0
    let encoding: u32 = 0x04000007;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_str_i_a1_a_field_imm12_8_poweroftwo_0_04000008() {
    // Encoding: 0x04000008
    // Test aarch32_STR_i_A1_A field imm12 = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, imm12=8, W=0, Rn=0, Rt=0, U=0, cond=0
    let encoding: u32 = 0x04000008;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_str_i_a1_a_field_imm12_15_poweroftwominusone_0_0400000f() {
    // Encoding: 0x0400000F
    // Test aarch32_STR_i_A1_A field imm12 = 15 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm12=15, cond=0, P=0, Rn=0, W=0, Rt=0, U=0
    let encoding: u32 = 0x0400000F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_str_i_a1_a_field_imm12_16_poweroftwo_0_04000010() {
    // Encoding: 0x04000010
    // Test aarch32_STR_i_A1_A field imm12 = 16 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, U=0, Rn=0, W=0, cond=0, Rt=0, imm12=16
    let encoding: u32 = 0x04000010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_str_i_a1_a_field_imm12_31_poweroftwominusone_0_0400001f() {
    // Encoding: 0x0400001F
    // Test aarch32_STR_i_A1_A field imm12 = 31 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm12=31, Rn=0, cond=0, U=0, P=0, W=0, Rt=0
    let encoding: u32 = 0x0400001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_str_i_a1_a_field_imm12_32_poweroftwo_0_04000020() {
    // Encoding: 0x04000020
    // Test aarch32_STR_i_A1_A field imm12 = 32 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, U=0, imm12=32, cond=0, P=0, W=0, Rt=0
    let encoding: u32 = 0x04000020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_str_i_a1_a_field_imm12_63_poweroftwominusone_0_0400003f() {
    // Encoding: 0x0400003F
    // Test aarch32_STR_i_A1_A field imm12 = 63 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rn=0, cond=0, P=0, W=0, U=0, Rt=0, imm12=63
    let encoding: u32 = 0x0400003F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_str_i_a1_a_field_imm12_64_poweroftwo_0_04000040() {
    // Encoding: 0x04000040
    // Test aarch32_STR_i_A1_A field imm12 = 64 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, cond=0, Rn=0, imm12=64, P=0, U=0, W=0
    let encoding: u32 = 0x04000040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 127, boundary: PowerOfTwoMinusOne }
/// 2^7 - 1 = 127
#[test]
fn test_aarch32_str_i_a1_a_field_imm12_127_poweroftwominusone_0_0400007f() {
    // Encoding: 0x0400007F
    // Test aarch32_STR_i_A1_A field imm12 = 127 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rn=0, cond=0, Rt=0, imm12=127, P=0, U=0, W=0
    let encoding: u32 = 0x0400007F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_str_i_a1_a_field_imm12_128_poweroftwo_0_04000080() {
    // Encoding: 0x04000080
    // Test aarch32_STR_i_A1_A field imm12 = 128 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, W=0, P=0, Rt=0, Rn=0, imm12=128, U=0
    let encoding: u32 = 0x04000080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 255, boundary: PowerOfTwoMinusOne }
/// 2^8 - 1 = 255
#[test]
fn test_aarch32_str_i_a1_a_field_imm12_255_poweroftwominusone_0_040000ff() {
    // Encoding: 0x040000FF
    // Test aarch32_STR_i_A1_A field imm12 = 255 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rn=0, imm12=255, W=0, cond=0, Rt=0, U=0, P=0
    let encoding: u32 = 0x040000FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 256, boundary: PowerOfTwo }
/// power of 2 (2^8 = 256)
#[test]
fn test_aarch32_str_i_a1_a_field_imm12_256_poweroftwo_0_04000100() {
    // Encoding: 0x04000100
    // Test aarch32_STR_i_A1_A field imm12 = 256 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, Rn=0, Rt=0, imm12=256, cond=0, P=0, U=0
    let encoding: u32 = 0x04000100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 511, boundary: PowerOfTwoMinusOne }
/// 2^9 - 1 = 511
#[test]
fn test_aarch32_str_i_a1_a_field_imm12_511_poweroftwominusone_0_040001ff() {
    // Encoding: 0x040001FF
    // Test aarch32_STR_i_A1_A field imm12 = 511 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm12=511, Rn=0, W=0, U=0, cond=0, Rt=0, P=0
    let encoding: u32 = 0x040001FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 512, boundary: PowerOfTwo }
/// power of 2 (2^9 = 512)
#[test]
fn test_aarch32_str_i_a1_a_field_imm12_512_poweroftwo_0_04000200() {
    // Encoding: 0x04000200
    // Test aarch32_STR_i_A1_A field imm12 = 512 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, Rn=0, Rt=0, P=0, imm12=512, U=0, cond=0
    let encoding: u32 = 0x04000200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1023, boundary: PowerOfTwoMinusOne }
/// 2^10 - 1 = 1023
#[test]
fn test_aarch32_str_i_a1_a_field_imm12_1023_poweroftwominusone_0_040003ff() {
    // Encoding: 0x040003FF
    // Test aarch32_STR_i_A1_A field imm12 = 1023 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, W=0, P=0, U=0, Rt=0, imm12=1023, Rn=0
    let encoding: u32 = 0x040003FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1024, boundary: PowerOfTwo }
/// power of 2 (2^10 = 1024)
#[test]
fn test_aarch32_str_i_a1_a_field_imm12_1024_poweroftwo_0_04000400() {
    // Encoding: 0x04000400
    // Test aarch32_STR_i_A1_A field imm12 = 1024 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, cond=0, Rn=0, P=0, Rt=0, imm12=1024, U=0
    let encoding: u32 = 0x04000400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2047, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (2047)
#[test]
fn test_aarch32_str_i_a1_a_field_imm12_2047_poweroftwominusone_0_040007ff() {
    // Encoding: 0x040007FF
    // Test aarch32_STR_i_A1_A field imm12 = 2047 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rn=0, imm12=2047, cond=0, Rt=0, P=0, U=0, W=0
    let encoding: u32 = 0x040007FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2048, boundary: PowerOfTwo }
/// power of 2 (2^11 = 2048)
#[test]
fn test_aarch32_str_i_a1_a_field_imm12_2048_poweroftwo_0_04000800() {
    // Encoding: 0x04000800
    // Test aarch32_STR_i_A1_A field imm12 = 2048 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, Rt=0, Rn=0, imm12=2048, P=0, cond=0, U=0
    let encoding: u32 = 0x04000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4095, boundary: Max }
/// maximum immediate (4095)
#[test]
fn test_aarch32_str_i_a1_a_field_imm12_4095_max_0_04000fff() {
    // Encoding: 0x04000FFF
    // Test aarch32_STR_i_A1_A field imm12 = 4095 (Max)
    // ISET: A32
    // Fields: Rt=0, W=0, imm12=4095, cond=0, P=0, U=0, Rn=0
    let encoding: u32 = 0x04000FFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_i_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_str_i_a1_a_combo_0_0_04000000() {
    // Encoding: 0x04000000
    // Test aarch32_STR_i_A1_A field combination: cond=0, P=0, U=0, W=0, Rn=0, Rt=0, imm12=0
    // ISET: A32
    // Fields: Rn=0, P=0, U=0, Rt=0, imm12=0, W=0, cond=0
    let encoding: u32 = 0x04000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_i_A1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=1 (condition NE (not equal))
#[test]
fn test_aarch32_str_i_a1_a_combo_1_0_14000000() {
    // Encoding: 0x14000000
    // Test aarch32_STR_i_A1_A field combination: cond=1, P=0, U=0, W=0, Rn=0, Rt=0, imm12=0
    // ISET: A32
    // Fields: Rt=0, W=0, imm12=0, P=0, cond=1, Rn=0, U=0
    let encoding: u32 = 0x14000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_i_A1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=2 (condition CS/HS (carry set))
#[test]
fn test_aarch32_str_i_a1_a_combo_2_0_24000000() {
    // Encoding: 0x24000000
    // Test aarch32_STR_i_A1_A field combination: cond=2, P=0, U=0, W=0, Rn=0, Rt=0, imm12=0
    // ISET: A32
    // Fields: P=0, U=0, cond=2, Rn=0, W=0, imm12=0, Rt=0
    let encoding: u32 = 0x24000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_i_A1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=3 (condition CC/LO (carry clear))
#[test]
fn test_aarch32_str_i_a1_a_combo_3_0_34000000() {
    // Encoding: 0x34000000
    // Test aarch32_STR_i_A1_A field combination: cond=3, P=0, U=0, W=0, Rn=0, Rt=0, imm12=0
    // ISET: A32
    // Fields: W=0, P=0, Rn=0, Rt=0, imm12=0, cond=3, U=0
    let encoding: u32 = 0x34000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_i_A1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=4 (condition MI (minus/negative))
#[test]
fn test_aarch32_str_i_a1_a_combo_4_0_44000000() {
    // Encoding: 0x44000000
    // Test aarch32_STR_i_A1_A field combination: cond=4, P=0, U=0, W=0, Rn=0, Rt=0, imm12=0
    // ISET: A32
    // Fields: cond=4, Rt=0, imm12=0, Rn=0, P=0, W=0, U=0
    let encoding: u32 = 0x44000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_i_A1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=5 (condition PL (plus/positive))
#[test]
fn test_aarch32_str_i_a1_a_combo_5_0_54000000() {
    // Encoding: 0x54000000
    // Test aarch32_STR_i_A1_A field combination: cond=5, P=0, U=0, W=0, Rn=0, Rt=0, imm12=0
    // ISET: A32
    // Fields: W=0, Rn=0, Rt=0, imm12=0, P=0, cond=5, U=0
    let encoding: u32 = 0x54000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_i_A1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=6 (condition VS (overflow set))
#[test]
fn test_aarch32_str_i_a1_a_combo_6_0_64000000() {
    // Encoding: 0x64000000
    // Test aarch32_STR_i_A1_A field combination: cond=6, P=0, U=0, W=0, Rn=0, Rt=0, imm12=0
    // ISET: A32
    // Fields: Rn=0, imm12=0, Rt=0, cond=6, W=0, P=0, U=0
    let encoding: u32 = 0x64000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_i_A1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=7 (condition VC (overflow clear))
#[test]
fn test_aarch32_str_i_a1_a_combo_7_0_74000000() {
    // Encoding: 0x74000000
    // Test aarch32_STR_i_A1_A field combination: cond=7, P=0, U=0, W=0, Rn=0, Rt=0, imm12=0
    // ISET: A32
    // Fields: W=0, Rn=0, Rt=0, cond=7, P=0, U=0, imm12=0
    let encoding: u32 = 0x74000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_i_A1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=8 (condition HI (unsigned higher))
#[test]
fn test_aarch32_str_i_a1_a_combo_8_0_84000000() {
    // Encoding: 0x84000000
    // Test aarch32_STR_i_A1_A field combination: cond=8, P=0, U=0, W=0, Rn=0, Rt=0, imm12=0
    // ISET: A32
    // Fields: cond=8, imm12=0, U=0, Rt=0, Rn=0, W=0, P=0
    let encoding: u32 = 0x84000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_i_A1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=9 (condition LS (unsigned lower or same))
#[test]
fn test_aarch32_str_i_a1_a_combo_9_0_94000000() {
    // Encoding: 0x94000000
    // Test aarch32_STR_i_A1_A field combination: cond=9, P=0, U=0, W=0, Rn=0, Rt=0, imm12=0
    // ISET: A32
    // Fields: cond=9, P=0, U=0, W=0, Rt=0, imm12=0, Rn=0
    let encoding: u32 = 0x94000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_i_A1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=10 (condition GE (signed >=))
#[test]
fn test_aarch32_str_i_a1_a_combo_10_0_a4000000() {
    // Encoding: 0xA4000000
    // Test aarch32_STR_i_A1_A field combination: cond=10, P=0, U=0, W=0, Rn=0, Rt=0, imm12=0
    // ISET: A32
    // Fields: cond=10, P=0, imm12=0, Rn=0, Rt=0, W=0, U=0
    let encoding: u32 = 0xA4000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_i_A1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=11 (condition LT (signed <))
#[test]
fn test_aarch32_str_i_a1_a_combo_11_0_b4000000() {
    // Encoding: 0xB4000000
    // Test aarch32_STR_i_A1_A field combination: cond=11, P=0, U=0, W=0, Rn=0, Rt=0, imm12=0
    // ISET: A32
    // Fields: imm12=0, cond=11, P=0, W=0, Rn=0, Rt=0, U=0
    let encoding: u32 = 0xB4000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_i_A1_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=12 (condition GT (signed >))
#[test]
fn test_aarch32_str_i_a1_a_combo_12_0_c4000000() {
    // Encoding: 0xC4000000
    // Test aarch32_STR_i_A1_A field combination: cond=12, P=0, U=0, W=0, Rn=0, Rt=0, imm12=0
    // ISET: A32
    // Fields: W=0, Rt=0, Rn=0, cond=12, U=0, imm12=0, P=0
    let encoding: u32 = 0xC4000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_i_A1_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=13 (condition LE (signed <=))
#[test]
fn test_aarch32_str_i_a1_a_combo_13_0_d4000000() {
    // Encoding: 0xD4000000
    // Test aarch32_STR_i_A1_A field combination: cond=13, P=0, U=0, W=0, Rn=0, Rt=0, imm12=0
    // ISET: A32
    // Fields: imm12=0, W=0, Rn=0, Rt=0, P=0, U=0, cond=13
    let encoding: u32 = 0xD4000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_i_A1_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=14 (condition AL (always))
#[test]
fn test_aarch32_str_i_a1_a_combo_14_0_e4000000() {
    // Encoding: 0xE4000000
    // Test aarch32_STR_i_A1_A field combination: cond=14, P=0, U=0, W=0, Rn=0, Rt=0, imm12=0
    // ISET: A32
    // Fields: P=0, Rt=0, Rn=0, imm12=0, W=0, cond=14, U=0
    let encoding: u32 = 0xE4000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_i_A1_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=15 (condition NV (never, reserved))
#[test]
fn test_aarch32_str_i_a1_a_combo_15_0_f4000000() {
    // Encoding: 0xF4000000
    // Test aarch32_STR_i_A1_A field combination: cond=15, P=0, U=0, W=0, Rn=0, Rt=0, imm12=0
    // ISET: A32
    // Fields: P=0, Rn=0, cond=15, W=0, U=0, imm12=0, Rt=0
    let encoding: u32 = 0xF4000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_i_A1_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// P=0 (minimum value)
#[test]
fn test_aarch32_str_i_a1_a_combo_16_0_04000000() {
    // Encoding: 0x04000000
    // Test aarch32_STR_i_A1_A field combination: cond=0, P=0, U=0, W=0, Rn=0, Rt=0, imm12=0
    // ISET: A32
    // Fields: Rt=0, imm12=0, Rn=0, W=0, P=0, cond=0, U=0
    let encoding: u32 = 0x04000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_i_A1_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// P=1 (maximum value (1))
#[test]
fn test_aarch32_str_i_a1_a_combo_17_0_05000000() {
    // Encoding: 0x05000000
    // Test aarch32_STR_i_A1_A field combination: cond=0, P=1, U=0, W=0, Rn=0, Rt=0, imm12=0
    // ISET: A32
    // Fields: Rt=0, imm12=0, P=1, W=0, cond=0, U=0, Rn=0
    let encoding: u32 = 0x05000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_i_A1_A
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=0 (minimum value)
#[test]
fn test_aarch32_str_i_a1_a_combo_18_0_04000000() {
    // Encoding: 0x04000000
    // Test aarch32_STR_i_A1_A field combination: cond=0, P=0, U=0, W=0, Rn=0, Rt=0, imm12=0
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=0, P=0, imm12=0, U=0, W=0
    let encoding: u32 = 0x04000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_i_A1_A
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=1 (maximum value (1))
#[test]
fn test_aarch32_str_i_a1_a_combo_19_0_04800000() {
    // Encoding: 0x04800000
    // Test aarch32_STR_i_A1_A field combination: cond=0, P=0, U=1, W=0, Rn=0, Rt=0, imm12=0
    // ISET: A32
    // Fields: imm12=0, U=1, cond=0, W=0, Rn=0, Rt=0, P=0
    let encoding: u32 = 0x04800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_i_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_str_i_a1_a_special_cond_0_condition_eq_0_04000000() {
    // Encoding: 0x04000000
    // Test aarch32_STR_i_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: U=0, Rn=0, Rt=0, P=0, cond=0, W=0, imm12=0
    let encoding: u32 = 0x04000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_i_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_str_i_a1_a_special_cond_1_condition_ne_0_14000000() {
    // Encoding: 0x14000000
    // Test aarch32_STR_i_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: Rn=0, W=0, Rt=0, P=0, U=0, cond=1, imm12=0
    let encoding: u32 = 0x14000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_i_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_str_i_a1_a_special_cond_2_condition_cs_hs_0_24000000() {
    // Encoding: 0x24000000
    // Test aarch32_STR_i_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: imm12=0, cond=2, W=0, P=0, Rn=0, Rt=0, U=0
    let encoding: u32 = 0x24000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_i_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_str_i_a1_a_special_cond_3_condition_cc_lo_0_34000000() {
    // Encoding: 0x34000000
    // Test aarch32_STR_i_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: cond=3, P=0, U=0, Rt=0, W=0, Rn=0, imm12=0
    let encoding: u32 = 0x34000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_i_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_str_i_a1_a_special_cond_4_condition_mi_0_44000000() {
    // Encoding: 0x44000000
    // Test aarch32_STR_i_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: imm12=0, cond=4, U=0, P=0, Rn=0, W=0, Rt=0
    let encoding: u32 = 0x44000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_i_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_str_i_a1_a_special_cond_5_condition_pl_0_54000000() {
    // Encoding: 0x54000000
    // Test aarch32_STR_i_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: Rt=0, W=0, U=0, imm12=0, cond=5, P=0, Rn=0
    let encoding: u32 = 0x54000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_i_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_str_i_a1_a_special_cond_6_condition_vs_0_64000000() {
    // Encoding: 0x64000000
    // Test aarch32_STR_i_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: W=0, cond=6, Rt=0, imm12=0, P=0, U=0, Rn=0
    let encoding: u32 = 0x64000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_i_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_str_i_a1_a_special_cond_7_condition_vc_0_74000000() {
    // Encoding: 0x74000000
    // Test aarch32_STR_i_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: U=0, cond=7, Rt=0, P=0, imm12=0, W=0, Rn=0
    let encoding: u32 = 0x74000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_i_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_str_i_a1_a_special_cond_8_condition_hi_0_84000000() {
    // Encoding: 0x84000000
    // Test aarch32_STR_i_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: W=0, imm12=0, P=0, Rn=0, U=0, cond=8, Rt=0
    let encoding: u32 = 0x84000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_i_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_str_i_a1_a_special_cond_9_condition_ls_0_94000000() {
    // Encoding: 0x94000000
    // Test aarch32_STR_i_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: Rt=0, U=0, Rn=0, cond=9, imm12=0, W=0, P=0
    let encoding: u32 = 0x94000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_i_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_str_i_a1_a_special_cond_10_condition_ge_0_a4000000() {
    // Encoding: 0xA4000000
    // Test aarch32_STR_i_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: W=0, Rt=0, imm12=0, U=0, Rn=0, P=0, cond=10
    let encoding: u32 = 0xA4000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_i_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_str_i_a1_a_special_cond_11_condition_lt_0_b4000000() {
    // Encoding: 0xB4000000
    // Test aarch32_STR_i_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: U=0, W=0, Rn=0, imm12=0, Rt=0, cond=11, P=0
    let encoding: u32 = 0xB4000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_i_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_str_i_a1_a_special_cond_12_condition_gt_0_c4000000() {
    // Encoding: 0xC4000000
    // Test aarch32_STR_i_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: P=0, Rn=0, Rt=0, imm12=0, W=0, cond=12, U=0
    let encoding: u32 = 0xC4000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_i_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_str_i_a1_a_special_cond_13_condition_le_0_d4000000() {
    // Encoding: 0xD4000000
    // Test aarch32_STR_i_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: Rt=0, P=0, imm12=0, Rn=0, cond=13, U=0, W=0
    let encoding: u32 = 0xD4000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_i_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_str_i_a1_a_special_cond_14_condition_al_0_e4000000() {
    // Encoding: 0xE4000000
    // Test aarch32_STR_i_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: W=0, Rn=0, P=0, imm12=0, Rt=0, cond=14, U=0
    let encoding: u32 = 0xE4000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_i_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_str_i_a1_a_special_cond_15_condition_nv_0_f4000000() {
    // Encoding: 0xF4000000
    // Test aarch32_STR_i_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: cond=15, U=0, W=0, Rn=0, Rt=0, imm12=0, P=0
    let encoding: u32 = 0xF4000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_i_A1_A
/// ASL: `Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"wback\" }), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }) } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_str_i_a1_a_invalid_0_0_04000000() {
    // Encoding: 0x04000000
    // Test aarch32_STR_i_A1_A invalid encoding: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) } }
    // ISET: A32
    // Fields: imm12=0, U=0, P=0, Rn=0, cond=0, W=0, Rt=0
    let encoding: u32 = 0x04000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STR_i_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_str_i_a1_a_invalid_1_0_04000000() {
    // Encoding: 0x04000000
    // Test aarch32_STR_i_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: imm12=0, U=0, cond=0, W=0, Rn=0, P=0, Rt=0
    let encoding: u32 = 0x04000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STR_i_T1_A
/// ASL: `field imm5 22 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_str_i_t1_a_field_imm5_0_zero_0_60000000() {
    // Thumb encoding (32): 0x60000000
    // Test aarch32_STR_i_T1_A field imm5 = 0 (Zero)
    // ISET: T32
    // Fields: Rn=0, imm5=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x60000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T1_A
/// ASL: `field imm5 22 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_str_i_t1_a_field_imm5_1_poweroftwo_0_60400000() {
    // Thumb encoding (32): 0x60400000
    // Test aarch32_STR_i_T1_A field imm5 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm5=1, Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x60400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T1_A
/// ASL: `field imm5 22 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_str_i_t1_a_field_imm5_3_poweroftwominusone_0_60c00000() {
    // Thumb encoding (32): 0x60C00000
    // Test aarch32_STR_i_T1_A field imm5 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm5=3, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x60C00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T1_A
/// ASL: `field imm5 22 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_str_i_t1_a_field_imm5_4_poweroftwo_0_61000000() {
    // Thumb encoding (32): 0x61000000
    // Test aarch32_STR_i_T1_A field imm5 = 4 (PowerOfTwo)
    // ISET: T32
    // Fields: imm5=4, Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x61000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T1_A
/// ASL: `field imm5 22 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_str_i_t1_a_field_imm5_7_poweroftwominusone_0_61c00000() {
    // Thumb encoding (32): 0x61C00000
    // Test aarch32_STR_i_T1_A field imm5 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm5=7, Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x61C00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T1_A
/// ASL: `field imm5 22 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_str_i_t1_a_field_imm5_8_poweroftwo_0_62000000() {
    // Thumb encoding (32): 0x62000000
    // Test aarch32_STR_i_T1_A field imm5 = 8 (PowerOfTwo)
    // ISET: T32
    // Fields: imm5=8, Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x62000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T1_A
/// ASL: `field imm5 22 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 15, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (15)
#[test]
fn test_aarch32_str_i_t1_a_field_imm5_15_poweroftwominusone_0_63c00000() {
    // Thumb encoding (32): 0x63C00000
    // Test aarch32_STR_i_T1_A field imm5 = 15 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, Rn=0, imm5=15
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x63C00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T1_A
/// ASL: `field imm5 22 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_str_i_t1_a_field_imm5_16_poweroftwo_0_64000000() {
    // Thumb encoding (32): 0x64000000
    // Test aarch32_STR_i_T1_A field imm5 = 16 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, Rn=0, imm5=16
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x64000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T1_A
/// ASL: `field imm5 22 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 31, boundary: Max }
/// maximum immediate (31)
#[test]
fn test_aarch32_str_i_t1_a_field_imm5_31_max_0_67c00000() {
    // Thumb encoding (32): 0x67C00000
    // Test aarch32_STR_i_T1_A field imm5 = 31 (Max)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm5=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x67C00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T1_A
/// ASL: `field Rn 19 +: 3`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_str_i_t1_a_field_rn_0_min_0_60000000() {
    // Thumb encoding (32): 0x60000000
    // Test aarch32_STR_i_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rt=0, Rn=0, imm5=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x60000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T1_A
/// ASL: `field Rn 19 +: 3`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_str_i_t1_a_field_rn_1_poweroftwo_0_60080000() {
    // Thumb encoding (32): 0x60080000
    // Test aarch32_STR_i_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm5=0, Rn=1, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x60080000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T1_A
/// ASL: `field Rt 16 +: 3`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_str_i_t1_a_field_rt_0_min_0_60000000() {
    // Thumb encoding (32): 0x60000000
    // Test aarch32_STR_i_T1_A field Rt = 0 (Min)
    // ISET: T32
    // Fields: Rt=0, Rn=0, imm5=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x60000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T1_A
/// ASL: `field Rt 16 +: 3`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_str_i_t1_a_field_rt_1_poweroftwo_0_60010000() {
    // Thumb encoding (32): 0x60010000
    // Test aarch32_STR_i_T1_A field Rt = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Rt=1, imm5=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x60010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=0 (immediate value 0)
#[test]
fn test_aarch32_str_i_t1_a_combo_0_0_60000000() {
    // Thumb encoding (32): 0x60000000
    // Test aarch32_STR_i_T1_A field combination: imm5=0, Rn=0, Rt=0
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm5=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x60000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=1 (immediate value 1)
#[test]
fn test_aarch32_str_i_t1_a_combo_1_0_60400000() {
    // Thumb encoding (32): 0x60400000
    // Test aarch32_STR_i_T1_A field combination: imm5=1, Rn=0, Rt=0
    // ISET: T32
    // Fields: imm5=1, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x60400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=3 (2^2 - 1 = 3)
#[test]
fn test_aarch32_str_i_t1_a_combo_2_0_60c00000() {
    // Thumb encoding (32): 0x60C00000
    // Test aarch32_STR_i_T1_A field combination: imm5=3, Rn=0, Rt=0
    // ISET: T32
    // Fields: Rn=0, imm5=3, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x60C00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=4 (power of 2 (2^2 = 4))
#[test]
fn test_aarch32_str_i_t1_a_combo_3_0_61000000() {
    // Thumb encoding (32): 0x61000000
    // Test aarch32_STR_i_T1_A field combination: imm5=4, Rn=0, Rt=0
    // ISET: T32
    // Fields: imm5=4, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x61000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=7 (2^3 - 1 = 7)
#[test]
fn test_aarch32_str_i_t1_a_combo_4_0_61c00000() {
    // Thumb encoding (32): 0x61C00000
    // Test aarch32_STR_i_T1_A field combination: imm5=7, Rn=0, Rt=0
    // ISET: T32
    // Fields: Rn=0, imm5=7, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x61C00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=8 (power of 2 (2^3 = 8))
#[test]
fn test_aarch32_str_i_t1_a_combo_5_0_62000000() {
    // Thumb encoding (32): 0x62000000
    // Test aarch32_STR_i_T1_A field combination: imm5=8, Rn=0, Rt=0
    // ISET: T32
    // Fields: imm5=8, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x62000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=15 (immediate midpoint (15))
#[test]
fn test_aarch32_str_i_t1_a_combo_6_0_63c00000() {
    // Thumb encoding (32): 0x63C00000
    // Test aarch32_STR_i_T1_A field combination: imm5=15, Rn=0, Rt=0
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm5=15
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x63C00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=16 (power of 2 (2^4 = 16))
#[test]
fn test_aarch32_str_i_t1_a_combo_7_0_64000000() {
    // Thumb encoding (32): 0x64000000
    // Test aarch32_STR_i_T1_A field combination: imm5=16, Rn=0, Rt=0
    // ISET: T32
    // Fields: imm5=16, Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x64000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=31 (maximum immediate (31))
#[test]
fn test_aarch32_str_i_t1_a_combo_8_0_67c00000() {
    // Thumb encoding (32): 0x67C00000
    // Test aarch32_STR_i_T1_A field combination: imm5=31, Rn=0, Rt=0
    // ISET: T32
    // Fields: Rn=0, imm5=31, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x67C00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_str_i_t1_a_combo_9_0_60000000() {
    // Thumb encoding (32): 0x60000000
    // Test aarch32_STR_i_T1_A field combination: imm5=0, Rn=0, Rt=0
    // ISET: T32
    // Fields: Rn=0, imm5=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x60000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_str_i_t1_a_combo_10_0_60080000() {
    // Thumb encoding (32): 0x60080000
    // Test aarch32_STR_i_T1_A field combination: imm5=0, Rn=1, Rt=0
    // ISET: T32
    // Fields: Rt=0, imm5=0, Rn=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x60080000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=0 (register index 0 (first register))
#[test]
fn test_aarch32_str_i_t1_a_combo_11_0_60000000() {
    // Thumb encoding (32): 0x60000000
    // Test aarch32_STR_i_T1_A field combination: imm5=0, Rn=0, Rt=0
    // ISET: T32
    // Fields: Rt=0, Rn=0, imm5=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x60000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T1_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=1 (register index 1 (second register))
#[test]
fn test_aarch32_str_i_t1_a_combo_12_0_60010000() {
    // Thumb encoding (32): 0x60010000
    // Test aarch32_STR_i_T1_A field combination: imm5=0, Rn=0, Rt=1
    // ISET: T32
    // Fields: Rn=0, Rt=1, imm5=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x60010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T1_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rt=1 (same register test (reg=1))
#[test]
fn test_aarch32_str_i_t1_a_combo_13_0_60090000() {
    // Thumb encoding (32): 0x60090000
    // Test aarch32_STR_i_T1_A field combination: imm5=0, Rn=1, Rt=1
    // ISET: T32
    // Fields: Rt=1, imm5=0, Rn=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x60090000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T1_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rt=31 (same register test (reg=31))
#[test]
fn test_aarch32_str_i_t1_a_combo_14_0_603f0000() {
    // Thumb encoding (32): 0x603F0000
    // Test aarch32_STR_i_T1_A field combination: imm5=0, Rn=31, Rt=31
    // ISET: T32
    // Fields: Rt=31, imm5=0, Rn=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x603F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T2_A
/// ASL: `field Rt 24 +: 3`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_str_i_t2_a_field_rt_0_min_0_90000000() {
    // Thumb encoding (32): 0x90000000
    // Test aarch32_STR_i_T2_A field Rt = 0 (Min)
    // ISET: T32
    // Fields: Rt=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x90000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T2_A
/// ASL: `field Rt 24 +: 3`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_str_i_t2_a_field_rt_1_poweroftwo_0_91000000() {
    // Thumb encoding (32): 0x91000000
    // Test aarch32_STR_i_T2_A field Rt = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=1, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x91000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T2_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_str_i_t2_a_field_imm8_0_zero_0_90000000() {
    // Thumb encoding (32): 0x90000000
    // Test aarch32_STR_i_T2_A field imm8 = 0 (Zero)
    // ISET: T32
    // Fields: Rt=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x90000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T2_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_str_i_t2_a_field_imm8_1_poweroftwo_0_90010000() {
    // Thumb encoding (32): 0x90010000
    // Test aarch32_STR_i_T2_A field imm8 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, imm8=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x90010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T2_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_str_i_t2_a_field_imm8_3_poweroftwominusone_0_90030000() {
    // Thumb encoding (32): 0x90030000
    // Test aarch32_STR_i_T2_A field imm8 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, imm8=3
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x90030000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T2_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_str_i_t2_a_field_imm8_4_poweroftwo_0_90040000() {
    // Thumb encoding (32): 0x90040000
    // Test aarch32_STR_i_T2_A field imm8 = 4 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, imm8=4
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x90040000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T2_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_str_i_t2_a_field_imm8_7_poweroftwominusone_0_90070000() {
    // Thumb encoding (32): 0x90070000
    // Test aarch32_STR_i_T2_A field imm8 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, imm8=7
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x90070000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T2_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_str_i_t2_a_field_imm8_8_poweroftwo_0_90080000() {
    // Thumb encoding (32): 0x90080000
    // Test aarch32_STR_i_T2_A field imm8 = 8 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=8, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x90080000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T2_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_str_i_t2_a_field_imm8_15_poweroftwominusone_0_900f0000() {
    // Thumb encoding (32): 0x900F0000
    // Test aarch32_STR_i_T2_A field imm8 = 15 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm8=15, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x900F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T2_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_str_i_t2_a_field_imm8_16_poweroftwo_0_90100000() {
    // Thumb encoding (32): 0x90100000
    // Test aarch32_STR_i_T2_A field imm8 = 16 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, imm8=16
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x90100000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T2_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_str_i_t2_a_field_imm8_31_poweroftwominusone_0_901f0000() {
    // Thumb encoding (32): 0x901F0000
    // Test aarch32_STR_i_T2_A field imm8 = 31 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm8=31, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x901F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T2_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_str_i_t2_a_field_imm8_32_poweroftwo_0_90200000() {
    // Thumb encoding (32): 0x90200000
    // Test aarch32_STR_i_T2_A field imm8 = 32 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, imm8=32
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x90200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T2_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_str_i_t2_a_field_imm8_63_poweroftwominusone_0_903f0000() {
    // Thumb encoding (32): 0x903F0000
    // Test aarch32_STR_i_T2_A field imm8 = 63 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, imm8=63
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x903F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T2_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_str_i_t2_a_field_imm8_64_poweroftwo_0_90400000() {
    // Thumb encoding (32): 0x90400000
    // Test aarch32_STR_i_T2_A field imm8 = 64 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, imm8=64
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x90400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T2_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 127, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (127)
#[test]
fn test_aarch32_str_i_t2_a_field_imm8_127_poweroftwominusone_0_907f0000() {
    // Thumb encoding (32): 0x907F0000
    // Test aarch32_STR_i_T2_A field imm8 = 127 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, imm8=127
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x907F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T2_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_str_i_t2_a_field_imm8_128_poweroftwo_0_90800000() {
    // Thumb encoding (32): 0x90800000
    // Test aarch32_STR_i_T2_A field imm8 = 128 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, imm8=128
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x90800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T2_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 255, boundary: Max }
/// maximum immediate (255)
#[test]
fn test_aarch32_str_i_t2_a_field_imm8_255_max_0_90ff0000() {
    // Thumb encoding (32): 0x90FF0000
    // Test aarch32_STR_i_T2_A field imm8 = 255 (Max)
    // ISET: T32
    // Fields: imm8=255, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x90FF0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T2_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=0 (register index 0 (first register))
#[test]
fn test_aarch32_str_i_t2_a_combo_0_0_90000000() {
    // Thumb encoding (32): 0x90000000
    // Test aarch32_STR_i_T2_A field combination: Rt=0, imm8=0
    // ISET: T32
    // Fields: Rt=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x90000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T2_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=1 (register index 1 (second register))
#[test]
fn test_aarch32_str_i_t2_a_combo_1_0_91000000() {
    // Thumb encoding (32): 0x91000000
    // Test aarch32_STR_i_T2_A field combination: Rt=1, imm8=0
    // ISET: T32
    // Fields: imm8=0, Rt=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x91000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T2_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=0 (immediate value 0)
#[test]
fn test_aarch32_str_i_t2_a_combo_2_0_90000000() {
    // Thumb encoding (32): 0x90000000
    // Test aarch32_STR_i_T2_A field combination: Rt=0, imm8=0
    // ISET: T32
    // Fields: Rt=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x90000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T2_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=1 (immediate value 1)
#[test]
fn test_aarch32_str_i_t2_a_combo_3_0_90010000() {
    // Thumb encoding (32): 0x90010000
    // Test aarch32_STR_i_T2_A field combination: Rt=0, imm8=1
    // ISET: T32
    // Fields: Rt=0, imm8=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x90010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T2_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=3 (2^2 - 1 = 3)
#[test]
fn test_aarch32_str_i_t2_a_combo_4_0_90030000() {
    // Thumb encoding (32): 0x90030000
    // Test aarch32_STR_i_T2_A field combination: Rt=0, imm8=3
    // ISET: T32
    // Fields: Rt=0, imm8=3
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x90030000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T2_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=4 (power of 2 (2^2 = 4))
#[test]
fn test_aarch32_str_i_t2_a_combo_5_0_90040000() {
    // Thumb encoding (32): 0x90040000
    // Test aarch32_STR_i_T2_A field combination: Rt=0, imm8=4
    // ISET: T32
    // Fields: Rt=0, imm8=4
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x90040000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T2_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=7 (2^3 - 1 = 7)
#[test]
fn test_aarch32_str_i_t2_a_combo_6_0_90070000() {
    // Thumb encoding (32): 0x90070000
    // Test aarch32_STR_i_T2_A field combination: Rt=0, imm8=7
    // ISET: T32
    // Fields: imm8=7, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x90070000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T2_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=8 (power of 2 (2^3 = 8))
#[test]
fn test_aarch32_str_i_t2_a_combo_7_0_90080000() {
    // Thumb encoding (32): 0x90080000
    // Test aarch32_STR_i_T2_A field combination: Rt=0, imm8=8
    // ISET: T32
    // Fields: Rt=0, imm8=8
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x90080000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T2_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=15 (2^4 - 1 = 15)
#[test]
fn test_aarch32_str_i_t2_a_combo_8_0_900f0000() {
    // Thumb encoding (32): 0x900F0000
    // Test aarch32_STR_i_T2_A field combination: Rt=0, imm8=15
    // ISET: T32
    // Fields: Rt=0, imm8=15
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x900F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T2_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=16 (power of 2 (2^4 = 16))
#[test]
fn test_aarch32_str_i_t2_a_combo_9_0_90100000() {
    // Thumb encoding (32): 0x90100000
    // Test aarch32_STR_i_T2_A field combination: Rt=0, imm8=16
    // ISET: T32
    // Fields: imm8=16, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x90100000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T2_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=31 (2^5 - 1 = 31)
#[test]
fn test_aarch32_str_i_t2_a_combo_10_0_901f0000() {
    // Thumb encoding (32): 0x901F0000
    // Test aarch32_STR_i_T2_A field combination: Rt=0, imm8=31
    // ISET: T32
    // Fields: Rt=0, imm8=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x901F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T2_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=32 (power of 2 (2^5 = 32))
#[test]
fn test_aarch32_str_i_t2_a_combo_11_0_90200000() {
    // Thumb encoding (32): 0x90200000
    // Test aarch32_STR_i_T2_A field combination: Rt=0, imm8=32
    // ISET: T32
    // Fields: Rt=0, imm8=32
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x90200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T2_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=63 (2^6 - 1 = 63)
#[test]
fn test_aarch32_str_i_t2_a_combo_12_0_903f0000() {
    // Thumb encoding (32): 0x903F0000
    // Test aarch32_STR_i_T2_A field combination: Rt=0, imm8=63
    // ISET: T32
    // Fields: Rt=0, imm8=63
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x903F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T2_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=64 (power of 2 (2^6 = 64))
#[test]
fn test_aarch32_str_i_t2_a_combo_13_0_90400000() {
    // Thumb encoding (32): 0x90400000
    // Test aarch32_STR_i_T2_A field combination: Rt=0, imm8=64
    // ISET: T32
    // Fields: Rt=0, imm8=64
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x90400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T2_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=127 (immediate midpoint (127))
#[test]
fn test_aarch32_str_i_t2_a_combo_14_0_907f0000() {
    // Thumb encoding (32): 0x907F0000
    // Test aarch32_STR_i_T2_A field combination: Rt=0, imm8=127
    // ISET: T32
    // Fields: imm8=127, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x907F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T2_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=128 (power of 2 (2^7 = 128))
#[test]
fn test_aarch32_str_i_t2_a_combo_15_0_90800000() {
    // Thumb encoding (32): 0x90800000
    // Test aarch32_STR_i_T2_A field combination: Rt=0, imm8=128
    // ISET: T32
    // Fields: imm8=128, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x90800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T2_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=255 (maximum immediate (255))
#[test]
fn test_aarch32_str_i_t2_a_combo_16_0_90ff0000() {
    // Thumb encoding (32): 0x90FF0000
    // Test aarch32_STR_i_T2_A field combination: Rt=0, imm8=255
    // ISET: T32
    // Fields: Rt=0, imm8=255
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x90FF0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T3_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_str_i_t3_a_field_rn_0_min_0_f8c00000() {
    // Thumb encoding (32): 0xF8C00000
    // Test aarch32_STR_i_T3_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm12=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8C00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T3_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_str_i_t3_a_field_rn_1_poweroftwo_0_f8c10000() {
    // Thumb encoding (32): 0xF8C10000
    // Test aarch32_STR_i_T3_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=1, imm12=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8C10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T3_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_str_i_t3_a_field_rt_0_min_0_f8c00000() {
    // Thumb encoding (32): 0xF8C00000
    // Test aarch32_STR_i_T3_A field Rt = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, imm12=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8C00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T3_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_str_i_t3_a_field_rt_1_poweroftwo_0_f8c01000() {
    // Thumb encoding (32): 0xF8C01000
    // Test aarch32_STR_i_T3_A field Rt = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Rt=1, imm12=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8C01000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T3_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_str_i_t3_a_field_imm12_0_zero_0_f8c00000() {
    // Thumb encoding (32): 0xF8C00000
    // Test aarch32_STR_i_T3_A field imm12 = 0 (Zero)
    // ISET: T32
    // Fields: Rt=0, Rn=0, imm12=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8C00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T3_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_str_i_t3_a_field_imm12_1_poweroftwo_0_f8c00001() {
    // Thumb encoding (32): 0xF8C00001
    // Test aarch32_STR_i_T3_A field imm12 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm12=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8C00001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T3_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_str_i_t3_a_field_imm12_3_poweroftwominusone_0_f8c00003() {
    // Thumb encoding (32): 0xF8C00003
    // Test aarch32_STR_i_T3_A field imm12 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, imm12=3, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8C00003;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T3_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_str_i_t3_a_field_imm12_4_poweroftwo_0_f8c00004() {
    // Thumb encoding (32): 0xF8C00004
    // Test aarch32_STR_i_T3_A field imm12 = 4 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, imm12=4, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8C00004;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T3_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_str_i_t3_a_field_imm12_7_poweroftwominusone_0_f8c00007() {
    // Thumb encoding (32): 0xF8C00007
    // Test aarch32_STR_i_T3_A field imm12 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, Rn=0, imm12=7
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8C00007;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T3_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_str_i_t3_a_field_imm12_8_poweroftwo_0_f8c00008() {
    // Thumb encoding (32): 0xF8C00008
    // Test aarch32_STR_i_T3_A field imm12 = 8 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, imm12=8, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8C00008;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T3_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_str_i_t3_a_field_imm12_15_poweroftwominusone_0_f8c0000f() {
    // Thumb encoding (32): 0xF8C0000F
    // Test aarch32_STR_i_T3_A field imm12 = 15 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm12=15
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8C0000F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T3_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_str_i_t3_a_field_imm12_16_poweroftwo_0_f8c00010() {
    // Thumb encoding (32): 0xF8C00010
    // Test aarch32_STR_i_T3_A field imm12 = 16 (PowerOfTwo)
    // ISET: T32
    // Fields: imm12=16, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8C00010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T3_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_str_i_t3_a_field_imm12_31_poweroftwominusone_0_f8c0001f() {
    // Thumb encoding (32): 0xF8C0001F
    // Test aarch32_STR_i_T3_A field imm12 = 31 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm12=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8C0001F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T3_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_str_i_t3_a_field_imm12_32_poweroftwo_0_f8c00020() {
    // Thumb encoding (32): 0xF8C00020
    // Test aarch32_STR_i_T3_A field imm12 = 32 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, imm12=32, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8C00020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T3_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_str_i_t3_a_field_imm12_63_poweroftwominusone_0_f8c0003f() {
    // Thumb encoding (32): 0xF8C0003F
    // Test aarch32_STR_i_T3_A field imm12 = 63 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm12=63, Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8C0003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T3_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_str_i_t3_a_field_imm12_64_poweroftwo_0_f8c00040() {
    // Thumb encoding (32): 0xF8C00040
    // Test aarch32_STR_i_T3_A field imm12 = 64 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm12=64
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8C00040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T3_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 127, boundary: PowerOfTwoMinusOne }
/// 2^7 - 1 = 127
#[test]
fn test_aarch32_str_i_t3_a_field_imm12_127_poweroftwominusone_0_f8c0007f() {
    // Thumb encoding (32): 0xF8C0007F
    // Test aarch32_STR_i_T3_A field imm12 = 127 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, imm12=127, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8C0007F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T3_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_str_i_t3_a_field_imm12_128_poweroftwo_0_f8c00080() {
    // Thumb encoding (32): 0xF8C00080
    // Test aarch32_STR_i_T3_A field imm12 = 128 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm12=128
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8C00080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T3_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 255, boundary: PowerOfTwoMinusOne }
/// 2^8 - 1 = 255
#[test]
fn test_aarch32_str_i_t3_a_field_imm12_255_poweroftwominusone_0_f8c000ff() {
    // Thumb encoding (32): 0xF8C000FF
    // Test aarch32_STR_i_T3_A field imm12 = 255 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, imm12=255, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8C000FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T3_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 256, boundary: PowerOfTwo }
/// power of 2 (2^8 = 256)
#[test]
fn test_aarch32_str_i_t3_a_field_imm12_256_poweroftwo_0_f8c00100() {
    // Thumb encoding (32): 0xF8C00100
    // Test aarch32_STR_i_T3_A field imm12 = 256 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, imm12=256, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8C00100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T3_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 511, boundary: PowerOfTwoMinusOne }
/// 2^9 - 1 = 511
#[test]
fn test_aarch32_str_i_t3_a_field_imm12_511_poweroftwominusone_0_f8c001ff() {
    // Thumb encoding (32): 0xF8C001FF
    // Test aarch32_STR_i_T3_A field imm12 = 511 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm12=511
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8C001FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T3_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 512, boundary: PowerOfTwo }
/// power of 2 (2^9 = 512)
#[test]
fn test_aarch32_str_i_t3_a_field_imm12_512_poweroftwo_0_f8c00200() {
    // Thumb encoding (32): 0xF8C00200
    // Test aarch32_STR_i_T3_A field imm12 = 512 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, imm12=512, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8C00200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T3_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1023, boundary: PowerOfTwoMinusOne }
/// 2^10 - 1 = 1023
#[test]
fn test_aarch32_str_i_t3_a_field_imm12_1023_poweroftwominusone_0_f8c003ff() {
    // Thumb encoding (32): 0xF8C003FF
    // Test aarch32_STR_i_T3_A field imm12 = 1023 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, imm12=1023, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8C003FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T3_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1024, boundary: PowerOfTwo }
/// power of 2 (2^10 = 1024)
#[test]
fn test_aarch32_str_i_t3_a_field_imm12_1024_poweroftwo_0_f8c00400() {
    // Thumb encoding (32): 0xF8C00400
    // Test aarch32_STR_i_T3_A field imm12 = 1024 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, imm12=1024, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8C00400;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T3_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2047, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (2047)
#[test]
fn test_aarch32_str_i_t3_a_field_imm12_2047_poweroftwominusone_0_f8c007ff() {
    // Thumb encoding (32): 0xF8C007FF
    // Test aarch32_STR_i_T3_A field imm12 = 2047 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, imm12=2047, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8C007FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T3_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2048, boundary: PowerOfTwo }
/// power of 2 (2^11 = 2048)
#[test]
fn test_aarch32_str_i_t3_a_field_imm12_2048_poweroftwo_0_f8c00800() {
    // Thumb encoding (32): 0xF8C00800
    // Test aarch32_STR_i_T3_A field imm12 = 2048 (PowerOfTwo)
    // ISET: T32
    // Fields: imm12=2048, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8C00800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T3_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4095, boundary: Max }
/// maximum immediate (4095)
#[test]
fn test_aarch32_str_i_t3_a_field_imm12_4095_max_0_f8c00fff() {
    // Thumb encoding (32): 0xF8C00FFF
    // Test aarch32_STR_i_T3_A field imm12 = 4095 (Max)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm12=4095
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8C00FFF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T3_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_str_i_t3_a_combo_0_0_f8c00000() {
    // Thumb encoding (32): 0xF8C00000
    // Test aarch32_STR_i_T3_A field combination: Rn=0, Rt=0, imm12=0
    // ISET: T32
    // Fields: imm12=0, Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8C00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T3_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_str_i_t3_a_combo_1_0_f8c10000() {
    // Thumb encoding (32): 0xF8C10000
    // Test aarch32_STR_i_T3_A field combination: Rn=1, Rt=0, imm12=0
    // ISET: T32
    // Fields: imm12=0, Rn=1, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8C10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T3_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=0 (register index 0 (first register))
#[test]
fn test_aarch32_str_i_t3_a_combo_2_0_f8c00000() {
    // Thumb encoding (32): 0xF8C00000
    // Test aarch32_STR_i_T3_A field combination: Rn=0, Rt=0, imm12=0
    // ISET: T32
    // Fields: Rn=0, imm12=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8C00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T3_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=1 (register index 1 (second register))
#[test]
fn test_aarch32_str_i_t3_a_combo_3_0_f8c01000() {
    // Thumb encoding (32): 0xF8C01000
    // Test aarch32_STR_i_T3_A field combination: Rn=0, Rt=1, imm12=0
    // ISET: T32
    // Fields: Rn=0, imm12=0, Rt=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8C01000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T3_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm12=0 (immediate value 0)
#[test]
fn test_aarch32_str_i_t3_a_combo_4_0_f8c00000() {
    // Thumb encoding (32): 0xF8C00000
    // Test aarch32_STR_i_T3_A field combination: Rn=0, Rt=0, imm12=0
    // ISET: T32
    // Fields: imm12=0, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8C00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T3_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm12=1 (immediate value 1)
#[test]
fn test_aarch32_str_i_t3_a_combo_5_0_f8c00001() {
    // Thumb encoding (32): 0xF8C00001
    // Test aarch32_STR_i_T3_A field combination: Rn=0, Rt=0, imm12=1
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm12=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8C00001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T3_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm12=3 (2^2 - 1 = 3)
#[test]
fn test_aarch32_str_i_t3_a_combo_6_0_f8c00003() {
    // Thumb encoding (32): 0xF8C00003
    // Test aarch32_STR_i_T3_A field combination: Rn=0, Rt=0, imm12=3
    // ISET: T32
    // Fields: imm12=3, Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8C00003;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T3_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm12=4 (power of 2 (2^2 = 4))
#[test]
fn test_aarch32_str_i_t3_a_combo_7_0_f8c00004() {
    // Thumb encoding (32): 0xF8C00004
    // Test aarch32_STR_i_T3_A field combination: Rn=0, Rt=0, imm12=4
    // ISET: T32
    // Fields: Rt=0, Rn=0, imm12=4
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8C00004;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T3_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm12=7 (2^3 - 1 = 7)
#[test]
fn test_aarch32_str_i_t3_a_combo_8_0_f8c00007() {
    // Thumb encoding (32): 0xF8C00007
    // Test aarch32_STR_i_T3_A field combination: Rn=0, Rt=0, imm12=7
    // ISET: T32
    // Fields: Rt=0, imm12=7, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8C00007;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T3_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm12=8 (power of 2 (2^3 = 8))
#[test]
fn test_aarch32_str_i_t3_a_combo_9_0_f8c00008() {
    // Thumb encoding (32): 0xF8C00008
    // Test aarch32_STR_i_T3_A field combination: Rn=0, Rt=0, imm12=8
    // ISET: T32
    // Fields: imm12=8, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8C00008;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T3_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm12=15 (2^4 - 1 = 15)
#[test]
fn test_aarch32_str_i_t3_a_combo_10_0_f8c0000f() {
    // Thumb encoding (32): 0xF8C0000F
    // Test aarch32_STR_i_T3_A field combination: Rn=0, Rt=0, imm12=15
    // ISET: T32
    // Fields: imm12=15, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8C0000F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T3_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm12=16 (power of 2 (2^4 = 16))
#[test]
fn test_aarch32_str_i_t3_a_combo_11_0_f8c00010() {
    // Thumb encoding (32): 0xF8C00010
    // Test aarch32_STR_i_T3_A field combination: Rn=0, Rt=0, imm12=16
    // ISET: T32
    // Fields: imm12=16, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8C00010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T3_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm12=31 (2^5 - 1 = 31)
#[test]
fn test_aarch32_str_i_t3_a_combo_12_0_f8c0001f() {
    // Thumb encoding (32): 0xF8C0001F
    // Test aarch32_STR_i_T3_A field combination: Rn=0, Rt=0, imm12=31
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm12=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8C0001F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T3_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm12=32 (power of 2 (2^5 = 32))
#[test]
fn test_aarch32_str_i_t3_a_combo_13_0_f8c00020() {
    // Thumb encoding (32): 0xF8C00020
    // Test aarch32_STR_i_T3_A field combination: Rn=0, Rt=0, imm12=32
    // ISET: T32
    // Fields: Rn=0, imm12=32, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8C00020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T3_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm12=63 (2^6 - 1 = 63)
#[test]
fn test_aarch32_str_i_t3_a_combo_14_0_f8c0003f() {
    // Thumb encoding (32): 0xF8C0003F
    // Test aarch32_STR_i_T3_A field combination: Rn=0, Rt=0, imm12=63
    // ISET: T32
    // Fields: Rn=0, imm12=63, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8C0003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T3_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm12=64 (power of 2 (2^6 = 64))
#[test]
fn test_aarch32_str_i_t3_a_combo_15_0_f8c00040() {
    // Thumb encoding (32): 0xF8C00040
    // Test aarch32_STR_i_T3_A field combination: Rn=0, Rt=0, imm12=64
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm12=64
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8C00040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T3_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm12=127 (2^7 - 1 = 127)
#[test]
fn test_aarch32_str_i_t3_a_combo_16_0_f8c0007f() {
    // Thumb encoding (32): 0xF8C0007F
    // Test aarch32_STR_i_T3_A field combination: Rn=0, Rt=0, imm12=127
    // ISET: T32
    // Fields: Rt=0, imm12=127, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8C0007F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T3_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm12=128 (power of 2 (2^7 = 128))
#[test]
fn test_aarch32_str_i_t3_a_combo_17_0_f8c00080() {
    // Thumb encoding (32): 0xF8C00080
    // Test aarch32_STR_i_T3_A field combination: Rn=0, Rt=0, imm12=128
    // ISET: T32
    // Fields: Rt=0, Rn=0, imm12=128
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8C00080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T3_A
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm12=255 (2^8 - 1 = 255)
#[test]
fn test_aarch32_str_i_t3_a_combo_18_0_f8c000ff() {
    // Thumb encoding (32): 0xF8C000FF
    // Test aarch32_STR_i_T3_A field combination: Rn=0, Rt=0, imm12=255
    // ISET: T32
    // Fields: imm12=255, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8C000FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T3_A
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm12=256 (power of 2 (2^8 = 256))
#[test]
fn test_aarch32_str_i_t3_a_combo_19_0_f8c00100() {
    // Thumb encoding (32): 0xF8C00100
    // Test aarch32_STR_i_T3_A field combination: Rn=0, Rt=0, imm12=256
    // ISET: T32
    // Fields: Rt=0, imm12=256, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8C00100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T3_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rn" }), rhs: LitBits([true, true, true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Rn\" }), rhs: LitBits([true, true, true, true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_str_i_t3_a_invalid_0_0_f8c00000() {
    // Thumb encoding (32): 0xF8C00000
    // Test aarch32_STR_i_T3_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rn" }), rhs: LitBits([true, true, true, true]) }
    // ISET: T32
    // Fields: Rn=0, imm12=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8C00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_STR_i_T3_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_str_i_t3_a_invalid_1_0_f8c00000() {
    // Thumb encoding (32): 0xF8C00000
    // Test aarch32_STR_i_T3_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: Rt=0, imm12=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8C00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_STR_i_T3_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_str_i_t3_a_invalid_2_0_f8c00000() {
    // Thumb encoding (32): 0xF8C00000
    // Test aarch32_STR_i_T3_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: LitInt(15) }
    // ISET: T32
    // Fields: Rt=0, imm12=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8C00000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_STR_i_T3_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_str_i_t3_a_invalid_3_0_f8c00000() {
    // Thumb encoding (32): 0xF8C00000
    // Test aarch32_STR_i_T3_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rt=0, Rn=0, imm12=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8C00000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_STR_i_T4_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_str_i_t4_a_field_rn_0_min_800_f8400800() {
    // Thumb encoding (32): 0xF8400800
    // Test aarch32_STR_i_T4_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rt=0, U=0, W=0, imm8=0, Rn=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8400800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T4_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_str_i_t4_a_field_rn_1_poweroftwo_800_f8410800() {
    // Thumb encoding (32): 0xF8410800
    // Test aarch32_STR_i_T4_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, U=0, W=0, Rn=1, imm8=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8410800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T4_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_str_i_t4_a_field_rt_0_min_800_f8400800() {
    // Thumb encoding (32): 0xF8400800
    // Test aarch32_STR_i_T4_A field Rt = 0 (Min)
    // ISET: T32
    // Fields: Rt=0, W=0, U=0, Rn=0, P=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8400800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T4_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_str_i_t4_a_field_rt_1_poweroftwo_800_f8401800() {
    // Thumb encoding (32): 0xF8401800
    // Test aarch32_STR_i_T4_A field Rt = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: P=0, W=0, U=0, Rn=0, Rt=1, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8401800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T4_A
/// ASL: `field P 10 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_str_i_t4_a_field_p_0_min_800_f8400800() {
    // Thumb encoding (32): 0xF8400800
    // Test aarch32_STR_i_T4_A field P = 0 (Min)
    // ISET: T32
    // Fields: W=0, imm8=0, P=0, Rn=0, Rt=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8400800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T4_A
/// ASL: `field P 10 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_str_i_t4_a_field_p_1_max_800_f8400c00() {
    // Thumb encoding (32): 0xF8400C00
    // Test aarch32_STR_i_T4_A field P = 1 (Max)
    // ISET: T32
    // Fields: U=0, Rt=0, P=1, W=0, Rn=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8400C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T4_A
/// ASL: `field U 9 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_str_i_t4_a_field_u_0_min_800_f8400800() {
    // Thumb encoding (32): 0xF8400800
    // Test aarch32_STR_i_T4_A field U = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, P=0, Rt=0, U=0, W=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8400800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T4_A
/// ASL: `field U 9 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_str_i_t4_a_field_u_1_max_800_f8400a00() {
    // Thumb encoding (32): 0xF8400A00
    // Test aarch32_STR_i_T4_A field U = 1 (Max)
    // ISET: T32
    // Fields: P=0, Rn=0, U=1, imm8=0, W=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8400A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T4_A
/// ASL: `field W 8 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_str_i_t4_a_field_w_0_min_800_f8400800() {
    // Thumb encoding (32): 0xF8400800
    // Test aarch32_STR_i_T4_A field W = 0 (Min)
    // ISET: T32
    // Fields: imm8=0, Rt=0, P=0, U=0, Rn=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8400800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T4_A
/// ASL: `field W 8 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_str_i_t4_a_field_w_1_max_800_f8400900() {
    // Thumb encoding (32): 0xF8400900
    // Test aarch32_STR_i_T4_A field W = 1 (Max)
    // ISET: T32
    // Fields: U=0, Rn=0, P=0, Rt=0, W=1, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8400900;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T4_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_str_i_t4_a_field_imm8_0_zero_800_f8400800() {
    // Thumb encoding (32): 0xF8400800
    // Test aarch32_STR_i_T4_A field imm8 = 0 (Zero)
    // ISET: T32
    // Fields: Rt=0, Rn=0, P=0, W=0, U=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8400800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T4_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_str_i_t4_a_field_imm8_1_poweroftwo_800_f8400801() {
    // Thumb encoding (32): 0xF8400801
    // Test aarch32_STR_i_T4_A field imm8 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=1, W=0, P=0, Rt=0, Rn=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8400801;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T4_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_str_i_t4_a_field_imm8_3_poweroftwominusone_800_f8400803() {
    // Thumb encoding (32): 0xF8400803
    // Test aarch32_STR_i_T4_A field imm8 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm8=3, U=0, W=0, Rn=0, Rt=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8400803;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T4_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_str_i_t4_a_field_imm8_4_poweroftwo_800_f8400804() {
    // Thumb encoding (32): 0xF8400804
    // Test aarch32_STR_i_T4_A field imm8 = 4 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=4, Rn=0, Rt=0, U=0, P=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8400804;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T4_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_str_i_t4_a_field_imm8_7_poweroftwominusone_800_f8400807() {
    // Thumb encoding (32): 0xF8400807
    // Test aarch32_STR_i_T4_A field imm8 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, U=0, P=0, W=0, Rn=0, imm8=7
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8400807;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T4_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_str_i_t4_a_field_imm8_8_poweroftwo_800_f8400808() {
    // Thumb encoding (32): 0xF8400808
    // Test aarch32_STR_i_T4_A field imm8 = 8 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, U=0, imm8=8, Rn=0, W=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8400808;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T4_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_str_i_t4_a_field_imm8_15_poweroftwominusone_800_f840080f() {
    // Thumb encoding (32): 0xF840080F
    // Test aarch32_STR_i_T4_A field imm8 = 15 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, Rt=0, U=0, P=0, W=0, imm8=15
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF840080F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T4_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_str_i_t4_a_field_imm8_16_poweroftwo_800_f8400810() {
    // Thumb encoding (32): 0xF8400810
    // Test aarch32_STR_i_T4_A field imm8 = 16 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Rt=0, U=0, W=0, imm8=16, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8400810;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T4_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_str_i_t4_a_field_imm8_31_poweroftwominusone_800_f840081f() {
    // Thumb encoding (32): 0xF840081F
    // Test aarch32_STR_i_T4_A field imm8 = 31 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm8=31, Rt=0, Rn=0, U=0, P=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF840081F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T4_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_str_i_t4_a_field_imm8_32_poweroftwo_800_f8400820() {
    // Thumb encoding (32): 0xF8400820
    // Test aarch32_STR_i_T4_A field imm8 = 32 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, U=0, W=0, Rn=0, P=0, imm8=32
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8400820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T4_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_str_i_t4_a_field_imm8_63_poweroftwominusone_800_f840083f() {
    // Thumb encoding (32): 0xF840083F
    // Test aarch32_STR_i_T4_A field imm8 = 63 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, imm8=63, Rn=0, U=0, W=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF840083F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T4_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_str_i_t4_a_field_imm8_64_poweroftwo_800_f8400840() {
    // Thumb encoding (32): 0xF8400840
    // Test aarch32_STR_i_T4_A field imm8 = 64 (PowerOfTwo)
    // ISET: T32
    // Fields: P=0, Rn=0, Rt=0, imm8=64, W=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8400840;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T4_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 127, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (127)
#[test]
fn test_aarch32_str_i_t4_a_field_imm8_127_poweroftwominusone_800_f840087f() {
    // Thumb encoding (32): 0xF840087F
    // Test aarch32_STR_i_T4_A field imm8 = 127 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, Rt=0, P=0, imm8=127, W=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF840087F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T4_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_str_i_t4_a_field_imm8_128_poweroftwo_800_f8400880() {
    // Thumb encoding (32): 0xF8400880
    // Test aarch32_STR_i_T4_A field imm8 = 128 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, U=0, P=0, W=0, imm8=128, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8400880;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T4_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 255, boundary: Max }
/// maximum immediate (255)
#[test]
fn test_aarch32_str_i_t4_a_field_imm8_255_max_800_f84008ff() {
    // Thumb encoding (32): 0xF84008FF
    // Test aarch32_STR_i_T4_A field imm8 = 255 (Max)
    // ISET: T32
    // Fields: Rn=0, P=0, W=0, U=0, imm8=255, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF84008FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T4_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_str_i_t4_a_combo_0_800_f8400800() {
    // Thumb encoding (32): 0xF8400800
    // Test aarch32_STR_i_T4_A field combination: Rn=0, Rt=0, P=0, U=0, W=0, imm8=0
    // ISET: T32
    // Fields: U=0, P=0, Rt=0, W=0, imm8=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8400800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T4_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_str_i_t4_a_combo_1_800_f8410800() {
    // Thumb encoding (32): 0xF8410800
    // Test aarch32_STR_i_T4_A field combination: Rn=1, Rt=0, P=0, U=0, W=0, imm8=0
    // ISET: T32
    // Fields: U=0, imm8=0, P=0, W=0, Rt=0, Rn=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8410800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T4_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=0 (register index 0 (first register))
#[test]
fn test_aarch32_str_i_t4_a_combo_2_800_f8400800() {
    // Thumb encoding (32): 0xF8400800
    // Test aarch32_STR_i_T4_A field combination: Rn=0, Rt=0, P=0, U=0, W=0, imm8=0
    // ISET: T32
    // Fields: imm8=0, Rn=0, P=0, W=0, Rt=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8400800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T4_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=1 (register index 1 (second register))
#[test]
fn test_aarch32_str_i_t4_a_combo_3_800_f8401800() {
    // Thumb encoding (32): 0xF8401800
    // Test aarch32_STR_i_T4_A field combination: Rn=0, Rt=1, P=0, U=0, W=0, imm8=0
    // ISET: T32
    // Fields: Rn=0, U=0, Rt=1, W=0, imm8=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8401800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T4_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// P=0 (minimum value)
#[test]
fn test_aarch32_str_i_t4_a_combo_4_800_f8400800() {
    // Thumb encoding (32): 0xF8400800
    // Test aarch32_STR_i_T4_A field combination: Rn=0, Rt=0, P=0, U=0, W=0, imm8=0
    // ISET: T32
    // Fields: P=0, U=0, Rt=0, W=0, Rn=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8400800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T4_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// P=1 (maximum value (1))
#[test]
fn test_aarch32_str_i_t4_a_combo_5_800_f8400c00() {
    // Thumb encoding (32): 0xF8400C00
    // Test aarch32_STR_i_T4_A field combination: Rn=0, Rt=0, P=1, U=0, W=0, imm8=0
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm8=0, P=1, U=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8400C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T4_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=0 (minimum value)
#[test]
fn test_aarch32_str_i_t4_a_combo_6_800_f8400800() {
    // Thumb encoding (32): 0xF8400800
    // Test aarch32_STR_i_T4_A field combination: Rn=0, Rt=0, P=0, U=0, W=0, imm8=0
    // ISET: T32
    // Fields: Rn=0, P=0, imm8=0, U=0, W=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8400800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T4_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=1 (maximum value (1))
#[test]
fn test_aarch32_str_i_t4_a_combo_7_800_f8400a00() {
    // Thumb encoding (32): 0xF8400A00
    // Test aarch32_STR_i_T4_A field combination: Rn=0, Rt=0, P=0, U=1, W=0, imm8=0
    // ISET: T32
    // Fields: Rt=0, W=0, imm8=0, U=1, P=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8400A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T4_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// W=0 (minimum value)
#[test]
fn test_aarch32_str_i_t4_a_combo_8_800_f8400800() {
    // Thumb encoding (32): 0xF8400800
    // Test aarch32_STR_i_T4_A field combination: Rn=0, Rt=0, P=0, U=0, W=0, imm8=0
    // ISET: T32
    // Fields: W=0, imm8=0, Rn=0, U=0, Rt=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8400800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T4_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// W=1 (maximum value (1))
#[test]
fn test_aarch32_str_i_t4_a_combo_9_800_f8400900() {
    // Thumb encoding (32): 0xF8400900
    // Test aarch32_STR_i_T4_A field combination: Rn=0, Rt=0, P=0, U=0, W=1, imm8=0
    // ISET: T32
    // Fields: W=1, P=0, Rt=0, Rn=0, imm8=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8400900;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T4_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=0 (immediate value 0)
#[test]
fn test_aarch32_str_i_t4_a_combo_10_800_f8400800() {
    // Thumb encoding (32): 0xF8400800
    // Test aarch32_STR_i_T4_A field combination: Rn=0, Rt=0, P=0, U=0, W=0, imm8=0
    // ISET: T32
    // Fields: Rn=0, Rt=0, P=0, U=0, W=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8400800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T4_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=1 (immediate value 1)
#[test]
fn test_aarch32_str_i_t4_a_combo_11_800_f8400801() {
    // Thumb encoding (32): 0xF8400801
    // Test aarch32_STR_i_T4_A field combination: Rn=0, Rt=0, P=0, U=0, W=0, imm8=1
    // ISET: T32
    // Fields: Rt=0, W=0, imm8=1, U=0, Rn=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8400801;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T4_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=3 (2^2 - 1 = 3)
#[test]
fn test_aarch32_str_i_t4_a_combo_12_800_f8400803() {
    // Thumb encoding (32): 0xF8400803
    // Test aarch32_STR_i_T4_A field combination: Rn=0, Rt=0, P=0, U=0, W=0, imm8=3
    // ISET: T32
    // Fields: P=0, U=0, imm8=3, Rn=0, W=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8400803;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T4_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=4 (power of 2 (2^2 = 4))
#[test]
fn test_aarch32_str_i_t4_a_combo_13_800_f8400804() {
    // Thumb encoding (32): 0xF8400804
    // Test aarch32_STR_i_T4_A field combination: Rn=0, Rt=0, P=0, U=0, W=0, imm8=4
    // ISET: T32
    // Fields: Rn=0, W=0, P=0, U=0, imm8=4, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8400804;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T4_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=7 (2^3 - 1 = 7)
#[test]
fn test_aarch32_str_i_t4_a_combo_14_800_f8400807() {
    // Thumb encoding (32): 0xF8400807
    // Test aarch32_STR_i_T4_A field combination: Rn=0, Rt=0, P=0, U=0, W=0, imm8=7
    // ISET: T32
    // Fields: U=0, W=0, Rt=0, Rn=0, imm8=7, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8400807;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T4_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=8 (power of 2 (2^3 = 8))
#[test]
fn test_aarch32_str_i_t4_a_combo_15_800_f8400808() {
    // Thumb encoding (32): 0xF8400808
    // Test aarch32_STR_i_T4_A field combination: Rn=0, Rt=0, P=0, U=0, W=0, imm8=8
    // ISET: T32
    // Fields: Rn=0, Rt=0, U=0, imm8=8, W=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8400808;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T4_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=15 (2^4 - 1 = 15)
#[test]
fn test_aarch32_str_i_t4_a_combo_16_800_f840080f() {
    // Thumb encoding (32): 0xF840080F
    // Test aarch32_STR_i_T4_A field combination: Rn=0, Rt=0, P=0, U=0, W=0, imm8=15
    // ISET: T32
    // Fields: imm8=15, P=0, Rn=0, W=0, Rt=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF840080F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T4_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=16 (power of 2 (2^4 = 16))
#[test]
fn test_aarch32_str_i_t4_a_combo_17_800_f8400810() {
    // Thumb encoding (32): 0xF8400810
    // Test aarch32_STR_i_T4_A field combination: Rn=0, Rt=0, P=0, U=0, W=0, imm8=16
    // ISET: T32
    // Fields: Rn=0, Rt=0, U=0, P=0, W=0, imm8=16
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8400810;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T4_A
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=31 (2^5 - 1 = 31)
#[test]
fn test_aarch32_str_i_t4_a_combo_18_800_f840081f() {
    // Thumb encoding (32): 0xF840081F
    // Test aarch32_STR_i_T4_A field combination: Rn=0, Rt=0, P=0, U=0, W=0, imm8=31
    // ISET: T32
    // Fields: P=0, Rn=0, imm8=31, Rt=0, U=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF840081F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T4_A
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=32 (power of 2 (2^5 = 32))
#[test]
fn test_aarch32_str_i_t4_a_combo_19_800_f8400820() {
    // Thumb encoding (32): 0xF8400820
    // Test aarch32_STR_i_T4_A field combination: Rn=0, Rt=0, P=0, U=0, W=0, imm8=32
    // ISET: T32
    // Fields: Rn=0, W=0, Rt=0, imm8=32, U=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8400820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_i_T4_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rn" }), rhs: Binary { op: Or, lhs: LitBits([true, true, true, true]), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "P" }), rhs: Binary { op: And, lhs: LitBits([false]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "W" }) } }, rhs: LitBits([false]) } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Rn\" }), rhs: Binary { op: Or, lhs: LitBits([true, true, true, true]), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"P\" }), rhs: Binary { op: And, lhs: LitBits([false]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"W\" }) } }, rhs: LitBits([false]) } } }" }
/// triggers Undefined
#[test]
fn test_aarch32_str_i_t4_a_invalid_0_800_f8400800() {
    // Thumb encoding (32): 0xF8400800
    // Test aarch32_STR_i_T4_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rn" }), rhs: Binary { op: Or, lhs: LitBits([true, true, true, true]), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "P" }), rhs: Binary { op: And, lhs: LitBits([false]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "W" }) } }, rhs: LitBits([false]) } } }
    // ISET: T32
    // Fields: P=0, W=0, imm8=0, Rn=0, U=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8400800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_STR_i_T4_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_str_i_t4_a_invalid_1_800_f8400800() {
    // Thumb encoding (32): 0xF8400800
    // Test aarch32_STR_i_T4_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: U=0, W=0, imm8=0, Rt=0, Rn=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8400800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_STR_i_T4_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Binary { op: Eq, lhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Binary { op: Eq, lhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"wback\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }) } } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_str_i_t4_a_invalid_2_800_f8400800() {
    // Thumb encoding (32): 0xF8400800
    // Test aarch32_STR_i_T4_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Binary { op: Eq, lhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) } } }
    // ISET: T32
    // Fields: U=0, imm8=0, W=0, Rt=0, Rn=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8400800;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_STR_i_T4_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_str_i_t4_a_invalid_3_800_f8400800() {
    // Thumb encoding (32): 0xF8400800
    // Test aarch32_STR_i_T4_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: W=0, Rt=0, P=0, Rn=0, imm8=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8400800;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_STR_i_A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_str_i_a1_a_store_0_04010000() {
    // Test aarch32_STR_i_A1_A memory store: 8 bytes
    // Encoding: 0x04010000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x04010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_STR_i_A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_str_i_a1_a_store_1_04010000() {
    // Test aarch32_STR_i_A1_A memory store: 8 bytes
    // Encoding: 0x04010000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0x04010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_STR_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 0 (32)
#[test]
fn test_aarch32_str_i_t1_a_lslv_oracle_32_0_60020020() {
    // Test LSLV 32-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x12345678, "W0 should be 0x12345678");
}

/// Provenance: aarch32_STR_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 0 (64)
#[test]
fn test_aarch32_str_i_t1_a_lslv_oracle_64_0_e0020020() {
    // Test LSLV 64-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x12345678, "X0 should be 0x0000000012345678");
}

/// Provenance: aarch32_STR_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4 (32)
#[test]
fn test_aarch32_str_i_t1_a_lslv_oracle_32_1_60020020() {
    // Test LSLV 32-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x4);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x23456780, "W0 should be 0x23456780");
}

/// Provenance: aarch32_STR_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 4 (64)
#[test]
fn test_aarch32_str_i_t1_a_lslv_oracle_64_1_e0020020() {
    // Test LSLV 64-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x4);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x23456780, "X0 should be 0x0000000123456780");
}

/// Provenance: aarch32_STR_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 8 (32)
#[test]
fn test_aarch32_str_i_t1_a_lslv_oracle_32_2_60020020() {
    // Test LSLV 32-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x8);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x34567800, "W0 should be 0x34567800");
}

/// Provenance: aarch32_STR_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 8 (64)
#[test]
fn test_aarch32_str_i_t1_a_lslv_oracle_64_2_e0020020() {
    // Test LSLV 64-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x8);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x34567800, "X0 should be 0x0000001234567800");
}

/// Provenance: aarch32_STR_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1 (32)
#[test]
fn test_aarch32_str_i_t1_a_lslv_oracle_32_3_60020020() {
    // Test LSLV 32-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_STR_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// MSB set, shift 1 (64)
#[test]
fn test_aarch32_str_i_t1_a_lslv_oracle_64_3_e0020020() {
    // Test LSLV 64-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_STR_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// LSB set, max shift (32)
#[test]
fn test_aarch32_str_i_t1_a_lslv_oracle_32_4_60020020() {
    // Test LSLV 32-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3F);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "W0 should be 0x80000000");
}

/// Provenance: aarch32_STR_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// LSB set, max shift (64)
#[test]
fn test_aarch32_str_i_t1_a_lslv_oracle_64_4_e0020020() {
    // Test LSLV 64-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x3F);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x8000000000000000");
}

/// Provenance: aarch32_STR_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// all ones, shift 32 (32)
#[test]
fn test_aarch32_str_i_t1_a_lslv_oracle_32_5_60020020() {
    // Test LSLV 32-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x20);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "W0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_STR_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// all ones, shift 32 (64)
#[test]
fn test_aarch32_str_i_t1_a_lslv_oracle_64_5_e0020020() {
    // Test LSLV 64-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x20);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0xFFFFFFFF00000000");
}

/// Provenance: aarch32_STR_i_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// no shift
#[test]
fn test_aarch32_str_i_t1_a_t16_oracle_0_60080000() {
    // Test T16 LSLS: no shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_STR_i_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4
#[test]
fn test_aarch32_str_i_t1_a_t16_oracle_1_60080000() {
    // Test T16 LSLS: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    set_w(&mut cpu, 2, 0x4);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF0, "R0 should be 0x00000FF0");
}

/// Provenance: aarch32_STR_i_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1
#[test]
fn test_aarch32_str_i_t1_a_t16_oracle_2_60080000() {
    // Test T16 LSLS: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_STR_i_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift to MSB
#[test]
fn test_aarch32_str_i_t1_a_t16_oracle_3_60080000() {
    // Test T16 LSLS: shift to MSB (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x1F);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "R0 should be 0x80000000");
}

/// Provenance: aarch32_STR_i_T1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_str_i_t1_a_store_0_60080000() {
    // Test aarch32_STR_i_T1_A memory store: 8 bytes
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_STR_i_T1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_str_i_t1_a_store_1_60080000() {
    // Test aarch32_STR_i_T1_A memory store: 8 bytes
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_STR_i_T2_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 0 (32)
#[test]
fn test_aarch32_str_i_t2_a_lslv_oracle_32_0_90020020() {
    // Test LSLV 32-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x12345678, "W0 should be 0x12345678");
}

/// Provenance: aarch32_STR_i_T2_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 0 (64)
#[test]
fn test_aarch32_str_i_t2_a_lslv_oracle_64_0_90020020() {
    // Test LSLV 64-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x12345678, "X0 should be 0x0000000012345678");
}

/// Provenance: aarch32_STR_i_T2_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4 (32)
#[test]
fn test_aarch32_str_i_t2_a_lslv_oracle_32_1_90020020() {
    // Test LSLV 32-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x4);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x23456780, "W0 should be 0x23456780");
}

/// Provenance: aarch32_STR_i_T2_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 4 (64)
#[test]
fn test_aarch32_str_i_t2_a_lslv_oracle_64_1_90020020() {
    // Test LSLV 64-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x4);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x23456780, "X0 should be 0x0000000123456780");
}

/// Provenance: aarch32_STR_i_T2_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 8 (32)
#[test]
fn test_aarch32_str_i_t2_a_lslv_oracle_32_2_90020020() {
    // Test LSLV 32-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x8);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x34567800, "W0 should be 0x34567800");
}

/// Provenance: aarch32_STR_i_T2_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 8 (64)
#[test]
fn test_aarch32_str_i_t2_a_lslv_oracle_64_2_90020020() {
    // Test LSLV 64-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x8);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x34567800, "X0 should be 0x0000001234567800");
}

/// Provenance: aarch32_STR_i_T2_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1 (32)
#[test]
fn test_aarch32_str_i_t2_a_lslv_oracle_32_3_90020020() {
    // Test LSLV 32-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_STR_i_T2_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// MSB set, shift 1 (64)
#[test]
fn test_aarch32_str_i_t2_a_lslv_oracle_64_3_90020020() {
    // Test LSLV 64-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_STR_i_T2_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// LSB set, max shift (32)
#[test]
fn test_aarch32_str_i_t2_a_lslv_oracle_32_4_90020020() {
    // Test LSLV 32-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x3F);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "W0 should be 0x80000000");
}

/// Provenance: aarch32_STR_i_T2_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// LSB set, max shift (64)
#[test]
fn test_aarch32_str_i_t2_a_lslv_oracle_64_4_90020020() {
    // Test LSLV 64-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x3F);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x8000000000000000");
}

/// Provenance: aarch32_STR_i_T2_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// all ones, shift 32 (32)
#[test]
fn test_aarch32_str_i_t2_a_lslv_oracle_32_5_90020020() {
    // Test LSLV 32-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x20);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "W0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_STR_i_T2_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// all ones, shift 32 (64)
#[test]
fn test_aarch32_str_i_t2_a_lslv_oracle_64_5_90020020() {
    // Test LSLV 64-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x20);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0xFFFFFFFF00000000");
}

/// Provenance: aarch32_STR_i_T2_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// no shift
#[test]
fn test_aarch32_str_i_t2_a_t16_oracle_0_90000000() {
    // Test T16 LSLS: no shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_STR_i_T2_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4
#[test]
fn test_aarch32_str_i_t2_a_t16_oracle_1_90000000() {
    // Test T16 LSLS: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    set_w(&mut cpu, 2, 0x4);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF0, "R0 should be 0x00000FF0");
}

/// Provenance: aarch32_STR_i_T2_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1
#[test]
fn test_aarch32_str_i_t2_a_t16_oracle_2_90000000() {
    // Test T16 LSLS: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_STR_i_T2_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift to MSB
#[test]
fn test_aarch32_str_i_t2_a_t16_oracle_3_90000000() {
    // Test T16 LSLS: shift to MSB (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1F);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "R0 should be 0x80000000");
}

/// Provenance: aarch32_STR_i_T2_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_str_i_t2_a_store_0_90000000() {
    // Test aarch32_STR_i_T2_A memory store: 8 bytes
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_STR_i_T2_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_str_i_t2_a_store_1_90000000() {
    // Test aarch32_STR_i_T2_A memory store: 8 bytes
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_STR_i_T3_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_str_i_t3_a_store_0_f8c10000() {
    // Test aarch32_STR_i_T3_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF8C10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_STR_i_T3_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_str_i_t3_a_store_1_f8c10000() {
    // Test aarch32_STR_i_T3_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF8C10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_STR_i_T4_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_str_i_t4_a_store_0_f8410800() {
    // Test aarch32_STR_i_T4_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0xF8410800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_STR_i_T4_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_str_i_t4_a_store_1_f8410800() {
    // Test aarch32_STR_i_T4_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0xF8410800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// aarch32_STREXH_A Tests
// ============================================================================

/// Provenance: aarch32_STREXH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_strexh_a1_a_field_cond_0_min_390_01e00390() {
    // Encoding: 0x01E00390
    // Test aarch32_STREXH_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rn=0, Rt=0, Rd=0
    let encoding: u32 = 0x01E00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_strexh_a1_a_field_cond_1_poweroftwo_390_11e00390() {
    // Encoding: 0x11E00390
    // Test aarch32_STREXH_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, cond=1, Rd=0, Rn=0
    let encoding: u32 = 0x11E00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_strexh_a1_a_field_cond_2_poweroftwo_390_21e00390() {
    // Encoding: 0x21E00390
    // Test aarch32_STREXH_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=2, Rd=0, Rt=0
    let encoding: u32 = 0x21E00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_strexh_a1_a_field_cond_3_poweroftwo_390_31e00390() {
    // Encoding: 0x31E00390
    // Test aarch32_STREXH_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=3, Rn=0, Rt=0, Rd=0
    let encoding: u32 = 0x31E00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_strexh_a1_a_field_cond_4_poweroftwo_390_41e00390() {
    // Encoding: 0x41E00390
    // Test aarch32_STREXH_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rn=0, Rt=0, cond=4
    let encoding: u32 = 0x41E00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_strexh_a1_a_field_cond_5_poweroftwo_390_51e00390() {
    // Encoding: 0x51E00390
    // Test aarch32_STREXH_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=5, Rd=0, Rn=0, Rt=0
    let encoding: u32 = 0x51E00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_strexh_a1_a_field_cond_6_poweroftwo_390_61e00390() {
    // Encoding: 0x61E00390
    // Test aarch32_STREXH_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=6, Rn=0, Rd=0, Rt=0
    let encoding: u32 = 0x61E00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_strexh_a1_a_field_cond_7_poweroftwo_390_71e00390() {
    // Encoding: 0x71E00390
    // Test aarch32_STREXH_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rd=0, Rt=0, cond=7
    let encoding: u32 = 0x71E00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_strexh_a1_a_field_cond_8_poweroftwo_390_81e00390() {
    // Encoding: 0x81E00390
    // Test aarch32_STREXH_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rt=0, cond=8, Rn=0
    let encoding: u32 = 0x81E00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_strexh_a1_a_field_cond_9_poweroftwo_390_91e00390() {
    // Encoding: 0x91E00390
    // Test aarch32_STREXH_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rt=0, Rn=0, cond=9
    let encoding: u32 = 0x91E00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_strexh_a1_a_field_cond_10_poweroftwo_390_a1e00390() {
    // Encoding: 0xA1E00390
    // Test aarch32_STREXH_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=10, Rd=0, Rt=0
    let encoding: u32 = 0xA1E00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_strexh_a1_a_field_cond_11_poweroftwo_390_b1e00390() {
    // Encoding: 0xB1E00390
    // Test aarch32_STREXH_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rn=0, cond=11, Rt=0
    let encoding: u32 = 0xB1E00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_strexh_a1_a_field_cond_12_poweroftwo_390_c1e00390() {
    // Encoding: 0xC1E00390
    // Test aarch32_STREXH_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rt=0, Rd=0, cond=12
    let encoding: u32 = 0xC1E00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_strexh_a1_a_field_cond_13_poweroftwo_390_d1e00390() {
    // Encoding: 0xD1E00390
    // Test aarch32_STREXH_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, cond=13, Rt=0, Rn=0
    let encoding: u32 = 0xD1E00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_strexh_a1_a_field_cond_14_poweroftwo_390_e1e00390() {
    // Encoding: 0xE1E00390
    // Test aarch32_STREXH_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rt=0, cond=14, Rn=0
    let encoding: u32 = 0xE1E00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_strexh_a1_a_field_cond_15_max_390_f1e00390() {
    // Encoding: 0xF1E00390
    // Test aarch32_STREXH_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: Rd=0, Rn=0, cond=15, Rt=0
    let encoding: u32 = 0xF1E00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXH_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_strexh_a1_a_field_rn_0_min_390_01e00390() {
    // Encoding: 0x01E00390
    // Test aarch32_STREXH_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rn=0, Rt=0, Rd=0
    let encoding: u32 = 0x01E00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXH_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_strexh_a1_a_field_rn_1_poweroftwo_390_01e10390() {
    // Encoding: 0x01E10390
    // Test aarch32_STREXH_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Rt=0, Rd=0, Rn=1
    let encoding: u32 = 0x01E10390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXH_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_strexh_a1_a_field_rd_0_min_390_01e00390() {
    // Encoding: 0x01E00390
    // Test aarch32_STREXH_A1_A field Rd = 0 (Min)
    // ISET: A32
    // Fields: Rd=0, cond=0, Rt=0, Rn=0
    let encoding: u32 = 0x01E00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXH_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_strexh_a1_a_field_rd_1_poweroftwo_390_01e01390() {
    // Encoding: 0x01E01390
    // Test aarch32_STREXH_A1_A field Rd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rd=1, Rt=0, cond=0
    let encoding: u32 = 0x01E01390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXH_A1_A
/// ASL: `field Rt 0 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_strexh_a1_a_field_rt_0_min_390_01e00390() {
    // Encoding: 0x01E00390
    // Test aarch32_STREXH_A1_A field Rt = 0 (Min)
    // ISET: A32
    // Fields: Rd=0, Rt=0, cond=0, Rn=0
    let encoding: u32 = 0x01E00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXH_A1_A
/// ASL: `field Rt 0 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_strexh_a1_a_field_rt_1_poweroftwo_390_01e00391() {
    // Encoding: 0x01E00391
    // Test aarch32_STREXH_A1_A field Rt = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Rn=0, Rt=1, Rd=0
    let encoding: u32 = 0x01E00391;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXH_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_strexh_a1_a_combo_0_390_01e00390() {
    // Encoding: 0x01E00390
    // Test aarch32_STREXH_A1_A field combination: cond=0, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rn=0, Rd=0, Rt=0, cond=0
    let encoding: u32 = 0x01E00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXH_A1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=1 (condition NE (not equal))
#[test]
fn test_aarch32_strexh_a1_a_combo_1_390_11e00390() {
    // Encoding: 0x11E00390
    // Test aarch32_STREXH_A1_A field combination: cond=1, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: cond=1, Rn=0, Rd=0, Rt=0
    let encoding: u32 = 0x11E00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXH_A1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=2 (condition CS/HS (carry set))
#[test]
fn test_aarch32_strexh_a1_a_combo_2_390_21e00390() {
    // Encoding: 0x21E00390
    // Test aarch32_STREXH_A1_A field combination: cond=2, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: cond=2, Rd=0, Rn=0, Rt=0
    let encoding: u32 = 0x21E00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXH_A1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=3 (condition CC/LO (carry clear))
#[test]
fn test_aarch32_strexh_a1_a_combo_3_390_31e00390() {
    // Encoding: 0x31E00390
    // Test aarch32_STREXH_A1_A field combination: cond=3, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rn=0, Rd=0, cond=3, Rt=0
    let encoding: u32 = 0x31E00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXH_A1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=4 (condition MI (minus/negative))
#[test]
fn test_aarch32_strexh_a1_a_combo_4_390_41e00390() {
    // Encoding: 0x41E00390
    // Test aarch32_STREXH_A1_A field combination: cond=4, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rn=0, cond=4, Rd=0, Rt=0
    let encoding: u32 = 0x41E00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXH_A1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=5 (condition PL (plus/positive))
#[test]
fn test_aarch32_strexh_a1_a_combo_5_390_51e00390() {
    // Encoding: 0x51E00390
    // Test aarch32_STREXH_A1_A field combination: cond=5, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rn=0, Rd=0, cond=5, Rt=0
    let encoding: u32 = 0x51E00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXH_A1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=6 (condition VS (overflow set))
#[test]
fn test_aarch32_strexh_a1_a_combo_6_390_61e00390() {
    // Encoding: 0x61E00390
    // Test aarch32_STREXH_A1_A field combination: cond=6, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=6, Rd=0
    let encoding: u32 = 0x61E00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXH_A1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=7 (condition VC (overflow clear))
#[test]
fn test_aarch32_strexh_a1_a_combo_7_390_71e00390() {
    // Encoding: 0x71E00390
    // Test aarch32_STREXH_A1_A field combination: cond=7, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: cond=7, Rn=0, Rd=0, Rt=0
    let encoding: u32 = 0x71E00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXH_A1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=8 (condition HI (unsigned higher))
#[test]
fn test_aarch32_strexh_a1_a_combo_8_390_81e00390() {
    // Encoding: 0x81E00390
    // Test aarch32_STREXH_A1_A field combination: cond=8, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: cond=8, Rt=0, Rn=0, Rd=0
    let encoding: u32 = 0x81E00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXH_A1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=9 (condition LS (unsigned lower or same))
#[test]
fn test_aarch32_strexh_a1_a_combo_9_390_91e00390() {
    // Encoding: 0x91E00390
    // Test aarch32_STREXH_A1_A field combination: cond=9, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rn=0, Rt=0, Rd=0, cond=9
    let encoding: u32 = 0x91E00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXH_A1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=10 (condition GE (signed >=))
#[test]
fn test_aarch32_strexh_a1_a_combo_10_390_a1e00390() {
    // Encoding: 0xA1E00390
    // Test aarch32_STREXH_A1_A field combination: cond=10, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rn=0, Rd=0, Rt=0, cond=10
    let encoding: u32 = 0xA1E00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXH_A1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=11 (condition LT (signed <))
#[test]
fn test_aarch32_strexh_a1_a_combo_11_390_b1e00390() {
    // Encoding: 0xB1E00390
    // Test aarch32_STREXH_A1_A field combination: cond=11, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rt=0, Rd=0, Rn=0, cond=11
    let encoding: u32 = 0xB1E00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXH_A1_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=12 (condition GT (signed >))
#[test]
fn test_aarch32_strexh_a1_a_combo_12_390_c1e00390() {
    // Encoding: 0xC1E00390
    // Test aarch32_STREXH_A1_A field combination: cond=12, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: cond=12, Rn=0, Rd=0, Rt=0
    let encoding: u32 = 0xC1E00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXH_A1_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=13 (condition LE (signed <=))
#[test]
fn test_aarch32_strexh_a1_a_combo_13_390_d1e00390() {
    // Encoding: 0xD1E00390
    // Test aarch32_STREXH_A1_A field combination: cond=13, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=13, Rd=0
    let encoding: u32 = 0xD1E00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXH_A1_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=14 (condition AL (always))
#[test]
fn test_aarch32_strexh_a1_a_combo_14_390_e1e00390() {
    // Encoding: 0xE1E00390
    // Test aarch32_STREXH_A1_A field combination: cond=14, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rn=0, Rt=0, Rd=0, cond=14
    let encoding: u32 = 0xE1E00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXH_A1_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=15 (condition NV (never, reserved))
#[test]
fn test_aarch32_strexh_a1_a_combo_15_390_f1e00390() {
    // Encoding: 0xF1E00390
    // Test aarch32_STREXH_A1_A field combination: cond=15, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rt=0, Rn=0, Rd=0, cond=15
    let encoding: u32 = 0xF1E00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXH_A1_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_strexh_a1_a_combo_16_390_01e00390() {
    // Encoding: 0x01E00390
    // Test aarch32_STREXH_A1_A field combination: cond=0, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: cond=0, Rn=0, Rt=0, Rd=0
    let encoding: u32 = 0x01E00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXH_A1_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_strexh_a1_a_combo_17_390_01e10390() {
    // Encoding: 0x01E10390
    // Test aarch32_STREXH_A1_A field combination: cond=0, Rn=1, Rd=0, Rt=0
    // ISET: A32
    // Fields: cond=0, Rt=0, Rn=1, Rd=0
    let encoding: u32 = 0x01E10390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXH_A1_A
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch32_strexh_a1_a_combo_18_390_01e00390() {
    // Encoding: 0x01E00390
    // Test aarch32_STREXH_A1_A field combination: cond=0, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rn=0, Rd=0, cond=0, Rt=0
    let encoding: u32 = 0x01E00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXH_A1_A
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch32_strexh_a1_a_combo_19_390_01e01390() {
    // Encoding: 0x01E01390
    // Test aarch32_STREXH_A1_A field combination: cond=0, Rn=0, Rd=1, Rt=0
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=0, Rd=1
    let encoding: u32 = 0x01E01390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXH_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_strexh_a1_a_special_cond_0_condition_eq_912_01e00390() {
    // Encoding: 0x01E00390
    // Test aarch32_STREXH_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: Rd=0, cond=0, Rt=0, Rn=0
    let encoding: u32 = 0x01E00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXH_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_strexh_a1_a_special_cond_1_condition_ne_912_11e00390() {
    // Encoding: 0x11E00390
    // Test aarch32_STREXH_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: Rd=0, Rn=0, cond=1, Rt=0
    let encoding: u32 = 0x11E00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXH_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_strexh_a1_a_special_cond_2_condition_cs_hs_912_21e00390() {
    // Encoding: 0x21E00390
    // Test aarch32_STREXH_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: cond=2, Rd=0, Rt=0, Rn=0
    let encoding: u32 = 0x21E00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXH_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_strexh_a1_a_special_cond_3_condition_cc_lo_912_31e00390() {
    // Encoding: 0x31E00390
    // Test aarch32_STREXH_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: Rn=0, Rd=0, Rt=0, cond=3
    let encoding: u32 = 0x31E00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXH_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_strexh_a1_a_special_cond_4_condition_mi_912_41e00390() {
    // Encoding: 0x41E00390
    // Test aarch32_STREXH_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: cond=4, Rn=0, Rt=0, Rd=0
    let encoding: u32 = 0x41E00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXH_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_strexh_a1_a_special_cond_5_condition_pl_912_51e00390() {
    // Encoding: 0x51E00390
    // Test aarch32_STREXH_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: Rt=0, cond=5, Rd=0, Rn=0
    let encoding: u32 = 0x51E00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXH_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_strexh_a1_a_special_cond_6_condition_vs_912_61e00390() {
    // Encoding: 0x61E00390
    // Test aarch32_STREXH_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: cond=6, Rd=0, Rt=0, Rn=0
    let encoding: u32 = 0x61E00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXH_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_strexh_a1_a_special_cond_7_condition_vc_912_71e00390() {
    // Encoding: 0x71E00390
    // Test aarch32_STREXH_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: cond=7, Rt=0, Rn=0, Rd=0
    let encoding: u32 = 0x71E00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXH_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_strexh_a1_a_special_cond_8_condition_hi_912_81e00390() {
    // Encoding: 0x81E00390
    // Test aarch32_STREXH_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: Rn=0, Rd=0, Rt=0, cond=8
    let encoding: u32 = 0x81E00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXH_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_strexh_a1_a_special_cond_9_condition_ls_912_91e00390() {
    // Encoding: 0x91E00390
    // Test aarch32_STREXH_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: Rd=0, cond=9, Rt=0, Rn=0
    let encoding: u32 = 0x91E00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXH_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_strexh_a1_a_special_cond_10_condition_ge_912_a1e00390() {
    // Encoding: 0xA1E00390
    // Test aarch32_STREXH_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: Rd=0, cond=10, Rt=0, Rn=0
    let encoding: u32 = 0xA1E00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXH_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_strexh_a1_a_special_cond_11_condition_lt_912_b1e00390() {
    // Encoding: 0xB1E00390
    // Test aarch32_STREXH_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: Rd=0, cond=11, Rt=0, Rn=0
    let encoding: u32 = 0xB1E00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXH_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_strexh_a1_a_special_cond_12_condition_gt_912_c1e00390() {
    // Encoding: 0xC1E00390
    // Test aarch32_STREXH_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: Rn=0, cond=12, Rt=0, Rd=0
    let encoding: u32 = 0xC1E00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXH_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_strexh_a1_a_special_cond_13_condition_le_912_d1e00390() {
    // Encoding: 0xD1E00390
    // Test aarch32_STREXH_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: Rn=0, Rd=0, cond=13, Rt=0
    let encoding: u32 = 0xD1E00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXH_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_strexh_a1_a_special_cond_14_condition_al_912_e1e00390() {
    // Encoding: 0xE1E00390
    // Test aarch32_STREXH_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: Rt=0, Rd=0, Rn=0, cond=14
    let encoding: u32 = 0xE1E00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXH_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_strexh_a1_a_special_cond_15_condition_nv_912_f1e00390() {
    // Encoding: 0xF1E00390
    // Test aarch32_STREXH_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: Rd=0, cond=15, Rn=0, Rt=0
    let encoding: u32 = 0xF1E00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXH_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strexh_a1_a_invalid_0_390_01e00390() {
    // Encoding: 0x01E00390
    // Test aarch32_STREXH_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }
    // ISET: A32
    // Fields: Rn=0, Rd=0, cond=0, Rt=0
    let encoding: u32 = 0x01E00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STREXH_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strexh_a1_a_invalid_1_390_01e00390() {
    // Encoding: 0x01E00390
    // Test aarch32_STREXH_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Rn=0, Rd=0, cond=0, Rt=0
    let encoding: u32 = 0x01E00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STREXH_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strexh_a1_a_invalid_2_390_01e00390() {
    // Encoding: 0x01E00390
    // Test aarch32_STREXH_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) }
    // ISET: A32
    // Fields: cond=0, Rn=0, Rt=0, Rd=0
    let encoding: u32 = 0x01E00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STREXH_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strexh_a1_a_invalid_3_390_01e00390() {
    // Encoding: 0x01E00390
    // Test aarch32_STREXH_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Rn=0, Rd=0, cond=0, Rt=0
    let encoding: u32 = 0x01E00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STREXH_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_strexh_t1_a_field_rn_0_min_50_e8c00050() {
    // Thumb encoding (32): 0xE8C00050
    // Test aarch32_STREXH_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rt=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C00050;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREXH_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_strexh_t1_a_field_rn_1_poweroftwo_50_e8c10050() {
    // Thumb encoding (32): 0xE8C10050
    // Test aarch32_STREXH_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rd=0, Rn=1, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C10050;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREXH_T1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_strexh_t1_a_field_rt_0_min_50_e8c00050() {
    // Thumb encoding (32): 0xE8C00050
    // Test aarch32_STREXH_T1_A field Rt = 0 (Min)
    // ISET: T32
    // Fields: Rd=0, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C00050;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREXH_T1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_strexh_t1_a_field_rt_1_poweroftwo_50_e8c01050() {
    // Thumb encoding (32): 0xE8C01050
    // Test aarch32_STREXH_T1_A field Rt = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Rt=1, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C01050;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREXH_T1_A
/// ASL: `field Rd 0 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_strexh_t1_a_field_rd_0_min_50_e8c00050() {
    // Thumb encoding (32): 0xE8C00050
    // Test aarch32_STREXH_T1_A field Rd = 0 (Min)
    // ISET: T32
    // Fields: Rt=0, Rd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C00050;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREXH_T1_A
/// ASL: `field Rd 0 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_strexh_t1_a_field_rd_1_poweroftwo_50_e8c00051() {
    // Thumb encoding (32): 0xE8C00051
    // Test aarch32_STREXH_T1_A field Rd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, Rn=0, Rd=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C00051;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREXH_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_strexh_t1_a_combo_0_50_e8c00050() {
    // Thumb encoding (32): 0xE8C00050
    // Test aarch32_STREXH_T1_A field combination: Rn=0, Rt=0, Rd=0
    // ISET: T32
    // Fields: Rt=0, Rn=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C00050;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREXH_T1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_strexh_t1_a_combo_1_50_e8c10050() {
    // Thumb encoding (32): 0xE8C10050
    // Test aarch32_STREXH_T1_A field combination: Rn=1, Rt=0, Rd=0
    // ISET: T32
    // Fields: Rd=0, Rn=1, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C10050;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREXH_T1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=0 (register index 0 (first register))
#[test]
fn test_aarch32_strexh_t1_a_combo_2_50_e8c00050() {
    // Thumb encoding (32): 0xE8C00050
    // Test aarch32_STREXH_T1_A field combination: Rn=0, Rt=0, Rd=0
    // ISET: T32
    // Fields: Rn=0, Rd=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C00050;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREXH_T1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=1 (register index 1 (second register))
#[test]
fn test_aarch32_strexh_t1_a_combo_3_50_e8c01050() {
    // Thumb encoding (32): 0xE8C01050
    // Test aarch32_STREXH_T1_A field combination: Rn=0, Rt=1, Rd=0
    // ISET: T32
    // Fields: Rn=0, Rt=1, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C01050;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREXH_T1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch32_strexh_t1_a_combo_4_50_e8c00050() {
    // Thumb encoding (32): 0xE8C00050
    // Test aarch32_STREXH_T1_A field combination: Rn=0, Rt=0, Rd=0
    // ISET: T32
    // Fields: Rt=0, Rn=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C00050;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREXH_T1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch32_strexh_t1_a_combo_5_50_e8c00051() {
    // Thumb encoding (32): 0xE8C00051
    // Test aarch32_STREXH_T1_A field combination: Rn=0, Rt=0, Rd=1
    // ISET: T32
    // Fields: Rd=1, Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C00051;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREXH_T1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rt=1 (same register test (reg=1))
#[test]
fn test_aarch32_strexh_t1_a_combo_6_50_e8c11050() {
    // Thumb encoding (32): 0xE8C11050
    // Test aarch32_STREXH_T1_A field combination: Rn=1, Rt=1, Rd=0
    // ISET: T32
    // Fields: Rd=0, Rn=1, Rt=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C11050;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREXH_T1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rt=31 (same register test (reg=31))
#[test]
fn test_aarch32_strexh_t1_a_combo_7_50_e8cff050() {
    // Thumb encoding (32): 0xE8CFF050
    // Test aarch32_STREXH_T1_A field combination: Rn=31, Rt=31, Rd=0
    // ISET: T32
    // Fields: Rn=31, Rd=0, Rt=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8CFF050;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREXH_T1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch32_strexh_t1_a_combo_8_50_e8c10051() {
    // Thumb encoding (32): 0xE8C10051
    // Test aarch32_STREXH_T1_A field combination: Rn=1, Rt=0, Rd=1
    // ISET: T32
    // Fields: Rt=0, Rn=1, Rd=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C10051;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREXH_T1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch32_strexh_t1_a_combo_9_50_e8cf005f() {
    // Thumb encoding (32): 0xE8CF005F
    // Test aarch32_STREXH_T1_A field combination: Rn=31, Rt=0, Rd=31
    // ISET: T32
    // Fields: Rt=0, Rn=31, Rd=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8CF005F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREXH_T1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch32_strexh_t1_a_combo_10_50_e8c01051() {
    // Thumb encoding (32): 0xE8C01051
    // Test aarch32_STREXH_T1_A field combination: Rn=0, Rt=1, Rd=1
    // ISET: T32
    // Fields: Rt=1, Rn=0, Rd=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C01051;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREXH_T1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch32_strexh_t1_a_combo_11_50_e8c0f05f() {
    // Thumb encoding (32): 0xE8C0F05F
    // Test aarch32_STREXH_T1_A field combination: Rn=0, Rt=31, Rd=31
    // ISET: T32
    // Fields: Rn=0, Rt=31, Rd=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C0F05F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREXH_T1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strexh_t1_a_invalid_0_50_e8c00050() {
    // Thumb encoding (32): 0xE8C00050
    // Test aarch32_STREXH_T1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }
    // ISET: T32
    // Fields: Rd=0, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C00050;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_STREXH_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strexh_t1_a_invalid_1_50_e8c00050() {
    // Thumb encoding (32): 0xE8C00050
    // Test aarch32_STREXH_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rn=0, Rt=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C00050;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_STREXH_T1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strexh_t1_a_invalid_2_50_e8c00050() {
    // Thumb encoding (32): 0xE8C00050
    // Test aarch32_STREXH_T1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) }
    // ISET: T32
    // Fields: Rt=0, Rd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C00050;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_STREXH_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strexh_t1_a_invalid_3_50_e8c00050() {
    // Thumb encoding (32): 0xE8C00050
    // Test aarch32_STREXH_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rn=0, Rt=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C00050;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_STREXH_A1_A
/// ASL: `SMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple multiply
#[test]
fn test_aarch32_strexh_a1_a_smull_oracle_0_9b227c20() {
    // Test SMULL: simple multiply (oracle)
    // Encoding: 0x9B227C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x2);
    set_w(&mut cpu, 2, 0x3);
    let encoding: u32 = 0x9B227C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6, "X0 should be 0x0000000000000006");
}

/// Provenance: aarch32_STREXH_A1_A
/// ASL: `SMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max 32-bit * 2
#[test]
fn test_aarch32_strexh_a1_a_smull_oracle_1_9b227c20() {
    // Test SMULL: max 32-bit * 2 (oracle)
    // Encoding: 0x9B227C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x9B227C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFE, "X0 should be 0xFFFFFFFFFFFFFFFE");
}

/// Provenance: aarch32_STREXH_A1_A
/// ASL: `SMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// large positive * large positive
#[test]
fn test_aarch32_strexh_a1_a_smull_oracle_2_9b227c20() {
    // Test SMULL: large positive * large positive (oracle)
    // Encoding: 0x9B227C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    set_w(&mut cpu, 2, 0x7FFFFFFF);
    let encoding: u32 = 0x9B227C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x3FFFFFFF00000001");
}

/// Provenance: aarch32_STREXH_A1_A
/// ASL: `SMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max unsigned * max unsigned
#[test]
fn test_aarch32_strexh_a1_a_smull_oracle_3_9b227c20() {
    // Test SMULL: max unsigned * max unsigned (oracle)
    // Encoding: 0x9B227C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x9B227C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x0000000000000001");
}

/// Provenance: aarch32_STREXH_A1_A
/// ASL: `SMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// medium values
#[test]
fn test_aarch32_strexh_a1_a_smull_oracle_4_9b227c20() {
    // Test SMULL: medium values (oracle)
    // Encoding: 0x9B227C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xC8);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x9B227C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4E20, "X0 should be 0x0000000000004E20");
}

/// Provenance: aarch32_STREXH_A1_A
/// ASL: `SMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// 16-bit values
#[test]
fn test_aarch32_strexh_a1_a_smull_oracle_5_9b227c20() {
    // Test SMULL: 16-bit values (oracle)
    // Encoding: 0x9B227C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1234);
    set_w(&mut cpu, 2, 0x5678);
    let encoding: u32 = 0x9B227C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6260060, "X0 should be 0x0000000006260060");
}

/// Provenance: aarch32_STREXH_A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_strexh_a1_a_store_0_01e10390() {
    // Test aarch32_STREXH_A1_A memory store: 8 bytes
    // Encoding: 0x01E10390
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0x01E10390;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_STREXH_T1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_strexh_t1_a_store_0_e8c10050() {
    // Test aarch32_STREXH_T1_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xE8C10050;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// aarch32_STRB_r_A Tests
// ============================================================================

/// Provenance: aarch32_STRB_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_strb_r_a1_a_field_cond_0_min_0_06400000() {
    // Encoding: 0x06400000
    // Test aarch32_STRB_r_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, U=0, W=0, type1=0, cond=0, P=0, Rt=0, imm5=0, Rm=0
    let encoding: u32 = 0x06400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_strb_r_a1_a_field_cond_1_poweroftwo_0_16400000() {
    // Encoding: 0x16400000
    // Test aarch32_STRB_r_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=1, U=0, type1=0, imm5=0, Rt=0, W=0, Rm=0, P=0
    let encoding: u32 = 0x16400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_strb_r_a1_a_field_cond_2_poweroftwo_0_26400000() {
    // Encoding: 0x26400000
    // Test aarch32_STRB_r_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, cond=2, U=0, Rt=0, Rm=0, imm5=0, Rn=0, P=0, type1=0
    let encoding: u32 = 0x26400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_strb_r_a1_a_field_cond_3_poweroftwo_0_36400000() {
    // Encoding: 0x36400000
    // Test aarch32_STRB_r_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=3, Rt=0, P=0, W=0, imm5=0, Rm=0, U=0, type1=0, Rn=0
    let encoding: u32 = 0x36400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_strb_r_a1_a_field_cond_4_poweroftwo_0_46400000() {
    // Encoding: 0x46400000
    // Test aarch32_STRB_r_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, cond=4, Rt=0, Rn=0, W=0, U=0, P=0, imm5=0, type1=0
    let encoding: u32 = 0x46400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_strb_r_a1_a_field_cond_5_poweroftwo_0_56400000() {
    // Encoding: 0x56400000
    // Test aarch32_STRB_r_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=5, W=0, imm5=0, Rn=0, Rt=0, type1=0, Rm=0, P=0, U=0
    let encoding: u32 = 0x56400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_strb_r_a1_a_field_cond_6_poweroftwo_0_66400000() {
    // Encoding: 0x66400000
    // Test aarch32_STRB_r_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: imm5=0, P=0, Rn=0, W=0, Rt=0, cond=6, U=0, Rm=0, type1=0
    let encoding: u32 = 0x66400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_strb_r_a1_a_field_cond_7_poweroftwo_0_76400000() {
    // Encoding: 0x76400000
    // Test aarch32_STRB_r_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: type1=0, Rn=0, Rm=0, cond=7, Rt=0, imm5=0, P=0, W=0, U=0
    let encoding: u32 = 0x76400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_strb_r_a1_a_field_cond_8_poweroftwo_0_86400000() {
    // Encoding: 0x86400000
    // Test aarch32_STRB_r_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: type1=0, imm5=0, Rn=0, P=0, U=0, Rm=0, Rt=0, cond=8, W=0
    let encoding: u32 = 0x86400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_strb_r_a1_a_field_cond_9_poweroftwo_0_96400000() {
    // Encoding: 0x96400000
    // Test aarch32_STRB_r_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, W=0, cond=9, Rn=0, imm5=0, P=0, Rm=0, type1=0, U=0
    let encoding: u32 = 0x96400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_strb_r_a1_a_field_cond_10_poweroftwo_0_a6400000() {
    // Encoding: 0xA6400000
    // Test aarch32_STRB_r_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, Rm=0, U=0, imm5=0, Rn=0, Rt=0, cond=10, W=0, type1=0
    let encoding: u32 = 0xA6400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_strb_r_a1_a_field_cond_11_poweroftwo_0_b6400000() {
    // Encoding: 0xB6400000
    // Test aarch32_STRB_r_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=11, Rn=0, Rm=0, W=0, P=0, Rt=0, type1=0, U=0, imm5=0
    let encoding: u32 = 0xB6400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_strb_r_a1_a_field_cond_12_poweroftwo_0_c6400000() {
    // Encoding: 0xC6400000
    // Test aarch32_STRB_r_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: imm5=0, W=0, Rm=0, Rn=0, Rt=0, cond=12, U=0, P=0, type1=0
    let encoding: u32 = 0xC6400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_strb_r_a1_a_field_cond_13_poweroftwo_0_d6400000() {
    // Encoding: 0xD6400000
    // Test aarch32_STRB_r_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, Rn=0, Rm=0, Rt=0, U=0, imm5=0, cond=13, type1=0, P=0
    let encoding: u32 = 0xD6400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_strb_r_a1_a_field_cond_14_poweroftwo_0_e6400000() {
    // Encoding: 0xE6400000
    // Test aarch32_STRB_r_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, cond=14, Rn=0, W=0, imm5=0, P=0, U=0, type1=0, Rt=0
    let encoding: u32 = 0xE6400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_strb_r_a1_a_field_cond_15_max_0_f6400000() {
    // Encoding: 0xF6400000
    // Test aarch32_STRB_r_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: imm5=0, cond=15, Rm=0, type1=0, Rn=0, P=0, Rt=0, U=0, W=0
    let encoding: u32 = 0xF6400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_r_A1_A
/// ASL: `field P 24 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_strb_r_a1_a_field_p_0_min_0_06400000() {
    // Encoding: 0x06400000
    // Test aarch32_STRB_r_A1_A field P = 0 (Min)
    // ISET: A32
    // Fields: W=0, imm5=0, type1=0, Rm=0, Rt=0, U=0, P=0, cond=0, Rn=0
    let encoding: u32 = 0x06400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_r_A1_A
/// ASL: `field P 24 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_strb_r_a1_a_field_p_1_max_0_07400000() {
    // Encoding: 0x07400000
    // Test aarch32_STRB_r_A1_A field P = 1 (Max)
    // ISET: A32
    // Fields: P=1, cond=0, W=0, Rt=0, imm5=0, type1=0, U=0, Rm=0, Rn=0
    let encoding: u32 = 0x07400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_r_A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_strb_r_a1_a_field_u_0_min_0_06400000() {
    // Encoding: 0x06400000
    // Test aarch32_STRB_r_A1_A field U = 0 (Min)
    // ISET: A32
    // Fields: type1=0, Rt=0, W=0, Rm=0, P=0, imm5=0, U=0, Rn=0, cond=0
    let encoding: u32 = 0x06400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_r_A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_strb_r_a1_a_field_u_1_max_0_06c00000() {
    // Encoding: 0x06C00000
    // Test aarch32_STRB_r_A1_A field U = 1 (Max)
    // ISET: A32
    // Fields: Rn=0, cond=0, Rm=0, Rt=0, U=1, P=0, imm5=0, W=0, type1=0
    let encoding: u32 = 0x06C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_r_A1_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_strb_r_a1_a_field_w_0_min_0_06400000() {
    // Encoding: 0x06400000
    // Test aarch32_STRB_r_A1_A field W = 0 (Min)
    // ISET: A32
    // Fields: Rt=0, P=0, type1=0, W=0, Rn=0, cond=0, imm5=0, Rm=0, U=0
    let encoding: u32 = 0x06400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_r_A1_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_strb_r_a1_a_field_w_1_max_0_06600000() {
    // Encoding: 0x06600000
    // Test aarch32_STRB_r_A1_A field W = 1 (Max)
    // ISET: A32
    // Fields: P=0, imm5=0, U=0, Rn=0, Rm=0, cond=0, W=1, Rt=0, type1=0
    let encoding: u32 = 0x06600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_r_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_strb_r_a1_a_field_rn_0_min_0_06400000() {
    // Encoding: 0x06400000
    // Test aarch32_STRB_r_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: U=0, P=0, imm5=0, type1=0, Rn=0, Rt=0, W=0, Rm=0, cond=0
    let encoding: u32 = 0x06400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_r_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_strb_r_a1_a_field_rn_1_poweroftwo_0_06410000() {
    // Encoding: 0x06410000
    // Test aarch32_STRB_r_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, type1=0, Rn=1, Rt=0, cond=0, P=0, W=0, U=0, imm5=0
    let encoding: u32 = 0x06410000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_r_A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_strb_r_a1_a_field_rt_0_min_0_06400000() {
    // Encoding: 0x06400000
    // Test aarch32_STRB_r_A1_A field Rt = 0 (Min)
    // ISET: A32
    // Fields: P=0, U=0, type1=0, Rm=0, Rn=0, W=0, Rt=0, cond=0, imm5=0
    let encoding: u32 = 0x06400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_r_A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_strb_r_a1_a_field_rt_1_poweroftwo_0_06401000() {
    // Encoding: 0x06401000
    // Test aarch32_STRB_r_A1_A field Rt = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Rt=1, P=0, imm5=0, U=0, Rn=0, type1=0, Rm=0, W=0
    let encoding: u32 = 0x06401000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_strb_r_a1_a_field_imm5_0_zero_0_06400000() {
    // Encoding: 0x06400000
    // Test aarch32_STRB_r_A1_A field imm5 = 0 (Zero)
    // ISET: A32
    // Fields: P=0, Rn=0, type1=0, U=0, W=0, cond=0, Rt=0, Rm=0, imm5=0
    let encoding: u32 = 0x06400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_strb_r_a1_a_field_imm5_1_poweroftwo_0_06400080() {
    // Encoding: 0x06400080
    // Test aarch32_STRB_r_A1_A field imm5 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, U=0, Rn=0, cond=0, type1=0, Rt=0, imm5=1, P=0, W=0
    let encoding: u32 = 0x06400080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_strb_r_a1_a_field_imm5_3_poweroftwominusone_0_06400180() {
    // Encoding: 0x06400180
    // Test aarch32_STRB_r_A1_A field imm5 = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm5=3, U=0, cond=0, Rt=0, W=0, Rn=0, type1=0, Rm=0, P=0
    let encoding: u32 = 0x06400180;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_strb_r_a1_a_field_imm5_4_poweroftwo_0_06400200() {
    // Encoding: 0x06400200
    // Test aarch32_STRB_r_A1_A field imm5 = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, cond=0, type1=0, U=0, Rm=0, imm5=4, P=0, Rn=0, Rt=0
    let encoding: u32 = 0x06400200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_strb_r_a1_a_field_imm5_7_poweroftwominusone_0_06400380() {
    // Encoding: 0x06400380
    // Test aarch32_STRB_r_A1_A field imm5 = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rt=0, W=0, P=0, Rn=0, U=0, imm5=7, type1=0, Rm=0, cond=0
    let encoding: u32 = 0x06400380;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_strb_r_a1_a_field_imm5_8_poweroftwo_0_06400400() {
    // Encoding: 0x06400400
    // Test aarch32_STRB_r_A1_A field imm5 = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: imm5=8, W=0, Rm=0, U=0, Rt=0, type1=0, P=0, cond=0, Rn=0
    let encoding: u32 = 0x06400400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 15, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (15)
#[test]
fn test_aarch32_strb_r_a1_a_field_imm5_15_poweroftwominusone_0_06400780() {
    // Encoding: 0x06400780
    // Test aarch32_STRB_r_A1_A field imm5 = 15 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, W=0, Rt=0, P=0, U=0, type1=0, Rm=0, Rn=0, imm5=15
    let encoding: u32 = 0x06400780;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_strb_r_a1_a_field_imm5_16_poweroftwo_0_06400800() {
    // Encoding: 0x06400800
    // Test aarch32_STRB_r_A1_A field imm5 = 16 (PowerOfTwo)
    // ISET: A32
    // Fields: type1=0, imm5=16, U=0, Rm=0, W=0, Rn=0, cond=0, P=0, Rt=0
    let encoding: u32 = 0x06400800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 31, boundary: Max }
/// maximum immediate (31)
#[test]
fn test_aarch32_strb_r_a1_a_field_imm5_31_max_0_06400f80() {
    // Encoding: 0x06400F80
    // Test aarch32_STRB_r_A1_A field imm5 = 31 (Max)
    // ISET: A32
    // Fields: imm5=31, Rm=0, W=0, cond=0, Rn=0, Rt=0, type1=0, P=0, U=0
    let encoding: u32 = 0x06400F80;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_r_A1_A
/// ASL: `field type1 5 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_strb_r_a1_a_field_type1_0_min_0_06400000() {
    // Encoding: 0x06400000
    // Test aarch32_STRB_r_A1_A field type1 = 0 (Min)
    // ISET: A32
    // Fields: P=0, imm5=0, U=0, Rt=0, W=0, type1=0, cond=0, Rm=0, Rn=0
    let encoding: u32 = 0x06400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_r_A1_A
/// ASL: `field type1 5 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_strb_r_a1_a_field_type1_1_poweroftwo_0_06400020() {
    // Encoding: 0x06400020
    // Test aarch32_STRB_r_A1_A field type1 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, W=0, Rt=0, Rn=0, Rm=0, cond=0, P=0, type1=1, imm5=0
    let encoding: u32 = 0x06400020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_r_A1_A
/// ASL: `field type1 5 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_aarch32_strb_r_a1_a_field_type1_3_max_0_06400060() {
    // Encoding: 0x06400060
    // Test aarch32_STRB_r_A1_A field type1 = 3 (Max)
    // ISET: A32
    // Fields: imm5=0, Rt=0, cond=0, U=0, W=0, P=0, Rm=0, Rn=0, type1=3
    let encoding: u32 = 0x06400060;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_r_A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_strb_r_a1_a_field_rm_0_min_0_06400000() {
    // Encoding: 0x06400000
    // Test aarch32_STRB_r_A1_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: W=0, type1=0, Rm=0, P=0, cond=0, Rt=0, U=0, imm5=0, Rn=0
    let encoding: u32 = 0x06400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_r_A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_strb_r_a1_a_field_rm_1_poweroftwo_0_06400001() {
    // Encoding: 0x06400001
    // Test aarch32_STRB_r_A1_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, cond=0, U=0, Rt=0, W=0, imm5=0, Rn=0, type1=0, Rm=1
    let encoding: u32 = 0x06400001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_r_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_strb_r_a1_a_combo_0_0_06400000() {
    // Encoding: 0x06400000
    // Test aarch32_STRB_r_A1_A field combination: cond=0, P=0, U=0, W=0, Rn=0, Rt=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: cond=0, W=0, P=0, imm5=0, Rm=0, U=0, Rn=0, Rt=0, type1=0
    let encoding: u32 = 0x06400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_r_A1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=1 (condition NE (not equal))
#[test]
fn test_aarch32_strb_r_a1_a_combo_1_0_16400000() {
    // Encoding: 0x16400000
    // Test aarch32_STRB_r_A1_A field combination: cond=1, P=0, U=0, W=0, Rn=0, Rt=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: U=0, imm5=0, Rn=0, P=0, W=0, Rt=0, type1=0, cond=1, Rm=0
    let encoding: u32 = 0x16400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_r_A1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=2 (condition CS/HS (carry set))
#[test]
fn test_aarch32_strb_r_a1_a_combo_2_0_26400000() {
    // Encoding: 0x26400000
    // Test aarch32_STRB_r_A1_A field combination: cond=2, P=0, U=0, W=0, Rn=0, Rt=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: type1=0, W=0, cond=2, imm5=0, Rt=0, P=0, Rm=0, Rn=0, U=0
    let encoding: u32 = 0x26400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_r_A1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=3 (condition CC/LO (carry clear))
#[test]
fn test_aarch32_strb_r_a1_a_combo_3_0_36400000() {
    // Encoding: 0x36400000
    // Test aarch32_STRB_r_A1_A field combination: cond=3, P=0, U=0, W=0, Rn=0, Rt=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: Rt=0, type1=0, cond=3, imm5=0, Rn=0, P=0, Rm=0, U=0, W=0
    let encoding: u32 = 0x36400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_r_A1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=4 (condition MI (minus/negative))
#[test]
fn test_aarch32_strb_r_a1_a_combo_4_0_46400000() {
    // Encoding: 0x46400000
    // Test aarch32_STRB_r_A1_A field combination: cond=4, P=0, U=0, W=0, Rn=0, Rt=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: U=0, W=0, Rt=0, type1=0, Rn=0, imm5=0, P=0, cond=4, Rm=0
    let encoding: u32 = 0x46400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_r_A1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=5 (condition PL (plus/positive))
#[test]
fn test_aarch32_strb_r_a1_a_combo_5_0_56400000() {
    // Encoding: 0x56400000
    // Test aarch32_STRB_r_A1_A field combination: cond=5, P=0, U=0, W=0, Rn=0, Rt=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: P=0, cond=5, W=0, Rm=0, imm5=0, U=0, Rt=0, Rn=0, type1=0
    let encoding: u32 = 0x56400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_r_A1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=6 (condition VS (overflow set))
#[test]
fn test_aarch32_strb_r_a1_a_combo_6_0_66400000() {
    // Encoding: 0x66400000
    // Test aarch32_STRB_r_A1_A field combination: cond=6, P=0, U=0, W=0, Rn=0, Rt=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: Rn=0, P=0, imm5=0, U=0, Rm=0, W=0, cond=6, Rt=0, type1=0
    let encoding: u32 = 0x66400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_r_A1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=7 (condition VC (overflow clear))
#[test]
fn test_aarch32_strb_r_a1_a_combo_7_0_76400000() {
    // Encoding: 0x76400000
    // Test aarch32_STRB_r_A1_A field combination: cond=7, P=0, U=0, W=0, Rn=0, Rt=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: cond=7, type1=0, U=0, W=0, Rt=0, Rm=0, P=0, Rn=0, imm5=0
    let encoding: u32 = 0x76400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_r_A1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=8 (condition HI (unsigned higher))
#[test]
fn test_aarch32_strb_r_a1_a_combo_8_0_86400000() {
    // Encoding: 0x86400000
    // Test aarch32_STRB_r_A1_A field combination: cond=8, P=0, U=0, W=0, Rn=0, Rt=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: Rm=0, type1=0, Rn=0, imm5=0, Rt=0, P=0, U=0, cond=8, W=0
    let encoding: u32 = 0x86400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_r_A1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=9 (condition LS (unsigned lower or same))
#[test]
fn test_aarch32_strb_r_a1_a_combo_9_0_96400000() {
    // Encoding: 0x96400000
    // Test aarch32_STRB_r_A1_A field combination: cond=9, P=0, U=0, W=0, Rn=0, Rt=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: type1=0, P=0, U=0, W=0, Rn=0, Rt=0, imm5=0, cond=9, Rm=0
    let encoding: u32 = 0x96400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_r_A1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=10 (condition GE (signed >=))
#[test]
fn test_aarch32_strb_r_a1_a_combo_10_0_a6400000() {
    // Encoding: 0xA6400000
    // Test aarch32_STRB_r_A1_A field combination: cond=10, P=0, U=0, W=0, Rn=0, Rt=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: Rm=0, Rn=0, imm5=0, cond=10, type1=0, Rt=0, P=0, W=0, U=0
    let encoding: u32 = 0xA6400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_r_A1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=11 (condition LT (signed <))
#[test]
fn test_aarch32_strb_r_a1_a_combo_11_0_b6400000() {
    // Encoding: 0xB6400000
    // Test aarch32_STRB_r_A1_A field combination: cond=11, P=0, U=0, W=0, Rn=0, Rt=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: Rm=0, Rt=0, type1=0, imm5=0, cond=11, P=0, Rn=0, W=0, U=0
    let encoding: u32 = 0xB6400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_r_A1_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=12 (condition GT (signed >))
#[test]
fn test_aarch32_strb_r_a1_a_combo_12_0_c6400000() {
    // Encoding: 0xC6400000
    // Test aarch32_STRB_r_A1_A field combination: cond=12, P=0, U=0, W=0, Rn=0, Rt=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: P=0, Rn=0, imm5=0, type1=0, U=0, cond=12, Rt=0, W=0, Rm=0
    let encoding: u32 = 0xC6400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_r_A1_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=13 (condition LE (signed <=))
#[test]
fn test_aarch32_strb_r_a1_a_combo_13_0_d6400000() {
    // Encoding: 0xD6400000
    // Test aarch32_STRB_r_A1_A field combination: cond=13, P=0, U=0, W=0, Rn=0, Rt=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: cond=13, imm5=0, U=0, P=0, type1=0, Rm=0, Rt=0, W=0, Rn=0
    let encoding: u32 = 0xD6400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_r_A1_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=14 (condition AL (always))
#[test]
fn test_aarch32_strb_r_a1_a_combo_14_0_e6400000() {
    // Encoding: 0xE6400000
    // Test aarch32_STRB_r_A1_A field combination: cond=14, P=0, U=0, W=0, Rn=0, Rt=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: W=0, Rn=0, type1=0, cond=14, Rm=0, U=0, P=0, Rt=0, imm5=0
    let encoding: u32 = 0xE6400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_r_A1_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=15 (condition NV (never, reserved))
#[test]
fn test_aarch32_strb_r_a1_a_combo_15_0_f6400000() {
    // Encoding: 0xF6400000
    // Test aarch32_STRB_r_A1_A field combination: cond=15, P=0, U=0, W=0, Rn=0, Rt=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: cond=15, W=0, Rn=0, Rt=0, imm5=0, type1=0, Rm=0, P=0, U=0
    let encoding: u32 = 0xF6400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_r_A1_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// P=0 (minimum value)
#[test]
fn test_aarch32_strb_r_a1_a_combo_16_0_06400000() {
    // Encoding: 0x06400000
    // Test aarch32_STRB_r_A1_A field combination: cond=0, P=0, U=0, W=0, Rn=0, Rt=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: P=0, U=0, type1=0, Rn=0, Rt=0, W=0, cond=0, Rm=0, imm5=0
    let encoding: u32 = 0x06400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_r_A1_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// P=1 (maximum value (1))
#[test]
fn test_aarch32_strb_r_a1_a_combo_17_0_07400000() {
    // Encoding: 0x07400000
    // Test aarch32_STRB_r_A1_A field combination: cond=0, P=1, U=0, W=0, Rn=0, Rt=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: U=0, W=0, cond=0, Rm=0, type1=0, Rt=0, P=1, Rn=0, imm5=0
    let encoding: u32 = 0x07400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_r_A1_A
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=0 (minimum value)
#[test]
fn test_aarch32_strb_r_a1_a_combo_18_0_06400000() {
    // Encoding: 0x06400000
    // Test aarch32_STRB_r_A1_A field combination: cond=0, P=0, U=0, W=0, Rn=0, Rt=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: P=0, cond=0, Rn=0, U=0, imm5=0, W=0, type1=0, Rm=0, Rt=0
    let encoding: u32 = 0x06400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_r_A1_A
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=1 (maximum value (1))
#[test]
fn test_aarch32_strb_r_a1_a_combo_19_0_06c00000() {
    // Encoding: 0x06C00000
    // Test aarch32_STRB_r_A1_A field combination: cond=0, P=0, U=1, W=0, Rn=0, Rt=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: P=0, U=1, Rt=0, Rm=0, cond=0, type1=0, W=0, Rn=0, imm5=0
    let encoding: u32 = 0x06C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_r_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_strb_r_a1_a_special_cond_0_condition_eq_0_06400000() {
    // Encoding: 0x06400000
    // Test aarch32_STRB_r_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: Rt=0, P=0, type1=0, cond=0, imm5=0, Rm=0, W=0, U=0, Rn=0
    let encoding: u32 = 0x06400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_r_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_strb_r_a1_a_special_cond_1_condition_ne_0_16400000() {
    // Encoding: 0x16400000
    // Test aarch32_STRB_r_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: U=0, cond=1, P=0, type1=0, Rt=0, Rm=0, W=0, Rn=0, imm5=0
    let encoding: u32 = 0x16400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_r_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_strb_r_a1_a_special_cond_2_condition_cs_hs_0_26400000() {
    // Encoding: 0x26400000
    // Test aarch32_STRB_r_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: U=0, Rn=0, Rt=0, P=0, type1=0, Rm=0, W=0, cond=2, imm5=0
    let encoding: u32 = 0x26400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_r_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_strb_r_a1_a_special_cond_3_condition_cc_lo_0_36400000() {
    // Encoding: 0x36400000
    // Test aarch32_STRB_r_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: Rm=0, Rt=0, W=0, P=0, type1=0, imm5=0, Rn=0, cond=3, U=0
    let encoding: u32 = 0x36400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_r_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_strb_r_a1_a_special_cond_4_condition_mi_0_46400000() {
    // Encoding: 0x46400000
    // Test aarch32_STRB_r_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: imm5=0, P=0, U=0, Rn=0, Rt=0, Rm=0, type1=0, W=0, cond=4
    let encoding: u32 = 0x46400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_r_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_strb_r_a1_a_special_cond_5_condition_pl_0_56400000() {
    // Encoding: 0x56400000
    // Test aarch32_STRB_r_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: cond=5, Rm=0, type1=0, P=0, imm5=0, W=0, Rn=0, Rt=0, U=0
    let encoding: u32 = 0x56400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_r_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_strb_r_a1_a_special_cond_6_condition_vs_0_66400000() {
    // Encoding: 0x66400000
    // Test aarch32_STRB_r_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: cond=6, Rt=0, P=0, imm5=0, type1=0, Rm=0, U=0, W=0, Rn=0
    let encoding: u32 = 0x66400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_r_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_strb_r_a1_a_special_cond_7_condition_vc_0_76400000() {
    // Encoding: 0x76400000
    // Test aarch32_STRB_r_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: Rt=0, W=0, Rn=0, type1=0, U=0, cond=7, imm5=0, P=0, Rm=0
    let encoding: u32 = 0x76400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_r_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_strb_r_a1_a_special_cond_8_condition_hi_0_86400000() {
    // Encoding: 0x86400000
    // Test aarch32_STRB_r_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: type1=0, imm5=0, Rm=0, P=0, W=0, cond=8, U=0, Rt=0, Rn=0
    let encoding: u32 = 0x86400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_r_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_strb_r_a1_a_special_cond_9_condition_ls_0_96400000() {
    // Encoding: 0x96400000
    // Test aarch32_STRB_r_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: Rt=0, cond=9, Rm=0, W=0, U=0, imm5=0, P=0, Rn=0, type1=0
    let encoding: u32 = 0x96400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_r_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_strb_r_a1_a_special_cond_10_condition_ge_0_a6400000() {
    // Encoding: 0xA6400000
    // Test aarch32_STRB_r_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: U=0, Rt=0, W=0, type1=0, Rm=0, P=0, cond=10, imm5=0, Rn=0
    let encoding: u32 = 0xA6400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_r_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_strb_r_a1_a_special_cond_11_condition_lt_0_b6400000() {
    // Encoding: 0xB6400000
    // Test aarch32_STRB_r_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: type1=0, cond=11, Rm=0, P=0, Rn=0, W=0, imm5=0, Rt=0, U=0
    let encoding: u32 = 0xB6400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_r_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_strb_r_a1_a_special_cond_12_condition_gt_0_c6400000() {
    // Encoding: 0xC6400000
    // Test aarch32_STRB_r_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: U=0, Rn=0, W=0, type1=0, Rm=0, cond=12, P=0, imm5=0, Rt=0
    let encoding: u32 = 0xC6400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_r_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_strb_r_a1_a_special_cond_13_condition_le_0_d6400000() {
    // Encoding: 0xD6400000
    // Test aarch32_STRB_r_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: U=0, P=0, type1=0, Rm=0, W=0, Rn=0, cond=13, imm5=0, Rt=0
    let encoding: u32 = 0xD6400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_r_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_strb_r_a1_a_special_cond_14_condition_al_0_e6400000() {
    // Encoding: 0xE6400000
    // Test aarch32_STRB_r_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: U=0, W=0, Rt=0, imm5=0, Rm=0, P=0, cond=14, Rn=0, type1=0
    let encoding: u32 = 0xE6400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_r_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_strb_r_a1_a_special_cond_15_condition_nv_0_f6400000() {
    // Encoding: 0xF6400000
    // Test aarch32_STRB_r_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: imm5=0, Rn=0, P=0, cond=15, type1=0, Rt=0, Rm=0, U=0, W=0
    let encoding: u32 = 0xF6400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_r_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strb_r_a1_a_invalid_0_0_06400000() {
    // Encoding: 0x06400000
    // Test aarch32_STRB_r_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }
    // ISET: A32
    // Fields: Rt=0, Rm=0, W=0, cond=0, U=0, Rn=0, imm5=0, P=0, type1=0
    let encoding: u32 = 0x06400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STRB_r_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strb_r_a1_a_invalid_1_0_06400000() {
    // Encoding: 0x06400000
    // Test aarch32_STRB_r_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Rm=0, cond=0, P=0, imm5=0, U=0, W=0, type1=0, Rn=0, Rt=0
    let encoding: u32 = 0x06400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STRB_r_A1_A
/// ASL: `Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"wback\" }), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }) } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strb_r_a1_a_invalid_2_0_06400000() {
    // Encoding: 0x06400000
    // Test aarch32_STRB_r_A1_A invalid encoding: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) } }
    // ISET: A32
    // Fields: imm5=0, type1=0, U=0, Rm=0, Rt=0, P=0, cond=0, W=0, Rn=0
    let encoding: u32 = 0x06400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STRB_r_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strb_r_a1_a_invalid_3_0_06400000() {
    // Encoding: 0x06400000
    // Test aarch32_STRB_r_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Rn=0, Rt=0, type1=0, P=0, U=0, cond=0, W=0, Rm=0, imm5=0
    let encoding: u32 = 0x06400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STRB_r_T1_A
/// ASL: `field Rm 22 +: 3`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_strb_r_t1_a_field_rm_0_min_0_54000000() {
    // Thumb encoding (32): 0x54000000
    // Test aarch32_STRB_r_T1_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: Rt=0, Rn=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x54000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_r_T1_A
/// ASL: `field Rm 22 +: 3`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_strb_r_t1_a_field_rm_1_poweroftwo_0_54400000() {
    // Thumb encoding (32): 0x54400000
    // Test aarch32_STRB_r_T1_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, Rm=1, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x54400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_r_T1_A
/// ASL: `field Rn 19 +: 3`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_strb_r_t1_a_field_rn_0_min_0_54000000() {
    // Thumb encoding (32): 0x54000000
    // Test aarch32_STRB_r_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rm=0, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x54000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_r_T1_A
/// ASL: `field Rn 19 +: 3`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_strb_r_t1_a_field_rn_1_poweroftwo_0_54080000() {
    // Thumb encoding (32): 0x54080000
    // Test aarch32_STRB_r_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=1, Rm=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x54080000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_r_T1_A
/// ASL: `field Rt 16 +: 3`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_strb_r_t1_a_field_rt_0_min_0_54000000() {
    // Thumb encoding (32): 0x54000000
    // Test aarch32_STRB_r_T1_A field Rt = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rt=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x54000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_r_T1_A
/// ASL: `field Rt 16 +: 3`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_strb_r_t1_a_field_rt_1_poweroftwo_0_54010000() {
    // Thumb encoding (32): 0x54010000
    // Test aarch32_STRB_r_T1_A field Rt = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=0, Rn=0, Rt=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x54010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_r_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch32_strb_r_t1_a_combo_0_0_54000000() {
    // Thumb encoding (32): 0x54000000
    // Test aarch32_STRB_r_T1_A field combination: Rm=0, Rn=0, Rt=0
    // ISET: T32
    // Fields: Rn=0, Rt=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x54000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_r_T1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_aarch32_strb_r_t1_a_combo_1_0_54400000() {
    // Thumb encoding (32): 0x54400000
    // Test aarch32_STRB_r_T1_A field combination: Rm=1, Rn=0, Rt=0
    // ISET: T32
    // Fields: Rn=0, Rt=0, Rm=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x54400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_r_T1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_strb_r_t1_a_combo_2_0_54000000() {
    // Thumb encoding (32): 0x54000000
    // Test aarch32_STRB_r_T1_A field combination: Rm=0, Rn=0, Rt=0
    // ISET: T32
    // Fields: Rn=0, Rt=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x54000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_r_T1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_strb_r_t1_a_combo_3_0_54080000() {
    // Thumb encoding (32): 0x54080000
    // Test aarch32_STRB_r_T1_A field combination: Rm=0, Rn=1, Rt=0
    // ISET: T32
    // Fields: Rt=0, Rn=1, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x54080000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_r_T1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=0 (register index 0 (first register))
#[test]
fn test_aarch32_strb_r_t1_a_combo_4_0_54000000() {
    // Thumb encoding (32): 0x54000000
    // Test aarch32_STRB_r_T1_A field combination: Rm=0, Rn=0, Rt=0
    // ISET: T32
    // Fields: Rt=0, Rn=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x54000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_r_T1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=1 (register index 1 (second register))
#[test]
fn test_aarch32_strb_r_t1_a_combo_5_0_54010000() {
    // Thumb encoding (32): 0x54010000
    // Test aarch32_STRB_r_T1_A field combination: Rm=0, Rn=0, Rt=1
    // ISET: T32
    // Fields: Rn=0, Rm=0, Rt=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x54010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_r_T1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (same register test (reg=1)), Rn=1 (same register test (reg=1))
#[test]
fn test_aarch32_strb_r_t1_a_combo_6_0_54480000() {
    // Thumb encoding (32): 0x54480000
    // Test aarch32_STRB_r_T1_A field combination: Rm=1, Rn=1, Rt=0
    // ISET: T32
    // Fields: Rn=1, Rt=0, Rm=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x54480000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_r_T1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (same register test (reg=31)), Rn=31 (same register test (reg=31))
#[test]
fn test_aarch32_strb_r_t1_a_combo_7_0_55f80000() {
    // Thumb encoding (32): 0x55F80000
    // Test aarch32_STRB_r_T1_A field combination: Rm=31, Rn=31, Rt=0
    // ISET: T32
    // Fields: Rm=31, Rn=31, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x55F80000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_r_T1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (same register test (reg=1)), Rt=1 (same register test (reg=1))
#[test]
fn test_aarch32_strb_r_t1_a_combo_8_0_54410000() {
    // Thumb encoding (32): 0x54410000
    // Test aarch32_STRB_r_T1_A field combination: Rm=1, Rn=0, Rt=1
    // ISET: T32
    // Fields: Rt=1, Rm=1, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x54410000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_r_T1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (same register test (reg=31)), Rt=31 (same register test (reg=31))
#[test]
fn test_aarch32_strb_r_t1_a_combo_9_0_55c70000() {
    // Thumb encoding (32): 0x55C70000
    // Test aarch32_STRB_r_T1_A field combination: Rm=31, Rn=0, Rt=31
    // ISET: T32
    // Fields: Rt=31, Rm=31, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x55C70000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_r_T1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rt=1 (same register test (reg=1))
#[test]
fn test_aarch32_strb_r_t1_a_combo_10_0_54090000() {
    // Thumb encoding (32): 0x54090000
    // Test aarch32_STRB_r_T1_A field combination: Rm=0, Rn=1, Rt=1
    // ISET: T32
    // Fields: Rm=0, Rt=1, Rn=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x54090000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_r_T1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rt=31 (same register test (reg=31))
#[test]
fn test_aarch32_strb_r_t1_a_combo_11_0_543f0000() {
    // Thumb encoding (32): 0x543F0000
    // Test aarch32_STRB_r_T1_A field combination: Rm=0, Rn=31, Rt=31
    // ISET: T32
    // Fields: Rm=0, Rn=31, Rt=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x543F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_r_T2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_strb_r_t2_a_field_rn_0_min_0_f8000000() {
    // Thumb encoding (32): 0xF8000000
    // Test aarch32_STRB_r_T2_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rt=0, imm2=0, Rn=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_r_T2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_strb_r_t2_a_field_rn_1_poweroftwo_0_f8010000() {
    // Thumb encoding (32): 0xF8010000
    // Test aarch32_STRB_r_T2_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=0, imm2=0, Rn=1, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_r_T2_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_strb_r_t2_a_field_rt_0_min_0_f8000000() {
    // Thumb encoding (32): 0xF8000000
    // Test aarch32_STRB_r_T2_A field Rt = 0 (Min)
    // ISET: T32
    // Fields: Rt=0, imm2=0, Rm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_r_T2_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_strb_r_t2_a_field_rt_1_poweroftwo_0_f8001000() {
    // Thumb encoding (32): 0xF8001000
    // Test aarch32_STRB_r_T2_A field Rt = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=1, Rm=0, imm2=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8001000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_r_T2_A
/// ASL: `field imm2 4 +: 2`
/// Requirement: FieldBoundary { field: "imm2", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_strb_r_t2_a_field_imm2_0_zero_0_f8000000() {
    // Thumb encoding (32): 0xF8000000
    // Test aarch32_STRB_r_T2_A field imm2 = 0 (Zero)
    // ISET: T32
    // Fields: Rm=0, Rn=0, Rt=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_r_T2_A
/// ASL: `field imm2 4 +: 2`
/// Requirement: FieldBoundary { field: "imm2", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_strb_r_t2_a_field_imm2_1_poweroftwo_0_f8000010() {
    // Thumb encoding (32): 0xF8000010
    // Test aarch32_STRB_r_T2_A field imm2 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, imm2=1, Rm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8000010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_r_T2_A
/// ASL: `field imm2 4 +: 2`
/// Requirement: FieldBoundary { field: "imm2", value: 3, boundary: Max }
/// maximum immediate (3)
#[test]
fn test_aarch32_strb_r_t2_a_field_imm2_3_max_0_f8000030() {
    // Thumb encoding (32): 0xF8000030
    // Test aarch32_STRB_r_T2_A field imm2 = 3 (Max)
    // ISET: T32
    // Fields: Rn=0, Rm=0, imm2=3, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8000030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_r_T2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_strb_r_t2_a_field_rm_0_min_0_f8000000() {
    // Thumb encoding (32): 0xF8000000
    // Test aarch32_STRB_r_T2_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm2=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_r_T2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_strb_r_t2_a_field_rm_1_poweroftwo_0_f8000001() {
    // Thumb encoding (32): 0xF8000001
    // Test aarch32_STRB_r_T2_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=1, Rn=0, imm2=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8000001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_r_T2_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_strb_r_t2_a_combo_0_0_f8000000() {
    // Thumb encoding (32): 0xF8000000
    // Test aarch32_STRB_r_T2_A field combination: Rn=0, Rt=0, imm2=0, Rm=0
    // ISET: T32
    // Fields: Rt=0, Rn=0, Rm=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_r_T2_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_strb_r_t2_a_combo_1_0_f8010000() {
    // Thumb encoding (32): 0xF8010000
    // Test aarch32_STRB_r_T2_A field combination: Rn=1, Rt=0, imm2=0, Rm=0
    // ISET: T32
    // Fields: imm2=0, Rt=0, Rn=1, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_r_T2_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=0 (register index 0 (first register))
#[test]
fn test_aarch32_strb_r_t2_a_combo_2_0_f8000000() {
    // Thumb encoding (32): 0xF8000000
    // Test aarch32_STRB_r_T2_A field combination: Rn=0, Rt=0, imm2=0, Rm=0
    // ISET: T32
    // Fields: imm2=0, Rt=0, Rn=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_r_T2_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=1 (register index 1 (second register))
#[test]
fn test_aarch32_strb_r_t2_a_combo_3_0_f8001000() {
    // Thumb encoding (32): 0xF8001000
    // Test aarch32_STRB_r_T2_A field combination: Rn=0, Rt=1, imm2=0, Rm=0
    // ISET: T32
    // Fields: Rn=0, Rm=0, imm2=0, Rt=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8001000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_r_T2_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm2=0 (immediate value 0)
#[test]
fn test_aarch32_strb_r_t2_a_combo_4_0_f8000000() {
    // Thumb encoding (32): 0xF8000000
    // Test aarch32_STRB_r_T2_A field combination: Rn=0, Rt=0, imm2=0, Rm=0
    // ISET: T32
    // Fields: Rm=0, Rt=0, imm2=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_r_T2_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm2=1 (immediate value 1)
#[test]
fn test_aarch32_strb_r_t2_a_combo_5_0_f8000010() {
    // Thumb encoding (32): 0xF8000010
    // Test aarch32_STRB_r_T2_A field combination: Rn=0, Rt=0, imm2=1, Rm=0
    // ISET: T32
    // Fields: Rn=0, Rm=0, imm2=1, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8000010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_r_T2_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm2=3 (maximum immediate (3))
#[test]
fn test_aarch32_strb_r_t2_a_combo_6_0_f8000030() {
    // Thumb encoding (32): 0xF8000030
    // Test aarch32_STRB_r_T2_A field combination: Rn=0, Rt=0, imm2=3, Rm=0
    // ISET: T32
    // Fields: Rn=0, imm2=3, Rt=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8000030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_r_T2_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch32_strb_r_t2_a_combo_7_0_f8000000() {
    // Thumb encoding (32): 0xF8000000
    // Test aarch32_STRB_r_T2_A field combination: Rn=0, Rt=0, imm2=0, Rm=0
    // ISET: T32
    // Fields: Rt=0, Rm=0, imm2=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_r_T2_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_aarch32_strb_r_t2_a_combo_8_0_f8000001() {
    // Thumb encoding (32): 0xF8000001
    // Test aarch32_STRB_r_T2_A field combination: Rn=0, Rt=0, imm2=0, Rm=1
    // ISET: T32
    // Fields: Rt=0, imm2=0, Rn=0, Rm=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8000001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_r_T2_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rt=1 (same register test (reg=1))
#[test]
fn test_aarch32_strb_r_t2_a_combo_9_0_f8011000() {
    // Thumb encoding (32): 0xF8011000
    // Test aarch32_STRB_r_T2_A field combination: Rn=1, Rt=1, imm2=0, Rm=0
    // ISET: T32
    // Fields: Rn=1, Rt=1, imm2=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8011000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_r_T2_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rt=31 (same register test (reg=31))
#[test]
fn test_aarch32_strb_r_t2_a_combo_10_0_f80ff000() {
    // Thumb encoding (32): 0xF80FF000
    // Test aarch32_STRB_r_T2_A field combination: Rn=31, Rt=31, imm2=0, Rm=0
    // ISET: T32
    // Fields: Rt=31, Rm=0, imm2=0, Rn=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF80FF000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_r_T2_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rm=1 (same register test (reg=1))
#[test]
fn test_aarch32_strb_r_t2_a_combo_11_0_f8010001() {
    // Thumb encoding (32): 0xF8010001
    // Test aarch32_STRB_r_T2_A field combination: Rn=1, Rt=0, imm2=0, Rm=1
    // ISET: T32
    // Fields: imm2=0, Rm=1, Rt=0, Rn=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8010001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_r_T2_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rm=31 (same register test (reg=31))
#[test]
fn test_aarch32_strb_r_t2_a_combo_12_0_f80f000f() {
    // Thumb encoding (32): 0xF80F000F
    // Test aarch32_STRB_r_T2_A field combination: Rn=31, Rt=0, imm2=0, Rm=31
    // ISET: T32
    // Fields: Rn=31, Rm=31, Rt=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF80F000F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_r_T2_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=1 (same register test (reg=1)), Rm=1 (same register test (reg=1))
#[test]
fn test_aarch32_strb_r_t2_a_combo_13_0_f8001001() {
    // Thumb encoding (32): 0xF8001001
    // Test aarch32_STRB_r_T2_A field combination: Rn=0, Rt=1, imm2=0, Rm=1
    // ISET: T32
    // Fields: Rm=1, Rt=1, Rn=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8001001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_r_T2_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=31 (same register test (reg=31)), Rm=31 (same register test (reg=31))
#[test]
fn test_aarch32_strb_r_t2_a_combo_14_0_f800f00f() {
    // Thumb encoding (32): 0xF800F00F
    // Test aarch32_STRB_r_T2_A field combination: Rn=0, Rt=31, imm2=0, Rm=31
    // ISET: T32
    // Fields: Rn=0, Rt=31, Rm=31, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF800F00F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_r_T2_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rn" }), rhs: LitBits([true, true, true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Rn\" }), rhs: LitBits([true, true, true, true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_strb_r_t2_a_invalid_0_0_f8000000() {
    // Thumb encoding (32): 0xF8000000
    // Test aarch32_STRB_r_T2_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rn" }), rhs: LitBits([true, true, true, true]) }
    // ISET: T32
    // Fields: imm2=0, Rt=0, Rn=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_STRB_r_T2_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_strb_r_t2_a_invalid_1_0_f8000000() {
    // Thumb encoding (32): 0xF8000000
    // Test aarch32_STRB_r_T2_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: imm2=0, Rt=0, Rn=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_STRB_r_T2_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strb_r_t2_a_invalid_2_0_f8000000() {
    // Thumb encoding (32): 0xF8000000
    // Test aarch32_STRB_r_T2_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }
    // ISET: T32
    // Fields: imm2=0, Rn=0, Rt=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8000000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_STRB_r_T2_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strb_r_t2_a_invalid_3_0_f8000000() {
    // Thumb encoding (32): 0xF8000000
    // Test aarch32_STRB_r_T2_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rm=0, Rn=0, imm2=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8000000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_STRB_r_A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_strb_r_a1_a_store_0_06410000() {
    // Test aarch32_STRB_r_A1_A memory store: 8 bytes
    // Encoding: 0x06410000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x06410000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_STRB_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 0 (32)
#[test]
fn test_aarch32_strb_r_t1_a_lslv_oracle_32_0_54020020() {
    // Test LSLV 32-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x12345678, "W0 should be 0x12345678");
}

/// Provenance: aarch32_STRB_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 0 (64)
#[test]
fn test_aarch32_strb_r_t1_a_lslv_oracle_64_0_d4020020() {
    // Test LSLV 64-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x12345678, "X0 should be 0x0000000012345678");
}

/// Provenance: aarch32_STRB_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4 (32)
#[test]
fn test_aarch32_strb_r_t1_a_lslv_oracle_32_1_54020020() {
    // Test LSLV 32-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x4);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x23456780, "W0 should be 0x23456780");
}

/// Provenance: aarch32_STRB_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 4 (64)
#[test]
fn test_aarch32_strb_r_t1_a_lslv_oracle_64_1_d4020020() {
    // Test LSLV 64-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x4);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x23456780, "X0 should be 0x0000000123456780");
}

/// Provenance: aarch32_STRB_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 8 (32)
#[test]
fn test_aarch32_strb_r_t1_a_lslv_oracle_32_2_54020020() {
    // Test LSLV 32-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x8);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x34567800, "W0 should be 0x34567800");
}

/// Provenance: aarch32_STRB_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 8 (64)
#[test]
fn test_aarch32_strb_r_t1_a_lslv_oracle_64_2_d4020020() {
    // Test LSLV 64-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x8);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x34567800, "X0 should be 0x0000001234567800");
}

/// Provenance: aarch32_STRB_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1 (32)
#[test]
fn test_aarch32_strb_r_t1_a_lslv_oracle_32_3_54020020() {
    // Test LSLV 32-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_STRB_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// MSB set, shift 1 (64)
#[test]
fn test_aarch32_strb_r_t1_a_lslv_oracle_64_3_d4020020() {
    // Test LSLV 64-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_STRB_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// LSB set, max shift (32)
#[test]
fn test_aarch32_strb_r_t1_a_lslv_oracle_32_4_54020020() {
    // Test LSLV 32-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x3F);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "W0 should be 0x80000000");
}

/// Provenance: aarch32_STRB_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// LSB set, max shift (64)
#[test]
fn test_aarch32_strb_r_t1_a_lslv_oracle_64_4_d4020020() {
    // Test LSLV 64-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x3F);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x8000000000000000");
}

/// Provenance: aarch32_STRB_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// all ones, shift 32 (32)
#[test]
fn test_aarch32_strb_r_t1_a_lslv_oracle_32_5_54020020() {
    // Test LSLV 32-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x20);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "W0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_STRB_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// all ones, shift 32 (64)
#[test]
fn test_aarch32_strb_r_t1_a_lslv_oracle_64_5_d4020020() {
    // Test LSLV 64-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x20);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0xFFFFFFFF00000000");
}

/// Provenance: aarch32_STRB_r_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// no shift
#[test]
fn test_aarch32_strb_r_t1_a_t16_oracle_0_54880000() {
    // Test T16 LSLS: no shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_STRB_r_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4
#[test]
fn test_aarch32_strb_r_t1_a_t16_oracle_1_54880000() {
    // Test T16 LSLS: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    set_w(&mut cpu, 2, 0x4);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF0, "R0 should be 0x00000FF0");
}

/// Provenance: aarch32_STRB_r_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1
#[test]
fn test_aarch32_strb_r_t1_a_t16_oracle_2_54880000() {
    // Test T16 LSLS: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_STRB_r_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift to MSB
#[test]
fn test_aarch32_strb_r_t1_a_t16_oracle_3_54880000() {
    // Test T16 LSLS: shift to MSB (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x1F);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "R0 should be 0x80000000");
}

/// Provenance: aarch32_STRB_r_T1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_strb_r_t1_a_store_0_54080000() {
    // Test aarch32_STRB_r_T1_A memory store: 8 bytes
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_STRB_r_T2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple multiply (32)
#[test]
fn test_aarch32_strb_r_t2_a_mul_oracle_32_0_1b027c20() {
    // Test MUL 32-bit: simple multiply (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3);
    set_w(&mut cpu, 1, 0x2);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6, "W0 should be 0x00000006");
}

/// Provenance: aarch32_STRB_r_T2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple multiply (64)
#[test]
fn test_aarch32_strb_r_t2_a_mul_oracle_64_0_9b027c20() {
    // Test MUL 64-bit: simple multiply (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x2);
    set_w(&mut cpu, 2, 0x3);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6, "X0 should be 0x0000000000000006");
}

/// Provenance: aarch32_STRB_r_T2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// multiply by zero (32)
#[test]
fn test_aarch32_strb_r_t2_a_mul_oracle_32_1_1b027c20() {
    // Test MUL 32-bit: multiply by zero (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x64);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_STRB_r_T2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// multiply by zero (64)
#[test]
fn test_aarch32_strb_r_t2_a_mul_oracle_64_1_9b027c20() {
    // Test MUL 64-bit: multiply by zero (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x64);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_STRB_r_T2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// multiply by one (32)
#[test]
fn test_aarch32_strb_r_t2_a_mul_oracle_32_2_1b027c20() {
    // Test MUL 32-bit: multiply by one (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_STRB_r_T2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// multiply by one (64)
#[test]
fn test_aarch32_strb_r_t2_a_mul_oracle_64_2_9b027c20() {
    // Test MUL 64-bit: multiply by one (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x0000000000000001");
}

/// Provenance: aarch32_STRB_r_T2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// 16-bit max * 16-bit max (32)
#[test]
fn test_aarch32_strb_r_t2_a_mul_oracle_32_3_1b027c20() {
    // Test MUL 32-bit: 16-bit max * 16-bit max (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFF);
    set_w(&mut cpu, 2, 0xFFFF);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFE0001, "W0 should be 0xFFFE0001");
}

/// Provenance: aarch32_STRB_r_T2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// 16-bit max * 16-bit max (64)
#[test]
fn test_aarch32_strb_r_t2_a_mul_oracle_64_3_9b027c20() {
    // Test MUL 64-bit: 16-bit max * 16-bit max (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFF);
    set_w(&mut cpu, 1, 0xFFFF);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFE0001, "X0 should be 0x00000000FFFE0001");
}

/// Provenance: aarch32_STRB_r_T2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift-like multiply (32)
#[test]
fn test_aarch32_strb_r_t2_a_mul_oracle_32_4_1b027c20() {
    // Test MUL 32-bit: shift-like multiply (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x2468ACF0, "W0 should be 0x2468ACF0");
}

/// Provenance: aarch32_STRB_r_T2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift-like multiply (64)
#[test]
fn test_aarch32_strb_r_t2_a_mul_oracle_64_4_9b027c20() {
    // Test MUL 64-bit: shift-like multiply (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x2468ACF0, "X0 should be 0x000000002468ACF0");
}

/// Provenance: aarch32_STRB_r_T2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// larger values (32)
#[test]
fn test_aarch32_strb_r_t2_a_mul_oracle_32_5_1b027c20() {
    // Test MUL 32-bit: larger values (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0xC8);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4E20, "W0 should be 0x00004E20");
}

/// Provenance: aarch32_STRB_r_T2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// larger values (64)
#[test]
fn test_aarch32_strb_r_t2_a_mul_oracle_64_5_9b027c20() {
    // Test MUL 64-bit: larger values (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xC8);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4E20, "X0 should be 0x0000000000004E20");
}

/// Provenance: aarch32_STRB_r_T2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// 32-bit overflow (32)
#[test]
fn test_aarch32_strb_r_t2_a_mul_oracle_32_6_1b027c20() {
    // Test MUL 32-bit: 32-bit overflow (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_STRB_r_T2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// 32-bit overflow (64)
#[test]
fn test_aarch32_strb_r_t2_a_mul_oracle_64_6_9b027c20() {
    // Test MUL 64-bit: 32-bit overflow (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0xFFFFFFFE00000001");
}

/// Provenance: aarch32_STRB_r_T2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// prime numbers (32)
#[test]
fn test_aarch32_strb_r_t2_a_mul_oracle_32_7_1b027c20() {
    // Test MUL 32-bit: prime numbers (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xB);
    set_w(&mut cpu, 1, 0x7);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4D, "W0 should be 0x0000004D");
}

/// Provenance: aarch32_STRB_r_T2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// prime numbers (64)
#[test]
fn test_aarch32_strb_r_t2_a_mul_oracle_64_7_9b027c20() {
    // Test MUL 64-bit: prime numbers (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7);
    set_w(&mut cpu, 2, 0xB);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4D, "X0 should be 0x000000000000004D");
}

/// Provenance: aarch32_STRB_r_T2_A
/// ASL: `MUL R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple values
#[test]
fn test_aarch32_strb_r_t2_a_t32_oracle_0_f8010002() {
    // Test T32 MUL: simple values (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x32);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF8010002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1388, "R0 should be 0x00001388");
}

/// Provenance: aarch32_STRB_r_T2_A
/// ASL: `MUL R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero values
#[test]
fn test_aarch32_strb_r_t2_a_t32_oracle_1_f8010002() {
    // Test T32 MUL: zero values (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xF8010002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_STRB_r_T2_A
/// ASL: `MUL R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max value
#[test]
fn test_aarch32_strb_r_t2_a_t32_oracle_2_f8010002() {
    // Test T32 MUL: max value (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF8010002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "R0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_STRB_r_T2_A
/// ASL: `MUL R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// mixed pattern
#[test]
fn test_aarch32_strb_r_t2_a_t32_oracle_3_f8010002() {
    // Test T32 MUL: mixed pattern (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xABCDEF01);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u32 = 0xF8010002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x55065E78, "R0 should be 0x55065E78");
}

/// Provenance: aarch32_STRB_r_T2_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_strb_r_t2_a_store_0_f8010000() {
    // Test aarch32_STRB_r_T2_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0xF8010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// aarch32_STLEX_A Tests
// ============================================================================

/// Provenance: aarch32_STLEX_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_stlex_a1_a_field_cond_0_min_290_01800290() {
    // Encoding: 0x01800290
    // Test aarch32_STLEX_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, Rd=0, cond=0, Rt=0
    let encoding: u32 = 0x01800290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEX_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_stlex_a1_a_field_cond_1_poweroftwo_290_11800290() {
    // Encoding: 0x11800290
    // Test aarch32_STLEX_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rt=0, cond=1, Rn=0
    let encoding: u32 = 0x11800290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEX_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_stlex_a1_a_field_cond_2_poweroftwo_290_21800290() {
    // Encoding: 0x21800290
    // Test aarch32_STLEX_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, Rn=0, Rd=0, cond=2
    let encoding: u32 = 0x21800290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEX_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_stlex_a1_a_field_cond_3_poweroftwo_290_31800290() {
    // Encoding: 0x31800290
    // Test aarch32_STLEX_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, Rn=0, cond=3, Rd=0
    let encoding: u32 = 0x31800290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEX_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_stlex_a1_a_field_cond_4_poweroftwo_290_41800290() {
    // Encoding: 0x41800290
    // Test aarch32_STLEX_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=4, Rt=0, Rd=0, Rn=0
    let encoding: u32 = 0x41800290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEX_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_stlex_a1_a_field_cond_5_poweroftwo_290_51800290() {
    // Encoding: 0x51800290
    // Test aarch32_STLEX_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, Rn=0, Rd=0, cond=5
    let encoding: u32 = 0x51800290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEX_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_stlex_a1_a_field_cond_6_poweroftwo_290_61800290() {
    // Encoding: 0x61800290
    // Test aarch32_STLEX_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rt=0, Rn=0, cond=6
    let encoding: u32 = 0x61800290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEX_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_stlex_a1_a_field_cond_7_poweroftwo_290_71800290() {
    // Encoding: 0x71800290
    // Test aarch32_STLEX_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=7, Rd=0
    let encoding: u32 = 0x71800290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEX_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_stlex_a1_a_field_cond_8_poweroftwo_290_81800290() {
    // Encoding: 0x81800290
    // Test aarch32_STLEX_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=8, Rd=0, Rt=0, Rn=0
    let encoding: u32 = 0x81800290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEX_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_stlex_a1_a_field_cond_9_poweroftwo_290_91800290() {
    // Encoding: 0x91800290
    // Test aarch32_STLEX_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=9, Rt=0, Rd=0, Rn=0
    let encoding: u32 = 0x91800290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEX_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_stlex_a1_a_field_cond_10_poweroftwo_290_a1800290() {
    // Encoding: 0xA1800290
    // Test aarch32_STLEX_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rt=0, cond=10, Rn=0
    let encoding: u32 = 0xA1800290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEX_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_stlex_a1_a_field_cond_11_poweroftwo_290_b1800290() {
    // Encoding: 0xB1800290
    // Test aarch32_STLEX_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=11, Rd=0, Rt=0
    let encoding: u32 = 0xB1800290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEX_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_stlex_a1_a_field_cond_12_poweroftwo_290_c1800290() {
    // Encoding: 0xC1800290
    // Test aarch32_STLEX_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, cond=12, Rt=0, Rn=0
    let encoding: u32 = 0xC1800290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEX_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_stlex_a1_a_field_cond_13_poweroftwo_290_d1800290() {
    // Encoding: 0xD1800290
    // Test aarch32_STLEX_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=13, Rt=0, Rd=0, Rn=0
    let encoding: u32 = 0xD1800290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEX_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_stlex_a1_a_field_cond_14_poweroftwo_290_e1800290() {
    // Encoding: 0xE1800290
    // Test aarch32_STLEX_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rd=0, Rt=0, cond=14
    let encoding: u32 = 0xE1800290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEX_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_stlex_a1_a_field_cond_15_max_290_f1800290() {
    // Encoding: 0xF1800290
    // Test aarch32_STLEX_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: cond=15, Rd=0, Rt=0, Rn=0
    let encoding: u32 = 0xF1800290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEX_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_stlex_a1_a_field_rn_0_min_290_01800290() {
    // Encoding: 0x01800290
    // Test aarch32_STLEX_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: Rt=0, Rd=0, cond=0, Rn=0
    let encoding: u32 = 0x01800290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEX_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_stlex_a1_a_field_rn_1_poweroftwo_290_01810290() {
    // Encoding: 0x01810290
    // Test aarch32_STLEX_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, cond=0, Rd=0, Rn=1
    let encoding: u32 = 0x01810290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEX_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_stlex_a1_a_field_rd_0_min_290_01800290() {
    // Encoding: 0x01800290
    // Test aarch32_STLEX_A1_A field Rd = 0 (Min)
    // ISET: A32
    // Fields: Rd=0, Rn=0, cond=0, Rt=0
    let encoding: u32 = 0x01800290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEX_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_stlex_a1_a_field_rd_1_poweroftwo_290_01801290() {
    // Encoding: 0x01801290
    // Test aarch32_STLEX_A1_A field Rd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=0, Rd=1
    let encoding: u32 = 0x01801290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEX_A1_A
/// ASL: `field Rt 0 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_stlex_a1_a_field_rt_0_min_290_01800290() {
    // Encoding: 0x01800290
    // Test aarch32_STLEX_A1_A field Rt = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, Rd=0, cond=0, Rt=0
    let encoding: u32 = 0x01800290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEX_A1_A
/// ASL: `field Rt 0 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_stlex_a1_a_field_rt_1_poweroftwo_290_01800291() {
    // Encoding: 0x01800291
    // Test aarch32_STLEX_A1_A field Rt = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rd=0, Rt=1, cond=0
    let encoding: u32 = 0x01800291;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEX_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_stlex_a1_a_combo_0_290_01800290() {
    // Encoding: 0x01800290
    // Test aarch32_STLEX_A1_A field combination: cond=0, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: cond=0, Rd=0, Rt=0, Rn=0
    let encoding: u32 = 0x01800290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEX_A1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=1 (condition NE (not equal))
#[test]
fn test_aarch32_stlex_a1_a_combo_1_290_11800290() {
    // Encoding: 0x11800290
    // Test aarch32_STLEX_A1_A field combination: cond=1, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: cond=1, Rt=0, Rd=0, Rn=0
    let encoding: u32 = 0x11800290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEX_A1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=2 (condition CS/HS (carry set))
#[test]
fn test_aarch32_stlex_a1_a_combo_2_290_21800290() {
    // Encoding: 0x21800290
    // Test aarch32_STLEX_A1_A field combination: cond=2, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rt=0, Rd=0, Rn=0, cond=2
    let encoding: u32 = 0x21800290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEX_A1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=3 (condition CC/LO (carry clear))
#[test]
fn test_aarch32_stlex_a1_a_combo_3_290_31800290() {
    // Encoding: 0x31800290
    // Test aarch32_STLEX_A1_A field combination: cond=3, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rn=0, cond=3, Rt=0, Rd=0
    let encoding: u32 = 0x31800290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEX_A1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=4 (condition MI (minus/negative))
#[test]
fn test_aarch32_stlex_a1_a_combo_4_290_41800290() {
    // Encoding: 0x41800290
    // Test aarch32_STLEX_A1_A field combination: cond=4, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: cond=4, Rn=0, Rt=0, Rd=0
    let encoding: u32 = 0x41800290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEX_A1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=5 (condition PL (plus/positive))
#[test]
fn test_aarch32_stlex_a1_a_combo_5_290_51800290() {
    // Encoding: 0x51800290
    // Test aarch32_STLEX_A1_A field combination: cond=5, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rd=0, Rn=0, Rt=0, cond=5
    let encoding: u32 = 0x51800290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEX_A1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=6 (condition VS (overflow set))
#[test]
fn test_aarch32_stlex_a1_a_combo_6_290_61800290() {
    // Encoding: 0x61800290
    // Test aarch32_STLEX_A1_A field combination: cond=6, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=6, Rd=0
    let encoding: u32 = 0x61800290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEX_A1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=7 (condition VC (overflow clear))
#[test]
fn test_aarch32_stlex_a1_a_combo_7_290_71800290() {
    // Encoding: 0x71800290
    // Test aarch32_STLEX_A1_A field combination: cond=7, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: cond=7, Rd=0, Rt=0, Rn=0
    let encoding: u32 = 0x71800290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEX_A1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=8 (condition HI (unsigned higher))
#[test]
fn test_aarch32_stlex_a1_a_combo_8_290_81800290() {
    // Encoding: 0x81800290
    // Test aarch32_STLEX_A1_A field combination: cond=8, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rt=0, Rn=0, cond=8, Rd=0
    let encoding: u32 = 0x81800290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEX_A1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=9 (condition LS (unsigned lower or same))
#[test]
fn test_aarch32_stlex_a1_a_combo_9_290_91800290() {
    // Encoding: 0x91800290
    // Test aarch32_STLEX_A1_A field combination: cond=9, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: cond=9, Rd=0, Rn=0, Rt=0
    let encoding: u32 = 0x91800290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEX_A1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=10 (condition GE (signed >=))
#[test]
fn test_aarch32_stlex_a1_a_combo_10_290_a1800290() {
    // Encoding: 0xA1800290
    // Test aarch32_STLEX_A1_A field combination: cond=10, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rn=0, cond=10, Rd=0, Rt=0
    let encoding: u32 = 0xA1800290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEX_A1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=11 (condition LT (signed <))
#[test]
fn test_aarch32_stlex_a1_a_combo_11_290_b1800290() {
    // Encoding: 0xB1800290
    // Test aarch32_STLEX_A1_A field combination: cond=11, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rd=0, Rt=0, Rn=0, cond=11
    let encoding: u32 = 0xB1800290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEX_A1_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=12 (condition GT (signed >))
#[test]
fn test_aarch32_stlex_a1_a_combo_12_290_c1800290() {
    // Encoding: 0xC1800290
    // Test aarch32_STLEX_A1_A field combination: cond=12, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rn=0, Rd=0, Rt=0, cond=12
    let encoding: u32 = 0xC1800290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEX_A1_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=13 (condition LE (signed <=))
#[test]
fn test_aarch32_stlex_a1_a_combo_13_290_d1800290() {
    // Encoding: 0xD1800290
    // Test aarch32_STLEX_A1_A field combination: cond=13, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: cond=13, Rt=0, Rd=0, Rn=0
    let encoding: u32 = 0xD1800290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEX_A1_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=14 (condition AL (always))
#[test]
fn test_aarch32_stlex_a1_a_combo_14_290_e1800290() {
    // Encoding: 0xE1800290
    // Test aarch32_STLEX_A1_A field combination: cond=14, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rd=0, Rn=0, Rt=0, cond=14
    let encoding: u32 = 0xE1800290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEX_A1_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=15 (condition NV (never, reserved))
#[test]
fn test_aarch32_stlex_a1_a_combo_15_290_f1800290() {
    // Encoding: 0xF1800290
    // Test aarch32_STLEX_A1_A field combination: cond=15, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rt=0, cond=15, Rn=0, Rd=0
    let encoding: u32 = 0xF1800290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEX_A1_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_stlex_a1_a_combo_16_290_01800290() {
    // Encoding: 0x01800290
    // Test aarch32_STLEX_A1_A field combination: cond=0, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rd=0, Rn=0, Rt=0, cond=0
    let encoding: u32 = 0x01800290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEX_A1_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_stlex_a1_a_combo_17_290_01810290() {
    // Encoding: 0x01810290
    // Test aarch32_STLEX_A1_A field combination: cond=0, Rn=1, Rd=0, Rt=0
    // ISET: A32
    // Fields: cond=0, Rn=1, Rt=0, Rd=0
    let encoding: u32 = 0x01810290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEX_A1_A
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch32_stlex_a1_a_combo_18_290_01800290() {
    // Encoding: 0x01800290
    // Test aarch32_STLEX_A1_A field combination: cond=0, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=0, Rd=0
    let encoding: u32 = 0x01800290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEX_A1_A
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch32_stlex_a1_a_combo_19_290_01801290() {
    // Encoding: 0x01801290
    // Test aarch32_STLEX_A1_A field combination: cond=0, Rn=0, Rd=1, Rt=0
    // ISET: A32
    // Fields: Rd=1, Rt=0, cond=0, Rn=0
    let encoding: u32 = 0x01801290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEX_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_stlex_a1_a_special_cond_0_condition_eq_656_01800290() {
    // Encoding: 0x01800290
    // Test aarch32_STLEX_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: Rn=0, cond=0, Rd=0, Rt=0
    let encoding: u32 = 0x01800290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEX_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_stlex_a1_a_special_cond_1_condition_ne_656_11800290() {
    // Encoding: 0x11800290
    // Test aarch32_STLEX_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: cond=1, Rt=0, Rd=0, Rn=0
    let encoding: u32 = 0x11800290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEX_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_stlex_a1_a_special_cond_2_condition_cs_hs_656_21800290() {
    // Encoding: 0x21800290
    // Test aarch32_STLEX_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: cond=2, Rd=0, Rn=0, Rt=0
    let encoding: u32 = 0x21800290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEX_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_stlex_a1_a_special_cond_3_condition_cc_lo_656_31800290() {
    // Encoding: 0x31800290
    // Test aarch32_STLEX_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: cond=3, Rt=0, Rd=0, Rn=0
    let encoding: u32 = 0x31800290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEX_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_stlex_a1_a_special_cond_4_condition_mi_656_41800290() {
    // Encoding: 0x41800290
    // Test aarch32_STLEX_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: cond=4, Rd=0, Rt=0, Rn=0
    let encoding: u32 = 0x41800290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEX_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_stlex_a1_a_special_cond_5_condition_pl_656_51800290() {
    // Encoding: 0x51800290
    // Test aarch32_STLEX_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: Rd=0, Rn=0, cond=5, Rt=0
    let encoding: u32 = 0x51800290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEX_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_stlex_a1_a_special_cond_6_condition_vs_656_61800290() {
    // Encoding: 0x61800290
    // Test aarch32_STLEX_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: cond=6, Rd=0, Rt=0, Rn=0
    let encoding: u32 = 0x61800290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEX_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_stlex_a1_a_special_cond_7_condition_vc_656_71800290() {
    // Encoding: 0x71800290
    // Test aarch32_STLEX_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: Rd=0, Rn=0, Rt=0, cond=7
    let encoding: u32 = 0x71800290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEX_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_stlex_a1_a_special_cond_8_condition_hi_656_81800290() {
    // Encoding: 0x81800290
    // Test aarch32_STLEX_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: cond=8, Rt=0, Rn=0, Rd=0
    let encoding: u32 = 0x81800290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEX_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_stlex_a1_a_special_cond_9_condition_ls_656_91800290() {
    // Encoding: 0x91800290
    // Test aarch32_STLEX_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: Rt=0, Rd=0, cond=9, Rn=0
    let encoding: u32 = 0x91800290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEX_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_stlex_a1_a_special_cond_10_condition_ge_656_a1800290() {
    // Encoding: 0xA1800290
    // Test aarch32_STLEX_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: Rn=0, Rd=0, Rt=0, cond=10
    let encoding: u32 = 0xA1800290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEX_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_stlex_a1_a_special_cond_11_condition_lt_656_b1800290() {
    // Encoding: 0xB1800290
    // Test aarch32_STLEX_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: Rt=0, cond=11, Rn=0, Rd=0
    let encoding: u32 = 0xB1800290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEX_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_stlex_a1_a_special_cond_12_condition_gt_656_c1800290() {
    // Encoding: 0xC1800290
    // Test aarch32_STLEX_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: cond=12, Rn=0, Rd=0, Rt=0
    let encoding: u32 = 0xC1800290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEX_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_stlex_a1_a_special_cond_13_condition_le_656_d1800290() {
    // Encoding: 0xD1800290
    // Test aarch32_STLEX_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: Rn=0, cond=13, Rd=0, Rt=0
    let encoding: u32 = 0xD1800290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEX_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_stlex_a1_a_special_cond_14_condition_al_656_e1800290() {
    // Encoding: 0xE1800290
    // Test aarch32_STLEX_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: cond=14, Rn=0, Rd=0, Rt=0
    let encoding: u32 = 0xE1800290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEX_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_stlex_a1_a_special_cond_15_condition_nv_656_f1800290() {
    // Encoding: 0xF1800290
    // Test aarch32_STLEX_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: cond=15, Rt=0, Rn=0, Rd=0
    let encoding: u32 = 0xF1800290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEX_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_stlex_a1_a_invalid_0_290_01800290() {
    // Encoding: 0x01800290
    // Test aarch32_STLEX_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }
    // ISET: A32
    // Fields: cond=0, Rt=0, Rn=0, Rd=0
    let encoding: u32 = 0x01800290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STLEX_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_stlex_a1_a_invalid_1_290_01800290() {
    // Encoding: 0x01800290
    // Test aarch32_STLEX_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: cond=0, Rn=0, Rt=0, Rd=0
    let encoding: u32 = 0x01800290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STLEX_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_stlex_a1_a_invalid_2_290_01800290() {
    // Encoding: 0x01800290
    // Test aarch32_STLEX_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) }
    // ISET: A32
    // Fields: Rt=0, cond=0, Rn=0, Rd=0
    let encoding: u32 = 0x01800290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STLEX_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_stlex_a1_a_invalid_3_290_01800290() {
    // Encoding: 0x01800290
    // Test aarch32_STLEX_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Rd=0, Rn=0, Rt=0, cond=0
    let encoding: u32 = 0x01800290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STLEX_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_stlex_t1_a_field_rn_0_min_e0_e8c000e0() {
    // Thumb encoding (32): 0xE8C000E0
    // Test aarch32_STLEX_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rt=0, Rd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C000E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLEX_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_stlex_t1_a_field_rn_1_poweroftwo_e0_e8c100e0() {
    // Thumb encoding (32): 0xE8C100E0
    // Test aarch32_STLEX_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, Rn=1, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C100E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLEX_T1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_stlex_t1_a_field_rt_0_min_e0_e8c000e0() {
    // Thumb encoding (32): 0xE8C000E0
    // Test aarch32_STLEX_T1_A field Rt = 0 (Min)
    // ISET: T32
    // Fields: Rd=0, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C000E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLEX_T1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_stlex_t1_a_field_rt_1_poweroftwo_e0_e8c010e0() {
    // Thumb encoding (32): 0xE8C010E0
    // Test aarch32_STLEX_T1_A field Rt = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rd=0, Rn=0, Rt=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C010E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLEX_T1_A
/// ASL: `field Rd 0 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_stlex_t1_a_field_rd_0_min_e0_e8c000e0() {
    // Thumb encoding (32): 0xE8C000E0
    // Test aarch32_STLEX_T1_A field Rd = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rt=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C000E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLEX_T1_A
/// ASL: `field Rd 0 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_stlex_t1_a_field_rd_1_poweroftwo_e0_e8c000e1() {
    // Thumb encoding (32): 0xE8C000E1
    // Test aarch32_STLEX_T1_A field Rd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, Rn=0, Rd=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C000E1;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLEX_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_stlex_t1_a_combo_0_e0_e8c000e0() {
    // Thumb encoding (32): 0xE8C000E0
    // Test aarch32_STLEX_T1_A field combination: Rn=0, Rt=0, Rd=0
    // ISET: T32
    // Fields: Rt=0, Rn=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C000E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLEX_T1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_stlex_t1_a_combo_1_e0_e8c100e0() {
    // Thumb encoding (32): 0xE8C100E0
    // Test aarch32_STLEX_T1_A field combination: Rn=1, Rt=0, Rd=0
    // ISET: T32
    // Fields: Rd=0, Rn=1, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C100E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLEX_T1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=0 (register index 0 (first register))
#[test]
fn test_aarch32_stlex_t1_a_combo_2_e0_e8c000e0() {
    // Thumb encoding (32): 0xE8C000E0
    // Test aarch32_STLEX_T1_A field combination: Rn=0, Rt=0, Rd=0
    // ISET: T32
    // Fields: Rd=0, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C000E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLEX_T1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=1 (register index 1 (second register))
#[test]
fn test_aarch32_stlex_t1_a_combo_3_e0_e8c010e0() {
    // Thumb encoding (32): 0xE8C010E0
    // Test aarch32_STLEX_T1_A field combination: Rn=0, Rt=1, Rd=0
    // ISET: T32
    // Fields: Rd=0, Rt=1, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C010E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLEX_T1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch32_stlex_t1_a_combo_4_e0_e8c000e0() {
    // Thumb encoding (32): 0xE8C000E0
    // Test aarch32_STLEX_T1_A field combination: Rn=0, Rt=0, Rd=0
    // ISET: T32
    // Fields: Rd=0, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C000E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLEX_T1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch32_stlex_t1_a_combo_5_e0_e8c000e1() {
    // Thumb encoding (32): 0xE8C000E1
    // Test aarch32_STLEX_T1_A field combination: Rn=0, Rt=0, Rd=1
    // ISET: T32
    // Fields: Rt=0, Rn=0, Rd=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C000E1;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLEX_T1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rt=1 (same register test (reg=1))
#[test]
fn test_aarch32_stlex_t1_a_combo_6_e0_e8c110e0() {
    // Thumb encoding (32): 0xE8C110E0
    // Test aarch32_STLEX_T1_A field combination: Rn=1, Rt=1, Rd=0
    // ISET: T32
    // Fields: Rn=1, Rt=1, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C110E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLEX_T1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rt=31 (same register test (reg=31))
#[test]
fn test_aarch32_stlex_t1_a_combo_7_e0_e8cff0e0() {
    // Thumb encoding (32): 0xE8CFF0E0
    // Test aarch32_STLEX_T1_A field combination: Rn=31, Rt=31, Rd=0
    // ISET: T32
    // Fields: Rn=31, Rd=0, Rt=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8CFF0E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLEX_T1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch32_stlex_t1_a_combo_8_e0_e8c100e1() {
    // Thumb encoding (32): 0xE8C100E1
    // Test aarch32_STLEX_T1_A field combination: Rn=1, Rt=0, Rd=1
    // ISET: T32
    // Fields: Rd=1, Rt=0, Rn=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C100E1;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLEX_T1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch32_stlex_t1_a_combo_9_e0_e8cf00ef() {
    // Thumb encoding (32): 0xE8CF00EF
    // Test aarch32_STLEX_T1_A field combination: Rn=31, Rt=0, Rd=31
    // ISET: T32
    // Fields: Rd=31, Rn=31, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8CF00EF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLEX_T1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch32_stlex_t1_a_combo_10_e0_e8c010e1() {
    // Thumb encoding (32): 0xE8C010E1
    // Test aarch32_STLEX_T1_A field combination: Rn=0, Rt=1, Rd=1
    // ISET: T32
    // Fields: Rd=1, Rn=0, Rt=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C010E1;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLEX_T1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch32_stlex_t1_a_combo_11_e0_e8c0f0ef() {
    // Thumb encoding (32): 0xE8C0F0EF
    // Test aarch32_STLEX_T1_A field combination: Rn=0, Rt=31, Rd=31
    // ISET: T32
    // Fields: Rt=31, Rd=31, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C0F0EF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLEX_T1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_stlex_t1_a_invalid_0_e0_e8c000e0() {
    // Thumb encoding (32): 0xE8C000E0
    // Test aarch32_STLEX_T1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }
    // ISET: T32
    // Fields: Rt=0, Rd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C000E0;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_STLEX_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_stlex_t1_a_invalid_1_e0_e8c000e0() {
    // Thumb encoding (32): 0xE8C000E0
    // Test aarch32_STLEX_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rd=0, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C000E0;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_STLEX_T1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_stlex_t1_a_invalid_2_e0_e8c000e0() {
    // Thumb encoding (32): 0xE8C000E0
    // Test aarch32_STLEX_T1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) }
    // ISET: T32
    // Fields: Rn=0, Rd=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C000E0;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_STLEX_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_stlex_t1_a_invalid_3_e0_e8c000e0() {
    // Thumb encoding (32): 0xE8C000E0
    // Test aarch32_STLEX_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rn=0, Rt=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C000E0;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_STLEX_A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_stlex_a1_a_store_0_01810290() {
    // Test aarch32_STLEX_A1_A memory store: 8 bytes
    // Encoding: 0x01810290
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x01810290;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_STLEX_T1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_stlex_t1_a_store_0_e8c100e0() {
    // Test aarch32_STLEX_T1_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0xE8C100E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// aarch32_STRH_i_A Tests
// ============================================================================

/// Provenance: aarch32_STRH_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_strh_i_a1_a_field_cond_0_min_b0_004000b0() {
    // Encoding: 0x004000B0
    // Test aarch32_STRH_i_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: imm4L=0, P=0, W=0, Rt=0, Rn=0, U=0, imm4H=0, cond=0
    let encoding: u32 = 0x004000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_strh_i_a1_a_field_cond_1_poweroftwo_b0_104000b0() {
    // Encoding: 0x104000B0
    // Test aarch32_STRH_i_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4H=0, cond=1, P=0, W=0, imm4L=0, U=0, Rt=0, Rn=0
    let encoding: u32 = 0x104000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_strh_i_a1_a_field_cond_2_poweroftwo_b0_204000b0() {
    // Encoding: 0x204000B0
    // Test aarch32_STRH_i_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4L=0, Rt=0, P=0, cond=2, W=0, U=0, imm4H=0, Rn=0
    let encoding: u32 = 0x204000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_strh_i_a1_a_field_cond_3_poweroftwo_b0_304000b0() {
    // Encoding: 0x304000B0
    // Test aarch32_STRH_i_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, U=0, imm4H=0, Rn=0, imm4L=0, W=0, cond=3, Rt=0
    let encoding: u32 = 0x304000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_strh_i_a1_a_field_cond_4_poweroftwo_b0_404000b0() {
    // Encoding: 0x404000B0
    // Test aarch32_STRH_i_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=4, U=0, imm4H=0, imm4L=0, W=0, P=0, Rn=0, Rt=0
    let encoding: u32 = 0x404000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_strh_i_a1_a_field_cond_5_poweroftwo_b0_504000b0() {
    // Encoding: 0x504000B0
    // Test aarch32_STRH_i_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4H=0, U=0, Rn=0, P=0, W=0, Rt=0, cond=5, imm4L=0
    let encoding: u32 = 0x504000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_strh_i_a1_a_field_cond_6_poweroftwo_b0_604000b0() {
    // Encoding: 0x604000B0
    // Test aarch32_STRH_i_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=6, W=0, P=0, Rn=0, imm4H=0, Rt=0, imm4L=0, U=0
    let encoding: u32 = 0x604000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_strh_i_a1_a_field_cond_7_poweroftwo_b0_704000b0() {
    // Encoding: 0x704000B0
    // Test aarch32_STRH_i_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, Rt=0, cond=7, P=0, W=0, imm4L=0, Rn=0, imm4H=0
    let encoding: u32 = 0x704000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_strh_i_a1_a_field_cond_8_poweroftwo_b0_804000b0() {
    // Encoding: 0x804000B0
    // Test aarch32_STRH_i_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4L=0, Rn=0, cond=8, imm4H=0, U=0, W=0, Rt=0, P=0
    let encoding: u32 = 0x804000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_strh_i_a1_a_field_cond_9_poweroftwo_b0_904000b0() {
    // Encoding: 0x904000B0
    // Test aarch32_STRH_i_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4H=0, U=0, Rn=0, cond=9, Rt=0, P=0, W=0, imm4L=0
    let encoding: u32 = 0x904000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_strh_i_a1_a_field_cond_10_poweroftwo_b0_a04000b0() {
    // Encoding: 0xA04000B0
    // Test aarch32_STRH_i_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=10, U=0, P=0, Rn=0, W=0, imm4H=0, imm4L=0, Rt=0
    let encoding: u32 = 0xA04000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_strh_i_a1_a_field_cond_11_poweroftwo_b0_b04000b0() {
    // Encoding: 0xB04000B0
    // Test aarch32_STRH_i_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4H=0, Rt=0, W=0, U=0, P=0, cond=11, imm4L=0, Rn=0
    let encoding: u32 = 0xB04000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_strh_i_a1_a_field_cond_12_poweroftwo_b0_c04000b0() {
    // Encoding: 0xC04000B0
    // Test aarch32_STRH_i_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, P=0, imm4L=0, Rt=0, U=0, Rn=0, imm4H=0, cond=12
    let encoding: u32 = 0xC04000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_strh_i_a1_a_field_cond_13_poweroftwo_b0_d04000b0() {
    // Encoding: 0xD04000B0
    // Test aarch32_STRH_i_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, W=0, cond=13, Rn=0, P=0, Rt=0, imm4H=0, imm4L=0
    let encoding: u32 = 0xD04000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_strh_i_a1_a_field_cond_14_poweroftwo_b0_e04000b0() {
    // Encoding: 0xE04000B0
    // Test aarch32_STRH_i_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4L=0, P=0, U=0, cond=14, Rn=0, imm4H=0, W=0, Rt=0
    let encoding: u32 = 0xE04000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_strh_i_a1_a_field_cond_15_max_b0_f04000b0() {
    // Encoding: 0xF04000B0
    // Test aarch32_STRH_i_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: imm4H=0, Rn=0, U=0, P=0, W=0, Rt=0, imm4L=0, cond=15
    let encoding: u32 = 0xF04000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_i_A1_A
/// ASL: `field P 24 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_strh_i_a1_a_field_p_0_min_b0_004000b0() {
    // Encoding: 0x004000B0
    // Test aarch32_STRH_i_A1_A field P = 0 (Min)
    // ISET: A32
    // Fields: P=0, U=0, Rn=0, imm4H=0, imm4L=0, cond=0, W=0, Rt=0
    let encoding: u32 = 0x004000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_i_A1_A
/// ASL: `field P 24 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_strh_i_a1_a_field_p_1_max_b0_014000b0() {
    // Encoding: 0x014000B0
    // Test aarch32_STRH_i_A1_A field P = 1 (Max)
    // ISET: A32
    // Fields: U=0, Rt=0, W=0, imm4L=0, Rn=0, imm4H=0, cond=0, P=1
    let encoding: u32 = 0x014000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_i_A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_strh_i_a1_a_field_u_0_min_b0_004000b0() {
    // Encoding: 0x004000B0
    // Test aarch32_STRH_i_A1_A field U = 0 (Min)
    // ISET: A32
    // Fields: P=0, W=0, imm4L=0, cond=0, imm4H=0, U=0, Rt=0, Rn=0
    let encoding: u32 = 0x004000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_i_A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_strh_i_a1_a_field_u_1_max_b0_00c000b0() {
    // Encoding: 0x00C000B0
    // Test aarch32_STRH_i_A1_A field U = 1 (Max)
    // ISET: A32
    // Fields: U=1, imm4L=0, imm4H=0, Rt=0, P=0, cond=0, W=0, Rn=0
    let encoding: u32 = 0x00C000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_i_A1_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_strh_i_a1_a_field_w_0_min_b0_004000b0() {
    // Encoding: 0x004000B0
    // Test aarch32_STRH_i_A1_A field W = 0 (Min)
    // ISET: A32
    // Fields: U=0, imm4H=0, cond=0, W=0, Rn=0, imm4L=0, Rt=0, P=0
    let encoding: u32 = 0x004000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_i_A1_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_strh_i_a1_a_field_w_1_max_b0_006000b0() {
    // Encoding: 0x006000B0
    // Test aarch32_STRH_i_A1_A field W = 1 (Max)
    // ISET: A32
    // Fields: U=0, P=0, imm4L=0, imm4H=0, Rt=0, W=1, cond=0, Rn=0
    let encoding: u32 = 0x006000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_i_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_strh_i_a1_a_field_rn_0_min_b0_004000b0() {
    // Encoding: 0x004000B0
    // Test aarch32_STRH_i_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: imm4L=0, cond=0, P=0, U=0, Rn=0, Rt=0, W=0, imm4H=0
    let encoding: u32 = 0x004000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_i_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_strh_i_a1_a_field_rn_1_poweroftwo_b0_004100b0() {
    // Encoding: 0x004100B0
    // Test aarch32_STRH_i_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, P=0, W=0, Rt=0, imm4L=0, imm4H=0, Rn=1, U=0
    let encoding: u32 = 0x004100B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_i_A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_strh_i_a1_a_field_rt_0_min_b0_004000b0() {
    // Encoding: 0x004000B0
    // Test aarch32_STRH_i_A1_A field Rt = 0 (Min)
    // ISET: A32
    // Fields: P=0, W=0, cond=0, Rn=0, Rt=0, U=0, imm4H=0, imm4L=0
    let encoding: u32 = 0x004000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_i_A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_strh_i_a1_a_field_rt_1_poweroftwo_b0_004010b0() {
    // Encoding: 0x004010B0
    // Test aarch32_STRH_i_A1_A field Rt = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, imm4H=0, imm4L=0, W=0, P=0, Rn=0, cond=0, Rt=1
    let encoding: u32 = 0x004010B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_i_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_strh_i_a1_a_field_imm4h_0_zero_b0_004000b0() {
    // Encoding: 0x004000B0
    // Test aarch32_STRH_i_A1_A field imm4H = 0 (Zero)
    // ISET: A32
    // Fields: P=0, imm4L=0, imm4H=0, Rn=0, W=0, cond=0, Rt=0, U=0
    let encoding: u32 = 0x004000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_i_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_strh_i_a1_a_field_imm4h_1_poweroftwo_b0_004001b0() {
    // Encoding: 0x004001B0
    // Test aarch32_STRH_i_A1_A field imm4H = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, P=0, U=0, W=0, Rt=0, Rn=0, imm4L=0, imm4H=1
    let encoding: u32 = 0x004001B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_i_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_strh_i_a1_a_field_imm4h_3_poweroftwominusone_b0_004003b0() {
    // Encoding: 0x004003B0
    // Test aarch32_STRH_i_A1_A field imm4H = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: W=0, U=0, imm4H=3, imm4L=0, cond=0, P=0, Rn=0, Rt=0
    let encoding: u32 = 0x004003B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_i_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_strh_i_a1_a_field_imm4h_4_poweroftwo_b0_004004b0() {
    // Encoding: 0x004004B0
    // Test aarch32_STRH_i_A1_A field imm4H = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, cond=0, U=0, imm4L=0, imm4H=4, Rn=0, Rt=0, W=0
    let encoding: u32 = 0x004004B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_i_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_aarch32_strh_i_a1_a_field_imm4h_7_poweroftwominusone_b0_004007b0() {
    // Encoding: 0x004007B0
    // Test aarch32_STRH_i_A1_A field imm4H = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm4H=7, imm4L=0, P=0, W=0, Rn=0, U=0, Rt=0, cond=0
    let encoding: u32 = 0x004007B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_i_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_strh_i_a1_a_field_imm4h_8_poweroftwo_b0_004008b0() {
    // Encoding: 0x004008B0
    // Test aarch32_STRH_i_A1_A field imm4H = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, U=0, imm4L=0, cond=0, W=0, Rt=0, Rn=0, imm4H=8
    let encoding: u32 = 0x004008B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_i_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_aarch32_strh_i_a1_a_field_imm4h_15_max_b0_00400fb0() {
    // Encoding: 0x00400FB0
    // Test aarch32_STRH_i_A1_A field imm4H = 15 (Max)
    // ISET: A32
    // Fields: Rt=0, W=0, imm4L=0, U=0, imm4H=15, Rn=0, P=0, cond=0
    let encoding: u32 = 0x00400FB0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_i_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_strh_i_a1_a_field_imm4l_0_zero_b0_004000b0() {
    // Encoding: 0x004000B0
    // Test aarch32_STRH_i_A1_A field imm4L = 0 (Zero)
    // ISET: A32
    // Fields: P=0, U=0, W=0, Rn=0, imm4H=0, imm4L=0, Rt=0, cond=0
    let encoding: u32 = 0x004000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_i_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_strh_i_a1_a_field_imm4l_1_poweroftwo_b0_004000b1() {
    // Encoding: 0x004000B1
    // Test aarch32_STRH_i_A1_A field imm4L = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, imm4L=1, U=0, imm4H=0, Rn=0, P=0, Rt=0, cond=0
    let encoding: u32 = 0x004000B1;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_i_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_strh_i_a1_a_field_imm4l_3_poweroftwominusone_b0_004000b3() {
    // Encoding: 0x004000B3
    // Test aarch32_STRH_i_A1_A field imm4L = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm4L=3, U=0, Rt=0, W=0, imm4H=0, Rn=0, P=0, cond=0
    let encoding: u32 = 0x004000B3;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_i_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_strh_i_a1_a_field_imm4l_4_poweroftwo_b0_004000b4() {
    // Encoding: 0x004000B4
    // Test aarch32_STRH_i_A1_A field imm4L = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, imm4H=0, Rt=0, Rn=0, P=0, imm4L=4, W=0, U=0
    let encoding: u32 = 0x004000B4;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_i_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_aarch32_strh_i_a1_a_field_imm4l_7_poweroftwominusone_b0_004000b7() {
    // Encoding: 0x004000B7
    // Test aarch32_STRH_i_A1_A field imm4L = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rn=0, imm4H=0, cond=0, U=0, Rt=0, P=0, W=0, imm4L=7
    let encoding: u32 = 0x004000B7;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_i_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_strh_i_a1_a_field_imm4l_8_poweroftwo_b0_004000b8() {
    // Encoding: 0x004000B8
    // Test aarch32_STRH_i_A1_A field imm4L = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, U=0, cond=0, Rt=0, imm4L=8, Rn=0, imm4H=0, P=0
    let encoding: u32 = 0x004000B8;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_i_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_aarch32_strh_i_a1_a_field_imm4l_15_max_b0_004000bf() {
    // Encoding: 0x004000BF
    // Test aarch32_STRH_i_A1_A field imm4L = 15 (Max)
    // ISET: A32
    // Fields: W=0, cond=0, U=0, Rt=0, Rn=0, imm4H=0, imm4L=15, P=0
    let encoding: u32 = 0x004000BF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_i_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_strh_i_a1_a_combo_0_b0_004000b0() {
    // Encoding: 0x004000B0
    // Test aarch32_STRH_i_A1_A field combination: cond=0, P=0, U=0, W=0, Rn=0, Rt=0, imm4H=0, imm4L=0
    // ISET: A32
    // Fields: U=0, Rt=0, W=0, P=0, cond=0, Rn=0, imm4H=0, imm4L=0
    let encoding: u32 = 0x004000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_i_A1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=1 (condition NE (not equal))
#[test]
fn test_aarch32_strh_i_a1_a_combo_1_b0_104000b0() {
    // Encoding: 0x104000B0
    // Test aarch32_STRH_i_A1_A field combination: cond=1, P=0, U=0, W=0, Rn=0, Rt=0, imm4H=0, imm4L=0
    // ISET: A32
    // Fields: U=0, imm4H=0, cond=1, W=0, Rt=0, Rn=0, P=0, imm4L=0
    let encoding: u32 = 0x104000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_i_A1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=2 (condition CS/HS (carry set))
#[test]
fn test_aarch32_strh_i_a1_a_combo_2_b0_204000b0() {
    // Encoding: 0x204000B0
    // Test aarch32_STRH_i_A1_A field combination: cond=2, P=0, U=0, W=0, Rn=0, Rt=0, imm4H=0, imm4L=0
    // ISET: A32
    // Fields: Rt=0, cond=2, P=0, U=0, imm4L=0, imm4H=0, Rn=0, W=0
    let encoding: u32 = 0x204000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_i_A1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=3 (condition CC/LO (carry clear))
#[test]
fn test_aarch32_strh_i_a1_a_combo_3_b0_304000b0() {
    // Encoding: 0x304000B0
    // Test aarch32_STRH_i_A1_A field combination: cond=3, P=0, U=0, W=0, Rn=0, Rt=0, imm4H=0, imm4L=0
    // ISET: A32
    // Fields: Rn=0, cond=3, Rt=0, imm4L=0, imm4H=0, W=0, U=0, P=0
    let encoding: u32 = 0x304000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_i_A1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=4 (condition MI (minus/negative))
#[test]
fn test_aarch32_strh_i_a1_a_combo_4_b0_404000b0() {
    // Encoding: 0x404000B0
    // Test aarch32_STRH_i_A1_A field combination: cond=4, P=0, U=0, W=0, Rn=0, Rt=0, imm4H=0, imm4L=0
    // ISET: A32
    // Fields: P=0, imm4L=0, Rn=0, U=0, cond=4, W=0, Rt=0, imm4H=0
    let encoding: u32 = 0x404000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_i_A1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=5 (condition PL (plus/positive))
#[test]
fn test_aarch32_strh_i_a1_a_combo_5_b0_504000b0() {
    // Encoding: 0x504000B0
    // Test aarch32_STRH_i_A1_A field combination: cond=5, P=0, U=0, W=0, Rn=0, Rt=0, imm4H=0, imm4L=0
    // ISET: A32
    // Fields: Rt=0, Rn=0, cond=5, U=0, imm4L=0, imm4H=0, P=0, W=0
    let encoding: u32 = 0x504000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_i_A1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=6 (condition VS (overflow set))
#[test]
fn test_aarch32_strh_i_a1_a_combo_6_b0_604000b0() {
    // Encoding: 0x604000B0
    // Test aarch32_STRH_i_A1_A field combination: cond=6, P=0, U=0, W=0, Rn=0, Rt=0, imm4H=0, imm4L=0
    // ISET: A32
    // Fields: imm4L=0, P=0, Rn=0, W=0, cond=6, imm4H=0, Rt=0, U=0
    let encoding: u32 = 0x604000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_i_A1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=7 (condition VC (overflow clear))
#[test]
fn test_aarch32_strh_i_a1_a_combo_7_b0_704000b0() {
    // Encoding: 0x704000B0
    // Test aarch32_STRH_i_A1_A field combination: cond=7, P=0, U=0, W=0, Rn=0, Rt=0, imm4H=0, imm4L=0
    // ISET: A32
    // Fields: U=0, Rn=0, imm4L=0, cond=7, P=0, W=0, Rt=0, imm4H=0
    let encoding: u32 = 0x704000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_i_A1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=8 (condition HI (unsigned higher))
#[test]
fn test_aarch32_strh_i_a1_a_combo_8_b0_804000b0() {
    // Encoding: 0x804000B0
    // Test aarch32_STRH_i_A1_A field combination: cond=8, P=0, U=0, W=0, Rn=0, Rt=0, imm4H=0, imm4L=0
    // ISET: A32
    // Fields: P=0, cond=8, imm4L=0, Rn=0, imm4H=0, U=0, Rt=0, W=0
    let encoding: u32 = 0x804000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_i_A1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=9 (condition LS (unsigned lower or same))
#[test]
fn test_aarch32_strh_i_a1_a_combo_9_b0_904000b0() {
    // Encoding: 0x904000B0
    // Test aarch32_STRH_i_A1_A field combination: cond=9, P=0, U=0, W=0, Rn=0, Rt=0, imm4H=0, imm4L=0
    // ISET: A32
    // Fields: Rt=0, Rn=0, imm4L=0, W=0, imm4H=0, U=0, cond=9, P=0
    let encoding: u32 = 0x904000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_i_A1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=10 (condition GE (signed >=))
#[test]
fn test_aarch32_strh_i_a1_a_combo_10_b0_a04000b0() {
    // Encoding: 0xA04000B0
    // Test aarch32_STRH_i_A1_A field combination: cond=10, P=0, U=0, W=0, Rn=0, Rt=0, imm4H=0, imm4L=0
    // ISET: A32
    // Fields: U=0, Rt=0, imm4L=0, cond=10, W=0, Rn=0, imm4H=0, P=0
    let encoding: u32 = 0xA04000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_i_A1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=11 (condition LT (signed <))
#[test]
fn test_aarch32_strh_i_a1_a_combo_11_b0_b04000b0() {
    // Encoding: 0xB04000B0
    // Test aarch32_STRH_i_A1_A field combination: cond=11, P=0, U=0, W=0, Rn=0, Rt=0, imm4H=0, imm4L=0
    // ISET: A32
    // Fields: U=0, Rt=0, cond=11, imm4L=0, P=0, Rn=0, W=0, imm4H=0
    let encoding: u32 = 0xB04000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_i_A1_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=12 (condition GT (signed >))
#[test]
fn test_aarch32_strh_i_a1_a_combo_12_b0_c04000b0() {
    // Encoding: 0xC04000B0
    // Test aarch32_STRH_i_A1_A field combination: cond=12, P=0, U=0, W=0, Rn=0, Rt=0, imm4H=0, imm4L=0
    // ISET: A32
    // Fields: imm4H=0, Rt=0, P=0, U=0, W=0, Rn=0, imm4L=0, cond=12
    let encoding: u32 = 0xC04000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_i_A1_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=13 (condition LE (signed <=))
#[test]
fn test_aarch32_strh_i_a1_a_combo_13_b0_d04000b0() {
    // Encoding: 0xD04000B0
    // Test aarch32_STRH_i_A1_A field combination: cond=13, P=0, U=0, W=0, Rn=0, Rt=0, imm4H=0, imm4L=0
    // ISET: A32
    // Fields: imm4L=0, P=0, Rn=0, imm4H=0, W=0, U=0, cond=13, Rt=0
    let encoding: u32 = 0xD04000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_i_A1_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=14 (condition AL (always))
#[test]
fn test_aarch32_strh_i_a1_a_combo_14_b0_e04000b0() {
    // Encoding: 0xE04000B0
    // Test aarch32_STRH_i_A1_A field combination: cond=14, P=0, U=0, W=0, Rn=0, Rt=0, imm4H=0, imm4L=0
    // ISET: A32
    // Fields: U=0, cond=14, W=0, Rt=0, imm4H=0, Rn=0, P=0, imm4L=0
    let encoding: u32 = 0xE04000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_i_A1_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=15 (condition NV (never, reserved))
#[test]
fn test_aarch32_strh_i_a1_a_combo_15_b0_f04000b0() {
    // Encoding: 0xF04000B0
    // Test aarch32_STRH_i_A1_A field combination: cond=15, P=0, U=0, W=0, Rn=0, Rt=0, imm4H=0, imm4L=0
    // ISET: A32
    // Fields: U=0, W=0, cond=15, Rt=0, imm4H=0, P=0, imm4L=0, Rn=0
    let encoding: u32 = 0xF04000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_i_A1_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// P=0 (minimum value)
#[test]
fn test_aarch32_strh_i_a1_a_combo_16_b0_004000b0() {
    // Encoding: 0x004000B0
    // Test aarch32_STRH_i_A1_A field combination: cond=0, P=0, U=0, W=0, Rn=0, Rt=0, imm4H=0, imm4L=0
    // ISET: A32
    // Fields: P=0, imm4L=0, Rt=0, Rn=0, cond=0, imm4H=0, U=0, W=0
    let encoding: u32 = 0x004000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_i_A1_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// P=1 (maximum value (1))
#[test]
fn test_aarch32_strh_i_a1_a_combo_17_b0_014000b0() {
    // Encoding: 0x014000B0
    // Test aarch32_STRH_i_A1_A field combination: cond=0, P=1, U=0, W=0, Rn=0, Rt=0, imm4H=0, imm4L=0
    // ISET: A32
    // Fields: Rn=0, P=1, Rt=0, W=0, cond=0, U=0, imm4H=0, imm4L=0
    let encoding: u32 = 0x014000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_i_A1_A
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=0 (minimum value)
#[test]
fn test_aarch32_strh_i_a1_a_combo_18_b0_004000b0() {
    // Encoding: 0x004000B0
    // Test aarch32_STRH_i_A1_A field combination: cond=0, P=0, U=0, W=0, Rn=0, Rt=0, imm4H=0, imm4L=0
    // ISET: A32
    // Fields: Rt=0, W=0, Rn=0, imm4L=0, imm4H=0, cond=0, P=0, U=0
    let encoding: u32 = 0x004000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_i_A1_A
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=1 (maximum value (1))
#[test]
fn test_aarch32_strh_i_a1_a_combo_19_b0_00c000b0() {
    // Encoding: 0x00C000B0
    // Test aarch32_STRH_i_A1_A field combination: cond=0, P=0, U=1, W=0, Rn=0, Rt=0, imm4H=0, imm4L=0
    // ISET: A32
    // Fields: Rt=0, W=0, U=1, cond=0, P=0, imm4L=0, Rn=0, imm4H=0
    let encoding: u32 = 0x00C000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_i_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_strh_i_a1_a_special_cond_0_condition_eq_176_004000b0() {
    // Encoding: 0x004000B0
    // Test aarch32_STRH_i_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: Rt=0, W=0, imm4H=0, cond=0, U=0, imm4L=0, Rn=0, P=0
    let encoding: u32 = 0x004000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_i_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_strh_i_a1_a_special_cond_1_condition_ne_176_104000b0() {
    // Encoding: 0x104000B0
    // Test aarch32_STRH_i_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: W=0, Rt=0, imm4H=0, U=0, Rn=0, cond=1, P=0, imm4L=0
    let encoding: u32 = 0x104000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_i_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_strh_i_a1_a_special_cond_2_condition_cs_hs_176_204000b0() {
    // Encoding: 0x204000B0
    // Test aarch32_STRH_i_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: Rt=0, imm4L=0, W=0, P=0, cond=2, Rn=0, imm4H=0, U=0
    let encoding: u32 = 0x204000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_i_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_strh_i_a1_a_special_cond_3_condition_cc_lo_176_304000b0() {
    // Encoding: 0x304000B0
    // Test aarch32_STRH_i_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: imm4L=0, U=0, Rn=0, P=0, W=0, Rt=0, imm4H=0, cond=3
    let encoding: u32 = 0x304000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_i_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_strh_i_a1_a_special_cond_4_condition_mi_176_404000b0() {
    // Encoding: 0x404000B0
    // Test aarch32_STRH_i_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: Rt=0, cond=4, Rn=0, U=0, P=0, imm4L=0, W=0, imm4H=0
    let encoding: u32 = 0x404000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_i_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_strh_i_a1_a_special_cond_5_condition_pl_176_504000b0() {
    // Encoding: 0x504000B0
    // Test aarch32_STRH_i_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: Rn=0, U=0, W=0, imm4H=0, cond=5, imm4L=0, P=0, Rt=0
    let encoding: u32 = 0x504000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_i_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_strh_i_a1_a_special_cond_6_condition_vs_176_604000b0() {
    // Encoding: 0x604000B0
    // Test aarch32_STRH_i_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: U=0, P=0, cond=6, W=0, Rt=0, imm4H=0, Rn=0, imm4L=0
    let encoding: u32 = 0x604000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_i_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_strh_i_a1_a_special_cond_7_condition_vc_176_704000b0() {
    // Encoding: 0x704000B0
    // Test aarch32_STRH_i_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: Rn=0, U=0, imm4H=0, W=0, imm4L=0, cond=7, P=0, Rt=0
    let encoding: u32 = 0x704000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_i_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_strh_i_a1_a_special_cond_8_condition_hi_176_804000b0() {
    // Encoding: 0x804000B0
    // Test aarch32_STRH_i_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: cond=8, P=0, imm4H=0, Rt=0, W=0, Rn=0, imm4L=0, U=0
    let encoding: u32 = 0x804000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_i_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_strh_i_a1_a_special_cond_9_condition_ls_176_904000b0() {
    // Encoding: 0x904000B0
    // Test aarch32_STRH_i_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: cond=9, imm4H=0, Rn=0, Rt=0, U=0, W=0, P=0, imm4L=0
    let encoding: u32 = 0x904000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_i_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_strh_i_a1_a_special_cond_10_condition_ge_176_a04000b0() {
    // Encoding: 0xA04000B0
    // Test aarch32_STRH_i_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: imm4H=0, Rn=0, imm4L=0, cond=10, W=0, P=0, Rt=0, U=0
    let encoding: u32 = 0xA04000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_i_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_strh_i_a1_a_special_cond_11_condition_lt_176_b04000b0() {
    // Encoding: 0xB04000B0
    // Test aarch32_STRH_i_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: cond=11, W=0, imm4L=0, Rt=0, Rn=0, U=0, P=0, imm4H=0
    let encoding: u32 = 0xB04000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_i_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_strh_i_a1_a_special_cond_12_condition_gt_176_c04000b0() {
    // Encoding: 0xC04000B0
    // Test aarch32_STRH_i_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: imm4H=0, Rn=0, imm4L=0, Rt=0, U=0, cond=12, P=0, W=0
    let encoding: u32 = 0xC04000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_i_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_strh_i_a1_a_special_cond_13_condition_le_176_d04000b0() {
    // Encoding: 0xD04000B0
    // Test aarch32_STRH_i_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: cond=13, P=0, U=0, Rt=0, imm4L=0, Rn=0, W=0, imm4H=0
    let encoding: u32 = 0xD04000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_i_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_strh_i_a1_a_special_cond_14_condition_al_176_e04000b0() {
    // Encoding: 0xE04000B0
    // Test aarch32_STRH_i_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: cond=14, P=0, Rn=0, U=0, imm4H=0, Rt=0, imm4L=0, W=0
    let encoding: u32 = 0xE04000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_i_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_strh_i_a1_a_special_cond_15_condition_nv_176_f04000b0() {
    // Encoding: 0xF04000B0
    // Test aarch32_STRH_i_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: imm4H=0, cond=15, U=0, W=0, Rn=0, Rt=0, imm4L=0, P=0
    let encoding: u32 = 0xF04000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_i_A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strh_i_a1_a_invalid_0_b0_004000b0() {
    // Encoding: 0x004000B0
    // Test aarch32_STRH_i_A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: LitInt(15) }
    // ISET: A32
    // Fields: P=0, imm4H=0, Rt=0, imm4L=0, cond=0, Rn=0, W=0, U=0
    let encoding: u32 = 0x004000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STRH_i_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strh_i_a1_a_invalid_1_b0_004000b0() {
    // Encoding: 0x004000B0
    // Test aarch32_STRH_i_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: cond=0, W=0, imm4H=0, imm4L=0, P=0, Rn=0, U=0, Rt=0
    let encoding: u32 = 0x004000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STRH_i_A1_A
/// ASL: `Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"wback\" }), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }) } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strh_i_a1_a_invalid_2_b0_004000b0() {
    // Encoding: 0x004000B0
    // Test aarch32_STRH_i_A1_A invalid encoding: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) } }
    // ISET: A32
    // Fields: U=0, Rn=0, W=0, Rt=0, imm4H=0, cond=0, P=0, imm4L=0
    let encoding: u32 = 0x004000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STRH_i_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strh_i_a1_a_invalid_3_b0_004000b0() {
    // Encoding: 0x004000B0
    // Test aarch32_STRH_i_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: imm4H=0, imm4L=0, Rn=0, U=0, P=0, cond=0, W=0, Rt=0
    let encoding: u32 = 0x004000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STRH_i_T1_A
/// ASL: `field imm5 22 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_strh_i_t1_a_field_imm5_0_zero_0_80000000() {
    // Thumb encoding (32): 0x80000000
    // Test aarch32_STRH_i_T1_A field imm5 = 0 (Zero)
    // ISET: T32
    // Fields: Rn=0, imm5=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x80000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T1_A
/// ASL: `field imm5 22 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_strh_i_t1_a_field_imm5_1_poweroftwo_0_80400000() {
    // Thumb encoding (32): 0x80400000
    // Test aarch32_STRH_i_T1_A field imm5 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, Rn=0, imm5=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x80400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T1_A
/// ASL: `field imm5 22 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_strh_i_t1_a_field_imm5_3_poweroftwominusone_0_80c00000() {
    // Thumb encoding (32): 0x80C00000
    // Test aarch32_STRH_i_T1_A field imm5 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm5=3, Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x80C00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T1_A
/// ASL: `field imm5 22 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_strh_i_t1_a_field_imm5_4_poweroftwo_0_81000000() {
    // Thumb encoding (32): 0x81000000
    // Test aarch32_STRH_i_T1_A field imm5 = 4 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm5=4
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x81000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T1_A
/// ASL: `field imm5 22 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_strh_i_t1_a_field_imm5_7_poweroftwominusone_0_81c00000() {
    // Thumb encoding (32): 0x81C00000
    // Test aarch32_STRH_i_T1_A field imm5 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm5=7, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x81C00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T1_A
/// ASL: `field imm5 22 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_strh_i_t1_a_field_imm5_8_poweroftwo_0_82000000() {
    // Thumb encoding (32): 0x82000000
    // Test aarch32_STRH_i_T1_A field imm5 = 8 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm5=8
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x82000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T1_A
/// ASL: `field imm5 22 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 15, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (15)
#[test]
fn test_aarch32_strh_i_t1_a_field_imm5_15_poweroftwominusone_0_83c00000() {
    // Thumb encoding (32): 0x83C00000
    // Test aarch32_STRH_i_T1_A field imm5 = 15 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm5=15, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x83C00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T1_A
/// ASL: `field imm5 22 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_strh_i_t1_a_field_imm5_16_poweroftwo_0_84000000() {
    // Thumb encoding (32): 0x84000000
    // Test aarch32_STRH_i_T1_A field imm5 = 16 (PowerOfTwo)
    // ISET: T32
    // Fields: imm5=16, Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x84000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T1_A
/// ASL: `field imm5 22 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 31, boundary: Max }
/// maximum immediate (31)
#[test]
fn test_aarch32_strh_i_t1_a_field_imm5_31_max_0_87c00000() {
    // Thumb encoding (32): 0x87C00000
    // Test aarch32_STRH_i_T1_A field imm5 = 31 (Max)
    // ISET: T32
    // Fields: imm5=31, Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x87C00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T1_A
/// ASL: `field Rn 19 +: 3`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_strh_i_t1_a_field_rn_0_min_0_80000000() {
    // Thumb encoding (32): 0x80000000
    // Test aarch32_STRH_i_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: imm5=0, Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x80000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T1_A
/// ASL: `field Rn 19 +: 3`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_strh_i_t1_a_field_rn_1_poweroftwo_0_80080000() {
    // Thumb encoding (32): 0x80080000
    // Test aarch32_STRH_i_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, imm5=0, Rn=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x80080000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T1_A
/// ASL: `field Rt 16 +: 3`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_strh_i_t1_a_field_rt_0_min_0_80000000() {
    // Thumb encoding (32): 0x80000000
    // Test aarch32_STRH_i_T1_A field Rt = 0 (Min)
    // ISET: T32
    // Fields: imm5=0, Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x80000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T1_A
/// ASL: `field Rt 16 +: 3`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_strh_i_t1_a_field_rt_1_poweroftwo_0_80010000() {
    // Thumb encoding (32): 0x80010000
    // Test aarch32_STRH_i_T1_A field Rt = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=1, imm5=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x80010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=0 (immediate value 0)
#[test]
fn test_aarch32_strh_i_t1_a_combo_0_0_80000000() {
    // Thumb encoding (32): 0x80000000
    // Test aarch32_STRH_i_T1_A field combination: imm5=0, Rn=0, Rt=0
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm5=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x80000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=1 (immediate value 1)
#[test]
fn test_aarch32_strh_i_t1_a_combo_1_0_80400000() {
    // Thumb encoding (32): 0x80400000
    // Test aarch32_STRH_i_T1_A field combination: imm5=1, Rn=0, Rt=0
    // ISET: T32
    // Fields: imm5=1, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x80400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=3 (2^2 - 1 = 3)
#[test]
fn test_aarch32_strh_i_t1_a_combo_2_0_80c00000() {
    // Thumb encoding (32): 0x80C00000
    // Test aarch32_STRH_i_T1_A field combination: imm5=3, Rn=0, Rt=0
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm5=3
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x80C00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=4 (power of 2 (2^2 = 4))
#[test]
fn test_aarch32_strh_i_t1_a_combo_3_0_81000000() {
    // Thumb encoding (32): 0x81000000
    // Test aarch32_STRH_i_T1_A field combination: imm5=4, Rn=0, Rt=0
    // ISET: T32
    // Fields: imm5=4, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x81000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=7 (2^3 - 1 = 7)
#[test]
fn test_aarch32_strh_i_t1_a_combo_4_0_81c00000() {
    // Thumb encoding (32): 0x81C00000
    // Test aarch32_STRH_i_T1_A field combination: imm5=7, Rn=0, Rt=0
    // ISET: T32
    // Fields: imm5=7, Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x81C00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=8 (power of 2 (2^3 = 8))
#[test]
fn test_aarch32_strh_i_t1_a_combo_5_0_82000000() {
    // Thumb encoding (32): 0x82000000
    // Test aarch32_STRH_i_T1_A field combination: imm5=8, Rn=0, Rt=0
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm5=8
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x82000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=15 (immediate midpoint (15))
#[test]
fn test_aarch32_strh_i_t1_a_combo_6_0_83c00000() {
    // Thumb encoding (32): 0x83C00000
    // Test aarch32_STRH_i_T1_A field combination: imm5=15, Rn=0, Rt=0
    // ISET: T32
    // Fields: Rt=0, Rn=0, imm5=15
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x83C00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=16 (power of 2 (2^4 = 16))
#[test]
fn test_aarch32_strh_i_t1_a_combo_7_0_84000000() {
    // Thumb encoding (32): 0x84000000
    // Test aarch32_STRH_i_T1_A field combination: imm5=16, Rn=0, Rt=0
    // ISET: T32
    // Fields: Rn=0, imm5=16, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x84000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=31 (maximum immediate (31))
#[test]
fn test_aarch32_strh_i_t1_a_combo_8_0_87c00000() {
    // Thumb encoding (32): 0x87C00000
    // Test aarch32_STRH_i_T1_A field combination: imm5=31, Rn=0, Rt=0
    // ISET: T32
    // Fields: imm5=31, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x87C00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_strh_i_t1_a_combo_9_0_80000000() {
    // Thumb encoding (32): 0x80000000
    // Test aarch32_STRH_i_T1_A field combination: imm5=0, Rn=0, Rt=0
    // ISET: T32
    // Fields: imm5=0, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x80000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_strh_i_t1_a_combo_10_0_80080000() {
    // Thumb encoding (32): 0x80080000
    // Test aarch32_STRH_i_T1_A field combination: imm5=0, Rn=1, Rt=0
    // ISET: T32
    // Fields: Rt=0, Rn=1, imm5=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x80080000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=0 (register index 0 (first register))
#[test]
fn test_aarch32_strh_i_t1_a_combo_11_0_80000000() {
    // Thumb encoding (32): 0x80000000
    // Test aarch32_STRH_i_T1_A field combination: imm5=0, Rn=0, Rt=0
    // ISET: T32
    // Fields: imm5=0, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x80000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T1_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=1 (register index 1 (second register))
#[test]
fn test_aarch32_strh_i_t1_a_combo_12_0_80010000() {
    // Thumb encoding (32): 0x80010000
    // Test aarch32_STRH_i_T1_A field combination: imm5=0, Rn=0, Rt=1
    // ISET: T32
    // Fields: imm5=0, Rt=1, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x80010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T1_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rt=1 (same register test (reg=1))
#[test]
fn test_aarch32_strh_i_t1_a_combo_13_0_80090000() {
    // Thumb encoding (32): 0x80090000
    // Test aarch32_STRH_i_T1_A field combination: imm5=0, Rn=1, Rt=1
    // ISET: T32
    // Fields: imm5=0, Rn=1, Rt=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x80090000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T1_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rt=31 (same register test (reg=31))
#[test]
fn test_aarch32_strh_i_t1_a_combo_14_0_803f0000() {
    // Thumb encoding (32): 0x803F0000
    // Test aarch32_STRH_i_T1_A field combination: imm5=0, Rn=31, Rt=31
    // ISET: T32
    // Fields: Rn=31, Rt=31, imm5=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x803F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_strh_i_t2_a_field_rn_0_min_0_f8a00000() {
    // Thumb encoding (32): 0xF8A00000
    // Test aarch32_STRH_i_T2_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, imm12=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_strh_i_t2_a_field_rn_1_poweroftwo_0_f8a10000() {
    // Thumb encoding (32): 0xF8A10000
    // Test aarch32_STRH_i_T2_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=1, Rt=0, imm12=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8A10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T2_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_strh_i_t2_a_field_rt_0_min_0_f8a00000() {
    // Thumb encoding (32): 0xF8A00000
    // Test aarch32_STRH_i_T2_A field Rt = 0 (Min)
    // ISET: T32
    // Fields: imm12=0, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T2_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_strh_i_t2_a_field_rt_1_poweroftwo_0_f8a01000() {
    // Thumb encoding (32): 0xF8A01000
    // Test aarch32_STRH_i_T2_A field Rt = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Rt=1, imm12=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8A01000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_strh_i_t2_a_field_imm12_0_zero_0_f8a00000() {
    // Thumb encoding (32): 0xF8A00000
    // Test aarch32_STRH_i_T2_A field imm12 = 0 (Zero)
    // ISET: T32
    // Fields: Rt=0, Rn=0, imm12=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_strh_i_t2_a_field_imm12_1_poweroftwo_0_f8a00001() {
    // Thumb encoding (32): 0xF8A00001
    // Test aarch32_STRH_i_T2_A field imm12 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, imm12=1, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8A00001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_strh_i_t2_a_field_imm12_3_poweroftwominusone_0_f8a00003() {
    // Thumb encoding (32): 0xF8A00003
    // Test aarch32_STRH_i_T2_A field imm12 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm12=3, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8A00003;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_strh_i_t2_a_field_imm12_4_poweroftwo_0_f8a00004() {
    // Thumb encoding (32): 0xF8A00004
    // Test aarch32_STRH_i_T2_A field imm12 = 4 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm12=4
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8A00004;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_strh_i_t2_a_field_imm12_7_poweroftwominusone_0_f8a00007() {
    // Thumb encoding (32): 0xF8A00007
    // Test aarch32_STRH_i_T2_A field imm12 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, imm12=7, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8A00007;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_strh_i_t2_a_field_imm12_8_poweroftwo_0_f8a00008() {
    // Thumb encoding (32): 0xF8A00008
    // Test aarch32_STRH_i_T2_A field imm12 = 8 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm12=8
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8A00008;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_strh_i_t2_a_field_imm12_15_poweroftwominusone_0_f8a0000f() {
    // Thumb encoding (32): 0xF8A0000F
    // Test aarch32_STRH_i_T2_A field imm12 = 15 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, Rn=0, imm12=15
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8A0000F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_strh_i_t2_a_field_imm12_16_poweroftwo_0_f8a00010() {
    // Thumb encoding (32): 0xF8A00010
    // Test aarch32_STRH_i_T2_A field imm12 = 16 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, imm12=16, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8A00010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_strh_i_t2_a_field_imm12_31_poweroftwominusone_0_f8a0001f() {
    // Thumb encoding (32): 0xF8A0001F
    // Test aarch32_STRH_i_T2_A field imm12 = 31 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, imm12=31, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8A0001F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_strh_i_t2_a_field_imm12_32_poweroftwo_0_f8a00020() {
    // Thumb encoding (32): 0xF8A00020
    // Test aarch32_STRH_i_T2_A field imm12 = 32 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm12=32
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8A00020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_strh_i_t2_a_field_imm12_63_poweroftwominusone_0_f8a0003f() {
    // Thumb encoding (32): 0xF8A0003F
    // Test aarch32_STRH_i_T2_A field imm12 = 63 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm12=63
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8A0003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_strh_i_t2_a_field_imm12_64_poweroftwo_0_f8a00040() {
    // Thumb encoding (32): 0xF8A00040
    // Test aarch32_STRH_i_T2_A field imm12 = 64 (PowerOfTwo)
    // ISET: T32
    // Fields: imm12=64, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8A00040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 127, boundary: PowerOfTwoMinusOne }
/// 2^7 - 1 = 127
#[test]
fn test_aarch32_strh_i_t2_a_field_imm12_127_poweroftwominusone_0_f8a0007f() {
    // Thumb encoding (32): 0xF8A0007F
    // Test aarch32_STRH_i_T2_A field imm12 = 127 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm12=127, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8A0007F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_strh_i_t2_a_field_imm12_128_poweroftwo_0_f8a00080() {
    // Thumb encoding (32): 0xF8A00080
    // Test aarch32_STRH_i_T2_A field imm12 = 128 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, Rn=0, imm12=128
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8A00080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 255, boundary: PowerOfTwoMinusOne }
/// 2^8 - 1 = 255
#[test]
fn test_aarch32_strh_i_t2_a_field_imm12_255_poweroftwominusone_0_f8a000ff() {
    // Thumb encoding (32): 0xF8A000FF
    // Test aarch32_STRH_i_T2_A field imm12 = 255 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, imm12=255, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8A000FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 256, boundary: PowerOfTwo }
/// power of 2 (2^8 = 256)
#[test]
fn test_aarch32_strh_i_t2_a_field_imm12_256_poweroftwo_0_f8a00100() {
    // Thumb encoding (32): 0xF8A00100
    // Test aarch32_STRH_i_T2_A field imm12 = 256 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, imm12=256, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8A00100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 511, boundary: PowerOfTwoMinusOne }
/// 2^9 - 1 = 511
#[test]
fn test_aarch32_strh_i_t2_a_field_imm12_511_poweroftwominusone_0_f8a001ff() {
    // Thumb encoding (32): 0xF8A001FF
    // Test aarch32_STRH_i_T2_A field imm12 = 511 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm12=511
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8A001FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 512, boundary: PowerOfTwo }
/// power of 2 (2^9 = 512)
#[test]
fn test_aarch32_strh_i_t2_a_field_imm12_512_poweroftwo_0_f8a00200() {
    // Thumb encoding (32): 0xF8A00200
    // Test aarch32_STRH_i_T2_A field imm12 = 512 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm12=512
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8A00200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1023, boundary: PowerOfTwoMinusOne }
/// 2^10 - 1 = 1023
#[test]
fn test_aarch32_strh_i_t2_a_field_imm12_1023_poweroftwominusone_0_f8a003ff() {
    // Thumb encoding (32): 0xF8A003FF
    // Test aarch32_STRH_i_T2_A field imm12 = 1023 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, Rn=0, imm12=1023
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8A003FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1024, boundary: PowerOfTwo }
/// power of 2 (2^10 = 1024)
#[test]
fn test_aarch32_strh_i_t2_a_field_imm12_1024_poweroftwo_0_f8a00400() {
    // Thumb encoding (32): 0xF8A00400
    // Test aarch32_STRH_i_T2_A field imm12 = 1024 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, imm12=1024, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8A00400;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2047, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (2047)
#[test]
fn test_aarch32_strh_i_t2_a_field_imm12_2047_poweroftwominusone_0_f8a007ff() {
    // Thumb encoding (32): 0xF8A007FF
    // Test aarch32_STRH_i_T2_A field imm12 = 2047 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm12=2047
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8A007FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2048, boundary: PowerOfTwo }
/// power of 2 (2^11 = 2048)
#[test]
fn test_aarch32_strh_i_t2_a_field_imm12_2048_poweroftwo_0_f8a00800() {
    // Thumb encoding (32): 0xF8A00800
    // Test aarch32_STRH_i_T2_A field imm12 = 2048 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, imm12=2048, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8A00800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4095, boundary: Max }
/// maximum immediate (4095)
#[test]
fn test_aarch32_strh_i_t2_a_field_imm12_4095_max_0_f8a00fff() {
    // Thumb encoding (32): 0xF8A00FFF
    // Test aarch32_STRH_i_T2_A field imm12 = 4095 (Max)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm12=4095
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8A00FFF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T2_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_strh_i_t2_a_combo_0_0_f8a00000() {
    // Thumb encoding (32): 0xF8A00000
    // Test aarch32_STRH_i_T2_A field combination: Rn=0, Rt=0, imm12=0
    // ISET: T32
    // Fields: Rt=0, Rn=0, imm12=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T2_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_strh_i_t2_a_combo_1_0_f8a10000() {
    // Thumb encoding (32): 0xF8A10000
    // Test aarch32_STRH_i_T2_A field combination: Rn=1, Rt=0, imm12=0
    // ISET: T32
    // Fields: imm12=0, Rn=1, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8A10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T2_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=0 (register index 0 (first register))
#[test]
fn test_aarch32_strh_i_t2_a_combo_2_0_f8a00000() {
    // Thumb encoding (32): 0xF8A00000
    // Test aarch32_STRH_i_T2_A field combination: Rn=0, Rt=0, imm12=0
    // ISET: T32
    // Fields: Rt=0, imm12=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T2_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=1 (register index 1 (second register))
#[test]
fn test_aarch32_strh_i_t2_a_combo_3_0_f8a01000() {
    // Thumb encoding (32): 0xF8A01000
    // Test aarch32_STRH_i_T2_A field combination: Rn=0, Rt=1, imm12=0
    // ISET: T32
    // Fields: Rt=1, imm12=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8A01000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T2_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm12=0 (immediate value 0)
#[test]
fn test_aarch32_strh_i_t2_a_combo_4_0_f8a00000() {
    // Thumb encoding (32): 0xF8A00000
    // Test aarch32_STRH_i_T2_A field combination: Rn=0, Rt=0, imm12=0
    // ISET: T32
    // Fields: Rt=0, imm12=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T2_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm12=1 (immediate value 1)
#[test]
fn test_aarch32_strh_i_t2_a_combo_5_0_f8a00001() {
    // Thumb encoding (32): 0xF8A00001
    // Test aarch32_STRH_i_T2_A field combination: Rn=0, Rt=0, imm12=1
    // ISET: T32
    // Fields: imm12=1, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8A00001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T2_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm12=3 (2^2 - 1 = 3)
#[test]
fn test_aarch32_strh_i_t2_a_combo_6_0_f8a00003() {
    // Thumb encoding (32): 0xF8A00003
    // Test aarch32_STRH_i_T2_A field combination: Rn=0, Rt=0, imm12=3
    // ISET: T32
    // Fields: imm12=3, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8A00003;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T2_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm12=4 (power of 2 (2^2 = 4))
#[test]
fn test_aarch32_strh_i_t2_a_combo_7_0_f8a00004() {
    // Thumb encoding (32): 0xF8A00004
    // Test aarch32_STRH_i_T2_A field combination: Rn=0, Rt=0, imm12=4
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm12=4
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8A00004;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T2_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm12=7 (2^3 - 1 = 7)
#[test]
fn test_aarch32_strh_i_t2_a_combo_8_0_f8a00007() {
    // Thumb encoding (32): 0xF8A00007
    // Test aarch32_STRH_i_T2_A field combination: Rn=0, Rt=0, imm12=7
    // ISET: T32
    // Fields: imm12=7, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8A00007;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T2_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm12=8 (power of 2 (2^3 = 8))
#[test]
fn test_aarch32_strh_i_t2_a_combo_9_0_f8a00008() {
    // Thumb encoding (32): 0xF8A00008
    // Test aarch32_STRH_i_T2_A field combination: Rn=0, Rt=0, imm12=8
    // ISET: T32
    // Fields: Rn=0, imm12=8, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8A00008;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T2_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm12=15 (2^4 - 1 = 15)
#[test]
fn test_aarch32_strh_i_t2_a_combo_10_0_f8a0000f() {
    // Thumb encoding (32): 0xF8A0000F
    // Test aarch32_STRH_i_T2_A field combination: Rn=0, Rt=0, imm12=15
    // ISET: T32
    // Fields: imm12=15, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8A0000F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T2_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm12=16 (power of 2 (2^4 = 16))
#[test]
fn test_aarch32_strh_i_t2_a_combo_11_0_f8a00010() {
    // Thumb encoding (32): 0xF8A00010
    // Test aarch32_STRH_i_T2_A field combination: Rn=0, Rt=0, imm12=16
    // ISET: T32
    // Fields: imm12=16, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8A00010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T2_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm12=31 (2^5 - 1 = 31)
#[test]
fn test_aarch32_strh_i_t2_a_combo_12_0_f8a0001f() {
    // Thumb encoding (32): 0xF8A0001F
    // Test aarch32_STRH_i_T2_A field combination: Rn=0, Rt=0, imm12=31
    // ISET: T32
    // Fields: imm12=31, Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8A0001F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T2_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm12=32 (power of 2 (2^5 = 32))
#[test]
fn test_aarch32_strh_i_t2_a_combo_13_0_f8a00020() {
    // Thumb encoding (32): 0xF8A00020
    // Test aarch32_STRH_i_T2_A field combination: Rn=0, Rt=0, imm12=32
    // ISET: T32
    // Fields: imm12=32, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8A00020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T2_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm12=63 (2^6 - 1 = 63)
#[test]
fn test_aarch32_strh_i_t2_a_combo_14_0_f8a0003f() {
    // Thumb encoding (32): 0xF8A0003F
    // Test aarch32_STRH_i_T2_A field combination: Rn=0, Rt=0, imm12=63
    // ISET: T32
    // Fields: imm12=63, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8A0003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T2_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm12=64 (power of 2 (2^6 = 64))
#[test]
fn test_aarch32_strh_i_t2_a_combo_15_0_f8a00040() {
    // Thumb encoding (32): 0xF8A00040
    // Test aarch32_STRH_i_T2_A field combination: Rn=0, Rt=0, imm12=64
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm12=64
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8A00040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T2_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm12=127 (2^7 - 1 = 127)
#[test]
fn test_aarch32_strh_i_t2_a_combo_16_0_f8a0007f() {
    // Thumb encoding (32): 0xF8A0007F
    // Test aarch32_STRH_i_T2_A field combination: Rn=0, Rt=0, imm12=127
    // ISET: T32
    // Fields: Rt=0, imm12=127, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8A0007F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T2_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm12=128 (power of 2 (2^7 = 128))
#[test]
fn test_aarch32_strh_i_t2_a_combo_17_0_f8a00080() {
    // Thumb encoding (32): 0xF8A00080
    // Test aarch32_STRH_i_T2_A field combination: Rn=0, Rt=0, imm12=128
    // ISET: T32
    // Fields: Rt=0, imm12=128, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8A00080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T2_A
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm12=255 (2^8 - 1 = 255)
#[test]
fn test_aarch32_strh_i_t2_a_combo_18_0_f8a000ff() {
    // Thumb encoding (32): 0xF8A000FF
    // Test aarch32_STRH_i_T2_A field combination: Rn=0, Rt=0, imm12=255
    // ISET: T32
    // Fields: Rn=0, imm12=255, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8A000FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T2_A
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm12=256 (power of 2 (2^8 = 256))
#[test]
fn test_aarch32_strh_i_t2_a_combo_19_0_f8a00100() {
    // Thumb encoding (32): 0xF8A00100
    // Test aarch32_STRH_i_T2_A field combination: Rn=0, Rt=0, imm12=256
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm12=256
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8A00100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T2_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rn" }), rhs: LitBits([true, true, true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Rn\" }), rhs: LitBits([true, true, true, true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_strh_i_t2_a_invalid_0_0_f8a00000() {
    // Thumb encoding (32): 0xF8A00000
    // Test aarch32_STRH_i_T2_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rn" }), rhs: LitBits([true, true, true, true]) }
    // ISET: T32
    // Fields: imm12=0, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_STRH_i_T2_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_strh_i_t2_a_invalid_1_0_f8a00000() {
    // Thumb encoding (32): 0xF8A00000
    // Test aarch32_STRH_i_T2_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: Rt=0, imm12=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_STRH_i_T2_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strh_i_t2_a_invalid_2_0_f8a00000() {
    // Thumb encoding (32): 0xF8A00000
    // Test aarch32_STRH_i_T2_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: LitInt(15) }
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm12=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8A00000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_STRH_i_T2_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strh_i_t2_a_invalid_3_0_f8a00000() {
    // Thumb encoding (32): 0xF8A00000
    // Test aarch32_STRH_i_T2_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rn=0, imm12=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8A00000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_STRH_i_T3_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_strh_i_t3_a_field_rn_0_min_800_f8200800() {
    // Thumb encoding (32): 0xF8200800
    // Test aarch32_STRH_i_T3_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: imm8=0, Rn=0, Rt=0, P=0, U=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8200800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T3_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_strh_i_t3_a_field_rn_1_poweroftwo_800_f8210800() {
    // Thumb encoding (32): 0xF8210800
    // Test aarch32_STRH_i_T3_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: P=0, W=0, Rn=1, imm8=0, U=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8210800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T3_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_strh_i_t3_a_field_rt_0_min_800_f8200800() {
    // Thumb encoding (32): 0xF8200800
    // Test aarch32_STRH_i_T3_A field Rt = 0 (Min)
    // ISET: T32
    // Fields: U=0, Rt=0, W=0, Rn=0, P=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8200800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T3_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_strh_i_t3_a_field_rt_1_poweroftwo_800_f8201800() {
    // Thumb encoding (32): 0xF8201800
    // Test aarch32_STRH_i_T3_A field Rt = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=0, Rt=1, P=0, Rn=0, W=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8201800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T3_A
/// ASL: `field P 10 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_strh_i_t3_a_field_p_0_min_800_f8200800() {
    // Thumb encoding (32): 0xF8200800
    // Test aarch32_STRH_i_T3_A field P = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rt=0, P=0, U=0, W=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8200800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T3_A
/// ASL: `field P 10 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_strh_i_t3_a_field_p_1_max_800_f8200c00() {
    // Thumb encoding (32): 0xF8200C00
    // Test aarch32_STRH_i_T3_A field P = 1 (Max)
    // ISET: T32
    // Fields: imm8=0, Rt=0, U=0, Rn=0, P=1, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8200C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T3_A
/// ASL: `field U 9 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_strh_i_t3_a_field_u_0_min_800_f8200800() {
    // Thumb encoding (32): 0xF8200800
    // Test aarch32_STRH_i_T3_A field U = 0 (Min)
    // ISET: T32
    // Fields: Rt=0, Rn=0, U=0, W=0, P=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8200800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T3_A
/// ASL: `field U 9 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_strh_i_t3_a_field_u_1_max_800_f8200a00() {
    // Thumb encoding (32): 0xF8200A00
    // Test aarch32_STRH_i_T3_A field U = 1 (Max)
    // ISET: T32
    // Fields: imm8=0, W=0, Rt=0, Rn=0, P=0, U=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8200A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T3_A
/// ASL: `field W 8 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_strh_i_t3_a_field_w_0_min_800_f8200800() {
    // Thumb encoding (32): 0xF8200800
    // Test aarch32_STRH_i_T3_A field W = 0 (Min)
    // ISET: T32
    // Fields: W=0, imm8=0, Rt=0, P=0, Rn=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8200800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T3_A
/// ASL: `field W 8 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_strh_i_t3_a_field_w_1_max_800_f8200900() {
    // Thumb encoding (32): 0xF8200900
    // Test aarch32_STRH_i_T3_A field W = 1 (Max)
    // ISET: T32
    // Fields: P=0, Rt=0, W=1, imm8=0, U=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8200900;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_strh_i_t3_a_field_imm8_0_zero_800_f8200800() {
    // Thumb encoding (32): 0xF8200800
    // Test aarch32_STRH_i_T3_A field imm8 = 0 (Zero)
    // ISET: T32
    // Fields: U=0, W=0, imm8=0, Rn=0, Rt=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8200800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_strh_i_t3_a_field_imm8_1_poweroftwo_800_f8200801() {
    // Thumb encoding (32): 0xF8200801
    // Test aarch32_STRH_i_T3_A field imm8 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: P=0, Rt=0, Rn=0, U=0, W=0, imm8=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8200801;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_strh_i_t3_a_field_imm8_3_poweroftwominusone_800_f8200803() {
    // Thumb encoding (32): 0xF8200803
    // Test aarch32_STRH_i_T3_A field imm8 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, P=0, U=0, W=0, imm8=3, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8200803;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_strh_i_t3_a_field_imm8_4_poweroftwo_800_f8200804() {
    // Thumb encoding (32): 0xF8200804
    // Test aarch32_STRH_i_T3_A field imm8 = 4 (PowerOfTwo)
    // ISET: T32
    // Fields: W=0, P=0, Rn=0, Rt=0, U=0, imm8=4
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8200804;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_strh_i_t3_a_field_imm8_7_poweroftwominusone_800_f8200807() {
    // Thumb encoding (32): 0xF8200807
    // Test aarch32_STRH_i_T3_A field imm8 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, imm8=7, Rn=0, U=0, W=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8200807;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_strh_i_t3_a_field_imm8_8_poweroftwo_800_f8200808() {
    // Thumb encoding (32): 0xF8200808
    // Test aarch32_STRH_i_T3_A field imm8 = 8 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, W=0, imm8=8, Rn=0, U=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8200808;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_strh_i_t3_a_field_imm8_15_poweroftwominusone_800_f820080f() {
    // Thumb encoding (32): 0xF820080F
    // Test aarch32_STRH_i_T3_A field imm8 = 15 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, U=0, W=0, imm8=15, P=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF820080F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_strh_i_t3_a_field_imm8_16_poweroftwo_800_f8200810() {
    // Thumb encoding (32): 0xF8200810
    // Test aarch32_STRH_i_T3_A field imm8 = 16 (PowerOfTwo)
    // ISET: T32
    // Fields: W=0, P=0, Rt=0, Rn=0, U=0, imm8=16
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8200810;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_strh_i_t3_a_field_imm8_31_poweroftwominusone_800_f820081f() {
    // Thumb encoding (32): 0xF820081F
    // Test aarch32_STRH_i_T3_A field imm8 = 31 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, imm8=31, W=0, P=0, Rt=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF820081F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_strh_i_t3_a_field_imm8_32_poweroftwo_800_f8200820() {
    // Thumb encoding (32): 0xF8200820
    // Test aarch32_STRH_i_T3_A field imm8 = 32 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=32, P=0, Rt=0, U=0, Rn=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8200820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_strh_i_t3_a_field_imm8_63_poweroftwominusone_800_f820083f() {
    // Thumb encoding (32): 0xF820083F
    // Test aarch32_STRH_i_T3_A field imm8 = 63 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm8=63, U=0, P=0, W=0, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF820083F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_strh_i_t3_a_field_imm8_64_poweroftwo_800_f8200840() {
    // Thumb encoding (32): 0xF8200840
    // Test aarch32_STRH_i_T3_A field imm8 = 64 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, imm8=64, W=0, Rn=0, U=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8200840;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 127, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (127)
#[test]
fn test_aarch32_strh_i_t3_a_field_imm8_127_poweroftwominusone_800_f820087f() {
    // Thumb encoding (32): 0xF820087F
    // Test aarch32_STRH_i_T3_A field imm8 = 127 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: U=0, W=0, imm8=127, Rn=0, P=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF820087F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_strh_i_t3_a_field_imm8_128_poweroftwo_800_f8200880() {
    // Thumb encoding (32): 0xF8200880
    // Test aarch32_STRH_i_T3_A field imm8 = 128 (PowerOfTwo)
    // ISET: T32
    // Fields: W=0, imm8=128, Rn=0, P=0, Rt=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8200880;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 255, boundary: Max }
/// maximum immediate (255)
#[test]
fn test_aarch32_strh_i_t3_a_field_imm8_255_max_800_f82008ff() {
    // Thumb encoding (32): 0xF82008FF
    // Test aarch32_STRH_i_T3_A field imm8 = 255 (Max)
    // ISET: T32
    // Fields: Rn=0, U=0, Rt=0, imm8=255, W=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF82008FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T3_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_strh_i_t3_a_combo_0_800_f8200800() {
    // Thumb encoding (32): 0xF8200800
    // Test aarch32_STRH_i_T3_A field combination: Rn=0, Rt=0, P=0, U=0, W=0, imm8=0
    // ISET: T32
    // Fields: Rt=0, Rn=0, P=0, U=0, W=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8200800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T3_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_strh_i_t3_a_combo_1_800_f8210800() {
    // Thumb encoding (32): 0xF8210800
    // Test aarch32_STRH_i_T3_A field combination: Rn=1, Rt=0, P=0, U=0, W=0, imm8=0
    // ISET: T32
    // Fields: U=0, P=0, Rn=1, W=0, Rt=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8210800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T3_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=0 (register index 0 (first register))
#[test]
fn test_aarch32_strh_i_t3_a_combo_2_800_f8200800() {
    // Thumb encoding (32): 0xF8200800
    // Test aarch32_STRH_i_T3_A field combination: Rn=0, Rt=0, P=0, U=0, W=0, imm8=0
    // ISET: T32
    // Fields: U=0, imm8=0, Rt=0, Rn=0, W=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8200800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T3_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=1 (register index 1 (second register))
#[test]
fn test_aarch32_strh_i_t3_a_combo_3_800_f8201800() {
    // Thumb encoding (32): 0xF8201800
    // Test aarch32_STRH_i_T3_A field combination: Rn=0, Rt=1, P=0, U=0, W=0, imm8=0
    // ISET: T32
    // Fields: Rt=1, P=0, U=0, Rn=0, W=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8201800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T3_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// P=0 (minimum value)
#[test]
fn test_aarch32_strh_i_t3_a_combo_4_800_f8200800() {
    // Thumb encoding (32): 0xF8200800
    // Test aarch32_STRH_i_T3_A field combination: Rn=0, Rt=0, P=0, U=0, W=0, imm8=0
    // ISET: T32
    // Fields: Rt=0, U=0, P=0, imm8=0, Rn=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8200800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T3_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// P=1 (maximum value (1))
#[test]
fn test_aarch32_strh_i_t3_a_combo_5_800_f8200c00() {
    // Thumb encoding (32): 0xF8200C00
    // Test aarch32_STRH_i_T3_A field combination: Rn=0, Rt=0, P=1, U=0, W=0, imm8=0
    // ISET: T32
    // Fields: Rn=0, Rt=0, U=0, W=0, P=1, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8200C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T3_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=0 (minimum value)
#[test]
fn test_aarch32_strh_i_t3_a_combo_6_800_f8200800() {
    // Thumb encoding (32): 0xF8200800
    // Test aarch32_STRH_i_T3_A field combination: Rn=0, Rt=0, P=0, U=0, W=0, imm8=0
    // ISET: T32
    // Fields: U=0, W=0, imm8=0, Rt=0, Rn=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8200800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T3_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=1 (maximum value (1))
#[test]
fn test_aarch32_strh_i_t3_a_combo_7_800_f8200a00() {
    // Thumb encoding (32): 0xF8200A00
    // Test aarch32_STRH_i_T3_A field combination: Rn=0, Rt=0, P=0, U=1, W=0, imm8=0
    // ISET: T32
    // Fields: P=0, Rn=0, Rt=0, W=0, imm8=0, U=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8200A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T3_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// W=0 (minimum value)
#[test]
fn test_aarch32_strh_i_t3_a_combo_8_800_f8200800() {
    // Thumb encoding (32): 0xF8200800
    // Test aarch32_STRH_i_T3_A field combination: Rn=0, Rt=0, P=0, U=0, W=0, imm8=0
    // ISET: T32
    // Fields: imm8=0, W=0, Rt=0, Rn=0, P=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8200800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T3_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// W=1 (maximum value (1))
#[test]
fn test_aarch32_strh_i_t3_a_combo_9_800_f8200900() {
    // Thumb encoding (32): 0xF8200900
    // Test aarch32_STRH_i_T3_A field combination: Rn=0, Rt=0, P=0, U=0, W=1, imm8=0
    // ISET: T32
    // Fields: P=0, imm8=0, Rn=0, U=0, W=1, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8200900;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T3_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=0 (immediate value 0)
#[test]
fn test_aarch32_strh_i_t3_a_combo_10_800_f8200800() {
    // Thumb encoding (32): 0xF8200800
    // Test aarch32_STRH_i_T3_A field combination: Rn=0, Rt=0, P=0, U=0, W=0, imm8=0
    // ISET: T32
    // Fields: P=0, W=0, imm8=0, U=0, Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8200800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T3_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=1 (immediate value 1)
#[test]
fn test_aarch32_strh_i_t3_a_combo_11_800_f8200801() {
    // Thumb encoding (32): 0xF8200801
    // Test aarch32_STRH_i_T3_A field combination: Rn=0, Rt=0, P=0, U=0, W=0, imm8=1
    // ISET: T32
    // Fields: W=0, imm8=1, Rn=0, P=0, U=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8200801;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T3_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=3 (2^2 - 1 = 3)
#[test]
fn test_aarch32_strh_i_t3_a_combo_12_800_f8200803() {
    // Thumb encoding (32): 0xF8200803
    // Test aarch32_STRH_i_T3_A field combination: Rn=0, Rt=0, P=0, U=0, W=0, imm8=3
    // ISET: T32
    // Fields: U=0, W=0, Rn=0, P=0, Rt=0, imm8=3
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8200803;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T3_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=4 (power of 2 (2^2 = 4))
#[test]
fn test_aarch32_strh_i_t3_a_combo_13_800_f8200804() {
    // Thumb encoding (32): 0xF8200804
    // Test aarch32_STRH_i_T3_A field combination: Rn=0, Rt=0, P=0, U=0, W=0, imm8=4
    // ISET: T32
    // Fields: Rn=0, P=0, Rt=0, W=0, imm8=4, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8200804;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T3_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=7 (2^3 - 1 = 7)
#[test]
fn test_aarch32_strh_i_t3_a_combo_14_800_f8200807() {
    // Thumb encoding (32): 0xF8200807
    // Test aarch32_STRH_i_T3_A field combination: Rn=0, Rt=0, P=0, U=0, W=0, imm8=7
    // ISET: T32
    // Fields: U=0, W=0, imm8=7, Rt=0, Rn=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8200807;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T3_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=8 (power of 2 (2^3 = 8))
#[test]
fn test_aarch32_strh_i_t3_a_combo_15_800_f8200808() {
    // Thumb encoding (32): 0xF8200808
    // Test aarch32_STRH_i_T3_A field combination: Rn=0, Rt=0, P=0, U=0, W=0, imm8=8
    // ISET: T32
    // Fields: Rn=0, U=0, P=0, W=0, imm8=8, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8200808;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T3_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=15 (2^4 - 1 = 15)
#[test]
fn test_aarch32_strh_i_t3_a_combo_16_800_f820080f() {
    // Thumb encoding (32): 0xF820080F
    // Test aarch32_STRH_i_T3_A field combination: Rn=0, Rt=0, P=0, U=0, W=0, imm8=15
    // ISET: T32
    // Fields: Rn=0, imm8=15, Rt=0, P=0, W=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF820080F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T3_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=16 (power of 2 (2^4 = 16))
#[test]
fn test_aarch32_strh_i_t3_a_combo_17_800_f8200810() {
    // Thumb encoding (32): 0xF8200810
    // Test aarch32_STRH_i_T3_A field combination: Rn=0, Rt=0, P=0, U=0, W=0, imm8=16
    // ISET: T32
    // Fields: imm8=16, Rt=0, Rn=0, P=0, U=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8200810;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T3_A
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=31 (2^5 - 1 = 31)
#[test]
fn test_aarch32_strh_i_t3_a_combo_18_800_f820081f() {
    // Thumb encoding (32): 0xF820081F
    // Test aarch32_STRH_i_T3_A field combination: Rn=0, Rt=0, P=0, U=0, W=0, imm8=31
    // ISET: T32
    // Fields: Rt=0, W=0, Rn=0, P=0, imm8=31, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF820081F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T3_A
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=32 (power of 2 (2^5 = 32))
#[test]
fn test_aarch32_strh_i_t3_a_combo_19_800_f8200820() {
    // Thumb encoding (32): 0xF8200820
    // Test aarch32_STRH_i_T3_A field combination: Rn=0, Rt=0, P=0, U=0, W=0, imm8=32
    // ISET: T32
    // Fields: imm8=32, Rt=0, Rn=0, U=0, W=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8200820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_i_T3_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rn" }), rhs: Binary { op: Or, lhs: LitBits([true, true, true, true]), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "P" }), rhs: Binary { op: And, lhs: LitBits([false]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "W" }) } }, rhs: LitBits([false]) } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Rn\" }), rhs: Binary { op: Or, lhs: LitBits([true, true, true, true]), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"P\" }), rhs: Binary { op: And, lhs: LitBits([false]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"W\" }) } }, rhs: LitBits([false]) } } }" }
/// triggers Undefined
#[test]
fn test_aarch32_strh_i_t3_a_invalid_0_800_f8200800() {
    // Thumb encoding (32): 0xF8200800
    // Test aarch32_STRH_i_T3_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rn" }), rhs: Binary { op: Or, lhs: LitBits([true, true, true, true]), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "P" }), rhs: Binary { op: And, lhs: LitBits([false]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "W" }) } }, rhs: LitBits([false]) } } }
    // ISET: T32
    // Fields: P=0, Rn=0, W=0, Rt=0, U=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8200800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_STRH_i_T3_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_strh_i_t3_a_invalid_1_800_f8200800() {
    // Thumb encoding (32): 0xF8200800
    // Test aarch32_STRH_i_T3_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: Rt=0, P=0, U=0, Rn=0, W=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8200800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_STRH_i_T3_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Binary { op: Eq, lhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Binary { op: Eq, lhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"wback\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }) } } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strh_i_t3_a_invalid_2_800_f8200800() {
    // Thumb encoding (32): 0xF8200800
    // Test aarch32_STRH_i_T3_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Binary { op: Eq, lhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) } } }
    // ISET: T32
    // Fields: W=0, Rt=0, P=0, Rn=0, U=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8200800;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_STRH_i_T3_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strh_i_t3_a_invalid_3_800_f8200800() {
    // Thumb encoding (32): 0xF8200800
    // Test aarch32_STRH_i_T3_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: U=0, W=0, imm8=0, Rn=0, Rt=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8200800;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_STRH_i_A1_A
/// ASL: `UMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple multiply
#[test]
fn test_aarch32_strh_i_a1_a_umull_oracle_0_9ba27c20() {
    // Test UMULL: simple multiply (oracle)
    // Encoding: 0x9BA27C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x2);
    set_w(&mut cpu, 2, 0x3);
    let encoding: u32 = 0x9BA27C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6, "X0 should be 0x0000000000000006");
}

/// Provenance: aarch32_STRH_i_A1_A
/// ASL: `UMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max 32-bit * 2
#[test]
fn test_aarch32_strh_i_a1_a_umull_oracle_1_9ba27c20() {
    // Test UMULL: max 32-bit * 2 (oracle)
    // Encoding: 0x9BA27C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x9BA27C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFE, "X0 should be 0x00000001FFFFFFFE");
}

/// Provenance: aarch32_STRH_i_A1_A
/// ASL: `UMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// large positive * large positive
#[test]
fn test_aarch32_strh_i_a1_a_umull_oracle_2_9ba27c20() {
    // Test UMULL: large positive * large positive (oracle)
    // Encoding: 0x9BA27C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x7FFFFFFF);
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x9BA27C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x3FFFFFFF00000001");
}

/// Provenance: aarch32_STRH_i_A1_A
/// ASL: `UMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max unsigned * max unsigned
#[test]
fn test_aarch32_strh_i_a1_a_umull_oracle_3_9ba27c20() {
    // Test UMULL: max unsigned * max unsigned (oracle)
    // Encoding: 0x9BA27C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x9BA27C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0xFFFFFFFE00000001");
}

/// Provenance: aarch32_STRH_i_A1_A
/// ASL: `UMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// medium values
#[test]
fn test_aarch32_strh_i_a1_a_umull_oracle_4_9ba27c20() {
    // Test UMULL: medium values (oracle)
    // Encoding: 0x9BA27C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xC8);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x9BA27C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4E20, "X0 should be 0x0000000000004E20");
}

/// Provenance: aarch32_STRH_i_A1_A
/// ASL: `UMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// 16-bit values
#[test]
fn test_aarch32_strh_i_a1_a_umull_oracle_5_9ba27c20() {
    // Test UMULL: 16-bit values (oracle)
    // Encoding: 0x9BA27C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x5678);
    set_w(&mut cpu, 1, 0x1234);
    let encoding: u32 = 0x9BA27C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6260060, "X0 should be 0x0000000006260060");
}

/// Provenance: aarch32_STRH_i_A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_strh_i_a1_a_store_0_004100b0() {
    // Test aarch32_STRH_i_A1_A memory store: 8 bytes
    // Encoding: 0x004100B0
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x004100B0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_STRH_i_A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_strh_i_a1_a_store_1_004100b0() {
    // Test aarch32_STRH_i_A1_A memory store: 8 bytes
    // Encoding: 0x004100B0
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0x004100B0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_STRH_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 0 (32)
#[test]
fn test_aarch32_strh_i_t1_a_lslv_oracle_32_0_80020020() {
    // Test LSLV 32-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x12345678, "W0 should be 0x12345678");
}

/// Provenance: aarch32_STRH_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 0 (64)
#[test]
fn test_aarch32_strh_i_t1_a_lslv_oracle_64_0_80020020() {
    // Test LSLV 64-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x12345678, "X0 should be 0x0000000012345678");
}

/// Provenance: aarch32_STRH_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4 (32)
#[test]
fn test_aarch32_strh_i_t1_a_lslv_oracle_32_1_80020020() {
    // Test LSLV 32-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x4);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x23456780, "W0 should be 0x23456780");
}

/// Provenance: aarch32_STRH_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 4 (64)
#[test]
fn test_aarch32_strh_i_t1_a_lslv_oracle_64_1_80020020() {
    // Test LSLV 64-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x4);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x23456780, "X0 should be 0x0000000123456780");
}

/// Provenance: aarch32_STRH_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 8 (32)
#[test]
fn test_aarch32_strh_i_t1_a_lslv_oracle_32_2_80020020() {
    // Test LSLV 32-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x8);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x34567800, "W0 should be 0x34567800");
}

/// Provenance: aarch32_STRH_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 8 (64)
#[test]
fn test_aarch32_strh_i_t1_a_lslv_oracle_64_2_80020020() {
    // Test LSLV 64-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x8);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x34567800, "X0 should be 0x0000001234567800");
}

/// Provenance: aarch32_STRH_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1 (32)
#[test]
fn test_aarch32_strh_i_t1_a_lslv_oracle_32_3_80020020() {
    // Test LSLV 32-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_STRH_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// MSB set, shift 1 (64)
#[test]
fn test_aarch32_strh_i_t1_a_lslv_oracle_64_3_80020020() {
    // Test LSLV 64-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_STRH_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// LSB set, max shift (32)
#[test]
fn test_aarch32_strh_i_t1_a_lslv_oracle_32_4_80020020() {
    // Test LSLV 32-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x3F);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "W0 should be 0x80000000");
}

/// Provenance: aarch32_STRH_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// LSB set, max shift (64)
#[test]
fn test_aarch32_strh_i_t1_a_lslv_oracle_64_4_80020020() {
    // Test LSLV 64-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3F);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x8000000000000000");
}

/// Provenance: aarch32_STRH_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// all ones, shift 32 (32)
#[test]
fn test_aarch32_strh_i_t1_a_lslv_oracle_32_5_80020020() {
    // Test LSLV 32-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x20);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "W0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_STRH_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// all ones, shift 32 (64)
#[test]
fn test_aarch32_strh_i_t1_a_lslv_oracle_64_5_80020020() {
    // Test LSLV 64-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x20);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0xFFFFFFFF00000000");
}

/// Provenance: aarch32_STRH_i_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// no shift
#[test]
fn test_aarch32_strh_i_t1_a_t16_oracle_0_80080000() {
    // Test T16 LSLS: no shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_STRH_i_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4
#[test]
fn test_aarch32_strh_i_t1_a_t16_oracle_1_80080000() {
    // Test T16 LSLS: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x4);
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF0, "R0 should be 0x00000FF0");
}

/// Provenance: aarch32_STRH_i_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1
#[test]
fn test_aarch32_strh_i_t1_a_t16_oracle_2_80080000() {
    // Test T16 LSLS: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_STRH_i_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift to MSB
#[test]
fn test_aarch32_strh_i_t1_a_t16_oracle_3_80080000() {
    // Test T16 LSLS: shift to MSB (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x1F);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "R0 should be 0x80000000");
}

/// Provenance: aarch32_STRH_i_T1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_strh_i_t1_a_store_0_80080000() {
    // Test aarch32_STRH_i_T1_A memory store: 8 bytes
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_STRH_i_T1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_strh_i_t1_a_store_1_80080000() {
    // Test aarch32_STRH_i_T1_A memory store: 8 bytes
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_STRH_i_T2_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_strh_i_t2_a_store_0_f8a10000() {
    // Test aarch32_STRH_i_T2_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF8A10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_STRH_i_T2_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_strh_i_t2_a_store_1_f8a10000() {
    // Test aarch32_STRH_i_T2_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF8A10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_STRH_i_T3_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_strh_i_t3_a_store_0_f8210800() {
    // Test aarch32_STRH_i_T3_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0xF8210800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_STRH_i_T3_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_strh_i_t3_a_store_1_f8210800() {
    // Test aarch32_STRH_i_T3_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0xF8210800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// aarch32_STRD_r_A Tests
// ============================================================================

/// Provenance: aarch32_STRD_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_strd_r_a1_a_field_cond_0_min_f0_000000f0() {
    // Encoding: 0x000000F0
    // Test aarch32_STRD_r_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: U=0, Rt=0, W=0, Rn=0, cond=0, P=0, Rm=0
    let encoding: u32 = 0x000000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_strd_r_a1_a_field_cond_1_poweroftwo_f0_100000f0() {
    // Encoding: 0x100000F0
    // Test aarch32_STRD_r_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, P=0, U=0, Rt=0, cond=1, Rm=0, W=0
    let encoding: u32 = 0x100000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_strd_r_a1_a_field_cond_2_poweroftwo_f0_200000f0() {
    // Encoding: 0x200000F0
    // Test aarch32_STRD_r_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, W=0, U=0, Rn=0, Rt=0, Rm=0, cond=2
    let encoding: u32 = 0x200000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_strd_r_a1_a_field_cond_3_poweroftwo_f0_300000f0() {
    // Encoding: 0x300000F0
    // Test aarch32_STRD_r_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, U=0, cond=3, W=0, Rm=0, P=0, Rn=0
    let encoding: u32 = 0x300000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_strd_r_a1_a_field_cond_4_poweroftwo_f0_400000f0() {
    // Encoding: 0x400000F0
    // Test aarch32_STRD_r_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, W=0, Rm=0, Rn=0, cond=4, Rt=0, P=0
    let encoding: u32 = 0x400000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_strd_r_a1_a_field_cond_5_poweroftwo_f0_500000f0() {
    // Encoding: 0x500000F0
    // Test aarch32_STRD_r_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=5, W=0, Rn=0, Rm=0, P=0, Rt=0, U=0
    let encoding: u32 = 0x500000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_strd_r_a1_a_field_cond_6_poweroftwo_f0_600000f0() {
    // Encoding: 0x600000F0
    // Test aarch32_STRD_r_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=6, Rm=0, W=0, Rn=0, P=0, U=0, Rt=0
    let encoding: u32 = 0x600000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_strd_r_a1_a_field_cond_7_poweroftwo_f0_700000f0() {
    // Encoding: 0x700000F0
    // Test aarch32_STRD_r_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, U=0, Rm=0, W=0, P=0, Rn=0, cond=7
    let encoding: u32 = 0x700000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_strd_r_a1_a_field_cond_8_poweroftwo_f0_800000f0() {
    // Encoding: 0x800000F0
    // Test aarch32_STRD_r_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, P=0, W=0, cond=8, U=0, Rn=0, Rt=0
    let encoding: u32 = 0x800000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_strd_r_a1_a_field_cond_9_poweroftwo_f0_900000f0() {
    // Encoding: 0x900000F0
    // Test aarch32_STRD_r_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, P=0, cond=9, W=0, Rn=0, U=0, Rm=0
    let encoding: u32 = 0x900000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_strd_r_a1_a_field_cond_10_poweroftwo_f0_a00000f0() {
    // Encoding: 0xA00000F0
    // Test aarch32_STRD_r_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, Rm=0, U=0, cond=10, P=0, W=0, Rn=0
    let encoding: u32 = 0xA00000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_strd_r_a1_a_field_cond_11_poweroftwo_f0_b00000f0() {
    // Encoding: 0xB00000F0
    // Test aarch32_STRD_r_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=11, W=0, Rt=0, U=0, Rm=0, Rn=0, P=0
    let encoding: u32 = 0xB00000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_strd_r_a1_a_field_cond_12_poweroftwo_f0_c00000f0() {
    // Encoding: 0xC00000F0
    // Test aarch32_STRD_r_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Rt=0, cond=12, W=0, Rn=0, U=0, P=0
    let encoding: u32 = 0xC00000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_strd_r_a1_a_field_cond_13_poweroftwo_f0_d00000f0() {
    // Encoding: 0xD00000F0
    // Test aarch32_STRD_r_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, W=0, Rm=0, Rn=0, U=0, cond=13, P=0
    let encoding: u32 = 0xD00000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_strd_r_a1_a_field_cond_14_poweroftwo_f0_e00000f0() {
    // Encoding: 0xE00000F0
    // Test aarch32_STRD_r_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, P=0, cond=14, Rt=0, Rn=0, Rm=0, U=0
    let encoding: u32 = 0xE00000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_strd_r_a1_a_field_cond_15_max_f0_f00000f0() {
    // Encoding: 0xF00000F0
    // Test aarch32_STRD_r_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: Rt=0, Rm=0, P=0, U=0, cond=15, W=0, Rn=0
    let encoding: u32 = 0xF00000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_r_A1_A
/// ASL: `field P 24 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_strd_r_a1_a_field_p_0_min_f0_000000f0() {
    // Encoding: 0x000000F0
    // Test aarch32_STRD_r_A1_A field P = 0 (Min)
    // ISET: A32
    // Fields: cond=0, P=0, W=0, Rn=0, Rt=0, U=0, Rm=0
    let encoding: u32 = 0x000000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_r_A1_A
/// ASL: `field P 24 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_strd_r_a1_a_field_p_1_max_f0_010000f0() {
    // Encoding: 0x010000F0
    // Test aarch32_STRD_r_A1_A field P = 1 (Max)
    // ISET: A32
    // Fields: U=0, Rt=0, cond=0, Rm=0, Rn=0, P=1, W=0
    let encoding: u32 = 0x010000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_r_A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_strd_r_a1_a_field_u_0_min_f0_000000f0() {
    // Encoding: 0x000000F0
    // Test aarch32_STRD_r_A1_A field U = 0 (Min)
    // ISET: A32
    // Fields: W=0, Rt=0, Rm=0, U=0, Rn=0, P=0, cond=0
    let encoding: u32 = 0x000000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_r_A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_strd_r_a1_a_field_u_1_max_f0_008000f0() {
    // Encoding: 0x008000F0
    // Test aarch32_STRD_r_A1_A field U = 1 (Max)
    // ISET: A32
    // Fields: Rm=0, U=1, Rt=0, Rn=0, P=0, W=0, cond=0
    let encoding: u32 = 0x008000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_r_A1_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_strd_r_a1_a_field_w_0_min_f0_000000f0() {
    // Encoding: 0x000000F0
    // Test aarch32_STRD_r_A1_A field W = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rn=0, U=0, P=0, W=0, Rt=0, Rm=0
    let encoding: u32 = 0x000000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_r_A1_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_strd_r_a1_a_field_w_1_max_f0_002000f0() {
    // Encoding: 0x002000F0
    // Test aarch32_STRD_r_A1_A field W = 1 (Max)
    // ISET: A32
    // Fields: U=0, P=0, cond=0, Rn=0, W=1, Rt=0, Rm=0
    let encoding: u32 = 0x002000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_r_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_strd_r_a1_a_field_rn_0_min_f0_000000f0() {
    // Encoding: 0x000000F0
    // Test aarch32_STRD_r_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, W=0, U=0, P=0, cond=0, Rn=0, Rt=0
    let encoding: u32 = 0x000000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_r_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_strd_r_a1_a_field_rn_1_poweroftwo_f0_000100f0() {
    // Encoding: 0x000100F0
    // Test aarch32_STRD_r_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, Rn=1, Rm=0, U=0, cond=0, Rt=0, P=0
    let encoding: u32 = 0x000100F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_r_A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_strd_r_a1_a_field_rt_0_min_f0_000000f0() {
    // Encoding: 0x000000F0
    // Test aarch32_STRD_r_A1_A field Rt = 0 (Min)
    // ISET: A32
    // Fields: W=0, Rt=0, U=0, cond=0, P=0, Rn=0, Rm=0
    let encoding: u32 = 0x000000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_r_A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_strd_r_a1_a_field_rt_1_poweroftwo_f0_000010f0() {
    // Encoding: 0x000010F0
    // Test aarch32_STRD_r_A1_A field Rt = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, W=0, Rt=1, P=0, Rm=0, Rn=0, cond=0
    let encoding: u32 = 0x000010F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_r_A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_strd_r_a1_a_field_rm_0_min_f0_000000f0() {
    // Encoding: 0x000000F0
    // Test aarch32_STRD_r_A1_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: P=0, Rm=0, cond=0, U=0, Rn=0, Rt=0, W=0
    let encoding: u32 = 0x000000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_r_A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_strd_r_a1_a_field_rm_1_poweroftwo_f0_000000f1() {
    // Encoding: 0x000000F1
    // Test aarch32_STRD_r_A1_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Rt=0, Rm=1, Rn=0, W=0, U=0, P=0
    let encoding: u32 = 0x000000F1;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_r_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_strd_r_a1_a_combo_0_f0_000000f0() {
    // Encoding: 0x000000F0
    // Test aarch32_STRD_r_A1_A field combination: cond=0, P=0, U=0, W=0, Rn=0, Rt=0, Rm=0
    // ISET: A32
    // Fields: P=0, U=0, W=0, Rt=0, cond=0, Rn=0, Rm=0
    let encoding: u32 = 0x000000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_r_A1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=1 (condition NE (not equal))
#[test]
fn test_aarch32_strd_r_a1_a_combo_1_f0_100000f0() {
    // Encoding: 0x100000F0
    // Test aarch32_STRD_r_A1_A field combination: cond=1, P=0, U=0, W=0, Rn=0, Rt=0, Rm=0
    // ISET: A32
    // Fields: cond=1, Rt=0, Rm=0, Rn=0, P=0, U=0, W=0
    let encoding: u32 = 0x100000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_r_A1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=2 (condition CS/HS (carry set))
#[test]
fn test_aarch32_strd_r_a1_a_combo_2_f0_200000f0() {
    // Encoding: 0x200000F0
    // Test aarch32_STRD_r_A1_A field combination: cond=2, P=0, U=0, W=0, Rn=0, Rt=0, Rm=0
    // ISET: A32
    // Fields: Rn=0, cond=2, W=0, U=0, Rt=0, Rm=0, P=0
    let encoding: u32 = 0x200000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_r_A1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=3 (condition CC/LO (carry clear))
#[test]
fn test_aarch32_strd_r_a1_a_combo_3_f0_300000f0() {
    // Encoding: 0x300000F0
    // Test aarch32_STRD_r_A1_A field combination: cond=3, P=0, U=0, W=0, Rn=0, Rt=0, Rm=0
    // ISET: A32
    // Fields: W=0, cond=3, P=0, Rn=0, Rt=0, U=0, Rm=0
    let encoding: u32 = 0x300000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_r_A1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=4 (condition MI (minus/negative))
#[test]
fn test_aarch32_strd_r_a1_a_combo_4_f0_400000f0() {
    // Encoding: 0x400000F0
    // Test aarch32_STRD_r_A1_A field combination: cond=4, P=0, U=0, W=0, Rn=0, Rt=0, Rm=0
    // ISET: A32
    // Fields: P=0, Rm=0, Rt=0, W=0, Rn=0, cond=4, U=0
    let encoding: u32 = 0x400000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_r_A1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=5 (condition PL (plus/positive))
#[test]
fn test_aarch32_strd_r_a1_a_combo_5_f0_500000f0() {
    // Encoding: 0x500000F0
    // Test aarch32_STRD_r_A1_A field combination: cond=5, P=0, U=0, W=0, Rn=0, Rt=0, Rm=0
    // ISET: A32
    // Fields: W=0, Rt=0, Rm=0, P=0, U=0, Rn=0, cond=5
    let encoding: u32 = 0x500000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_r_A1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=6 (condition VS (overflow set))
#[test]
fn test_aarch32_strd_r_a1_a_combo_6_f0_600000f0() {
    // Encoding: 0x600000F0
    // Test aarch32_STRD_r_A1_A field combination: cond=6, P=0, U=0, W=0, Rn=0, Rt=0, Rm=0
    // ISET: A32
    // Fields: Rt=0, P=0, W=0, Rn=0, U=0, Rm=0, cond=6
    let encoding: u32 = 0x600000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_r_A1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=7 (condition VC (overflow clear))
#[test]
fn test_aarch32_strd_r_a1_a_combo_7_f0_700000f0() {
    // Encoding: 0x700000F0
    // Test aarch32_STRD_r_A1_A field combination: cond=7, P=0, U=0, W=0, Rn=0, Rt=0, Rm=0
    // ISET: A32
    // Fields: cond=7, W=0, Rn=0, Rt=0, Rm=0, P=0, U=0
    let encoding: u32 = 0x700000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_r_A1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=8 (condition HI (unsigned higher))
#[test]
fn test_aarch32_strd_r_a1_a_combo_8_f0_800000f0() {
    // Encoding: 0x800000F0
    // Test aarch32_STRD_r_A1_A field combination: cond=8, P=0, U=0, W=0, Rn=0, Rt=0, Rm=0
    // ISET: A32
    // Fields: P=0, U=0, Rt=0, W=0, Rm=0, cond=8, Rn=0
    let encoding: u32 = 0x800000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_r_A1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=9 (condition LS (unsigned lower or same))
#[test]
fn test_aarch32_strd_r_a1_a_combo_9_f0_900000f0() {
    // Encoding: 0x900000F0
    // Test aarch32_STRD_r_A1_A field combination: cond=9, P=0, U=0, W=0, Rn=0, Rt=0, Rm=0
    // ISET: A32
    // Fields: Rm=0, Rn=0, cond=9, Rt=0, P=0, U=0, W=0
    let encoding: u32 = 0x900000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_r_A1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=10 (condition GE (signed >=))
#[test]
fn test_aarch32_strd_r_a1_a_combo_10_f0_a00000f0() {
    // Encoding: 0xA00000F0
    // Test aarch32_STRD_r_A1_A field combination: cond=10, P=0, U=0, W=0, Rn=0, Rt=0, Rm=0
    // ISET: A32
    // Fields: W=0, P=0, Rt=0, cond=10, Rn=0, Rm=0, U=0
    let encoding: u32 = 0xA00000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_r_A1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=11 (condition LT (signed <))
#[test]
fn test_aarch32_strd_r_a1_a_combo_11_f0_b00000f0() {
    // Encoding: 0xB00000F0
    // Test aarch32_STRD_r_A1_A field combination: cond=11, P=0, U=0, W=0, Rn=0, Rt=0, Rm=0
    // ISET: A32
    // Fields: Rn=0, Rt=0, Rm=0, U=0, W=0, P=0, cond=11
    let encoding: u32 = 0xB00000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_r_A1_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=12 (condition GT (signed >))
#[test]
fn test_aarch32_strd_r_a1_a_combo_12_f0_c00000f0() {
    // Encoding: 0xC00000F0
    // Test aarch32_STRD_r_A1_A field combination: cond=12, P=0, U=0, W=0, Rn=0, Rt=0, Rm=0
    // ISET: A32
    // Fields: Rm=0, W=0, U=0, Rt=0, P=0, cond=12, Rn=0
    let encoding: u32 = 0xC00000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_r_A1_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=13 (condition LE (signed <=))
#[test]
fn test_aarch32_strd_r_a1_a_combo_13_f0_d00000f0() {
    // Encoding: 0xD00000F0
    // Test aarch32_STRD_r_A1_A field combination: cond=13, P=0, U=0, W=0, Rn=0, Rt=0, Rm=0
    // ISET: A32
    // Fields: Rt=0, P=0, Rm=0, cond=13, Rn=0, U=0, W=0
    let encoding: u32 = 0xD00000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_r_A1_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=14 (condition AL (always))
#[test]
fn test_aarch32_strd_r_a1_a_combo_14_f0_e00000f0() {
    // Encoding: 0xE00000F0
    // Test aarch32_STRD_r_A1_A field combination: cond=14, P=0, U=0, W=0, Rn=0, Rt=0, Rm=0
    // ISET: A32
    // Fields: P=0, Rn=0, W=0, Rt=0, Rm=0, cond=14, U=0
    let encoding: u32 = 0xE00000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_r_A1_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=15 (condition NV (never, reserved))
#[test]
fn test_aarch32_strd_r_a1_a_combo_15_f0_f00000f0() {
    // Encoding: 0xF00000F0
    // Test aarch32_STRD_r_A1_A field combination: cond=15, P=0, U=0, W=0, Rn=0, Rt=0, Rm=0
    // ISET: A32
    // Fields: P=0, Rm=0, U=0, cond=15, W=0, Rn=0, Rt=0
    let encoding: u32 = 0xF00000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_r_A1_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// P=0 (minimum value)
#[test]
fn test_aarch32_strd_r_a1_a_combo_16_f0_000000f0() {
    // Encoding: 0x000000F0
    // Test aarch32_STRD_r_A1_A field combination: cond=0, P=0, U=0, W=0, Rn=0, Rt=0, Rm=0
    // ISET: A32
    // Fields: Rm=0, Rt=0, cond=0, Rn=0, P=0, W=0, U=0
    let encoding: u32 = 0x000000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_r_A1_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// P=1 (maximum value (1))
#[test]
fn test_aarch32_strd_r_a1_a_combo_17_f0_010000f0() {
    // Encoding: 0x010000F0
    // Test aarch32_STRD_r_A1_A field combination: cond=0, P=1, U=0, W=0, Rn=0, Rt=0, Rm=0
    // ISET: A32
    // Fields: cond=0, W=0, U=0, Rn=0, Rt=0, Rm=0, P=1
    let encoding: u32 = 0x010000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_r_A1_A
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=0 (minimum value)
#[test]
fn test_aarch32_strd_r_a1_a_combo_18_f0_000000f0() {
    // Encoding: 0x000000F0
    // Test aarch32_STRD_r_A1_A field combination: cond=0, P=0, U=0, W=0, Rn=0, Rt=0, Rm=0
    // ISET: A32
    // Fields: U=0, cond=0, P=0, W=0, Rm=0, Rt=0, Rn=0
    let encoding: u32 = 0x000000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_r_A1_A
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=1 (maximum value (1))
#[test]
fn test_aarch32_strd_r_a1_a_combo_19_f0_008000f0() {
    // Encoding: 0x008000F0
    // Test aarch32_STRD_r_A1_A field combination: cond=0, P=0, U=1, W=0, Rn=0, Rt=0, Rm=0
    // ISET: A32
    // Fields: Rn=0, W=0, Rm=0, cond=0, P=0, U=1, Rt=0
    let encoding: u32 = 0x008000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_r_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_strd_r_a1_a_special_cond_0_condition_eq_240_000000f0() {
    // Encoding: 0x000000F0
    // Test aarch32_STRD_r_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: Rm=0, U=0, W=0, Rt=0, Rn=0, cond=0, P=0
    let encoding: u32 = 0x000000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_r_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_strd_r_a1_a_special_cond_1_condition_ne_240_100000f0() {
    // Encoding: 0x100000F0
    // Test aarch32_STRD_r_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: Rt=0, W=0, Rm=0, P=0, Rn=0, cond=1, U=0
    let encoding: u32 = 0x100000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_r_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_strd_r_a1_a_special_cond_2_condition_cs_hs_240_200000f0() {
    // Encoding: 0x200000F0
    // Test aarch32_STRD_r_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: W=0, Rn=0, P=0, Rt=0, Rm=0, cond=2, U=0
    let encoding: u32 = 0x200000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_r_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_strd_r_a1_a_special_cond_3_condition_cc_lo_240_300000f0() {
    // Encoding: 0x300000F0
    // Test aarch32_STRD_r_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: U=0, cond=3, P=0, Rt=0, W=0, Rn=0, Rm=0
    let encoding: u32 = 0x300000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_r_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_strd_r_a1_a_special_cond_4_condition_mi_240_400000f0() {
    // Encoding: 0x400000F0
    // Test aarch32_STRD_r_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: Rm=0, cond=4, Rt=0, U=0, W=0, P=0, Rn=0
    let encoding: u32 = 0x400000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_r_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_strd_r_a1_a_special_cond_5_condition_pl_240_500000f0() {
    // Encoding: 0x500000F0
    // Test aarch32_STRD_r_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: Rt=0, Rn=0, U=0, W=0, Rm=0, cond=5, P=0
    let encoding: u32 = 0x500000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_r_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_strd_r_a1_a_special_cond_6_condition_vs_240_600000f0() {
    // Encoding: 0x600000F0
    // Test aarch32_STRD_r_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: Rt=0, Rn=0, U=0, Rm=0, P=0, cond=6, W=0
    let encoding: u32 = 0x600000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_r_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_strd_r_a1_a_special_cond_7_condition_vc_240_700000f0() {
    // Encoding: 0x700000F0
    // Test aarch32_STRD_r_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: Rm=0, W=0, Rn=0, Rt=0, cond=7, P=0, U=0
    let encoding: u32 = 0x700000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_r_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_strd_r_a1_a_special_cond_8_condition_hi_240_800000f0() {
    // Encoding: 0x800000F0
    // Test aarch32_STRD_r_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: U=0, cond=8, W=0, Rn=0, P=0, Rt=0, Rm=0
    let encoding: u32 = 0x800000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_r_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_strd_r_a1_a_special_cond_9_condition_ls_240_900000f0() {
    // Encoding: 0x900000F0
    // Test aarch32_STRD_r_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: Rn=0, Rt=0, Rm=0, P=0, cond=9, U=0, W=0
    let encoding: u32 = 0x900000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_r_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_strd_r_a1_a_special_cond_10_condition_ge_240_a00000f0() {
    // Encoding: 0xA00000F0
    // Test aarch32_STRD_r_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: Rm=0, cond=10, Rt=0, P=0, W=0, U=0, Rn=0
    let encoding: u32 = 0xA00000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_r_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_strd_r_a1_a_special_cond_11_condition_lt_240_b00000f0() {
    // Encoding: 0xB00000F0
    // Test aarch32_STRD_r_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: W=0, Rn=0, Rt=0, Rm=0, cond=11, P=0, U=0
    let encoding: u32 = 0xB00000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_r_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_strd_r_a1_a_special_cond_12_condition_gt_240_c00000f0() {
    // Encoding: 0xC00000F0
    // Test aarch32_STRD_r_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: cond=12, U=0, W=0, Rm=0, Rn=0, Rt=0, P=0
    let encoding: u32 = 0xC00000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_r_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_strd_r_a1_a_special_cond_13_condition_le_240_d00000f0() {
    // Encoding: 0xD00000F0
    // Test aarch32_STRD_r_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: P=0, U=0, Rn=0, cond=13, Rt=0, Rm=0, W=0
    let encoding: u32 = 0xD00000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_r_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_strd_r_a1_a_special_cond_14_condition_al_240_e00000f0() {
    // Encoding: 0xE00000F0
    // Test aarch32_STRD_r_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: W=0, Rn=0, P=0, Rm=0, cond=14, Rt=0, U=0
    let encoding: u32 = 0xE00000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_r_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_strd_r_a1_a_special_cond_15_condition_nv_240_f00000f0() {
    // Encoding: 0xF00000F0
    // Test aarch32_STRD_r_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: cond=15, W=0, Rn=0, U=0, Rt=0, P=0, Rm=0
    let encoding: u32 = 0xF00000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_r_A1_A
/// ASL: `Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Rt" }), indices: [Single(LitInt(0))] }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Rt\" }), indices: [Single(LitInt(0))] }, rhs: LitBits([true]) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strd_r_a1_a_invalid_0_f0_000000f0() {
    // Encoding: 0x000000F0
    // Test aarch32_STRD_r_A1_A invalid encoding: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Rt" }), indices: [Single(LitInt(0))] }, rhs: LitBits([true]) }
    // ISET: A32
    // Fields: cond=0, P=0, U=0, W=0, Rn=0, Rt=0, Rm=0
    let encoding: u32 = 0x000000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STRD_r_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strd_r_a1_a_invalid_1_f0_000000f0() {
    // Encoding: 0x000000F0
    // Test aarch32_STRD_r_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Rn=0, Rt=0, P=0, U=0, cond=0, W=0, Rm=0
    let encoding: u32 = 0x000000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STRD_r_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "P" }), rhs: Binary { op: And, lhs: LitBits([false]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "W" }) } }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"P\" }), rhs: Binary { op: And, lhs: LitBits([false]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"W\" }) } }, rhs: LitBits([true]) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strd_r_a1_a_invalid_2_f0_000000f0() {
    // Encoding: 0x000000F0
    // Test aarch32_STRD_r_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "P" }), rhs: Binary { op: And, lhs: LitBits([false]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "W" }) } }, rhs: LitBits([true]) }
    // ISET: A32
    // Fields: Rt=0, U=0, Rm=0, Rn=0, cond=0, P=0, W=0
    let encoding: u32 = 0x000000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STRD_r_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strd_r_a1_a_invalid_3_f0_000000f0() {
    // Encoding: 0x000000F0
    // Test aarch32_STRD_r_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: W=0, P=0, Rn=0, Rt=0, U=0, Rm=0, cond=0
    let encoding: u32 = 0x000000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STRD_r_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t2" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t2\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strd_r_a1_a_invalid_4_f0_000000f0() {
    // Encoding: 0x000000F0
    // Test aarch32_STRD_r_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t2" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }
    // ISET: A32
    // Fields: Rn=0, cond=0, P=0, Rt=0, Rm=0, U=0, W=0
    let encoding: u32 = 0x000000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STRD_r_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strd_r_a1_a_invalid_5_f0_000000f0() {
    // Encoding: 0x000000F0
    // Test aarch32_STRD_r_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: P=0, U=0, Rt=0, cond=0, Rn=0, W=0, Rm=0
    let encoding: u32 = 0x000000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STRD_r_A1_A
/// ASL: `Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t2" }) } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"wback\" }), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t2\" }) } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strd_r_a1_a_invalid_6_f0_000000f0() {
    // Encoding: 0x000000F0
    // Test aarch32_STRD_r_A1_A invalid encoding: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t2" }) } }
    // ISET: A32
    // Fields: Rm=0, cond=0, U=0, W=0, P=0, Rn=0, Rt=0
    let encoding: u32 = 0x000000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STRD_r_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strd_r_a1_a_invalid_7_f0_000000f0() {
    // Encoding: 0x000000F0
    // Test aarch32_STRD_r_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: P=0, Rm=0, W=0, Rn=0, Rt=0, U=0, cond=0
    let encoding: u32 = 0x000000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STRD_r_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple multiply (32)
#[test]
fn test_aarch32_strd_r_a1_a_mul_oracle_32_0_1b027c20() {
    // Test MUL 32-bit: simple multiply (oracle)
    // Encoding: 0x1B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x2);
    set_w(&mut cpu, 2, 0x3);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6, "W0 should be 0x00000006");
}

/// Provenance: aarch32_STRD_r_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple multiply (64)
#[test]
fn test_aarch32_strd_r_a1_a_mul_oracle_64_0_9b027c20() {
    // Test MUL 64-bit: simple multiply (oracle)
    // Encoding: 0x9B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3);
    set_w(&mut cpu, 1, 0x2);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6, "X0 should be 0x0000000000000006");
}

/// Provenance: aarch32_STRD_r_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// multiply by zero (32)
#[test]
fn test_aarch32_strd_r_a1_a_mul_oracle_32_1_1b027c20() {
    // Test MUL 32-bit: multiply by zero (oracle)
    // Encoding: 0x1B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x64);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_STRD_r_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// multiply by zero (64)
#[test]
fn test_aarch32_strd_r_a1_a_mul_oracle_64_1_9b027c20() {
    // Test MUL 64-bit: multiply by zero (oracle)
    // Encoding: 0x9B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x64);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_STRD_r_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// multiply by one (32)
#[test]
fn test_aarch32_strd_r_a1_a_mul_oracle_32_2_1b027c20() {
    // Test MUL 32-bit: multiply by one (oracle)
    // Encoding: 0x1B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_STRD_r_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// multiply by one (64)
#[test]
fn test_aarch32_strd_r_a1_a_mul_oracle_64_2_9b027c20() {
    // Test MUL 64-bit: multiply by one (oracle)
    // Encoding: 0x9B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x0000000000000001");
}

/// Provenance: aarch32_STRD_r_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// 16-bit max * 16-bit max (32)
#[test]
fn test_aarch32_strd_r_a1_a_mul_oracle_32_3_1b027c20() {
    // Test MUL 32-bit: 16-bit max * 16-bit max (oracle)
    // Encoding: 0x1B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFF);
    set_w(&mut cpu, 2, 0xFFFF);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFE0001, "W0 should be 0xFFFE0001");
}

/// Provenance: aarch32_STRD_r_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// 16-bit max * 16-bit max (64)
#[test]
fn test_aarch32_strd_r_a1_a_mul_oracle_64_3_9b027c20() {
    // Test MUL 64-bit: 16-bit max * 16-bit max (oracle)
    // Encoding: 0x9B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFF);
    set_w(&mut cpu, 1, 0xFFFF);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFE0001, "X0 should be 0x00000000FFFE0001");
}

/// Provenance: aarch32_STRD_r_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift-like multiply (32)
#[test]
fn test_aarch32_strd_r_a1_a_mul_oracle_32_4_1b027c20() {
    // Test MUL 32-bit: shift-like multiply (oracle)
    // Encoding: 0x1B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x2468ACF0, "W0 should be 0x2468ACF0");
}

/// Provenance: aarch32_STRD_r_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift-like multiply (64)
#[test]
fn test_aarch32_strd_r_a1_a_mul_oracle_64_4_9b027c20() {
    // Test MUL 64-bit: shift-like multiply (oracle)
    // Encoding: 0x9B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x2468ACF0, "X0 should be 0x000000002468ACF0");
}

/// Provenance: aarch32_STRD_r_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// larger values (32)
#[test]
fn test_aarch32_strd_r_a1_a_mul_oracle_32_5_1b027c20() {
    // Test MUL 32-bit: larger values (oracle)
    // Encoding: 0x1B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xC8);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4E20, "W0 should be 0x00004E20");
}

/// Provenance: aarch32_STRD_r_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// larger values (64)
#[test]
fn test_aarch32_strd_r_a1_a_mul_oracle_64_5_9b027c20() {
    // Test MUL 64-bit: larger values (oracle)
    // Encoding: 0x9B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xC8);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4E20, "X0 should be 0x0000000000004E20");
}

/// Provenance: aarch32_STRD_r_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// 32-bit overflow (32)
#[test]
fn test_aarch32_strd_r_a1_a_mul_oracle_32_6_1b027c20() {
    // Test MUL 32-bit: 32-bit overflow (oracle)
    // Encoding: 0x1B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_STRD_r_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// 32-bit overflow (64)
#[test]
fn test_aarch32_strd_r_a1_a_mul_oracle_64_6_9b027c20() {
    // Test MUL 64-bit: 32-bit overflow (oracle)
    // Encoding: 0x9B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0xFFFFFFFE00000001");
}

/// Provenance: aarch32_STRD_r_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// prime numbers (32)
#[test]
fn test_aarch32_strd_r_a1_a_mul_oracle_32_7_1b027c20() {
    // Test MUL 32-bit: prime numbers (oracle)
    // Encoding: 0x1B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xB);
    set_w(&mut cpu, 1, 0x7);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4D, "W0 should be 0x0000004D");
}

/// Provenance: aarch32_STRD_r_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// prime numbers (64)
#[test]
fn test_aarch32_strd_r_a1_a_mul_oracle_64_7_9b027c20() {
    // Test MUL 64-bit: prime numbers (oracle)
    // Encoding: 0x9B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xB);
    set_w(&mut cpu, 1, 0x7);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4D, "X0 should be 0x000000000000004D");
}

/// Provenance: aarch32_STRD_r_A1_A
/// ASL: `MUL R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple values
#[test]
fn test_aarch32_strd_r_a1_a_a32_mul_0_0000f291() {
    // Test A32 MUL: simple values (oracle)
    // Encoding: 0x0000F291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x32);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x0000F291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1388, "R0 should be 0x00001388");
}

/// Provenance: aarch32_STRD_r_A1_A
/// ASL: `MUL R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero values
#[test]
fn test_aarch32_strd_r_a1_a_a32_mul_1_0000f291() {
    // Test A32 MUL: zero values (oracle)
    // Encoding: 0x0000F291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x0000F291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_STRD_r_A1_A
/// ASL: `MUL R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max value
#[test]
fn test_aarch32_strd_r_a1_a_a32_mul_2_0000f291() {
    // Test A32 MUL: max value (oracle)
    // Encoding: 0x0000F291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x0000F291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "R0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_STRD_r_A1_A
/// ASL: `MUL R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set
#[test]
fn test_aarch32_strd_r_a1_a_a32_mul_3_0000f291() {
    // Test A32 MUL: MSB set (oracle)
    // Encoding: 0x0000F291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x80000000);
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0x0000F291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_STRD_r_A1_A
/// ASL: `MUL R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// mixed pattern
#[test]
fn test_aarch32_strd_r_a1_a_a32_mul_4_0000f291() {
    // Test A32 MUL: mixed pattern (oracle)
    // Encoding: 0x0000F291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x9ABCDEF0);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u32 = 0x0000F291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x242D2080, "R0 should be 0x242D2080");
}

/// Provenance: aarch32_STRD_r_A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_strd_r_a1_a_store_0_000100f0() {
    // Test aarch32_STRD_r_A1_A memory store: 8 bytes
    // Encoding: 0x000100F0
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x000100F0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_STRD_r_A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_strd_r_a1_a_store_1_000100f0() {
    // Test aarch32_STRD_r_A1_A memory store: 8 bytes
    // Encoding: 0x000100F0
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x000100F0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_STRD_r_A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_strd_r_a1_a_store_2_000100f0() {
    // Test aarch32_STRD_r_A1_A memory store: 8 bytes
    // Encoding: 0x000100F0
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x000100F0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// aarch32_STREXB_A Tests
// ============================================================================

/// Provenance: aarch32_STREXB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_strexb_a1_a_field_cond_0_min_390_01c00390() {
    // Encoding: 0x01C00390
    // Test aarch32_STREXB_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rt=0, Rd=0, Rn=0
    let encoding: u32 = 0x01C00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_strexb_a1_a_field_cond_1_poweroftwo_390_11c00390() {
    // Encoding: 0x11C00390
    // Test aarch32_STREXB_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rn=0, Rt=0, cond=1
    let encoding: u32 = 0x11C00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_strexb_a1_a_field_cond_2_poweroftwo_390_21c00390() {
    // Encoding: 0x21C00390
    // Test aarch32_STREXB_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=2, Rt=0, Rd=0, Rn=0
    let encoding: u32 = 0x21C00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_strexb_a1_a_field_cond_3_poweroftwo_390_31c00390() {
    // Encoding: 0x31C00390
    // Test aarch32_STREXB_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rd=0, cond=3, Rt=0
    let encoding: u32 = 0x31C00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_strexb_a1_a_field_cond_4_poweroftwo_390_41c00390() {
    // Encoding: 0x41C00390
    // Test aarch32_STREXB_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, Rd=0, cond=4, Rn=0
    let encoding: u32 = 0x41C00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_strexb_a1_a_field_cond_5_poweroftwo_390_51c00390() {
    // Encoding: 0x51C00390
    // Test aarch32_STREXB_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=5, Rt=0, Rd=0
    let encoding: u32 = 0x51C00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_strexb_a1_a_field_cond_6_poweroftwo_390_61c00390() {
    // Encoding: 0x61C00390
    // Test aarch32_STREXB_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, Rn=0, cond=6, Rd=0
    let encoding: u32 = 0x61C00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_strexb_a1_a_field_cond_7_poweroftwo_390_71c00390() {
    // Encoding: 0x71C00390
    // Test aarch32_STREXB_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, cond=7, Rt=0, Rn=0
    let encoding: u32 = 0x71C00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_strexb_a1_a_field_cond_8_poweroftwo_390_81c00390() {
    // Encoding: 0x81C00390
    // Test aarch32_STREXB_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=8, Rn=0, Rd=0, Rt=0
    let encoding: u32 = 0x81C00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_strexb_a1_a_field_cond_9_poweroftwo_390_91c00390() {
    // Encoding: 0x91C00390
    // Test aarch32_STREXB_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=9, Rd=0, Rt=0, Rn=0
    let encoding: u32 = 0x91C00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_strexb_a1_a_field_cond_10_poweroftwo_390_a1c00390() {
    // Encoding: 0xA1C00390
    // Test aarch32_STREXB_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=10, Rd=0, Rt=0, Rn=0
    let encoding: u32 = 0xA1C00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_strexb_a1_a_field_cond_11_poweroftwo_390_b1c00390() {
    // Encoding: 0xB1C00390
    // Test aarch32_STREXB_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=11, Rn=0, Rd=0, Rt=0
    let encoding: u32 = 0xB1C00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_strexb_a1_a_field_cond_12_poweroftwo_390_c1c00390() {
    // Encoding: 0xC1C00390
    // Test aarch32_STREXB_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=12, Rd=0, Rt=0
    let encoding: u32 = 0xC1C00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_strexb_a1_a_field_cond_13_poweroftwo_390_d1c00390() {
    // Encoding: 0xD1C00390
    // Test aarch32_STREXB_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=13, Rn=0, Rd=0, Rt=0
    let encoding: u32 = 0xD1C00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_strexb_a1_a_field_cond_14_poweroftwo_390_e1c00390() {
    // Encoding: 0xE1C00390
    // Test aarch32_STREXB_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rd=0, Rt=0, cond=14
    let encoding: u32 = 0xE1C00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_strexb_a1_a_field_cond_15_max_390_f1c00390() {
    // Encoding: 0xF1C00390
    // Test aarch32_STREXB_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: cond=15, Rt=0, Rn=0, Rd=0
    let encoding: u32 = 0xF1C00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXB_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_strexb_a1_a_field_rn_0_min_390_01c00390() {
    // Encoding: 0x01C00390
    // Test aarch32_STREXB_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: Rt=0, Rd=0, cond=0, Rn=0
    let encoding: u32 = 0x01C00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXB_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_strexb_a1_a_field_rn_1_poweroftwo_390_01c10390() {
    // Encoding: 0x01C10390
    // Test aarch32_STREXB_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Rn=1, Rd=0, Rt=0
    let encoding: u32 = 0x01C10390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXB_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_strexb_a1_a_field_rd_0_min_390_01c00390() {
    // Encoding: 0x01C00390
    // Test aarch32_STREXB_A1_A field Rd = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, cond=0, Rt=0, Rd=0
    let encoding: u32 = 0x01C00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXB_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_strexb_a1_a_field_rd_1_poweroftwo_390_01c01390() {
    // Encoding: 0x01C01390
    // Test aarch32_STREXB_A1_A field Rd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=0, Rd=1, Rt=0
    let encoding: u32 = 0x01C01390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXB_A1_A
/// ASL: `field Rt 0 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_strexb_a1_a_field_rt_0_min_390_01c00390() {
    // Encoding: 0x01C00390
    // Test aarch32_STREXB_A1_A field Rt = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rn=0, Rd=0, Rt=0
    let encoding: u32 = 0x01C00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXB_A1_A
/// ASL: `field Rt 0 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_strexb_a1_a_field_rt_1_poweroftwo_390_01c00391() {
    // Encoding: 0x01C00391
    // Test aarch32_STREXB_A1_A field Rt = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rd=0, Rt=1, cond=0
    let encoding: u32 = 0x01C00391;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXB_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_strexb_a1_a_combo_0_390_01c00390() {
    // Encoding: 0x01C00390
    // Test aarch32_STREXB_A1_A field combination: cond=0, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rd=0, Rt=0, cond=0, Rn=0
    let encoding: u32 = 0x01C00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXB_A1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=1 (condition NE (not equal))
#[test]
fn test_aarch32_strexb_a1_a_combo_1_390_11c00390() {
    // Encoding: 0x11C00390
    // Test aarch32_STREXB_A1_A field combination: cond=1, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: cond=1, Rt=0, Rn=0, Rd=0
    let encoding: u32 = 0x11C00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXB_A1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=2 (condition CS/HS (carry set))
#[test]
fn test_aarch32_strexb_a1_a_combo_2_390_21c00390() {
    // Encoding: 0x21C00390
    // Test aarch32_STREXB_A1_A field combination: cond=2, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: cond=2, Rd=0, Rn=0, Rt=0
    let encoding: u32 = 0x21C00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXB_A1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=3 (condition CC/LO (carry clear))
#[test]
fn test_aarch32_strexb_a1_a_combo_3_390_31c00390() {
    // Encoding: 0x31C00390
    // Test aarch32_STREXB_A1_A field combination: cond=3, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rd=0, Rt=0, cond=3, Rn=0
    let encoding: u32 = 0x31C00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXB_A1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=4 (condition MI (minus/negative))
#[test]
fn test_aarch32_strexb_a1_a_combo_4_390_41c00390() {
    // Encoding: 0x41C00390
    // Test aarch32_STREXB_A1_A field combination: cond=4, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rd=0, Rt=0, cond=4, Rn=0
    let encoding: u32 = 0x41C00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXB_A1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=5 (condition PL (plus/positive))
#[test]
fn test_aarch32_strexb_a1_a_combo_5_390_51c00390() {
    // Encoding: 0x51C00390
    // Test aarch32_STREXB_A1_A field combination: cond=5, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rn=0, cond=5, Rt=0, Rd=0
    let encoding: u32 = 0x51C00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXB_A1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=6 (condition VS (overflow set))
#[test]
fn test_aarch32_strexb_a1_a_combo_6_390_61c00390() {
    // Encoding: 0x61C00390
    // Test aarch32_STREXB_A1_A field combination: cond=6, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rd=0, Rt=0, cond=6, Rn=0
    let encoding: u32 = 0x61C00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXB_A1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=7 (condition VC (overflow clear))
#[test]
fn test_aarch32_strexb_a1_a_combo_7_390_71c00390() {
    // Encoding: 0x71C00390
    // Test aarch32_STREXB_A1_A field combination: cond=7, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rd=0, cond=7, Rn=0, Rt=0
    let encoding: u32 = 0x71C00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXB_A1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=8 (condition HI (unsigned higher))
#[test]
fn test_aarch32_strexb_a1_a_combo_8_390_81c00390() {
    // Encoding: 0x81C00390
    // Test aarch32_STREXB_A1_A field combination: cond=8, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: cond=8, Rt=0, Rn=0, Rd=0
    let encoding: u32 = 0x81C00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXB_A1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=9 (condition LS (unsigned lower or same))
#[test]
fn test_aarch32_strexb_a1_a_combo_9_390_91c00390() {
    // Encoding: 0x91C00390
    // Test aarch32_STREXB_A1_A field combination: cond=9, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rt=0, cond=9, Rn=0, Rd=0
    let encoding: u32 = 0x91C00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXB_A1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=10 (condition GE (signed >=))
#[test]
fn test_aarch32_strexb_a1_a_combo_10_390_a1c00390() {
    // Encoding: 0xA1C00390
    // Test aarch32_STREXB_A1_A field combination: cond=10, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: cond=10, Rn=0, Rd=0, Rt=0
    let encoding: u32 = 0xA1C00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXB_A1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=11 (condition LT (signed <))
#[test]
fn test_aarch32_strexb_a1_a_combo_11_390_b1c00390() {
    // Encoding: 0xB1C00390
    // Test aarch32_STREXB_A1_A field combination: cond=11, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rt=0, Rd=0, Rn=0, cond=11
    let encoding: u32 = 0xB1C00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXB_A1_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=12 (condition GT (signed >))
#[test]
fn test_aarch32_strexb_a1_a_combo_12_390_c1c00390() {
    // Encoding: 0xC1C00390
    // Test aarch32_STREXB_A1_A field combination: cond=12, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rt=0, Rd=0, cond=12, Rn=0
    let encoding: u32 = 0xC1C00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXB_A1_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=13 (condition LE (signed <=))
#[test]
fn test_aarch32_strexb_a1_a_combo_13_390_d1c00390() {
    // Encoding: 0xD1C00390
    // Test aarch32_STREXB_A1_A field combination: cond=13, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rn=0, Rd=0, cond=13, Rt=0
    let encoding: u32 = 0xD1C00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXB_A1_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=14 (condition AL (always))
#[test]
fn test_aarch32_strexb_a1_a_combo_14_390_e1c00390() {
    // Encoding: 0xE1C00390
    // Test aarch32_STREXB_A1_A field combination: cond=14, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: cond=14, Rd=0, Rn=0, Rt=0
    let encoding: u32 = 0xE1C00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXB_A1_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=15 (condition NV (never, reserved))
#[test]
fn test_aarch32_strexb_a1_a_combo_15_390_f1c00390() {
    // Encoding: 0xF1C00390
    // Test aarch32_STREXB_A1_A field combination: cond=15, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: cond=15, Rd=0, Rn=0, Rt=0
    let encoding: u32 = 0xF1C00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXB_A1_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_strexb_a1_a_combo_16_390_01c00390() {
    // Encoding: 0x01C00390
    // Test aarch32_STREXB_A1_A field combination: cond=0, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=0, Rd=0
    let encoding: u32 = 0x01C00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXB_A1_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_strexb_a1_a_combo_17_390_01c10390() {
    // Encoding: 0x01C10390
    // Test aarch32_STREXB_A1_A field combination: cond=0, Rn=1, Rd=0, Rt=0
    // ISET: A32
    // Fields: cond=0, Rn=1, Rd=0, Rt=0
    let encoding: u32 = 0x01C10390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXB_A1_A
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch32_strexb_a1_a_combo_18_390_01c00390() {
    // Encoding: 0x01C00390
    // Test aarch32_STREXB_A1_A field combination: cond=0, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rn=0, cond=0, Rt=0, Rd=0
    let encoding: u32 = 0x01C00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXB_A1_A
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch32_strexb_a1_a_combo_19_390_01c01390() {
    // Encoding: 0x01C01390
    // Test aarch32_STREXB_A1_A field combination: cond=0, Rn=0, Rd=1, Rt=0
    // ISET: A32
    // Fields: Rt=0, Rd=1, Rn=0, cond=0
    let encoding: u32 = 0x01C01390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXB_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_strexb_a1_a_special_cond_0_condition_eq_912_01c00390() {
    // Encoding: 0x01C00390
    // Test aarch32_STREXB_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: Rd=0, Rn=0, Rt=0, cond=0
    let encoding: u32 = 0x01C00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXB_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_strexb_a1_a_special_cond_1_condition_ne_912_11c00390() {
    // Encoding: 0x11C00390
    // Test aarch32_STREXB_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: cond=1, Rd=0, Rt=0, Rn=0
    let encoding: u32 = 0x11C00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXB_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_strexb_a1_a_special_cond_2_condition_cs_hs_912_21c00390() {
    // Encoding: 0x21C00390
    // Test aarch32_STREXB_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: Rd=0, Rt=0, cond=2, Rn=0
    let encoding: u32 = 0x21C00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXB_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_strexb_a1_a_special_cond_3_condition_cc_lo_912_31c00390() {
    // Encoding: 0x31C00390
    // Test aarch32_STREXB_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: cond=3, Rd=0, Rn=0, Rt=0
    let encoding: u32 = 0x31C00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXB_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_strexb_a1_a_special_cond_4_condition_mi_912_41c00390() {
    // Encoding: 0x41C00390
    // Test aarch32_STREXB_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: cond=4, Rn=0, Rd=0, Rt=0
    let encoding: u32 = 0x41C00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXB_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_strexb_a1_a_special_cond_5_condition_pl_912_51c00390() {
    // Encoding: 0x51C00390
    // Test aarch32_STREXB_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: Rn=0, Rd=0, Rt=0, cond=5
    let encoding: u32 = 0x51C00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXB_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_strexb_a1_a_special_cond_6_condition_vs_912_61c00390() {
    // Encoding: 0x61C00390
    // Test aarch32_STREXB_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: Rt=0, Rd=0, Rn=0, cond=6
    let encoding: u32 = 0x61C00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXB_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_strexb_a1_a_special_cond_7_condition_vc_912_71c00390() {
    // Encoding: 0x71C00390
    // Test aarch32_STREXB_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: cond=7, Rn=0, Rd=0, Rt=0
    let encoding: u32 = 0x71C00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXB_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_strexb_a1_a_special_cond_8_condition_hi_912_81c00390() {
    // Encoding: 0x81C00390
    // Test aarch32_STREXB_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: Rd=0, Rn=0, Rt=0, cond=8
    let encoding: u32 = 0x81C00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXB_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_strexb_a1_a_special_cond_9_condition_ls_912_91c00390() {
    // Encoding: 0x91C00390
    // Test aarch32_STREXB_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: Rd=0, Rt=0, cond=9, Rn=0
    let encoding: u32 = 0x91C00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXB_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_strexb_a1_a_special_cond_10_condition_ge_912_a1c00390() {
    // Encoding: 0xA1C00390
    // Test aarch32_STREXB_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: Rn=0, cond=10, Rd=0, Rt=0
    let encoding: u32 = 0xA1C00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXB_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_strexb_a1_a_special_cond_11_condition_lt_912_b1c00390() {
    // Encoding: 0xB1C00390
    // Test aarch32_STREXB_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: Rn=0, Rd=0, cond=11, Rt=0
    let encoding: u32 = 0xB1C00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXB_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_strexb_a1_a_special_cond_12_condition_gt_912_c1c00390() {
    // Encoding: 0xC1C00390
    // Test aarch32_STREXB_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: Rt=0, cond=12, Rn=0, Rd=0
    let encoding: u32 = 0xC1C00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXB_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_strexb_a1_a_special_cond_13_condition_le_912_d1c00390() {
    // Encoding: 0xD1C00390
    // Test aarch32_STREXB_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: cond=13, Rn=0, Rd=0, Rt=0
    let encoding: u32 = 0xD1C00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXB_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_strexb_a1_a_special_cond_14_condition_al_912_e1c00390() {
    // Encoding: 0xE1C00390
    // Test aarch32_STREXB_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: cond=14, Rt=0, Rn=0, Rd=0
    let encoding: u32 = 0xE1C00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXB_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_strexb_a1_a_special_cond_15_condition_nv_912_f1c00390() {
    // Encoding: 0xF1C00390
    // Test aarch32_STREXB_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: cond=15, Rn=0, Rd=0, Rt=0
    let encoding: u32 = 0xF1C00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXB_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strexb_a1_a_invalid_0_390_01c00390() {
    // Encoding: 0x01C00390
    // Test aarch32_STREXB_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }
    // ISET: A32
    // Fields: cond=0, Rn=0, Rt=0, Rd=0
    let encoding: u32 = 0x01C00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STREXB_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strexb_a1_a_invalid_1_390_01c00390() {
    // Encoding: 0x01C00390
    // Test aarch32_STREXB_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Rt=0, Rn=0, cond=0, Rd=0
    let encoding: u32 = 0x01C00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STREXB_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strexb_a1_a_invalid_2_390_01c00390() {
    // Encoding: 0x01C00390
    // Test aarch32_STREXB_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) }
    // ISET: A32
    // Fields: Rd=0, cond=0, Rt=0, Rn=0
    let encoding: u32 = 0x01C00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STREXB_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strexb_a1_a_invalid_3_390_01c00390() {
    // Encoding: 0x01C00390
    // Test aarch32_STREXB_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: cond=0, Rn=0, Rd=0, Rt=0
    let encoding: u32 = 0x01C00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STREXB_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_strexb_t1_a_field_rn_0_min_40_e8c00040() {
    // Thumb encoding (32): 0xE8C00040
    // Test aarch32_STREXB_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rt=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C00040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREXB_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_strexb_t1_a_field_rn_1_poweroftwo_40_e8c10040() {
    // Thumb encoding (32): 0xE8C10040
    // Test aarch32_STREXB_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=1, Rd=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C10040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREXB_T1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_strexb_t1_a_field_rt_0_min_40_e8c00040() {
    // Thumb encoding (32): 0xE8C00040
    // Test aarch32_STREXB_T1_A field Rt = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rd=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C00040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREXB_T1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_strexb_t1_a_field_rt_1_poweroftwo_40_e8c01040() {
    // Thumb encoding (32): 0xE8C01040
    // Test aarch32_STREXB_T1_A field Rt = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rd=0, Rt=1, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C01040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREXB_T1_A
/// ASL: `field Rd 0 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_strexb_t1_a_field_rd_0_min_40_e8c00040() {
    // Thumb encoding (32): 0xE8C00040
    // Test aarch32_STREXB_T1_A field Rd = 0 (Min)
    // ISET: T32
    // Fields: Rt=0, Rn=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C00040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREXB_T1_A
/// ASL: `field Rd 0 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_strexb_t1_a_field_rd_1_poweroftwo_40_e8c00041() {
    // Thumb encoding (32): 0xE8C00041
    // Test aarch32_STREXB_T1_A field Rd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rd=1, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C00041;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREXB_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_strexb_t1_a_combo_0_40_e8c00040() {
    // Thumb encoding (32): 0xE8C00040
    // Test aarch32_STREXB_T1_A field combination: Rn=0, Rt=0, Rd=0
    // ISET: T32
    // Fields: Rn=0, Rd=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C00040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREXB_T1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_strexb_t1_a_combo_1_40_e8c10040() {
    // Thumb encoding (32): 0xE8C10040
    // Test aarch32_STREXB_T1_A field combination: Rn=1, Rt=0, Rd=0
    // ISET: T32
    // Fields: Rd=0, Rn=1, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C10040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREXB_T1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=0 (register index 0 (first register))
#[test]
fn test_aarch32_strexb_t1_a_combo_2_40_e8c00040() {
    // Thumb encoding (32): 0xE8C00040
    // Test aarch32_STREXB_T1_A field combination: Rn=0, Rt=0, Rd=0
    // ISET: T32
    // Fields: Rt=0, Rn=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C00040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREXB_T1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=1 (register index 1 (second register))
#[test]
fn test_aarch32_strexb_t1_a_combo_3_40_e8c01040() {
    // Thumb encoding (32): 0xE8C01040
    // Test aarch32_STREXB_T1_A field combination: Rn=0, Rt=1, Rd=0
    // ISET: T32
    // Fields: Rt=1, Rn=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C01040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREXB_T1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch32_strexb_t1_a_combo_4_40_e8c00040() {
    // Thumb encoding (32): 0xE8C00040
    // Test aarch32_STREXB_T1_A field combination: Rn=0, Rt=0, Rd=0
    // ISET: T32
    // Fields: Rt=0, Rd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C00040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREXB_T1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch32_strexb_t1_a_combo_5_40_e8c00041() {
    // Thumb encoding (32): 0xE8C00041
    // Test aarch32_STREXB_T1_A field combination: Rn=0, Rt=0, Rd=1
    // ISET: T32
    // Fields: Rt=0, Rn=0, Rd=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C00041;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREXB_T1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rt=1 (same register test (reg=1))
#[test]
fn test_aarch32_strexb_t1_a_combo_6_40_e8c11040() {
    // Thumb encoding (32): 0xE8C11040
    // Test aarch32_STREXB_T1_A field combination: Rn=1, Rt=1, Rd=0
    // ISET: T32
    // Fields: Rt=1, Rn=1, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C11040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREXB_T1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rt=31 (same register test (reg=31))
#[test]
fn test_aarch32_strexb_t1_a_combo_7_40_e8cff040() {
    // Thumb encoding (32): 0xE8CFF040
    // Test aarch32_STREXB_T1_A field combination: Rn=31, Rt=31, Rd=0
    // ISET: T32
    // Fields: Rn=31, Rt=31, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8CFF040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREXB_T1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch32_strexb_t1_a_combo_8_40_e8c10041() {
    // Thumb encoding (32): 0xE8C10041
    // Test aarch32_STREXB_T1_A field combination: Rn=1, Rt=0, Rd=1
    // ISET: T32
    // Fields: Rd=1, Rn=1, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C10041;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREXB_T1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch32_strexb_t1_a_combo_9_40_e8cf004f() {
    // Thumb encoding (32): 0xE8CF004F
    // Test aarch32_STREXB_T1_A field combination: Rn=31, Rt=0, Rd=31
    // ISET: T32
    // Fields: Rt=0, Rn=31, Rd=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8CF004F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREXB_T1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch32_strexb_t1_a_combo_10_40_e8c01041() {
    // Thumb encoding (32): 0xE8C01041
    // Test aarch32_STREXB_T1_A field combination: Rn=0, Rt=1, Rd=1
    // ISET: T32
    // Fields: Rn=0, Rd=1, Rt=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C01041;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREXB_T1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch32_strexb_t1_a_combo_11_40_e8c0f04f() {
    // Thumb encoding (32): 0xE8C0F04F
    // Test aarch32_STREXB_T1_A field combination: Rn=0, Rt=31, Rd=31
    // ISET: T32
    // Fields: Rn=0, Rt=31, Rd=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C0F04F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREXB_T1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strexb_t1_a_invalid_0_40_e8c00040() {
    // Thumb encoding (32): 0xE8C00040
    // Test aarch32_STREXB_T1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }
    // ISET: T32
    // Fields: Rt=0, Rn=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C00040;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_STREXB_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strexb_t1_a_invalid_1_40_e8c00040() {
    // Thumb encoding (32): 0xE8C00040
    // Test aarch32_STREXB_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rd=0, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C00040;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_STREXB_T1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strexb_t1_a_invalid_2_40_e8c00040() {
    // Thumb encoding (32): 0xE8C00040
    // Test aarch32_STREXB_T1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) }
    // ISET: T32
    // Fields: Rd=0, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C00040;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_STREXB_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strexb_t1_a_invalid_3_40_e8c00040() {
    // Thumb encoding (32): 0xE8C00040
    // Test aarch32_STREXB_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rn=0, Rt=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C00040;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_STREXB_A1_A
/// ASL: `SMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple multiply
#[test]
fn test_aarch32_strexb_a1_a_smull_oracle_0_9b227c20() {
    // Test SMULL: simple multiply (oracle)
    // Encoding: 0x9B227C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x2);
    set_w(&mut cpu, 2, 0x3);
    let encoding: u32 = 0x9B227C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6, "X0 should be 0x0000000000000006");
}

/// Provenance: aarch32_STREXB_A1_A
/// ASL: `SMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max 32-bit * 2
#[test]
fn test_aarch32_strexb_a1_a_smull_oracle_1_9b227c20() {
    // Test SMULL: max 32-bit * 2 (oracle)
    // Encoding: 0x9B227C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x9B227C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFE, "X0 should be 0xFFFFFFFFFFFFFFFE");
}

/// Provenance: aarch32_STREXB_A1_A
/// ASL: `SMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// large positive * large positive
#[test]
fn test_aarch32_strexb_a1_a_smull_oracle_2_9b227c20() {
    // Test SMULL: large positive * large positive (oracle)
    // Encoding: 0x9B227C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    set_w(&mut cpu, 2, 0x7FFFFFFF);
    let encoding: u32 = 0x9B227C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x3FFFFFFF00000001");
}

/// Provenance: aarch32_STREXB_A1_A
/// ASL: `SMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max unsigned * max unsigned
#[test]
fn test_aarch32_strexb_a1_a_smull_oracle_3_9b227c20() {
    // Test SMULL: max unsigned * max unsigned (oracle)
    // Encoding: 0x9B227C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x9B227C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x0000000000000001");
}

/// Provenance: aarch32_STREXB_A1_A
/// ASL: `SMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// medium values
#[test]
fn test_aarch32_strexb_a1_a_smull_oracle_4_9b227c20() {
    // Test SMULL: medium values (oracle)
    // Encoding: 0x9B227C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0xC8);
    let encoding: u32 = 0x9B227C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4E20, "X0 should be 0x0000000000004E20");
}

/// Provenance: aarch32_STREXB_A1_A
/// ASL: `SMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// 16-bit values
#[test]
fn test_aarch32_strexb_a1_a_smull_oracle_5_9b227c20() {
    // Test SMULL: 16-bit values (oracle)
    // Encoding: 0x9B227C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1234);
    set_w(&mut cpu, 2, 0x5678);
    let encoding: u32 = 0x9B227C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6260060, "X0 should be 0x0000000006260060");
}

/// Provenance: aarch32_STREXB_A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_strexb_a1_a_store_0_01c10390() {
    // Test aarch32_STREXB_A1_A memory store: 8 bytes
    // Encoding: 0x01C10390
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0x01C10390;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_STREXB_T1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_strexb_t1_a_store_0_e8c10040() {
    // Test aarch32_STREXB_T1_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0xE8C10040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// aarch32_STRH_r_A Tests
// ============================================================================

/// Provenance: aarch32_STRH_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_strh_r_a1_a_field_cond_0_min_b0_000000b0() {
    // Encoding: 0x000000B0
    // Test aarch32_STRH_r_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rn=0, P=0, U=0, W=0, Rt=0, Rm=0
    let encoding: u32 = 0x000000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_strh_r_a1_a_field_cond_1_poweroftwo_b0_100000b0() {
    // Encoding: 0x100000B0
    // Test aarch32_STRH_r_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=1, W=0, Rt=0, U=0, Rm=0, P=0, Rn=0
    let encoding: u32 = 0x100000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_strh_r_a1_a_field_cond_2_poweroftwo_b0_200000b0() {
    // Encoding: 0x200000B0
    // Test aarch32_STRH_r_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, P=0, U=0, Rm=0, cond=2, W=0, Rn=0
    let encoding: u32 = 0x200000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_strh_r_a1_a_field_cond_3_poweroftwo_b0_300000b0() {
    // Encoding: 0x300000B0
    // Test aarch32_STRH_r_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=3, Rn=0, U=0, W=0, Rt=0, Rm=0, P=0
    let encoding: u32 = 0x300000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_strh_r_a1_a_field_cond_4_poweroftwo_b0_400000b0() {
    // Encoding: 0x400000B0
    // Test aarch32_STRH_r_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Rt=0, cond=4, U=0, W=0, Rn=0, P=0
    let encoding: u32 = 0x400000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_strh_r_a1_a_field_cond_5_poweroftwo_b0_500000b0() {
    // Encoding: 0x500000B0
    // Test aarch32_STRH_r_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, P=0, cond=5, Rn=0, U=0, W=0, Rm=0
    let encoding: u32 = 0x500000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_strh_r_a1_a_field_cond_6_poweroftwo_b0_600000b0() {
    // Encoding: 0x600000B0
    // Test aarch32_STRH_r_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, Rn=0, W=0, Rm=0, cond=6, Rt=0, P=0
    let encoding: u32 = 0x600000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_strh_r_a1_a_field_cond_7_poweroftwo_b0_700000b0() {
    // Encoding: 0x700000B0
    // Test aarch32_STRH_r_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, P=0, U=0, W=0, Rn=0, cond=7, Rt=0
    let encoding: u32 = 0x700000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_strh_r_a1_a_field_cond_8_poweroftwo_b0_800000b0() {
    // Encoding: 0x800000B0
    // Test aarch32_STRH_r_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, Rm=0, cond=8, P=0, Rn=0, U=0, W=0
    let encoding: u32 = 0x800000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_strh_r_a1_a_field_cond_9_poweroftwo_b0_900000b0() {
    // Encoding: 0x900000B0
    // Test aarch32_STRH_r_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, cond=9, P=0, Rn=0, Rm=0, W=0, U=0
    let encoding: u32 = 0x900000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_strh_r_a1_a_field_cond_10_poweroftwo_b0_a00000b0() {
    // Encoding: 0xA00000B0
    // Test aarch32_STRH_r_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=10, W=0, Rn=0, Rt=0, Rm=0, U=0, P=0
    let encoding: u32 = 0xA00000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_strh_r_a1_a_field_cond_11_poweroftwo_b0_b00000b0() {
    // Encoding: 0xB00000B0
    // Test aarch32_STRH_r_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, Rt=0, Rn=0, P=0, cond=11, Rm=0, U=0
    let encoding: u32 = 0xB00000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_strh_r_a1_a_field_cond_12_poweroftwo_b0_c00000b0() {
    // Encoding: 0xC00000B0
    // Test aarch32_STRH_r_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, cond=12, P=0, Rn=0, Rm=0, W=0, U=0
    let encoding: u32 = 0xC00000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_strh_r_a1_a_field_cond_13_poweroftwo_b0_d00000b0() {
    // Encoding: 0xD00000B0
    // Test aarch32_STRH_r_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=13, P=0, U=0, Rt=0, Rn=0, W=0, Rm=0
    let encoding: u32 = 0xD00000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_strh_r_a1_a_field_cond_14_poweroftwo_b0_e00000b0() {
    // Encoding: 0xE00000B0
    // Test aarch32_STRH_r_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, W=0, Rn=0, U=0, cond=14, Rt=0, P=0
    let encoding: u32 = 0xE00000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_strh_r_a1_a_field_cond_15_max_b0_f00000b0() {
    // Encoding: 0xF00000B0
    // Test aarch32_STRH_r_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: U=0, cond=15, W=0, Rn=0, Rt=0, P=0, Rm=0
    let encoding: u32 = 0xF00000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_r_A1_A
/// ASL: `field P 24 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_strh_r_a1_a_field_p_0_min_b0_000000b0() {
    // Encoding: 0x000000B0
    // Test aarch32_STRH_r_A1_A field P = 0 (Min)
    // ISET: A32
    // Fields: U=0, P=0, cond=0, Rn=0, Rt=0, Rm=0, W=0
    let encoding: u32 = 0x000000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_r_A1_A
/// ASL: `field P 24 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_strh_r_a1_a_field_p_1_max_b0_010000b0() {
    // Encoding: 0x010000B0
    // Test aarch32_STRH_r_A1_A field P = 1 (Max)
    // ISET: A32
    // Fields: W=0, Rt=0, Rm=0, P=1, U=0, Rn=0, cond=0
    let encoding: u32 = 0x010000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_r_A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_strh_r_a1_a_field_u_0_min_b0_000000b0() {
    // Encoding: 0x000000B0
    // Test aarch32_STRH_r_A1_A field U = 0 (Min)
    // ISET: A32
    // Fields: W=0, Rt=0, Rm=0, P=0, cond=0, Rn=0, U=0
    let encoding: u32 = 0x000000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_r_A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_strh_r_a1_a_field_u_1_max_b0_008000b0() {
    // Encoding: 0x008000B0
    // Test aarch32_STRH_r_A1_A field U = 1 (Max)
    // ISET: A32
    // Fields: P=0, Rm=0, cond=0, U=1, Rn=0, Rt=0, W=0
    let encoding: u32 = 0x008000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_r_A1_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_strh_r_a1_a_field_w_0_min_b0_000000b0() {
    // Encoding: 0x000000B0
    // Test aarch32_STRH_r_A1_A field W = 0 (Min)
    // ISET: A32
    // Fields: U=0, W=0, Rm=0, cond=0, Rt=0, P=0, Rn=0
    let encoding: u32 = 0x000000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_r_A1_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_strh_r_a1_a_field_w_1_max_b0_002000b0() {
    // Encoding: 0x002000B0
    // Test aarch32_STRH_r_A1_A field W = 1 (Max)
    // ISET: A32
    // Fields: Rt=0, Rm=0, P=0, U=0, cond=0, Rn=0, W=1
    let encoding: u32 = 0x002000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_r_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_strh_r_a1_a_field_rn_0_min_b0_000000b0() {
    // Encoding: 0x000000B0
    // Test aarch32_STRH_r_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: P=0, Rn=0, Rm=0, cond=0, Rt=0, U=0, W=0
    let encoding: u32 = 0x000000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_r_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_strh_r_a1_a_field_rn_1_poweroftwo_b0_000100b0() {
    // Encoding: 0x000100B0
    // Test aarch32_STRH_r_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, W=0, U=0, P=0, Rt=0, Rn=1, cond=0
    let encoding: u32 = 0x000100B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_r_A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_strh_r_a1_a_field_rt_0_min_b0_000000b0() {
    // Encoding: 0x000000B0
    // Test aarch32_STRH_r_A1_A field Rt = 0 (Min)
    // ISET: A32
    // Fields: P=0, cond=0, W=0, Rt=0, U=0, Rn=0, Rm=0
    let encoding: u32 = 0x000000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_r_A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_strh_r_a1_a_field_rt_1_poweroftwo_b0_000010b0() {
    // Encoding: 0x000010B0
    // Test aarch32_STRH_r_A1_A field Rt = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rt=1, cond=0, Rm=0, P=0, U=0, W=0
    let encoding: u32 = 0x000010B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_r_A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_strh_r_a1_a_field_rm_0_min_b0_000000b0() {
    // Encoding: 0x000000B0
    // Test aarch32_STRH_r_A1_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: W=0, Rn=0, cond=0, P=0, U=0, Rt=0, Rm=0
    let encoding: u32 = 0x000000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_r_A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_strh_r_a1_a_field_rm_1_poweroftwo_b0_000000b1() {
    // Encoding: 0x000000B1
    // Test aarch32_STRH_r_A1_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, Rt=0, Rn=0, P=0, W=0, Rm=1, cond=0
    let encoding: u32 = 0x000000B1;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_r_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_strh_r_a1_a_combo_0_b0_000000b0() {
    // Encoding: 0x000000B0
    // Test aarch32_STRH_r_A1_A field combination: cond=0, P=0, U=0, W=0, Rn=0, Rt=0, Rm=0
    // ISET: A32
    // Fields: Rn=0, P=0, Rm=0, W=0, Rt=0, cond=0, U=0
    let encoding: u32 = 0x000000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_r_A1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=1 (condition NE (not equal))
#[test]
fn test_aarch32_strh_r_a1_a_combo_1_b0_100000b0() {
    // Encoding: 0x100000B0
    // Test aarch32_STRH_r_A1_A field combination: cond=1, P=0, U=0, W=0, Rn=0, Rt=0, Rm=0
    // ISET: A32
    // Fields: W=0, cond=1, Rt=0, U=0, Rn=0, P=0, Rm=0
    let encoding: u32 = 0x100000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_r_A1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=2 (condition CS/HS (carry set))
#[test]
fn test_aarch32_strh_r_a1_a_combo_2_b0_200000b0() {
    // Encoding: 0x200000B0
    // Test aarch32_STRH_r_A1_A field combination: cond=2, P=0, U=0, W=0, Rn=0, Rt=0, Rm=0
    // ISET: A32
    // Fields: cond=2, Rt=0, U=0, P=0, Rn=0, W=0, Rm=0
    let encoding: u32 = 0x200000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_r_A1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=3 (condition CC/LO (carry clear))
#[test]
fn test_aarch32_strh_r_a1_a_combo_3_b0_300000b0() {
    // Encoding: 0x300000B0
    // Test aarch32_STRH_r_A1_A field combination: cond=3, P=0, U=0, W=0, Rn=0, Rt=0, Rm=0
    // ISET: A32
    // Fields: Rm=0, cond=3, W=0, P=0, Rn=0, Rt=0, U=0
    let encoding: u32 = 0x300000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_r_A1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=4 (condition MI (minus/negative))
#[test]
fn test_aarch32_strh_r_a1_a_combo_4_b0_400000b0() {
    // Encoding: 0x400000B0
    // Test aarch32_STRH_r_A1_A field combination: cond=4, P=0, U=0, W=0, Rn=0, Rt=0, Rm=0
    // ISET: A32
    // Fields: Rt=0, cond=4, Rm=0, W=0, Rn=0, U=0, P=0
    let encoding: u32 = 0x400000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_r_A1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=5 (condition PL (plus/positive))
#[test]
fn test_aarch32_strh_r_a1_a_combo_5_b0_500000b0() {
    // Encoding: 0x500000B0
    // Test aarch32_STRH_r_A1_A field combination: cond=5, P=0, U=0, W=0, Rn=0, Rt=0, Rm=0
    // ISET: A32
    // Fields: Rt=0, Rm=0, W=0, Rn=0, P=0, cond=5, U=0
    let encoding: u32 = 0x500000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_r_A1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=6 (condition VS (overflow set))
#[test]
fn test_aarch32_strh_r_a1_a_combo_6_b0_600000b0() {
    // Encoding: 0x600000B0
    // Test aarch32_STRH_r_A1_A field combination: cond=6, P=0, U=0, W=0, Rn=0, Rt=0, Rm=0
    // ISET: A32
    // Fields: Rt=0, cond=6, Rm=0, W=0, P=0, Rn=0, U=0
    let encoding: u32 = 0x600000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_r_A1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=7 (condition VC (overflow clear))
#[test]
fn test_aarch32_strh_r_a1_a_combo_7_b0_700000b0() {
    // Encoding: 0x700000B0
    // Test aarch32_STRH_r_A1_A field combination: cond=7, P=0, U=0, W=0, Rn=0, Rt=0, Rm=0
    // ISET: A32
    // Fields: W=0, P=0, Rn=0, U=0, Rt=0, Rm=0, cond=7
    let encoding: u32 = 0x700000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_r_A1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=8 (condition HI (unsigned higher))
#[test]
fn test_aarch32_strh_r_a1_a_combo_8_b0_800000b0() {
    // Encoding: 0x800000B0
    // Test aarch32_STRH_r_A1_A field combination: cond=8, P=0, U=0, W=0, Rn=0, Rt=0, Rm=0
    // ISET: A32
    // Fields: cond=8, W=0, P=0, Rm=0, U=0, Rn=0, Rt=0
    let encoding: u32 = 0x800000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_r_A1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=9 (condition LS (unsigned lower or same))
#[test]
fn test_aarch32_strh_r_a1_a_combo_9_b0_900000b0() {
    // Encoding: 0x900000B0
    // Test aarch32_STRH_r_A1_A field combination: cond=9, P=0, U=0, W=0, Rn=0, Rt=0, Rm=0
    // ISET: A32
    // Fields: Rm=0, Rn=0, U=0, P=0, cond=9, W=0, Rt=0
    let encoding: u32 = 0x900000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_r_A1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=10 (condition GE (signed >=))
#[test]
fn test_aarch32_strh_r_a1_a_combo_10_b0_a00000b0() {
    // Encoding: 0xA00000B0
    // Test aarch32_STRH_r_A1_A field combination: cond=10, P=0, U=0, W=0, Rn=0, Rt=0, Rm=0
    // ISET: A32
    // Fields: P=0, Rt=0, Rn=0, cond=10, W=0, U=0, Rm=0
    let encoding: u32 = 0xA00000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_r_A1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=11 (condition LT (signed <))
#[test]
fn test_aarch32_strh_r_a1_a_combo_11_b0_b00000b0() {
    // Encoding: 0xB00000B0
    // Test aarch32_STRH_r_A1_A field combination: cond=11, P=0, U=0, W=0, Rn=0, Rt=0, Rm=0
    // ISET: A32
    // Fields: cond=11, Rm=0, U=0, P=0, Rn=0, Rt=0, W=0
    let encoding: u32 = 0xB00000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_r_A1_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=12 (condition GT (signed >))
#[test]
fn test_aarch32_strh_r_a1_a_combo_12_b0_c00000b0() {
    // Encoding: 0xC00000B0
    // Test aarch32_STRH_r_A1_A field combination: cond=12, P=0, U=0, W=0, Rn=0, Rt=0, Rm=0
    // ISET: A32
    // Fields: Rn=0, Rt=0, U=0, cond=12, Rm=0, P=0, W=0
    let encoding: u32 = 0xC00000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_r_A1_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=13 (condition LE (signed <=))
#[test]
fn test_aarch32_strh_r_a1_a_combo_13_b0_d00000b0() {
    // Encoding: 0xD00000B0
    // Test aarch32_STRH_r_A1_A field combination: cond=13, P=0, U=0, W=0, Rn=0, Rt=0, Rm=0
    // ISET: A32
    // Fields: Rm=0, U=0, P=0, cond=13, W=0, Rn=0, Rt=0
    let encoding: u32 = 0xD00000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_r_A1_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=14 (condition AL (always))
#[test]
fn test_aarch32_strh_r_a1_a_combo_14_b0_e00000b0() {
    // Encoding: 0xE00000B0
    // Test aarch32_STRH_r_A1_A field combination: cond=14, P=0, U=0, W=0, Rn=0, Rt=0, Rm=0
    // ISET: A32
    // Fields: Rt=0, Rm=0, U=0, W=0, cond=14, P=0, Rn=0
    let encoding: u32 = 0xE00000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_r_A1_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=15 (condition NV (never, reserved))
#[test]
fn test_aarch32_strh_r_a1_a_combo_15_b0_f00000b0() {
    // Encoding: 0xF00000B0
    // Test aarch32_STRH_r_A1_A field combination: cond=15, P=0, U=0, W=0, Rn=0, Rt=0, Rm=0
    // ISET: A32
    // Fields: cond=15, Rt=0, Rn=0, Rm=0, W=0, U=0, P=0
    let encoding: u32 = 0xF00000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_r_A1_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// P=0 (minimum value)
#[test]
fn test_aarch32_strh_r_a1_a_combo_16_b0_000000b0() {
    // Encoding: 0x000000B0
    // Test aarch32_STRH_r_A1_A field combination: cond=0, P=0, U=0, W=0, Rn=0, Rt=0, Rm=0
    // ISET: A32
    // Fields: U=0, Rt=0, P=0, Rm=0, cond=0, W=0, Rn=0
    let encoding: u32 = 0x000000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_r_A1_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// P=1 (maximum value (1))
#[test]
fn test_aarch32_strh_r_a1_a_combo_17_b0_010000b0() {
    // Encoding: 0x010000B0
    // Test aarch32_STRH_r_A1_A field combination: cond=0, P=1, U=0, W=0, Rn=0, Rt=0, Rm=0
    // ISET: A32
    // Fields: cond=0, P=1, U=0, W=0, Rt=0, Rm=0, Rn=0
    let encoding: u32 = 0x010000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_r_A1_A
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=0 (minimum value)
#[test]
fn test_aarch32_strh_r_a1_a_combo_18_b0_000000b0() {
    // Encoding: 0x000000B0
    // Test aarch32_STRH_r_A1_A field combination: cond=0, P=0, U=0, W=0, Rn=0, Rt=0, Rm=0
    // ISET: A32
    // Fields: cond=0, Rn=0, P=0, W=0, Rm=0, Rt=0, U=0
    let encoding: u32 = 0x000000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_r_A1_A
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=1 (maximum value (1))
#[test]
fn test_aarch32_strh_r_a1_a_combo_19_b0_008000b0() {
    // Encoding: 0x008000B0
    // Test aarch32_STRH_r_A1_A field combination: cond=0, P=0, U=1, W=0, Rn=0, Rt=0, Rm=0
    // ISET: A32
    // Fields: Rn=0, Rm=0, cond=0, U=1, P=0, W=0, Rt=0
    let encoding: u32 = 0x008000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_r_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_strh_r_a1_a_special_cond_0_condition_eq_176_000000b0() {
    // Encoding: 0x000000B0
    // Test aarch32_STRH_r_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: U=0, W=0, Rn=0, Rt=0, Rm=0, P=0, cond=0
    let encoding: u32 = 0x000000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_r_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_strh_r_a1_a_special_cond_1_condition_ne_176_100000b0() {
    // Encoding: 0x100000B0
    // Test aarch32_STRH_r_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: Rm=0, cond=1, U=0, Rn=0, Rt=0, P=0, W=0
    let encoding: u32 = 0x100000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_r_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_strh_r_a1_a_special_cond_2_condition_cs_hs_176_200000b0() {
    // Encoding: 0x200000B0
    // Test aarch32_STRH_r_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: Rt=0, Rn=0, Rm=0, cond=2, U=0, P=0, W=0
    let encoding: u32 = 0x200000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_r_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_strh_r_a1_a_special_cond_3_condition_cc_lo_176_300000b0() {
    // Encoding: 0x300000B0
    // Test aarch32_STRH_r_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: cond=3, Rm=0, Rn=0, U=0, Rt=0, P=0, W=0
    let encoding: u32 = 0x300000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_r_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_strh_r_a1_a_special_cond_4_condition_mi_176_400000b0() {
    // Encoding: 0x400000B0
    // Test aarch32_STRH_r_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: W=0, Rn=0, Rt=0, P=0, U=0, Rm=0, cond=4
    let encoding: u32 = 0x400000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_r_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_strh_r_a1_a_special_cond_5_condition_pl_176_500000b0() {
    // Encoding: 0x500000B0
    // Test aarch32_STRH_r_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: U=0, P=0, W=0, Rn=0, Rt=0, cond=5, Rm=0
    let encoding: u32 = 0x500000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_r_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_strh_r_a1_a_special_cond_6_condition_vs_176_600000b0() {
    // Encoding: 0x600000B0
    // Test aarch32_STRH_r_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: Rm=0, cond=6, Rt=0, Rn=0, U=0, P=0, W=0
    let encoding: u32 = 0x600000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_r_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_strh_r_a1_a_special_cond_7_condition_vc_176_700000b0() {
    // Encoding: 0x700000B0
    // Test aarch32_STRH_r_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: P=0, Rt=0, cond=7, U=0, W=0, Rn=0, Rm=0
    let encoding: u32 = 0x700000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_r_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_strh_r_a1_a_special_cond_8_condition_hi_176_800000b0() {
    // Encoding: 0x800000B0
    // Test aarch32_STRH_r_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: W=0, U=0, cond=8, Rn=0, Rt=0, P=0, Rm=0
    let encoding: u32 = 0x800000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_r_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_strh_r_a1_a_special_cond_9_condition_ls_176_900000b0() {
    // Encoding: 0x900000B0
    // Test aarch32_STRH_r_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: P=0, U=0, Rn=0, cond=9, Rt=0, W=0, Rm=0
    let encoding: u32 = 0x900000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_r_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_strh_r_a1_a_special_cond_10_condition_ge_176_a00000b0() {
    // Encoding: 0xA00000B0
    // Test aarch32_STRH_r_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: P=0, Rn=0, U=0, Rt=0, Rm=0, cond=10, W=0
    let encoding: u32 = 0xA00000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_r_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_strh_r_a1_a_special_cond_11_condition_lt_176_b00000b0() {
    // Encoding: 0xB00000B0
    // Test aarch32_STRH_r_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: cond=11, P=0, U=0, Rn=0, Rt=0, Rm=0, W=0
    let encoding: u32 = 0xB00000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_r_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_strh_r_a1_a_special_cond_12_condition_gt_176_c00000b0() {
    // Encoding: 0xC00000B0
    // Test aarch32_STRH_r_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: Rm=0, P=0, W=0, U=0, Rn=0, Rt=0, cond=12
    let encoding: u32 = 0xC00000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_r_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_strh_r_a1_a_special_cond_13_condition_le_176_d00000b0() {
    // Encoding: 0xD00000B0
    // Test aarch32_STRH_r_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: U=0, P=0, Rn=0, Rt=0, cond=13, Rm=0, W=0
    let encoding: u32 = 0xD00000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_r_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_strh_r_a1_a_special_cond_14_condition_al_176_e00000b0() {
    // Encoding: 0xE00000B0
    // Test aarch32_STRH_r_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: P=0, U=0, cond=14, Rm=0, W=0, Rn=0, Rt=0
    let encoding: u32 = 0xE00000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_r_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_strh_r_a1_a_special_cond_15_condition_nv_176_f00000b0() {
    // Encoding: 0xF00000B0
    // Test aarch32_STRH_r_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: U=0, cond=15, Rt=0, W=0, Rn=0, Rm=0, P=0
    let encoding: u32 = 0xF00000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRH_r_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strh_r_a1_a_invalid_0_b0_000000b0() {
    // Encoding: 0x000000B0
    // Test aarch32_STRH_r_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }
    // ISET: A32
    // Fields: Rm=0, W=0, U=0, cond=0, Rn=0, P=0, Rt=0
    let encoding: u32 = 0x000000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STRH_r_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strh_r_a1_a_invalid_1_b0_000000b0() {
    // Encoding: 0x000000B0
    // Test aarch32_STRH_r_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: cond=0, U=0, W=0, Rn=0, Rm=0, Rt=0, P=0
    let encoding: u32 = 0x000000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STRH_r_A1_A
/// ASL: `Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"wback\" }), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }) } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strh_r_a1_a_invalid_2_b0_000000b0() {
    // Encoding: 0x000000B0
    // Test aarch32_STRH_r_A1_A invalid encoding: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) } }
    // ISET: A32
    // Fields: Rm=0, U=0, P=0, cond=0, Rn=0, Rt=0, W=0
    let encoding: u32 = 0x000000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STRH_r_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strh_r_a1_a_invalid_3_b0_000000b0() {
    // Encoding: 0x000000B0
    // Test aarch32_STRH_r_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Rt=0, U=0, cond=0, W=0, P=0, Rm=0, Rn=0
    let encoding: u32 = 0x000000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STRH_r_T1_A
/// ASL: `field Rm 22 +: 3`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_strh_r_t1_a_field_rm_0_min_0_52000000() {
    // Thumb encoding (32): 0x52000000
    // Test aarch32_STRH_r_T1_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: Rm=0, Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x52000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_r_T1_A
/// ASL: `field Rm 22 +: 3`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_strh_r_t1_a_field_rm_1_poweroftwo_0_52400000() {
    // Thumb encoding (32): 0x52400000
    // Test aarch32_STRH_r_T1_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, Rm=1, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x52400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_r_T1_A
/// ASL: `field Rn 19 +: 3`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_strh_r_t1_a_field_rn_0_min_0_52000000() {
    // Thumb encoding (32): 0x52000000
    // Test aarch32_STRH_r_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rt=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x52000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_r_T1_A
/// ASL: `field Rn 19 +: 3`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_strh_r_t1_a_field_rn_1_poweroftwo_0_52080000() {
    // Thumb encoding (32): 0x52080000
    // Test aarch32_STRH_r_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=1, Rt=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x52080000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_r_T1_A
/// ASL: `field Rt 16 +: 3`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_strh_r_t1_a_field_rt_0_min_0_52000000() {
    // Thumb encoding (32): 0x52000000
    // Test aarch32_STRH_r_T1_A field Rt = 0 (Min)
    // ISET: T32
    // Fields: Rm=0, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x52000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_r_T1_A
/// ASL: `field Rt 16 +: 3`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_strh_r_t1_a_field_rt_1_poweroftwo_0_52010000() {
    // Thumb encoding (32): 0x52010000
    // Test aarch32_STRH_r_T1_A field Rt = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=1, Rm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x52010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_r_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch32_strh_r_t1_a_combo_0_0_52000000() {
    // Thumb encoding (32): 0x52000000
    // Test aarch32_STRH_r_T1_A field combination: Rm=0, Rn=0, Rt=0
    // ISET: T32
    // Fields: Rt=0, Rm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x52000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_r_T1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_aarch32_strh_r_t1_a_combo_1_0_52400000() {
    // Thumb encoding (32): 0x52400000
    // Test aarch32_STRH_r_T1_A field combination: Rm=1, Rn=0, Rt=0
    // ISET: T32
    // Fields: Rt=0, Rm=1, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x52400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_r_T1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_strh_r_t1_a_combo_2_0_52000000() {
    // Thumb encoding (32): 0x52000000
    // Test aarch32_STRH_r_T1_A field combination: Rm=0, Rn=0, Rt=0
    // ISET: T32
    // Fields: Rm=0, Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x52000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_r_T1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_strh_r_t1_a_combo_3_0_52080000() {
    // Thumb encoding (32): 0x52080000
    // Test aarch32_STRH_r_T1_A field combination: Rm=0, Rn=1, Rt=0
    // ISET: T32
    // Fields: Rm=0, Rn=1, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x52080000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_r_T1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=0 (register index 0 (first register))
#[test]
fn test_aarch32_strh_r_t1_a_combo_4_0_52000000() {
    // Thumb encoding (32): 0x52000000
    // Test aarch32_STRH_r_T1_A field combination: Rm=0, Rn=0, Rt=0
    // ISET: T32
    // Fields: Rn=0, Rt=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x52000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_r_T1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=1 (register index 1 (second register))
#[test]
fn test_aarch32_strh_r_t1_a_combo_5_0_52010000() {
    // Thumb encoding (32): 0x52010000
    // Test aarch32_STRH_r_T1_A field combination: Rm=0, Rn=0, Rt=1
    // ISET: T32
    // Fields: Rm=0, Rn=0, Rt=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x52010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_r_T1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (same register test (reg=1)), Rn=1 (same register test (reg=1))
#[test]
fn test_aarch32_strh_r_t1_a_combo_6_0_52480000() {
    // Thumb encoding (32): 0x52480000
    // Test aarch32_STRH_r_T1_A field combination: Rm=1, Rn=1, Rt=0
    // ISET: T32
    // Fields: Rn=1, Rm=1, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x52480000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_r_T1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (same register test (reg=31)), Rn=31 (same register test (reg=31))
#[test]
fn test_aarch32_strh_r_t1_a_combo_7_0_53f80000() {
    // Thumb encoding (32): 0x53F80000
    // Test aarch32_STRH_r_T1_A field combination: Rm=31, Rn=31, Rt=0
    // ISET: T32
    // Fields: Rt=0, Rm=31, Rn=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x53F80000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_r_T1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (same register test (reg=1)), Rt=1 (same register test (reg=1))
#[test]
fn test_aarch32_strh_r_t1_a_combo_8_0_52410000() {
    // Thumb encoding (32): 0x52410000
    // Test aarch32_STRH_r_T1_A field combination: Rm=1, Rn=0, Rt=1
    // ISET: T32
    // Fields: Rt=1, Rn=0, Rm=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x52410000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_r_T1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (same register test (reg=31)), Rt=31 (same register test (reg=31))
#[test]
fn test_aarch32_strh_r_t1_a_combo_9_0_53c70000() {
    // Thumb encoding (32): 0x53C70000
    // Test aarch32_STRH_r_T1_A field combination: Rm=31, Rn=0, Rt=31
    // ISET: T32
    // Fields: Rm=31, Rt=31, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x53C70000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_r_T1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rt=1 (same register test (reg=1))
#[test]
fn test_aarch32_strh_r_t1_a_combo_10_0_52090000() {
    // Thumb encoding (32): 0x52090000
    // Test aarch32_STRH_r_T1_A field combination: Rm=0, Rn=1, Rt=1
    // ISET: T32
    // Fields: Rn=1, Rm=0, Rt=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x52090000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_r_T1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rt=31 (same register test (reg=31))
#[test]
fn test_aarch32_strh_r_t1_a_combo_11_0_523f0000() {
    // Thumb encoding (32): 0x523F0000
    // Test aarch32_STRH_r_T1_A field combination: Rm=0, Rn=31, Rt=31
    // ISET: T32
    // Fields: Rt=31, Rm=0, Rn=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x523F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_r_T2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_strh_r_t2_a_field_rn_0_min_0_f8200000() {
    // Thumb encoding (32): 0xF8200000
    // Test aarch32_STRH_r_T2_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rt=0, Rm=0, Rn=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_r_T2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_strh_r_t2_a_field_rn_1_poweroftwo_0_f8210000() {
    // Thumb encoding (32): 0xF8210000
    // Test aarch32_STRH_r_T2_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=1, Rt=0, imm2=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8210000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_r_T2_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_strh_r_t2_a_field_rt_0_min_0_f8200000() {
    // Thumb encoding (32): 0xF8200000
    // Test aarch32_STRH_r_T2_A field Rt = 0 (Min)
    // ISET: T32
    // Fields: Rt=0, Rn=0, imm2=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_r_T2_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_strh_r_t2_a_field_rt_1_poweroftwo_0_f8201000() {
    // Thumb encoding (32): 0xF8201000
    // Test aarch32_STRH_r_T2_A field Rt = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=0, Rn=0, Rt=1, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8201000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_r_T2_A
/// ASL: `field imm2 4 +: 2`
/// Requirement: FieldBoundary { field: "imm2", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_strh_r_t2_a_field_imm2_0_zero_0_f8200000() {
    // Thumb encoding (32): 0xF8200000
    // Test aarch32_STRH_r_T2_A field imm2 = 0 (Zero)
    // ISET: T32
    // Fields: imm2=0, Rm=0, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_r_T2_A
/// ASL: `field imm2 4 +: 2`
/// Requirement: FieldBoundary { field: "imm2", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_strh_r_t2_a_field_imm2_1_poweroftwo_0_f8200010() {
    // Thumb encoding (32): 0xF8200010
    // Test aarch32_STRH_r_T2_A field imm2 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Rm=0, Rt=0, imm2=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8200010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_r_T2_A
/// ASL: `field imm2 4 +: 2`
/// Requirement: FieldBoundary { field: "imm2", value: 3, boundary: Max }
/// maximum immediate (3)
#[test]
fn test_aarch32_strh_r_t2_a_field_imm2_3_max_0_f8200030() {
    // Thumb encoding (32): 0xF8200030
    // Test aarch32_STRH_r_T2_A field imm2 = 3 (Max)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm2=3, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8200030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_r_T2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_strh_r_t2_a_field_rm_0_min_0_f8200000() {
    // Thumb encoding (32): 0xF8200000
    // Test aarch32_STRH_r_T2_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: Rm=0, Rn=0, Rt=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_r_T2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_strh_r_t2_a_field_rm_1_poweroftwo_0_f8200001() {
    // Thumb encoding (32): 0xF8200001
    // Test aarch32_STRH_r_T2_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Rm=1, Rt=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8200001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_r_T2_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_strh_r_t2_a_combo_0_0_f8200000() {
    // Thumb encoding (32): 0xF8200000
    // Test aarch32_STRH_r_T2_A field combination: Rn=0, Rt=0, imm2=0, Rm=0
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm2=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_r_T2_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_strh_r_t2_a_combo_1_0_f8210000() {
    // Thumb encoding (32): 0xF8210000
    // Test aarch32_STRH_r_T2_A field combination: Rn=1, Rt=0, imm2=0, Rm=0
    // ISET: T32
    // Fields: Rm=0, Rn=1, Rt=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8210000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_r_T2_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=0 (register index 0 (first register))
#[test]
fn test_aarch32_strh_r_t2_a_combo_2_0_f8200000() {
    // Thumb encoding (32): 0xF8200000
    // Test aarch32_STRH_r_T2_A field combination: Rn=0, Rt=0, imm2=0, Rm=0
    // ISET: T32
    // Fields: Rt=0, imm2=0, Rn=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_r_T2_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=1 (register index 1 (second register))
#[test]
fn test_aarch32_strh_r_t2_a_combo_3_0_f8201000() {
    // Thumb encoding (32): 0xF8201000
    // Test aarch32_STRH_r_T2_A field combination: Rn=0, Rt=1, imm2=0, Rm=0
    // ISET: T32
    // Fields: imm2=0, Rm=0, Rn=0, Rt=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8201000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_r_T2_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm2=0 (immediate value 0)
#[test]
fn test_aarch32_strh_r_t2_a_combo_4_0_f8200000() {
    // Thumb encoding (32): 0xF8200000
    // Test aarch32_STRH_r_T2_A field combination: Rn=0, Rt=0, imm2=0, Rm=0
    // ISET: T32
    // Fields: Rn=0, Rm=0, Rt=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_r_T2_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm2=1 (immediate value 1)
#[test]
fn test_aarch32_strh_r_t2_a_combo_5_0_f8200010() {
    // Thumb encoding (32): 0xF8200010
    // Test aarch32_STRH_r_T2_A field combination: Rn=0, Rt=0, imm2=1, Rm=0
    // ISET: T32
    // Fields: imm2=1, Rn=0, Rm=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8200010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_r_T2_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm2=3 (maximum immediate (3))
#[test]
fn test_aarch32_strh_r_t2_a_combo_6_0_f8200030() {
    // Thumb encoding (32): 0xF8200030
    // Test aarch32_STRH_r_T2_A field combination: Rn=0, Rt=0, imm2=3, Rm=0
    // ISET: T32
    // Fields: Rt=0, imm2=3, Rn=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8200030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_r_T2_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch32_strh_r_t2_a_combo_7_0_f8200000() {
    // Thumb encoding (32): 0xF8200000
    // Test aarch32_STRH_r_T2_A field combination: Rn=0, Rt=0, imm2=0, Rm=0
    // ISET: T32
    // Fields: Rm=0, imm2=0, Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_r_T2_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_aarch32_strh_r_t2_a_combo_8_0_f8200001() {
    // Thumb encoding (32): 0xF8200001
    // Test aarch32_STRH_r_T2_A field combination: Rn=0, Rt=0, imm2=0, Rm=1
    // ISET: T32
    // Fields: imm2=0, Rn=0, Rm=1, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8200001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_r_T2_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rt=1 (same register test (reg=1))
#[test]
fn test_aarch32_strh_r_t2_a_combo_9_0_f8211000() {
    // Thumb encoding (32): 0xF8211000
    // Test aarch32_STRH_r_T2_A field combination: Rn=1, Rt=1, imm2=0, Rm=0
    // ISET: T32
    // Fields: Rm=0, imm2=0, Rt=1, Rn=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8211000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_r_T2_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rt=31 (same register test (reg=31))
#[test]
fn test_aarch32_strh_r_t2_a_combo_10_0_f82ff000() {
    // Thumb encoding (32): 0xF82FF000
    // Test aarch32_STRH_r_T2_A field combination: Rn=31, Rt=31, imm2=0, Rm=0
    // ISET: T32
    // Fields: imm2=0, Rm=0, Rn=31, Rt=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF82FF000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_r_T2_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rm=1 (same register test (reg=1))
#[test]
fn test_aarch32_strh_r_t2_a_combo_11_0_f8210001() {
    // Thumb encoding (32): 0xF8210001
    // Test aarch32_STRH_r_T2_A field combination: Rn=1, Rt=0, imm2=0, Rm=1
    // ISET: T32
    // Fields: Rn=1, imm2=0, Rt=0, Rm=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8210001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_r_T2_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rm=31 (same register test (reg=31))
#[test]
fn test_aarch32_strh_r_t2_a_combo_12_0_f82f000f() {
    // Thumb encoding (32): 0xF82F000F
    // Test aarch32_STRH_r_T2_A field combination: Rn=31, Rt=0, imm2=0, Rm=31
    // ISET: T32
    // Fields: Rt=0, Rn=31, Rm=31, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF82F000F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_r_T2_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=1 (same register test (reg=1)), Rm=1 (same register test (reg=1))
#[test]
fn test_aarch32_strh_r_t2_a_combo_13_0_f8201001() {
    // Thumb encoding (32): 0xF8201001
    // Test aarch32_STRH_r_T2_A field combination: Rn=0, Rt=1, imm2=0, Rm=1
    // ISET: T32
    // Fields: Rn=0, Rt=1, imm2=0, Rm=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8201001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_r_T2_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=31 (same register test (reg=31)), Rm=31 (same register test (reg=31))
#[test]
fn test_aarch32_strh_r_t2_a_combo_14_0_f820f00f() {
    // Thumb encoding (32): 0xF820F00F
    // Test aarch32_STRH_r_T2_A field combination: Rn=0, Rt=31, imm2=0, Rm=31
    // ISET: T32
    // Fields: imm2=0, Rn=0, Rt=31, Rm=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF820F00F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRH_r_T2_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rn" }), rhs: LitBits([true, true, true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Rn\" }), rhs: LitBits([true, true, true, true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_strh_r_t2_a_invalid_0_0_f8200000() {
    // Thumb encoding (32): 0xF8200000
    // Test aarch32_STRH_r_T2_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rn" }), rhs: LitBits([true, true, true, true]) }
    // ISET: T32
    // Fields: Rt=0, Rm=0, imm2=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_STRH_r_T2_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_strh_r_t2_a_invalid_1_0_f8200000() {
    // Thumb encoding (32): 0xF8200000
    // Test aarch32_STRH_r_T2_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: imm2=0, Rn=0, Rm=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_STRH_r_T2_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strh_r_t2_a_invalid_2_0_f8200000() {
    // Thumb encoding (32): 0xF8200000
    // Test aarch32_STRH_r_T2_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }
    // ISET: T32
    // Fields: Rn=0, imm2=0, Rt=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8200000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_STRH_r_T2_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strh_r_t2_a_invalid_3_0_f8200000() {
    // Thumb encoding (32): 0xF8200000
    // Test aarch32_STRH_r_T2_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rm=0, Rt=0, Rn=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8200000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_STRH_r_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple multiply (32)
#[test]
fn test_aarch32_strh_r_a1_a_mul_oracle_32_0_1b027c20() {
    // Test MUL 32-bit: simple multiply (oracle)
    // Encoding: 0x1B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x2);
    set_w(&mut cpu, 2, 0x3);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6, "W0 should be 0x00000006");
}

/// Provenance: aarch32_STRH_r_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple multiply (64)
#[test]
fn test_aarch32_strh_r_a1_a_mul_oracle_64_0_9b027c20() {
    // Test MUL 64-bit: simple multiply (oracle)
    // Encoding: 0x9B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3);
    set_w(&mut cpu, 1, 0x2);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6, "X0 should be 0x0000000000000006");
}

/// Provenance: aarch32_STRH_r_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// multiply by zero (32)
#[test]
fn test_aarch32_strh_r_a1_a_mul_oracle_32_1_1b027c20() {
    // Test MUL 32-bit: multiply by zero (oracle)
    // Encoding: 0x1B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x64);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_STRH_r_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// multiply by zero (64)
#[test]
fn test_aarch32_strh_r_a1_a_mul_oracle_64_1_9b027c20() {
    // Test MUL 64-bit: multiply by zero (oracle)
    // Encoding: 0x9B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x64);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_STRH_r_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// multiply by one (32)
#[test]
fn test_aarch32_strh_r_a1_a_mul_oracle_32_2_1b027c20() {
    // Test MUL 32-bit: multiply by one (oracle)
    // Encoding: 0x1B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_STRH_r_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// multiply by one (64)
#[test]
fn test_aarch32_strh_r_a1_a_mul_oracle_64_2_9b027c20() {
    // Test MUL 64-bit: multiply by one (oracle)
    // Encoding: 0x9B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x0000000000000001");
}

/// Provenance: aarch32_STRH_r_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// 16-bit max * 16-bit max (32)
#[test]
fn test_aarch32_strh_r_a1_a_mul_oracle_32_3_1b027c20() {
    // Test MUL 32-bit: 16-bit max * 16-bit max (oracle)
    // Encoding: 0x1B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFF);
    set_w(&mut cpu, 2, 0xFFFF);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFE0001, "W0 should be 0xFFFE0001");
}

/// Provenance: aarch32_STRH_r_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// 16-bit max * 16-bit max (64)
#[test]
fn test_aarch32_strh_r_a1_a_mul_oracle_64_3_9b027c20() {
    // Test MUL 64-bit: 16-bit max * 16-bit max (oracle)
    // Encoding: 0x9B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFF);
    set_w(&mut cpu, 2, 0xFFFF);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFE0001, "X0 should be 0x00000000FFFE0001");
}

/// Provenance: aarch32_STRH_r_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift-like multiply (32)
#[test]
fn test_aarch32_strh_r_a1_a_mul_oracle_32_4_1b027c20() {
    // Test MUL 32-bit: shift-like multiply (oracle)
    // Encoding: 0x1B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x2468ACF0, "W0 should be 0x2468ACF0");
}

/// Provenance: aarch32_STRH_r_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift-like multiply (64)
#[test]
fn test_aarch32_strh_r_a1_a_mul_oracle_64_4_9b027c20() {
    // Test MUL 64-bit: shift-like multiply (oracle)
    // Encoding: 0x9B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x2468ACF0, "X0 should be 0x000000002468ACF0");
}

/// Provenance: aarch32_STRH_r_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// larger values (32)
#[test]
fn test_aarch32_strh_r_a1_a_mul_oracle_32_5_1b027c20() {
    // Test MUL 32-bit: larger values (oracle)
    // Encoding: 0x1B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0xC8);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4E20, "W0 should be 0x00004E20");
}

/// Provenance: aarch32_STRH_r_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// larger values (64)
#[test]
fn test_aarch32_strh_r_a1_a_mul_oracle_64_5_9b027c20() {
    // Test MUL 64-bit: larger values (oracle)
    // Encoding: 0x9B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0xC8);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4E20, "X0 should be 0x0000000000004E20");
}

/// Provenance: aarch32_STRH_r_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// 32-bit overflow (32)
#[test]
fn test_aarch32_strh_r_a1_a_mul_oracle_32_6_1b027c20() {
    // Test MUL 32-bit: 32-bit overflow (oracle)
    // Encoding: 0x1B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_STRH_r_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// 32-bit overflow (64)
#[test]
fn test_aarch32_strh_r_a1_a_mul_oracle_64_6_9b027c20() {
    // Test MUL 64-bit: 32-bit overflow (oracle)
    // Encoding: 0x9B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0xFFFFFFFE00000001");
}

/// Provenance: aarch32_STRH_r_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// prime numbers (32)
#[test]
fn test_aarch32_strh_r_a1_a_mul_oracle_32_7_1b027c20() {
    // Test MUL 32-bit: prime numbers (oracle)
    // Encoding: 0x1B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7);
    set_w(&mut cpu, 2, 0xB);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4D, "W0 should be 0x0000004D");
}

/// Provenance: aarch32_STRH_r_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// prime numbers (64)
#[test]
fn test_aarch32_strh_r_a1_a_mul_oracle_64_7_9b027c20() {
    // Test MUL 64-bit: prime numbers (oracle)
    // Encoding: 0x9B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xB);
    set_w(&mut cpu, 1, 0x7);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4D, "X0 should be 0x000000000000004D");
}

/// Provenance: aarch32_STRH_r_A1_A
/// ASL: `MUL R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple values
#[test]
fn test_aarch32_strh_r_a1_a_a32_mul_0_0000f291() {
    // Test A32 MUL: simple values (oracle)
    // Encoding: 0x0000F291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x32);
    let encoding: u32 = 0x0000F291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1388, "R0 should be 0x00001388");
}

/// Provenance: aarch32_STRH_r_A1_A
/// ASL: `MUL R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero values
#[test]
fn test_aarch32_strh_r_a1_a_a32_mul_1_0000f291() {
    // Test A32 MUL: zero values (oracle)
    // Encoding: 0x0000F291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x0000F291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_STRH_r_A1_A
/// ASL: `MUL R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max value
#[test]
fn test_aarch32_strh_r_a1_a_a32_mul_2_0000f291() {
    // Test A32 MUL: max value (oracle)
    // Encoding: 0x0000F291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x0000F291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "R0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_STRH_r_A1_A
/// ASL: `MUL R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set
#[test]
fn test_aarch32_strh_r_a1_a_a32_mul_3_0000f291() {
    // Test A32 MUL: MSB set (oracle)
    // Encoding: 0x0000F291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x80000000);
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0x0000F291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_STRH_r_A1_A
/// ASL: `MUL R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// mixed pattern
#[test]
fn test_aarch32_strh_r_a1_a_a32_mul_4_0000f291() {
    // Test A32 MUL: mixed pattern (oracle)
    // Encoding: 0x0000F291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x9ABCDEF0);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u32 = 0x0000F291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x242D2080, "R0 should be 0x242D2080");
}

/// Provenance: aarch32_STRH_r_A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_strh_r_a1_a_store_0_000100b0() {
    // Test aarch32_STRH_r_A1_A memory store: 8 bytes
    // Encoding: 0x000100B0
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0x000100B0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_STRH_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 0 (32)
#[test]
fn test_aarch32_strh_r_t1_a_lslv_oracle_32_0_52020020() {
    // Test LSLV 32-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x12345678, "W0 should be 0x12345678");
}

/// Provenance: aarch32_STRH_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 0 (64)
#[test]
fn test_aarch32_strh_r_t1_a_lslv_oracle_64_0_d2020020() {
    // Test LSLV 64-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x12345678, "X0 should be 0x0000000012345678");
}

/// Provenance: aarch32_STRH_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4 (32)
#[test]
fn test_aarch32_strh_r_t1_a_lslv_oracle_32_1_52020020() {
    // Test LSLV 32-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x4);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x23456780, "W0 should be 0x23456780");
}

/// Provenance: aarch32_STRH_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 4 (64)
#[test]
fn test_aarch32_strh_r_t1_a_lslv_oracle_64_1_d2020020() {
    // Test LSLV 64-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x4);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x23456780, "X0 should be 0x0000000123456780");
}

/// Provenance: aarch32_STRH_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 8 (32)
#[test]
fn test_aarch32_strh_r_t1_a_lslv_oracle_32_2_52020020() {
    // Test LSLV 32-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x8);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x34567800, "W0 should be 0x34567800");
}

/// Provenance: aarch32_STRH_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 8 (64)
#[test]
fn test_aarch32_strh_r_t1_a_lslv_oracle_64_2_d2020020() {
    // Test LSLV 64-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x8);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x34567800, "X0 should be 0x0000001234567800");
}

/// Provenance: aarch32_STRH_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1 (32)
#[test]
fn test_aarch32_strh_r_t1_a_lslv_oracle_32_3_52020020() {
    // Test LSLV 32-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_STRH_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// MSB set, shift 1 (64)
#[test]
fn test_aarch32_strh_r_t1_a_lslv_oracle_64_3_d2020020() {
    // Test LSLV 64-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_STRH_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// LSB set, max shift (32)
#[test]
fn test_aarch32_strh_r_t1_a_lslv_oracle_32_4_52020020() {
    // Test LSLV 32-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x3F);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "W0 should be 0x80000000");
}

/// Provenance: aarch32_STRH_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// LSB set, max shift (64)
#[test]
fn test_aarch32_strh_r_t1_a_lslv_oracle_64_4_d2020020() {
    // Test LSLV 64-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x3F);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x8000000000000000");
}

/// Provenance: aarch32_STRH_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// all ones, shift 32 (32)
#[test]
fn test_aarch32_strh_r_t1_a_lslv_oracle_32_5_52020020() {
    // Test LSLV 32-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x20);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "W0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_STRH_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// all ones, shift 32 (64)
#[test]
fn test_aarch32_strh_r_t1_a_lslv_oracle_64_5_d2020020() {
    // Test LSLV 64-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x20);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0xFFFFFFFF00000000");
}

/// Provenance: aarch32_STRH_r_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// no shift
#[test]
fn test_aarch32_strh_r_t1_a_t16_oracle_0_52880000() {
    // Test T16 LSLS: no shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_STRH_r_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4
#[test]
fn test_aarch32_strh_r_t1_a_t16_oracle_1_52880000() {
    // Test T16 LSLS: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x4);
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF0, "R0 should be 0x00000FF0");
}

/// Provenance: aarch32_STRH_r_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1
#[test]
fn test_aarch32_strh_r_t1_a_t16_oracle_2_52880000() {
    // Test T16 LSLS: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_STRH_r_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift to MSB
#[test]
fn test_aarch32_strh_r_t1_a_t16_oracle_3_52880000() {
    // Test T16 LSLS: shift to MSB (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x1F);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "R0 should be 0x80000000");
}

/// Provenance: aarch32_STRH_r_T1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_strh_r_t1_a_store_0_52080000() {
    // Test aarch32_STRH_r_T1_A memory store: 8 bytes
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_STRH_r_T2_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_strh_r_t2_a_store_0_f8210000() {
    // Test aarch32_STRH_r_T2_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0xF8210000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// aarch32_STRD_i_A Tests
// ============================================================================

/// Provenance: aarch32_STRD_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_strd_i_a1_a_field_cond_0_min_f0_004000f0() {
    // Encoding: 0x004000F0
    // Test aarch32_STRD_i_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: cond=0, P=0, imm4L=0, U=0, W=0, Rt=0, Rn=0, imm4H=0
    let encoding: u32 = 0x004000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_strd_i_a1_a_field_cond_1_poweroftwo_f0_104000f0() {
    // Encoding: 0x104000F0
    // Test aarch32_STRD_i_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, Rn=0, Rt=0, imm4L=0, cond=1, P=0, W=0, imm4H=0
    let encoding: u32 = 0x104000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_strd_i_a1_a_field_cond_2_poweroftwo_f0_204000f0() {
    // Encoding: 0x204000F0
    // Test aarch32_STRD_i_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4L=0, imm4H=0, U=0, Rt=0, P=0, cond=2, W=0, Rn=0
    let encoding: u32 = 0x204000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_strd_i_a1_a_field_cond_3_poweroftwo_f0_304000f0() {
    // Encoding: 0x304000F0
    // Test aarch32_STRD_i_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, P=0, Rn=0, cond=3, U=0, imm4L=0, imm4H=0, W=0
    let encoding: u32 = 0x304000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_strd_i_a1_a_field_cond_4_poweroftwo_f0_404000f0() {
    // Encoding: 0x404000F0
    // Test aarch32_STRD_i_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, cond=4, Rn=0, U=0, Rt=0, imm4H=0, W=0, imm4L=0
    let encoding: u32 = 0x404000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_strd_i_a1_a_field_cond_5_poweroftwo_f0_504000f0() {
    // Encoding: 0x504000F0
    // Test aarch32_STRD_i_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, Rn=0, cond=5, P=0, Rt=0, imm4H=0, U=0, imm4L=0
    let encoding: u32 = 0x504000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_strd_i_a1_a_field_cond_6_poweroftwo_f0_604000f0() {
    // Encoding: 0x604000F0
    // Test aarch32_STRD_i_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=6, U=0, W=0, Rt=0, Rn=0, imm4H=0, imm4L=0, P=0
    let encoding: u32 = 0x604000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_strd_i_a1_a_field_cond_7_poweroftwo_f0_704000f0() {
    // Encoding: 0x704000F0
    // Test aarch32_STRD_i_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=7, imm4H=0, U=0, W=0, imm4L=0, Rt=0, Rn=0, P=0
    let encoding: u32 = 0x704000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_strd_i_a1_a_field_cond_8_poweroftwo_f0_804000f0() {
    // Encoding: 0x804000F0
    // Test aarch32_STRD_i_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=8, W=0, Rn=0, imm4L=0, P=0, Rt=0, U=0, imm4H=0
    let encoding: u32 = 0x804000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_strd_i_a1_a_field_cond_9_poweroftwo_f0_904000f0() {
    // Encoding: 0x904000F0
    // Test aarch32_STRD_i_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, U=0, P=0, cond=9, imm4H=0, W=0, imm4L=0, Rn=0
    let encoding: u32 = 0x904000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_strd_i_a1_a_field_cond_10_poweroftwo_f0_a04000f0() {
    // Encoding: 0xA04000F0
    // Test aarch32_STRD_i_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, cond=10, W=0, P=0, Rn=0, Rt=0, imm4L=0, imm4H=0
    let encoding: u32 = 0xA04000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_strd_i_a1_a_field_cond_11_poweroftwo_f0_b04000f0() {
    // Encoding: 0xB04000F0
    // Test aarch32_STRD_i_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4H=0, Rt=0, imm4L=0, U=0, P=0, cond=11, W=0, Rn=0
    let encoding: u32 = 0xB04000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_strd_i_a1_a_field_cond_12_poweroftwo_f0_c04000f0() {
    // Encoding: 0xC04000F0
    // Test aarch32_STRD_i_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, cond=12, W=0, U=0, Rn=0, imm4H=0, Rt=0, imm4L=0
    let encoding: u32 = 0xC04000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_strd_i_a1_a_field_cond_13_poweroftwo_f0_d04000f0() {
    // Encoding: 0xD04000F0
    // Test aarch32_STRD_i_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, Rn=0, Rt=0, P=0, cond=13, imm4L=0, imm4H=0, U=0
    let encoding: u32 = 0xD04000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_strd_i_a1_a_field_cond_14_poweroftwo_f0_e04000f0() {
    // Encoding: 0xE04000F0
    // Test aarch32_STRD_i_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4L=0, W=0, imm4H=0, U=0, cond=14, P=0, Rn=0, Rt=0
    let encoding: u32 = 0xE04000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_strd_i_a1_a_field_cond_15_max_f0_f04000f0() {
    // Encoding: 0xF04000F0
    // Test aarch32_STRD_i_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: P=0, imm4H=0, imm4L=0, Rn=0, U=0, cond=15, W=0, Rt=0
    let encoding: u32 = 0xF04000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_i_A1_A
/// ASL: `field P 24 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_strd_i_a1_a_field_p_0_min_f0_004000f0() {
    // Encoding: 0x004000F0
    // Test aarch32_STRD_i_A1_A field P = 0 (Min)
    // ISET: A32
    // Fields: imm4L=0, U=0, Rt=0, P=0, cond=0, W=0, imm4H=0, Rn=0
    let encoding: u32 = 0x004000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_i_A1_A
/// ASL: `field P 24 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_strd_i_a1_a_field_p_1_max_f0_014000f0() {
    // Encoding: 0x014000F0
    // Test aarch32_STRD_i_A1_A field P = 1 (Max)
    // ISET: A32
    // Fields: imm4L=0, Rt=0, U=0, imm4H=0, W=0, cond=0, Rn=0, P=1
    let encoding: u32 = 0x014000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_i_A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_strd_i_a1_a_field_u_0_min_f0_004000f0() {
    // Encoding: 0x004000F0
    // Test aarch32_STRD_i_A1_A field U = 0 (Min)
    // ISET: A32
    // Fields: cond=0, W=0, imm4L=0, P=0, imm4H=0, Rt=0, Rn=0, U=0
    let encoding: u32 = 0x004000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_i_A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_strd_i_a1_a_field_u_1_max_f0_00c000f0() {
    // Encoding: 0x00C000F0
    // Test aarch32_STRD_i_A1_A field U = 1 (Max)
    // ISET: A32
    // Fields: imm4L=0, W=0, Rt=0, U=1, cond=0, P=0, Rn=0, imm4H=0
    let encoding: u32 = 0x00C000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_i_A1_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_strd_i_a1_a_field_w_0_min_f0_004000f0() {
    // Encoding: 0x004000F0
    // Test aarch32_STRD_i_A1_A field W = 0 (Min)
    // ISET: A32
    // Fields: imm4H=0, U=0, imm4L=0, cond=0, W=0, Rn=0, P=0, Rt=0
    let encoding: u32 = 0x004000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_i_A1_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_strd_i_a1_a_field_w_1_max_f0_006000f0() {
    // Encoding: 0x006000F0
    // Test aarch32_STRD_i_A1_A field W = 1 (Max)
    // ISET: A32
    // Fields: U=0, Rt=0, imm4H=0, P=0, imm4L=0, cond=0, Rn=0, W=1
    let encoding: u32 = 0x006000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_i_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_strd_i_a1_a_field_rn_0_min_f0_004000f0() {
    // Encoding: 0x004000F0
    // Test aarch32_STRD_i_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: imm4H=0, W=0, cond=0, imm4L=0, Rn=0, U=0, P=0, Rt=0
    let encoding: u32 = 0x004000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_i_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_strd_i_a1_a_field_rn_1_poweroftwo_f0_004100f0() {
    // Encoding: 0x004100F0
    // Test aarch32_STRD_i_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4H=0, imm4L=0, U=0, W=0, Rn=1, Rt=0, cond=0, P=0
    let encoding: u32 = 0x004100F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_i_A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_strd_i_a1_a_field_rt_0_min_f0_004000f0() {
    // Encoding: 0x004000F0
    // Test aarch32_STRD_i_A1_A field Rt = 0 (Min)
    // ISET: A32
    // Fields: imm4L=0, P=0, Rn=0, U=0, Rt=0, imm4H=0, cond=0, W=0
    let encoding: u32 = 0x004000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_i_A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_strd_i_a1_a_field_rt_1_poweroftwo_f0_004010f0() {
    // Encoding: 0x004010F0
    // Test aarch32_STRD_i_A1_A field Rt = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, cond=0, U=0, Rn=0, W=0, imm4L=0, imm4H=0, Rt=1
    let encoding: u32 = 0x004010F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_i_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_strd_i_a1_a_field_imm4h_0_zero_f0_004000f0() {
    // Encoding: 0x004000F0
    // Test aarch32_STRD_i_A1_A field imm4H = 0 (Zero)
    // ISET: A32
    // Fields: Rt=0, cond=0, U=0, Rn=0, W=0, P=0, imm4H=0, imm4L=0
    let encoding: u32 = 0x004000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_i_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_strd_i_a1_a_field_imm4h_1_poweroftwo_f0_004001f0() {
    // Encoding: 0x004001F0
    // Test aarch32_STRD_i_A1_A field imm4H = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, U=0, Rn=0, W=0, Rt=0, cond=0, imm4L=0, imm4H=1
    let encoding: u32 = 0x004001F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_i_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_strd_i_a1_a_field_imm4h_3_poweroftwominusone_f0_004003f0() {
    // Encoding: 0x004003F0
    // Test aarch32_STRD_i_A1_A field imm4H = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm4L=0, Rt=0, P=0, cond=0, U=0, Rn=0, W=0, imm4H=3
    let encoding: u32 = 0x004003F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_i_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_strd_i_a1_a_field_imm4h_4_poweroftwo_f0_004004f0() {
    // Encoding: 0x004004F0
    // Test aarch32_STRD_i_A1_A field imm4H = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, P=0, Rn=0, imm4H=4, cond=0, U=0, Rt=0, imm4L=0
    let encoding: u32 = 0x004004F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_i_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_aarch32_strd_i_a1_a_field_imm4h_7_poweroftwominusone_f0_004007f0() {
    // Encoding: 0x004007F0
    // Test aarch32_STRD_i_A1_A field imm4H = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: P=0, cond=0, Rn=0, imm4L=0, imm4H=7, Rt=0, U=0, W=0
    let encoding: u32 = 0x004007F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_i_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_strd_i_a1_a_field_imm4h_8_poweroftwo_f0_004008f0() {
    // Encoding: 0x004008F0
    // Test aarch32_STRD_i_A1_A field imm4H = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4L=0, Rt=0, W=0, U=0, imm4H=8, Rn=0, cond=0, P=0
    let encoding: u32 = 0x004008F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_i_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_aarch32_strd_i_a1_a_field_imm4h_15_max_f0_00400ff0() {
    // Encoding: 0x00400FF0
    // Test aarch32_STRD_i_A1_A field imm4H = 15 (Max)
    // ISET: A32
    // Fields: imm4H=15, cond=0, W=0, P=0, U=0, Rn=0, Rt=0, imm4L=0
    let encoding: u32 = 0x00400FF0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_i_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_strd_i_a1_a_field_imm4l_0_zero_f0_004000f0() {
    // Encoding: 0x004000F0
    // Test aarch32_STRD_i_A1_A field imm4L = 0 (Zero)
    // ISET: A32
    // Fields: cond=0, Rn=0, U=0, imm4L=0, W=0, imm4H=0, Rt=0, P=0
    let encoding: u32 = 0x004000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_i_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_strd_i_a1_a_field_imm4l_1_poweroftwo_f0_004000f1() {
    // Encoding: 0x004000F1
    // Test aarch32_STRD_i_A1_A field imm4L = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, Rn=0, P=0, U=0, imm4L=1, W=0, imm4H=0, cond=0
    let encoding: u32 = 0x004000F1;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_i_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_strd_i_a1_a_field_imm4l_3_poweroftwominusone_f0_004000f3() {
    // Encoding: 0x004000F3
    // Test aarch32_STRD_i_A1_A field imm4L = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: P=0, imm4L=3, Rn=0, W=0, Rt=0, U=0, imm4H=0, cond=0
    let encoding: u32 = 0x004000F3;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_i_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_strd_i_a1_a_field_imm4l_4_poweroftwo_f0_004000f4() {
    // Encoding: 0x004000F4
    // Test aarch32_STRD_i_A1_A field imm4L = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=0, W=0, imm4L=4, P=0, U=0, imm4H=0
    let encoding: u32 = 0x004000F4;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_i_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_aarch32_strd_i_a1_a_field_imm4l_7_poweroftwominusone_f0_004000f7() {
    // Encoding: 0x004000F7
    // Test aarch32_STRD_i_A1_A field imm4L = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: W=0, Rt=0, imm4L=7, Rn=0, U=0, cond=0, imm4H=0, P=0
    let encoding: u32 = 0x004000F7;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_i_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_strd_i_a1_a_field_imm4l_8_poweroftwo_f0_004000f8() {
    // Encoding: 0x004000F8
    // Test aarch32_STRD_i_A1_A field imm4L = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, U=0, W=0, imm4L=8, Rn=0, imm4H=0, Rt=0, P=0
    let encoding: u32 = 0x004000F8;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_i_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_aarch32_strd_i_a1_a_field_imm4l_15_max_f0_004000ff() {
    // Encoding: 0x004000FF
    // Test aarch32_STRD_i_A1_A field imm4L = 15 (Max)
    // ISET: A32
    // Fields: cond=0, Rt=0, Rn=0, P=0, imm4H=0, imm4L=15, W=0, U=0
    let encoding: u32 = 0x004000FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_i_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_strd_i_a1_a_combo_0_f0_004000f0() {
    // Encoding: 0x004000F0
    // Test aarch32_STRD_i_A1_A field combination: cond=0, P=0, U=0, W=0, Rn=0, Rt=0, imm4H=0, imm4L=0
    // ISET: A32
    // Fields: imm4L=0, Rn=0, U=0, Rt=0, imm4H=0, P=0, W=0, cond=0
    let encoding: u32 = 0x004000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_i_A1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=1 (condition NE (not equal))
#[test]
fn test_aarch32_strd_i_a1_a_combo_1_f0_104000f0() {
    // Encoding: 0x104000F0
    // Test aarch32_STRD_i_A1_A field combination: cond=1, P=0, U=0, W=0, Rn=0, Rt=0, imm4H=0, imm4L=0
    // ISET: A32
    // Fields: W=0, imm4L=0, U=0, cond=1, imm4H=0, P=0, Rn=0, Rt=0
    let encoding: u32 = 0x104000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_i_A1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=2 (condition CS/HS (carry set))
#[test]
fn test_aarch32_strd_i_a1_a_combo_2_f0_204000f0() {
    // Encoding: 0x204000F0
    // Test aarch32_STRD_i_A1_A field combination: cond=2, P=0, U=0, W=0, Rn=0, Rt=0, imm4H=0, imm4L=0
    // ISET: A32
    // Fields: Rt=0, imm4H=0, U=0, W=0, Rn=0, P=0, imm4L=0, cond=2
    let encoding: u32 = 0x204000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_i_A1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=3 (condition CC/LO (carry clear))
#[test]
fn test_aarch32_strd_i_a1_a_combo_3_f0_304000f0() {
    // Encoding: 0x304000F0
    // Test aarch32_STRD_i_A1_A field combination: cond=3, P=0, U=0, W=0, Rn=0, Rt=0, imm4H=0, imm4L=0
    // ISET: A32
    // Fields: Rn=0, P=0, cond=3, U=0, Rt=0, imm4H=0, W=0, imm4L=0
    let encoding: u32 = 0x304000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_i_A1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=4 (condition MI (minus/negative))
#[test]
fn test_aarch32_strd_i_a1_a_combo_4_f0_404000f0() {
    // Encoding: 0x404000F0
    // Test aarch32_STRD_i_A1_A field combination: cond=4, P=0, U=0, W=0, Rn=0, Rt=0, imm4H=0, imm4L=0
    // ISET: A32
    // Fields: W=0, imm4L=0, U=0, cond=4, P=0, Rn=0, imm4H=0, Rt=0
    let encoding: u32 = 0x404000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_i_A1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=5 (condition PL (plus/positive))
#[test]
fn test_aarch32_strd_i_a1_a_combo_5_f0_504000f0() {
    // Encoding: 0x504000F0
    // Test aarch32_STRD_i_A1_A field combination: cond=5, P=0, U=0, W=0, Rn=0, Rt=0, imm4H=0, imm4L=0
    // ISET: A32
    // Fields: cond=5, imm4H=0, Rn=0, U=0, W=0, P=0, Rt=0, imm4L=0
    let encoding: u32 = 0x504000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_i_A1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=6 (condition VS (overflow set))
#[test]
fn test_aarch32_strd_i_a1_a_combo_6_f0_604000f0() {
    // Encoding: 0x604000F0
    // Test aarch32_STRD_i_A1_A field combination: cond=6, P=0, U=0, W=0, Rn=0, Rt=0, imm4H=0, imm4L=0
    // ISET: A32
    // Fields: W=0, P=0, U=0, cond=6, Rn=0, imm4L=0, Rt=0, imm4H=0
    let encoding: u32 = 0x604000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_i_A1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=7 (condition VC (overflow clear))
#[test]
fn test_aarch32_strd_i_a1_a_combo_7_f0_704000f0() {
    // Encoding: 0x704000F0
    // Test aarch32_STRD_i_A1_A field combination: cond=7, P=0, U=0, W=0, Rn=0, Rt=0, imm4H=0, imm4L=0
    // ISET: A32
    // Fields: imm4L=0, U=0, cond=7, W=0, P=0, Rn=0, Rt=0, imm4H=0
    let encoding: u32 = 0x704000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_i_A1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=8 (condition HI (unsigned higher))
#[test]
fn test_aarch32_strd_i_a1_a_combo_8_f0_804000f0() {
    // Encoding: 0x804000F0
    // Test aarch32_STRD_i_A1_A field combination: cond=8, P=0, U=0, W=0, Rn=0, Rt=0, imm4H=0, imm4L=0
    // ISET: A32
    // Fields: P=0, Rn=0, W=0, Rt=0, cond=8, imm4H=0, U=0, imm4L=0
    let encoding: u32 = 0x804000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_i_A1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=9 (condition LS (unsigned lower or same))
#[test]
fn test_aarch32_strd_i_a1_a_combo_9_f0_904000f0() {
    // Encoding: 0x904000F0
    // Test aarch32_STRD_i_A1_A field combination: cond=9, P=0, U=0, W=0, Rn=0, Rt=0, imm4H=0, imm4L=0
    // ISET: A32
    // Fields: cond=9, P=0, U=0, Rt=0, imm4H=0, Rn=0, imm4L=0, W=0
    let encoding: u32 = 0x904000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_i_A1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=10 (condition GE (signed >=))
#[test]
fn test_aarch32_strd_i_a1_a_combo_10_f0_a04000f0() {
    // Encoding: 0xA04000F0
    // Test aarch32_STRD_i_A1_A field combination: cond=10, P=0, U=0, W=0, Rn=0, Rt=0, imm4H=0, imm4L=0
    // ISET: A32
    // Fields: U=0, imm4H=0, cond=10, Rt=0, W=0, imm4L=0, P=0, Rn=0
    let encoding: u32 = 0xA04000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_i_A1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=11 (condition LT (signed <))
#[test]
fn test_aarch32_strd_i_a1_a_combo_11_f0_b04000f0() {
    // Encoding: 0xB04000F0
    // Test aarch32_STRD_i_A1_A field combination: cond=11, P=0, U=0, W=0, Rn=0, Rt=0, imm4H=0, imm4L=0
    // ISET: A32
    // Fields: cond=11, imm4L=0, U=0, W=0, Rt=0, imm4H=0, P=0, Rn=0
    let encoding: u32 = 0xB04000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_i_A1_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=12 (condition GT (signed >))
#[test]
fn test_aarch32_strd_i_a1_a_combo_12_f0_c04000f0() {
    // Encoding: 0xC04000F0
    // Test aarch32_STRD_i_A1_A field combination: cond=12, P=0, U=0, W=0, Rn=0, Rt=0, imm4H=0, imm4L=0
    // ISET: A32
    // Fields: imm4H=0, cond=12, imm4L=0, U=0, Rt=0, P=0, W=0, Rn=0
    let encoding: u32 = 0xC04000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_i_A1_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=13 (condition LE (signed <=))
#[test]
fn test_aarch32_strd_i_a1_a_combo_13_f0_d04000f0() {
    // Encoding: 0xD04000F0
    // Test aarch32_STRD_i_A1_A field combination: cond=13, P=0, U=0, W=0, Rn=0, Rt=0, imm4H=0, imm4L=0
    // ISET: A32
    // Fields: P=0, U=0, cond=13, W=0, imm4H=0, imm4L=0, Rt=0, Rn=0
    let encoding: u32 = 0xD04000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_i_A1_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=14 (condition AL (always))
#[test]
fn test_aarch32_strd_i_a1_a_combo_14_f0_e04000f0() {
    // Encoding: 0xE04000F0
    // Test aarch32_STRD_i_A1_A field combination: cond=14, P=0, U=0, W=0, Rn=0, Rt=0, imm4H=0, imm4L=0
    // ISET: A32
    // Fields: cond=14, W=0, imm4L=0, Rt=0, U=0, imm4H=0, P=0, Rn=0
    let encoding: u32 = 0xE04000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_i_A1_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=15 (condition NV (never, reserved))
#[test]
fn test_aarch32_strd_i_a1_a_combo_15_f0_f04000f0() {
    // Encoding: 0xF04000F0
    // Test aarch32_STRD_i_A1_A field combination: cond=15, P=0, U=0, W=0, Rn=0, Rt=0, imm4H=0, imm4L=0
    // ISET: A32
    // Fields: cond=15, P=0, W=0, imm4H=0, imm4L=0, Rn=0, U=0, Rt=0
    let encoding: u32 = 0xF04000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_i_A1_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// P=0 (minimum value)
#[test]
fn test_aarch32_strd_i_a1_a_combo_16_f0_004000f0() {
    // Encoding: 0x004000F0
    // Test aarch32_STRD_i_A1_A field combination: cond=0, P=0, U=0, W=0, Rn=0, Rt=0, imm4H=0, imm4L=0
    // ISET: A32
    // Fields: imm4L=0, Rn=0, imm4H=0, P=0, W=0, cond=0, U=0, Rt=0
    let encoding: u32 = 0x004000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_i_A1_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// P=1 (maximum value (1))
#[test]
fn test_aarch32_strd_i_a1_a_combo_17_f0_014000f0() {
    // Encoding: 0x014000F0
    // Test aarch32_STRD_i_A1_A field combination: cond=0, P=1, U=0, W=0, Rn=0, Rt=0, imm4H=0, imm4L=0
    // ISET: A32
    // Fields: cond=0, imm4L=0, P=1, Rn=0, Rt=0, imm4H=0, U=0, W=0
    let encoding: u32 = 0x014000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_i_A1_A
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=0 (minimum value)
#[test]
fn test_aarch32_strd_i_a1_a_combo_18_f0_004000f0() {
    // Encoding: 0x004000F0
    // Test aarch32_STRD_i_A1_A field combination: cond=0, P=0, U=0, W=0, Rn=0, Rt=0, imm4H=0, imm4L=0
    // ISET: A32
    // Fields: U=0, Rn=0, Rt=0, cond=0, imm4L=0, P=0, W=0, imm4H=0
    let encoding: u32 = 0x004000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_i_A1_A
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=1 (maximum value (1))
#[test]
fn test_aarch32_strd_i_a1_a_combo_19_f0_00c000f0() {
    // Encoding: 0x00C000F0
    // Test aarch32_STRD_i_A1_A field combination: cond=0, P=0, U=1, W=0, Rn=0, Rt=0, imm4H=0, imm4L=0
    // ISET: A32
    // Fields: U=1, Rt=0, imm4H=0, cond=0, imm4L=0, Rn=0, W=0, P=0
    let encoding: u32 = 0x00C000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_i_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_strd_i_a1_a_special_cond_0_condition_eq_240_004000f0() {
    // Encoding: 0x004000F0
    // Test aarch32_STRD_i_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: imm4H=0, Rt=0, Rn=0, cond=0, U=0, P=0, W=0, imm4L=0
    let encoding: u32 = 0x004000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_i_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_strd_i_a1_a_special_cond_1_condition_ne_240_104000f0() {
    // Encoding: 0x104000F0
    // Test aarch32_STRD_i_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: imm4L=0, Rt=0, imm4H=0, Rn=0, cond=1, P=0, U=0, W=0
    let encoding: u32 = 0x104000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_i_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_strd_i_a1_a_special_cond_2_condition_cs_hs_240_204000f0() {
    // Encoding: 0x204000F0
    // Test aarch32_STRD_i_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: Rt=0, W=0, Rn=0, U=0, P=0, imm4H=0, cond=2, imm4L=0
    let encoding: u32 = 0x204000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_i_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_strd_i_a1_a_special_cond_3_condition_cc_lo_240_304000f0() {
    // Encoding: 0x304000F0
    // Test aarch32_STRD_i_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: P=0, cond=3, Rt=0, U=0, Rn=0, imm4H=0, imm4L=0, W=0
    let encoding: u32 = 0x304000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_i_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_strd_i_a1_a_special_cond_4_condition_mi_240_404000f0() {
    // Encoding: 0x404000F0
    // Test aarch32_STRD_i_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: imm4L=0, Rn=0, Rt=0, imm4H=0, U=0, P=0, W=0, cond=4
    let encoding: u32 = 0x404000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_i_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_strd_i_a1_a_special_cond_5_condition_pl_240_504000f0() {
    // Encoding: 0x504000F0
    // Test aarch32_STRD_i_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: Rt=0, U=0, imm4H=0, Rn=0, P=0, cond=5, W=0, imm4L=0
    let encoding: u32 = 0x504000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_i_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_strd_i_a1_a_special_cond_6_condition_vs_240_604000f0() {
    // Encoding: 0x604000F0
    // Test aarch32_STRD_i_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: P=0, U=0, W=0, Rt=0, imm4L=0, imm4H=0, Rn=0, cond=6
    let encoding: u32 = 0x604000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_i_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_strd_i_a1_a_special_cond_7_condition_vc_240_704000f0() {
    // Encoding: 0x704000F0
    // Test aarch32_STRD_i_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: P=0, W=0, cond=7, Rn=0, imm4H=0, imm4L=0, U=0, Rt=0
    let encoding: u32 = 0x704000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_i_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_strd_i_a1_a_special_cond_8_condition_hi_240_804000f0() {
    // Encoding: 0x804000F0
    // Test aarch32_STRD_i_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: imm4H=0, Rt=0, Rn=0, cond=8, U=0, P=0, W=0, imm4L=0
    let encoding: u32 = 0x804000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_i_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_strd_i_a1_a_special_cond_9_condition_ls_240_904000f0() {
    // Encoding: 0x904000F0
    // Test aarch32_STRD_i_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: Rn=0, Rt=0, imm4H=0, cond=9, P=0, imm4L=0, U=0, W=0
    let encoding: u32 = 0x904000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_i_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_strd_i_a1_a_special_cond_10_condition_ge_240_a04000f0() {
    // Encoding: 0xA04000F0
    // Test aarch32_STRD_i_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: imm4H=0, cond=10, W=0, imm4L=0, P=0, Rn=0, U=0, Rt=0
    let encoding: u32 = 0xA04000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_i_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_strd_i_a1_a_special_cond_11_condition_lt_240_b04000f0() {
    // Encoding: 0xB04000F0
    // Test aarch32_STRD_i_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: U=0, W=0, imm4L=0, Rn=0, P=0, imm4H=0, Rt=0, cond=11
    let encoding: u32 = 0xB04000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_i_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_strd_i_a1_a_special_cond_12_condition_gt_240_c04000f0() {
    // Encoding: 0xC04000F0
    // Test aarch32_STRD_i_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: cond=12, Rt=0, Rn=0, P=0, W=0, U=0, imm4H=0, imm4L=0
    let encoding: u32 = 0xC04000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_i_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_strd_i_a1_a_special_cond_13_condition_le_240_d04000f0() {
    // Encoding: 0xD04000F0
    // Test aarch32_STRD_i_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: cond=13, imm4H=0, P=0, W=0, Rt=0, Rn=0, U=0, imm4L=0
    let encoding: u32 = 0xD04000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_i_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_strd_i_a1_a_special_cond_14_condition_al_240_e04000f0() {
    // Encoding: 0xE04000F0
    // Test aarch32_STRD_i_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: Rn=0, imm4H=0, imm4L=0, U=0, cond=14, P=0, Rt=0, W=0
    let encoding: u32 = 0xE04000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_i_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_strd_i_a1_a_special_cond_15_condition_nv_240_f04000f0() {
    // Encoding: 0xF04000F0
    // Test aarch32_STRD_i_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: imm4H=0, P=0, cond=15, W=0, U=0, Rn=0, Rt=0, imm4L=0
    let encoding: u32 = 0xF04000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRD_i_A1_A
/// ASL: `Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Rt" }), indices: [Single(LitInt(0))] }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Rt\" }), indices: [Single(LitInt(0))] }, rhs: LitBits([true]) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strd_i_a1_a_invalid_0_f0_004000f0() {
    // Encoding: 0x004000F0
    // Test aarch32_STRD_i_A1_A invalid encoding: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Rt" }), indices: [Single(LitInt(0))] }, rhs: LitBits([true]) }
    // ISET: A32
    // Fields: imm4H=0, Rn=0, cond=0, imm4L=0, U=0, Rt=0, P=0, W=0
    let encoding: u32 = 0x004000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STRD_i_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strd_i_a1_a_invalid_1_f0_004000f0() {
    // Encoding: 0x004000F0
    // Test aarch32_STRD_i_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: imm4L=0, Rn=0, P=0, U=0, W=0, Rt=0, cond=0, imm4H=0
    let encoding: u32 = 0x004000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STRD_i_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "P" }), rhs: Binary { op: And, lhs: LitBits([false]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "W" }) } }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"P\" }), rhs: Binary { op: And, lhs: LitBits([false]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"W\" }) } }, rhs: LitBits([true]) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strd_i_a1_a_invalid_2_f0_004000f0() {
    // Encoding: 0x004000F0
    // Test aarch32_STRD_i_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "P" }), rhs: Binary { op: And, lhs: LitBits([false]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "W" }) } }, rhs: LitBits([true]) }
    // ISET: A32
    // Fields: W=0, U=0, cond=0, Rt=0, Rn=0, P=0, imm4H=0, imm4L=0
    let encoding: u32 = 0x004000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STRD_i_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strd_i_a1_a_invalid_3_f0_004000f0() {
    // Encoding: 0x004000F0
    // Test aarch32_STRD_i_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: W=0, Rn=0, imm4H=0, imm4L=0, cond=0, P=0, U=0, Rt=0
    let encoding: u32 = 0x004000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STRD_i_A1_A
/// ASL: `Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t2" }) } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"wback\" }), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t2\" }) } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strd_i_a1_a_invalid_4_f0_004000f0() {
    // Encoding: 0x004000F0
    // Test aarch32_STRD_i_A1_A invalid encoding: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t2" }) } }
    // ISET: A32
    // Fields: imm4L=0, cond=0, Rt=0, imm4H=0, Rn=0, P=0, W=0, U=0
    let encoding: u32 = 0x004000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STRD_i_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strd_i_a1_a_invalid_5_f0_004000f0() {
    // Encoding: 0x004000F0
    // Test aarch32_STRD_i_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=0, imm4L=0, U=0, imm4H=0, P=0, W=0
    let encoding: u32 = 0x004000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STRD_i_A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t2" }), rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t2\" }), rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strd_i_a1_a_invalid_6_f0_004000f0() {
    // Encoding: 0x004000F0
    // Test aarch32_STRD_i_A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t2" }), rhs: LitInt(15) }
    // ISET: A32
    // Fields: U=0, cond=0, imm4L=0, P=0, imm4H=0, Rt=0, W=0, Rn=0
    let encoding: u32 = 0x004000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STRD_i_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strd_i_a1_a_invalid_7_f0_004000f0() {
    // Encoding: 0x004000F0
    // Test aarch32_STRD_i_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: imm4H=0, cond=0, Rt=0, imm4L=0, U=0, P=0, Rn=0, W=0
    let encoding: u32 = 0x004000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STRD_i_T1_A
/// ASL: `field P 24 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_strd_i_t1_a_field_p_0_min_0_e8400000() {
    // Thumb encoding (32): 0xE8400000
    // Test aarch32_STRD_i_T1_A field P = 0 (Min)
    // ISET: T32
    // Fields: Rt=0, Rn=0, imm8=0, U=0, W=0, P=0, Rt2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRD_i_T1_A
/// ASL: `field P 24 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_strd_i_t1_a_field_p_1_max_0_e9400000() {
    // Thumb encoding (32): 0xE9400000
    // Test aarch32_STRD_i_T1_A field P = 1 (Max)
    // ISET: T32
    // Fields: Rn=0, P=1, U=0, Rt=0, W=0, Rt2=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE9400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRD_i_T1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_strd_i_t1_a_field_u_0_min_0_e8400000() {
    // Thumb encoding (32): 0xE8400000
    // Test aarch32_STRD_i_T1_A field U = 0 (Min)
    // ISET: T32
    // Fields: Rt=0, U=0, W=0, Rn=0, imm8=0, Rt2=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRD_i_T1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_strd_i_t1_a_field_u_1_max_0_e8c00000() {
    // Thumb encoding (32): 0xE8C00000
    // Test aarch32_STRD_i_T1_A field U = 1 (Max)
    // ISET: T32
    // Fields: P=0, Rt2=0, U=1, imm8=0, Rn=0, Rt=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRD_i_T1_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_strd_i_t1_a_field_w_0_min_0_e8400000() {
    // Thumb encoding (32): 0xE8400000
    // Test aarch32_STRD_i_T1_A field W = 0 (Min)
    // ISET: T32
    // Fields: P=0, W=0, imm8=0, Rn=0, U=0, Rt=0, Rt2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRD_i_T1_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_strd_i_t1_a_field_w_1_max_0_e8600000() {
    // Thumb encoding (32): 0xE8600000
    // Test aarch32_STRD_i_T1_A field W = 1 (Max)
    // ISET: T32
    // Fields: Rt=0, P=0, Rn=0, imm8=0, W=1, U=0, Rt2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8600000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRD_i_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_strd_i_t1_a_field_rn_0_min_0_e8400000() {
    // Thumb encoding (32): 0xE8400000
    // Test aarch32_STRD_i_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, imm8=0, U=0, P=0, W=0, Rt=0, Rt2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRD_i_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_strd_i_t1_a_field_rn_1_poweroftwo_0_e8410000() {
    // Thumb encoding (32): 0xE8410000
    // Test aarch32_STRD_i_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt2=0, imm8=0, P=0, U=0, W=0, Rn=1, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8410000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRD_i_T1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_strd_i_t1_a_field_rt_0_min_0_e8400000() {
    // Thumb encoding (32): 0xE8400000
    // Test aarch32_STRD_i_T1_A field Rt = 0 (Min)
    // ISET: T32
    // Fields: U=0, Rt=0, W=0, Rt2=0, imm8=0, P=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRD_i_T1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_strd_i_t1_a_field_rt_1_poweroftwo_0_e8401000() {
    // Thumb encoding (32): 0xE8401000
    // Test aarch32_STRD_i_T1_A field Rt = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: U=0, Rt=1, imm8=0, Rn=0, P=0, Rt2=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8401000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRD_i_T1_A
/// ASL: `field Rt2 8 +: 4`
/// Requirement: FieldBoundary { field: "Rt2", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_strd_i_t1_a_field_rt2_0_min_0_e8400000() {
    // Thumb encoding (32): 0xE8400000
    // Test aarch32_STRD_i_T1_A field Rt2 = 0 (Min)
    // ISET: T32
    // Fields: Rt=0, W=0, U=0, Rn=0, P=0, Rt2=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRD_i_T1_A
/// ASL: `field Rt2 8 +: 4`
/// Requirement: FieldBoundary { field: "Rt2", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_strd_i_t1_a_field_rt2_1_poweroftwo_0_e8400100() {
    // Thumb encoding (32): 0xE8400100
    // Test aarch32_STRD_i_T1_A field Rt2 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, P=0, Rt2=1, Rt=0, imm8=0, U=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8400100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRD_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_strd_i_t1_a_field_imm8_0_zero_0_e8400000() {
    // Thumb encoding (32): 0xE8400000
    // Test aarch32_STRD_i_T1_A field imm8 = 0 (Zero)
    // ISET: T32
    // Fields: P=0, Rt2=0, imm8=0, U=0, W=0, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRD_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_strd_i_t1_a_field_imm8_1_poweroftwo_0_e8400001() {
    // Thumb encoding (32): 0xE8400001
    // Test aarch32_STRD_i_T1_A field imm8 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=1, W=0, Rt2=0, Rt=0, U=0, P=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8400001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRD_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_strd_i_t1_a_field_imm8_3_poweroftwominusone_0_e8400003() {
    // Thumb encoding (32): 0xE8400003
    // Test aarch32_STRD_i_T1_A field imm8 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt2=0, W=0, imm8=3, U=0, Rn=0, Rt=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8400003;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRD_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_strd_i_t1_a_field_imm8_4_poweroftwo_0_e8400004() {
    // Thumb encoding (32): 0xE8400004
    // Test aarch32_STRD_i_T1_A field imm8 = 4 (PowerOfTwo)
    // ISET: T32
    // Fields: U=0, Rt2=0, W=0, Rn=0, imm8=4, P=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8400004;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRD_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_strd_i_t1_a_field_imm8_7_poweroftwominusone_0_e8400007() {
    // Thumb encoding (32): 0xE8400007
    // Test aarch32_STRD_i_T1_A field imm8 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm8=7, P=0, Rt2=0, U=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8400007;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRD_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_strd_i_t1_a_field_imm8_8_poweroftwo_0_e8400008() {
    // Thumb encoding (32): 0xE8400008
    // Test aarch32_STRD_i_T1_A field imm8 = 8 (PowerOfTwo)
    // ISET: T32
    // Fields: U=0, Rt=0, P=0, Rt2=0, W=0, Rn=0, imm8=8
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8400008;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRD_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_strd_i_t1_a_field_imm8_15_poweroftwominusone_0_e840000f() {
    // Thumb encoding (32): 0xE840000F
    // Test aarch32_STRD_i_T1_A field imm8 = 15 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm8=15, P=0, U=0, W=0, Rt=0, Rt2=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE840000F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRD_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_strd_i_t1_a_field_imm8_16_poweroftwo_0_e8400010() {
    // Thumb encoding (32): 0xE8400010
    // Test aarch32_STRD_i_T1_A field imm8 = 16 (PowerOfTwo)
    // ISET: T32
    // Fields: P=0, U=0, W=0, Rt2=0, imm8=16, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8400010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRD_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_strd_i_t1_a_field_imm8_31_poweroftwominusone_0_e840001f() {
    // Thumb encoding (32): 0xE840001F
    // Test aarch32_STRD_i_T1_A field imm8 = 31 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: U=0, P=0, Rn=0, Rt2=0, imm8=31, Rt=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE840001F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRD_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_strd_i_t1_a_field_imm8_32_poweroftwo_0_e8400020() {
    // Thumb encoding (32): 0xE8400020
    // Test aarch32_STRD_i_T1_A field imm8 = 32 (PowerOfTwo)
    // ISET: T32
    // Fields: P=0, U=0, W=0, Rt2=0, Rn=0, Rt=0, imm8=32
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8400020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRD_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_strd_i_t1_a_field_imm8_63_poweroftwominusone_0_e840003f() {
    // Thumb encoding (32): 0xE840003F
    // Test aarch32_STRD_i_T1_A field imm8 = 63 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, P=0, W=0, imm8=63, U=0, Rt2=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE840003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRD_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_strd_i_t1_a_field_imm8_64_poweroftwo_0_e8400040() {
    // Thumb encoding (32): 0xE8400040
    // Test aarch32_STRD_i_T1_A field imm8 = 64 (PowerOfTwo)
    // ISET: T32
    // Fields: W=0, U=0, Rn=0, Rt2=0, P=0, Rt=0, imm8=64
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8400040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRD_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 127, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (127)
#[test]
fn test_aarch32_strd_i_t1_a_field_imm8_127_poweroftwominusone_0_e840007f() {
    // Thumb encoding (32): 0xE840007F
    // Test aarch32_STRD_i_T1_A field imm8 = 127 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, U=0, P=0, Rn=0, imm8=127, W=0, Rt2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE840007F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRD_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_strd_i_t1_a_field_imm8_128_poweroftwo_0_e8400080() {
    // Thumb encoding (32): 0xE8400080
    // Test aarch32_STRD_i_T1_A field imm8 = 128 (PowerOfTwo)
    // ISET: T32
    // Fields: U=0, P=0, W=0, Rn=0, Rt2=0, imm8=128, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8400080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRD_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 255, boundary: Max }
/// maximum immediate (255)
#[test]
fn test_aarch32_strd_i_t1_a_field_imm8_255_max_0_e84000ff() {
    // Thumb encoding (32): 0xE84000FF
    // Test aarch32_STRD_i_T1_A field imm8 = 255 (Max)
    // ISET: T32
    // Fields: W=0, Rt=0, imm8=255, Rt2=0, P=0, U=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE84000FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRD_i_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// P=0 (minimum value)
#[test]
fn test_aarch32_strd_i_t1_a_combo_0_0_e8400000() {
    // Thumb encoding (32): 0xE8400000
    // Test aarch32_STRD_i_T1_A field combination: P=0, U=0, W=0, Rn=0, Rt=0, Rt2=0, imm8=0
    // ISET: T32
    // Fields: imm8=0, Rn=0, P=0, U=0, Rt2=0, W=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRD_i_T1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// P=1 (maximum value (1))
#[test]
fn test_aarch32_strd_i_t1_a_combo_1_0_e9400000() {
    // Thumb encoding (32): 0xE9400000
    // Test aarch32_STRD_i_T1_A field combination: P=1, U=0, W=0, Rn=0, Rt=0, Rt2=0, imm8=0
    // ISET: T32
    // Fields: W=0, imm8=0, P=1, Rt=0, Rt2=0, U=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE9400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRD_i_T1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=0 (minimum value)
#[test]
fn test_aarch32_strd_i_t1_a_combo_2_0_e8400000() {
    // Thumb encoding (32): 0xE8400000
    // Test aarch32_STRD_i_T1_A field combination: P=0, U=0, W=0, Rn=0, Rt=0, Rt2=0, imm8=0
    // ISET: T32
    // Fields: W=0, Rt=0, U=0, Rt2=0, imm8=0, Rn=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRD_i_T1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=1 (maximum value (1))
#[test]
fn test_aarch32_strd_i_t1_a_combo_3_0_e8c00000() {
    // Thumb encoding (32): 0xE8C00000
    // Test aarch32_STRD_i_T1_A field combination: P=0, U=1, W=0, Rn=0, Rt=0, Rt2=0, imm8=0
    // ISET: T32
    // Fields: U=1, P=0, Rt=0, imm8=0, Rn=0, W=0, Rt2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRD_i_T1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// W=0 (minimum value)
#[test]
fn test_aarch32_strd_i_t1_a_combo_4_0_e8400000() {
    // Thumb encoding (32): 0xE8400000
    // Test aarch32_STRD_i_T1_A field combination: P=0, U=0, W=0, Rn=0, Rt=0, Rt2=0, imm8=0
    // ISET: T32
    // Fields: U=0, W=0, P=0, Rn=0, imm8=0, Rt2=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRD_i_T1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// W=1 (maximum value (1))
#[test]
fn test_aarch32_strd_i_t1_a_combo_5_0_e8600000() {
    // Thumb encoding (32): 0xE8600000
    // Test aarch32_STRD_i_T1_A field combination: P=0, U=0, W=1, Rn=0, Rt=0, Rt2=0, imm8=0
    // ISET: T32
    // Fields: imm8=0, W=1, Rn=0, Rt2=0, Rt=0, P=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8600000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRD_i_T1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_strd_i_t1_a_combo_6_0_e8400000() {
    // Thumb encoding (32): 0xE8400000
    // Test aarch32_STRD_i_T1_A field combination: P=0, U=0, W=0, Rn=0, Rt=0, Rt2=0, imm8=0
    // ISET: T32
    // Fields: Rt2=0, imm8=0, U=0, P=0, Rn=0, Rt=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRD_i_T1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_strd_i_t1_a_combo_7_0_e8410000() {
    // Thumb encoding (32): 0xE8410000
    // Test aarch32_STRD_i_T1_A field combination: P=0, U=0, W=0, Rn=1, Rt=0, Rt2=0, imm8=0
    // ISET: T32
    // Fields: Rt=0, imm8=0, U=0, Rt2=0, P=0, W=0, Rn=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8410000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRD_i_T1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=0 (register index 0 (first register))
#[test]
fn test_aarch32_strd_i_t1_a_combo_8_0_e8400000() {
    // Thumb encoding (32): 0xE8400000
    // Test aarch32_STRD_i_T1_A field combination: P=0, U=0, W=0, Rn=0, Rt=0, Rt2=0, imm8=0
    // ISET: T32
    // Fields: W=0, imm8=0, P=0, Rt=0, Rn=0, U=0, Rt2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRD_i_T1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=1 (register index 1 (second register))
#[test]
fn test_aarch32_strd_i_t1_a_combo_9_0_e8401000() {
    // Thumb encoding (32): 0xE8401000
    // Test aarch32_STRD_i_T1_A field combination: P=0, U=0, W=0, Rn=0, Rt=1, Rt2=0, imm8=0
    // ISET: T32
    // Fields: Rt=1, imm8=0, P=0, Rt2=0, W=0, Rn=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8401000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRD_i_T1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt2=0 (register index 0 (first register))
#[test]
fn test_aarch32_strd_i_t1_a_combo_10_0_e8400000() {
    // Thumb encoding (32): 0xE8400000
    // Test aarch32_STRD_i_T1_A field combination: P=0, U=0, W=0, Rn=0, Rt=0, Rt2=0, imm8=0
    // ISET: T32
    // Fields: U=0, W=0, Rn=0, Rt=0, P=0, Rt2=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRD_i_T1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt2=1 (register index 1 (second register))
#[test]
fn test_aarch32_strd_i_t1_a_combo_11_0_e8400100() {
    // Thumb encoding (32): 0xE8400100
    // Test aarch32_STRD_i_T1_A field combination: P=0, U=0, W=0, Rn=0, Rt=0, Rt2=1, imm8=0
    // ISET: T32
    // Fields: Rt=0, U=0, W=0, Rt2=1, imm8=0, P=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8400100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRD_i_T1_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=0 (immediate value 0)
#[test]
fn test_aarch32_strd_i_t1_a_combo_12_0_e8400000() {
    // Thumb encoding (32): 0xE8400000
    // Test aarch32_STRD_i_T1_A field combination: P=0, U=0, W=0, Rn=0, Rt=0, Rt2=0, imm8=0
    // ISET: T32
    // Fields: U=0, Rt=0, P=0, W=0, imm8=0, Rt2=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRD_i_T1_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=1 (immediate value 1)
#[test]
fn test_aarch32_strd_i_t1_a_combo_13_0_e8400001() {
    // Thumb encoding (32): 0xE8400001
    // Test aarch32_STRD_i_T1_A field combination: P=0, U=0, W=0, Rn=0, Rt=0, Rt2=0, imm8=1
    // ISET: T32
    // Fields: Rt2=0, Rt=0, imm8=1, Rn=0, U=0, P=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8400001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRD_i_T1_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=3 (2^2 - 1 = 3)
#[test]
fn test_aarch32_strd_i_t1_a_combo_14_0_e8400003() {
    // Thumb encoding (32): 0xE8400003
    // Test aarch32_STRD_i_T1_A field combination: P=0, U=0, W=0, Rn=0, Rt=0, Rt2=0, imm8=3
    // ISET: T32
    // Fields: Rt=0, U=0, W=0, Rn=0, Rt2=0, imm8=3, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8400003;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRD_i_T1_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=4 (power of 2 (2^2 = 4))
#[test]
fn test_aarch32_strd_i_t1_a_combo_15_0_e8400004() {
    // Thumb encoding (32): 0xE8400004
    // Test aarch32_STRD_i_T1_A field combination: P=0, U=0, W=0, Rn=0, Rt=0, Rt2=0, imm8=4
    // ISET: T32
    // Fields: P=0, Rt=0, Rt2=0, imm8=4, Rn=0, U=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8400004;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRD_i_T1_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=7 (2^3 - 1 = 7)
#[test]
fn test_aarch32_strd_i_t1_a_combo_16_0_e8400007() {
    // Thumb encoding (32): 0xE8400007
    // Test aarch32_STRD_i_T1_A field combination: P=0, U=0, W=0, Rn=0, Rt=0, Rt2=0, imm8=7
    // ISET: T32
    // Fields: Rt=0, Rt2=0, Rn=0, W=0, P=0, imm8=7, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8400007;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRD_i_T1_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=8 (power of 2 (2^3 = 8))
#[test]
fn test_aarch32_strd_i_t1_a_combo_17_0_e8400008() {
    // Thumb encoding (32): 0xE8400008
    // Test aarch32_STRD_i_T1_A field combination: P=0, U=0, W=0, Rn=0, Rt=0, Rt2=0, imm8=8
    // ISET: T32
    // Fields: Rt=0, Rt2=0, imm8=8, U=0, W=0, P=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8400008;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRD_i_T1_A
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=15 (2^4 - 1 = 15)
#[test]
fn test_aarch32_strd_i_t1_a_combo_18_0_e840000f() {
    // Thumb encoding (32): 0xE840000F
    // Test aarch32_STRD_i_T1_A field combination: P=0, U=0, W=0, Rn=0, Rt=0, Rt2=0, imm8=15
    // ISET: T32
    // Fields: P=0, Rt=0, Rn=0, Rt2=0, W=0, imm8=15, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE840000F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRD_i_T1_A
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=16 (power of 2 (2^4 = 16))
#[test]
fn test_aarch32_strd_i_t1_a_combo_19_0_e8400010() {
    // Thumb encoding (32): 0xE8400010
    // Test aarch32_STRD_i_T1_A field combination: P=0, U=0, W=0, Rn=0, Rt=0, Rt2=0, imm8=16
    // ISET: T32
    // Fields: Rn=0, U=0, imm8=16, W=0, Rt=0, P=0, Rt2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8400010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRD_i_T1_A
/// ASL: `Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t2" }) } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"wback\" }), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t2\" }) } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strd_i_t1_a_invalid_0_0_e8400000() {
    // Thumb encoding (32): 0xE8400000
    // Test aarch32_STRD_i_T1_A invalid encoding: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t2" }) } }
    // ISET: T32
    // Fields: Rn=0, imm8=0, Rt2=0, U=0, W=0, P=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8400000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_STRD_i_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strd_i_t1_a_invalid_1_0_e8400000() {
    // Thumb encoding (32): 0xE8400000
    // Test aarch32_STRD_i_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: U=0, W=0, Rt=0, Rt2=0, imm8=0, P=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8400000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_STRD_i_T1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t2" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t2\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strd_i_t1_a_invalid_2_0_e8400000() {
    // Thumb encoding (32): 0xE8400000
    // Test aarch32_STRD_i_T1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t2" }) } }, rhs: LitInt(15) }
    // ISET: T32
    // Fields: Rt2=0, imm8=0, P=0, Rn=0, W=0, U=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8400000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_STRD_i_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strd_i_t1_a_invalid_3_0_e8400000() {
    // Thumb encoding (32): 0xE8400000
    // Test aarch32_STRD_i_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: U=0, W=0, Rn=0, P=0, Rt2=0, Rt=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8400000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_STRD_i_A1_A
/// ASL: `UMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple multiply
#[test]
fn test_aarch32_strd_i_a1_a_umull_oracle_0_9ba27c20() {
    // Test UMULL: simple multiply (oracle)
    // Encoding: 0x9BA27C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x2);
    set_w(&mut cpu, 2, 0x3);
    let encoding: u32 = 0x9BA27C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6, "X0 should be 0x0000000000000006");
}

/// Provenance: aarch32_STRD_i_A1_A
/// ASL: `UMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max 32-bit * 2
#[test]
fn test_aarch32_strd_i_a1_a_umull_oracle_1_9ba27c20() {
    // Test UMULL: max 32-bit * 2 (oracle)
    // Encoding: 0x9BA27C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x9BA27C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFE, "X0 should be 0x00000001FFFFFFFE");
}

/// Provenance: aarch32_STRD_i_A1_A
/// ASL: `UMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// large positive * large positive
#[test]
fn test_aarch32_strd_i_a1_a_umull_oracle_2_9ba27c20() {
    // Test UMULL: large positive * large positive (oracle)
    // Encoding: 0x9BA27C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    set_w(&mut cpu, 2, 0x7FFFFFFF);
    let encoding: u32 = 0x9BA27C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x3FFFFFFF00000001");
}

/// Provenance: aarch32_STRD_i_A1_A
/// ASL: `UMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max unsigned * max unsigned
#[test]
fn test_aarch32_strd_i_a1_a_umull_oracle_3_9ba27c20() {
    // Test UMULL: max unsigned * max unsigned (oracle)
    // Encoding: 0x9BA27C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x9BA27C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0xFFFFFFFE00000001");
}

/// Provenance: aarch32_STRD_i_A1_A
/// ASL: `UMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// medium values
#[test]
fn test_aarch32_strd_i_a1_a_umull_oracle_4_9ba27c20() {
    // Test UMULL: medium values (oracle)
    // Encoding: 0x9BA27C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0xC8);
    let encoding: u32 = 0x9BA27C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4E20, "X0 should be 0x0000000000004E20");
}

/// Provenance: aarch32_STRD_i_A1_A
/// ASL: `UMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// 16-bit values
#[test]
fn test_aarch32_strd_i_a1_a_umull_oracle_5_9ba27c20() {
    // Test UMULL: 16-bit values (oracle)
    // Encoding: 0x9BA27C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1234);
    set_w(&mut cpu, 2, 0x5678);
    let encoding: u32 = 0x9BA27C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6260060, "X0 should be 0x0000000006260060");
}

/// Provenance: aarch32_STRD_i_A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_strd_i_a1_a_store_0_004100f0() {
    // Test aarch32_STRD_i_A1_A memory store: 8 bytes
    // Encoding: 0x004100F0
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0x004100F0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_STRD_i_A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_strd_i_a1_a_store_1_004100f0() {
    // Test aarch32_STRD_i_A1_A memory store: 8 bytes
    // Encoding: 0x004100F0
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0x004100F0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_STRD_i_A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_strd_i_a1_a_store_2_004100f0() {
    // Test aarch32_STRD_i_A1_A memory store: 8 bytes
    // Encoding: 0x004100F0
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0x004100F0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_STRD_i_T1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_strd_i_t1_a_store_0_e8410000() {
    // Test aarch32_STRD_i_T1_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0xE8410000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_STRD_i_T1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_strd_i_t1_a_store_1_e8410000() {
    // Test aarch32_STRD_i_T1_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0xE8410000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_STRD_i_T1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_strd_i_t1_a_store_2_e8410000() {
    // Test aarch32_STRD_i_T1_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0xE8410000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// aarch32_STRBT_A Tests
// ============================================================================

/// Provenance: aarch32_STRBT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_strbt_a1_a_field_cond_0_min_0_04600000() {
    // Encoding: 0x04600000
    // Test aarch32_STRBT_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: U=0, Rt=0, cond=0, Rn=0, imm12=0
    let encoding: u32 = 0x04600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_strbt_a1_a_field_cond_1_poweroftwo_0_14600000() {
    // Encoding: 0x14600000
    // Test aarch32_STRBT_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, cond=1, U=0, imm12=0, Rn=0
    let encoding: u32 = 0x14600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_strbt_a1_a_field_cond_2_poweroftwo_0_24600000() {
    // Encoding: 0x24600000
    // Test aarch32_STRBT_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, imm12=0, Rt=0, cond=2, U=0
    let encoding: u32 = 0x24600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_strbt_a1_a_field_cond_3_poweroftwo_0_34600000() {
    // Encoding: 0x34600000
    // Test aarch32_STRBT_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=3, U=0, Rt=0, imm12=0
    let encoding: u32 = 0x34600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_strbt_a1_a_field_cond_4_poweroftwo_0_44600000() {
    // Encoding: 0x44600000
    // Test aarch32_STRBT_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rt=0, U=0, imm12=0, cond=4
    let encoding: u32 = 0x44600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_strbt_a1_a_field_cond_5_poweroftwo_0_54600000() {
    // Encoding: 0x54600000
    // Test aarch32_STRBT_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, U=0, cond=5, Rt=0, imm12=0
    let encoding: u32 = 0x54600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_strbt_a1_a_field_cond_6_poweroftwo_0_64600000() {
    // Encoding: 0x64600000
    // Test aarch32_STRBT_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=6, U=0, Rn=0, imm12=0, Rt=0
    let encoding: u32 = 0x64600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_strbt_a1_a_field_cond_7_poweroftwo_0_74600000() {
    // Encoding: 0x74600000
    // Test aarch32_STRBT_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, Rn=0, imm12=0, cond=7, Rt=0
    let encoding: u32 = 0x74600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_strbt_a1_a_field_cond_8_poweroftwo_0_84600000() {
    // Encoding: 0x84600000
    // Test aarch32_STRBT_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=8, Rn=0, imm12=0, U=0, Rt=0
    let encoding: u32 = 0x84600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_strbt_a1_a_field_cond_9_poweroftwo_0_94600000() {
    // Encoding: 0x94600000
    // Test aarch32_STRBT_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=9, Rt=0, Rn=0, U=0, imm12=0
    let encoding: u32 = 0x94600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_strbt_a1_a_field_cond_10_poweroftwo_0_a4600000() {
    // Encoding: 0xA4600000
    // Test aarch32_STRBT_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, cond=10, Rt=0, Rn=0, imm12=0
    let encoding: u32 = 0xA4600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_strbt_a1_a_field_cond_11_poweroftwo_0_b4600000() {
    // Encoding: 0xB4600000
    // Test aarch32_STRBT_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, U=0, cond=11, Rt=0, imm12=0
    let encoding: u32 = 0xB4600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_strbt_a1_a_field_cond_12_poweroftwo_0_c4600000() {
    // Encoding: 0xC4600000
    // Test aarch32_STRBT_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, U=0, cond=12, Rn=0, imm12=0
    let encoding: u32 = 0xC4600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_strbt_a1_a_field_cond_13_poweroftwo_0_d4600000() {
    // Encoding: 0xD4600000
    // Test aarch32_STRBT_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=0, Rn=0, cond=13, Rt=0, U=0
    let encoding: u32 = 0xD4600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_strbt_a1_a_field_cond_14_poweroftwo_0_e4600000() {
    // Encoding: 0xE4600000
    // Test aarch32_STRBT_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, U=0, cond=14, Rn=0, imm12=0
    let encoding: u32 = 0xE4600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_strbt_a1_a_field_cond_15_max_0_f4600000() {
    // Encoding: 0xF4600000
    // Test aarch32_STRBT_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: cond=15, U=0, Rn=0, Rt=0, imm12=0
    let encoding: u32 = 0xF4600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_strbt_a1_a_field_u_0_min_0_04600000() {
    // Encoding: 0x04600000
    // Test aarch32_STRBT_A1_A field U = 0 (Min)
    // ISET: A32
    // Fields: Rt=0, U=0, cond=0, Rn=0, imm12=0
    let encoding: u32 = 0x04600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_strbt_a1_a_field_u_1_max_0_04e00000() {
    // Encoding: 0x04E00000
    // Test aarch32_STRBT_A1_A field U = 1 (Max)
    // ISET: A32
    // Fields: Rn=0, U=1, Rt=0, cond=0, imm12=0
    let encoding: u32 = 0x04E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_strbt_a1_a_field_rn_0_min_0_04600000() {
    // Encoding: 0x04600000
    // Test aarch32_STRBT_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rt=0, Rn=0, U=0, imm12=0
    let encoding: u32 = 0x04600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_strbt_a1_a_field_rn_1_poweroftwo_0_04610000() {
    // Encoding: 0x04610000
    // Test aarch32_STRBT_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, U=0, Rn=1, imm12=0, Rt=0
    let encoding: u32 = 0x04610000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_strbt_a1_a_field_rt_0_min_0_04600000() {
    // Encoding: 0x04600000
    // Test aarch32_STRBT_A1_A field Rt = 0 (Min)
    // ISET: A32
    // Fields: imm12=0, Rt=0, U=0, cond=0, Rn=0
    let encoding: u32 = 0x04600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_strbt_a1_a_field_rt_1_poweroftwo_0_04601000() {
    // Encoding: 0x04601000
    // Test aarch32_STRBT_A1_A field Rt = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, Rn=0, cond=0, Rt=1, imm12=0
    let encoding: u32 = 0x04601000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_strbt_a1_a_field_imm12_0_zero_0_04600000() {
    // Encoding: 0x04600000
    // Test aarch32_STRBT_A1_A field imm12 = 0 (Zero)
    // ISET: A32
    // Fields: Rn=0, U=0, imm12=0, cond=0, Rt=0
    let encoding: u32 = 0x04600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_strbt_a1_a_field_imm12_1_poweroftwo_0_04600001() {
    // Encoding: 0x04600001
    // Test aarch32_STRBT_A1_A field imm12 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, U=0, imm12=1, Rn=0, cond=0
    let encoding: u32 = 0x04600001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_strbt_a1_a_field_imm12_3_poweroftwominusone_0_04600003() {
    // Encoding: 0x04600003
    // Test aarch32_STRBT_A1_A field imm12 = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: U=0, Rt=0, imm12=3, Rn=0, cond=0
    let encoding: u32 = 0x04600003;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_strbt_a1_a_field_imm12_4_poweroftwo_0_04600004() {
    // Encoding: 0x04600004
    // Test aarch32_STRBT_A1_A field imm12 = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, U=0, cond=0, Rt=0, imm12=4
    let encoding: u32 = 0x04600004;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_strbt_a1_a_field_imm12_7_poweroftwominusone_0_04600007() {
    // Encoding: 0x04600007
    // Test aarch32_STRBT_A1_A field imm12 = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rt=0, U=0, cond=0, Rn=0, imm12=7
    let encoding: u32 = 0x04600007;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_strbt_a1_a_field_imm12_8_poweroftwo_0_04600008() {
    // Encoding: 0x04600008
    // Test aarch32_STRBT_A1_A field imm12 = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, imm12=8, Rt=0, U=0, Rn=0
    let encoding: u32 = 0x04600008;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_strbt_a1_a_field_imm12_15_poweroftwominusone_0_0460000f() {
    // Encoding: 0x0460000F
    // Test aarch32_STRBT_A1_A field imm12 = 15 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, U=0, Rn=0, imm12=15, Rt=0
    let encoding: u32 = 0x0460000F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_strbt_a1_a_field_imm12_16_poweroftwo_0_04600010() {
    // Encoding: 0x04600010
    // Test aarch32_STRBT_A1_A field imm12 = 16 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, imm12=16, cond=0, Rn=0, Rt=0
    let encoding: u32 = 0x04600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_strbt_a1_a_field_imm12_31_poweroftwominusone_0_0460001f() {
    // Encoding: 0x0460001F
    // Test aarch32_STRBT_A1_A field imm12 = 31 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: U=0, Rt=0, imm12=31, cond=0, Rn=0
    let encoding: u32 = 0x0460001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_strbt_a1_a_field_imm12_32_poweroftwo_0_04600020() {
    // Encoding: 0x04600020
    // Test aarch32_STRBT_A1_A field imm12 = 32 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=32, cond=0, Rt=0, U=0, Rn=0
    let encoding: u32 = 0x04600020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_strbt_a1_a_field_imm12_63_poweroftwominusone_0_0460003f() {
    // Encoding: 0x0460003F
    // Test aarch32_STRBT_A1_A field imm12 = 63 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, Rt=0, U=0, Rn=0, imm12=63
    let encoding: u32 = 0x0460003F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_strbt_a1_a_field_imm12_64_poweroftwo_0_04600040() {
    // Encoding: 0x04600040
    // Test aarch32_STRBT_A1_A field imm12 = 64 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, cond=0, Rn=0, Rt=0, imm12=64
    let encoding: u32 = 0x04600040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 127, boundary: PowerOfTwoMinusOne }
/// 2^7 - 1 = 127
#[test]
fn test_aarch32_strbt_a1_a_field_imm12_127_poweroftwominusone_0_0460007f() {
    // Encoding: 0x0460007F
    // Test aarch32_STRBT_A1_A field imm12 = 127 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, Rn=0, Rt=0, imm12=127, U=0
    let encoding: u32 = 0x0460007F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_strbt_a1_a_field_imm12_128_poweroftwo_0_04600080() {
    // Encoding: 0x04600080
    // Test aarch32_STRBT_A1_A field imm12 = 128 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Rn=0, Rt=0, imm12=128, U=0
    let encoding: u32 = 0x04600080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 255, boundary: PowerOfTwoMinusOne }
/// 2^8 - 1 = 255
#[test]
fn test_aarch32_strbt_a1_a_field_imm12_255_poweroftwominusone_0_046000ff() {
    // Encoding: 0x046000FF
    // Test aarch32_STRBT_A1_A field imm12 = 255 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: U=0, Rn=0, Rt=0, imm12=255, cond=0
    let encoding: u32 = 0x046000FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 256, boundary: PowerOfTwo }
/// power of 2 (2^8 = 256)
#[test]
fn test_aarch32_strbt_a1_a_field_imm12_256_poweroftwo_0_04600100() {
    // Encoding: 0x04600100
    // Test aarch32_STRBT_A1_A field imm12 = 256 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=256, cond=0, Rn=0, Rt=0, U=0
    let encoding: u32 = 0x04600100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 511, boundary: PowerOfTwoMinusOne }
/// 2^9 - 1 = 511
#[test]
fn test_aarch32_strbt_a1_a_field_imm12_511_poweroftwominusone_0_046001ff() {
    // Encoding: 0x046001FF
    // Test aarch32_STRBT_A1_A field imm12 = 511 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, imm12=511, U=0, Rt=0, Rn=0
    let encoding: u32 = 0x046001FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 512, boundary: PowerOfTwo }
/// power of 2 (2^9 = 512)
#[test]
fn test_aarch32_strbt_a1_a_field_imm12_512_poweroftwo_0_04600200() {
    // Encoding: 0x04600200
    // Test aarch32_STRBT_A1_A field imm12 = 512 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, U=0, cond=0, imm12=512, Rt=0
    let encoding: u32 = 0x04600200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1023, boundary: PowerOfTwoMinusOne }
/// 2^10 - 1 = 1023
#[test]
fn test_aarch32_strbt_a1_a_field_imm12_1023_poweroftwominusone_0_046003ff() {
    // Encoding: 0x046003FF
    // Test aarch32_STRBT_A1_A field imm12 = 1023 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, Rn=0, imm12=1023, Rt=0, U=0
    let encoding: u32 = 0x046003FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1024, boundary: PowerOfTwo }
/// power of 2 (2^10 = 1024)
#[test]
fn test_aarch32_strbt_a1_a_field_imm12_1024_poweroftwo_0_04600400() {
    // Encoding: 0x04600400
    // Test aarch32_STRBT_A1_A field imm12 = 1024 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, Rt=0, cond=0, Rn=0, imm12=1024
    let encoding: u32 = 0x04600400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2047, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (2047)
#[test]
fn test_aarch32_strbt_a1_a_field_imm12_2047_poweroftwominusone_0_046007ff() {
    // Encoding: 0x046007FF
    // Test aarch32_STRBT_A1_A field imm12 = 2047 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rt=0, cond=0, U=0, Rn=0, imm12=2047
    let encoding: u32 = 0x046007FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2048, boundary: PowerOfTwo }
/// power of 2 (2^11 = 2048)
#[test]
fn test_aarch32_strbt_a1_a_field_imm12_2048_poweroftwo_0_04600800() {
    // Encoding: 0x04600800
    // Test aarch32_STRBT_A1_A field imm12 = 2048 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=2048, cond=0, Rt=0, U=0, Rn=0
    let encoding: u32 = 0x04600800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4095, boundary: Max }
/// maximum immediate (4095)
#[test]
fn test_aarch32_strbt_a1_a_field_imm12_4095_max_0_04600fff() {
    // Encoding: 0x04600FFF
    // Test aarch32_STRBT_A1_A field imm12 = 4095 (Max)
    // ISET: A32
    // Fields: cond=0, Rn=0, Rt=0, U=0, imm12=4095
    let encoding: u32 = 0x04600FFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_strbt_a1_a_combo_0_0_04600000() {
    // Encoding: 0x04600000
    // Test aarch32_STRBT_A1_A field combination: cond=0, U=0, Rn=0, Rt=0, imm12=0
    // ISET: A32
    // Fields: U=0, Rn=0, Rt=0, cond=0, imm12=0
    let encoding: u32 = 0x04600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=1 (condition NE (not equal))
#[test]
fn test_aarch32_strbt_a1_a_combo_1_0_14600000() {
    // Encoding: 0x14600000
    // Test aarch32_STRBT_A1_A field combination: cond=1, U=0, Rn=0, Rt=0, imm12=0
    // ISET: A32
    // Fields: imm12=0, U=0, cond=1, Rt=0, Rn=0
    let encoding: u32 = 0x14600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=2 (condition CS/HS (carry set))
#[test]
fn test_aarch32_strbt_a1_a_combo_2_0_24600000() {
    // Encoding: 0x24600000
    // Test aarch32_STRBT_A1_A field combination: cond=2, U=0, Rn=0, Rt=0, imm12=0
    // ISET: A32
    // Fields: cond=2, Rt=0, Rn=0, imm12=0, U=0
    let encoding: u32 = 0x24600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=3 (condition CC/LO (carry clear))
#[test]
fn test_aarch32_strbt_a1_a_combo_3_0_34600000() {
    // Encoding: 0x34600000
    // Test aarch32_STRBT_A1_A field combination: cond=3, U=0, Rn=0, Rt=0, imm12=0
    // ISET: A32
    // Fields: U=0, imm12=0, Rt=0, cond=3, Rn=0
    let encoding: u32 = 0x34600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=4 (condition MI (minus/negative))
#[test]
fn test_aarch32_strbt_a1_a_combo_4_0_44600000() {
    // Encoding: 0x44600000
    // Test aarch32_STRBT_A1_A field combination: cond=4, U=0, Rn=0, Rt=0, imm12=0
    // ISET: A32
    // Fields: Rt=0, Rn=0, U=0, imm12=0, cond=4
    let encoding: u32 = 0x44600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=5 (condition PL (plus/positive))
#[test]
fn test_aarch32_strbt_a1_a_combo_5_0_54600000() {
    // Encoding: 0x54600000
    // Test aarch32_STRBT_A1_A field combination: cond=5, U=0, Rn=0, Rt=0, imm12=0
    // ISET: A32
    // Fields: U=0, Rn=0, cond=5, Rt=0, imm12=0
    let encoding: u32 = 0x54600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=6 (condition VS (overflow set))
#[test]
fn test_aarch32_strbt_a1_a_combo_6_0_64600000() {
    // Encoding: 0x64600000
    // Test aarch32_STRBT_A1_A field combination: cond=6, U=0, Rn=0, Rt=0, imm12=0
    // ISET: A32
    // Fields: U=0, imm12=0, Rn=0, Rt=0, cond=6
    let encoding: u32 = 0x64600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=7 (condition VC (overflow clear))
#[test]
fn test_aarch32_strbt_a1_a_combo_7_0_74600000() {
    // Encoding: 0x74600000
    // Test aarch32_STRBT_A1_A field combination: cond=7, U=0, Rn=0, Rt=0, imm12=0
    // ISET: A32
    // Fields: imm12=0, Rn=0, Rt=0, cond=7, U=0
    let encoding: u32 = 0x74600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=8 (condition HI (unsigned higher))
#[test]
fn test_aarch32_strbt_a1_a_combo_8_0_84600000() {
    // Encoding: 0x84600000
    // Test aarch32_STRBT_A1_A field combination: cond=8, U=0, Rn=0, Rt=0, imm12=0
    // ISET: A32
    // Fields: imm12=0, U=0, Rn=0, cond=8, Rt=0
    let encoding: u32 = 0x84600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=9 (condition LS (unsigned lower or same))
#[test]
fn test_aarch32_strbt_a1_a_combo_9_0_94600000() {
    // Encoding: 0x94600000
    // Test aarch32_STRBT_A1_A field combination: cond=9, U=0, Rn=0, Rt=0, imm12=0
    // ISET: A32
    // Fields: cond=9, Rt=0, imm12=0, U=0, Rn=0
    let encoding: u32 = 0x94600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=10 (condition GE (signed >=))
#[test]
fn test_aarch32_strbt_a1_a_combo_10_0_a4600000() {
    // Encoding: 0xA4600000
    // Test aarch32_STRBT_A1_A field combination: cond=10, U=0, Rn=0, Rt=0, imm12=0
    // ISET: A32
    // Fields: imm12=0, Rn=0, U=0, cond=10, Rt=0
    let encoding: u32 = 0xA4600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=11 (condition LT (signed <))
#[test]
fn test_aarch32_strbt_a1_a_combo_11_0_b4600000() {
    // Encoding: 0xB4600000
    // Test aarch32_STRBT_A1_A field combination: cond=11, U=0, Rn=0, Rt=0, imm12=0
    // ISET: A32
    // Fields: cond=11, U=0, Rt=0, imm12=0, Rn=0
    let encoding: u32 = 0xB4600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A1_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=12 (condition GT (signed >))
#[test]
fn test_aarch32_strbt_a1_a_combo_12_0_c4600000() {
    // Encoding: 0xC4600000
    // Test aarch32_STRBT_A1_A field combination: cond=12, U=0, Rn=0, Rt=0, imm12=0
    // ISET: A32
    // Fields: Rt=0, U=0, cond=12, imm12=0, Rn=0
    let encoding: u32 = 0xC4600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A1_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=13 (condition LE (signed <=))
#[test]
fn test_aarch32_strbt_a1_a_combo_13_0_d4600000() {
    // Encoding: 0xD4600000
    // Test aarch32_STRBT_A1_A field combination: cond=13, U=0, Rn=0, Rt=0, imm12=0
    // ISET: A32
    // Fields: cond=13, U=0, Rt=0, imm12=0, Rn=0
    let encoding: u32 = 0xD4600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A1_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=14 (condition AL (always))
#[test]
fn test_aarch32_strbt_a1_a_combo_14_0_e4600000() {
    // Encoding: 0xE4600000
    // Test aarch32_STRBT_A1_A field combination: cond=14, U=0, Rn=0, Rt=0, imm12=0
    // ISET: A32
    // Fields: cond=14, Rn=0, Rt=0, imm12=0, U=0
    let encoding: u32 = 0xE4600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A1_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=15 (condition NV (never, reserved))
#[test]
fn test_aarch32_strbt_a1_a_combo_15_0_f4600000() {
    // Encoding: 0xF4600000
    // Test aarch32_STRBT_A1_A field combination: cond=15, U=0, Rn=0, Rt=0, imm12=0
    // ISET: A32
    // Fields: Rn=0, U=0, imm12=0, cond=15, Rt=0
    let encoding: u32 = 0xF4600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A1_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=0 (minimum value)
#[test]
fn test_aarch32_strbt_a1_a_combo_16_0_04600000() {
    // Encoding: 0x04600000
    // Test aarch32_STRBT_A1_A field combination: cond=0, U=0, Rn=0, Rt=0, imm12=0
    // ISET: A32
    // Fields: cond=0, U=0, Rt=0, imm12=0, Rn=0
    let encoding: u32 = 0x04600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A1_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=1 (maximum value (1))
#[test]
fn test_aarch32_strbt_a1_a_combo_17_0_04e00000() {
    // Encoding: 0x04E00000
    // Test aarch32_STRBT_A1_A field combination: cond=0, U=1, Rn=0, Rt=0, imm12=0
    // ISET: A32
    // Fields: Rn=0, imm12=0, U=1, cond=0, Rt=0
    let encoding: u32 = 0x04E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A1_A
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_strbt_a1_a_combo_18_0_04600000() {
    // Encoding: 0x04600000
    // Test aarch32_STRBT_A1_A field combination: cond=0, U=0, Rn=0, Rt=0, imm12=0
    // ISET: A32
    // Fields: U=0, Rn=0, Rt=0, cond=0, imm12=0
    let encoding: u32 = 0x04600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A1_A
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_strbt_a1_a_combo_19_0_04610000() {
    // Encoding: 0x04610000
    // Test aarch32_STRBT_A1_A field combination: cond=0, U=0, Rn=1, Rt=0, imm12=0
    // ISET: A32
    // Fields: U=0, cond=0, imm12=0, Rt=0, Rn=1
    let encoding: u32 = 0x04610000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_strbt_a1_a_special_cond_0_condition_eq_0_04600000() {
    // Encoding: 0x04600000
    // Test aarch32_STRBT_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: Rt=0, cond=0, imm12=0, U=0, Rn=0
    let encoding: u32 = 0x04600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_strbt_a1_a_special_cond_1_condition_ne_0_14600000() {
    // Encoding: 0x14600000
    // Test aarch32_STRBT_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: Rn=0, imm12=0, U=0, Rt=0, cond=1
    let encoding: u32 = 0x14600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_strbt_a1_a_special_cond_2_condition_cs_hs_0_24600000() {
    // Encoding: 0x24600000
    // Test aarch32_STRBT_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: cond=2, U=0, Rt=0, Rn=0, imm12=0
    let encoding: u32 = 0x24600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_strbt_a1_a_special_cond_3_condition_cc_lo_0_34600000() {
    // Encoding: 0x34600000
    // Test aarch32_STRBT_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: Rn=0, cond=3, imm12=0, U=0, Rt=0
    let encoding: u32 = 0x34600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_strbt_a1_a_special_cond_4_condition_mi_0_44600000() {
    // Encoding: 0x44600000
    // Test aarch32_STRBT_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: imm12=0, U=0, cond=4, Rt=0, Rn=0
    let encoding: u32 = 0x44600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_strbt_a1_a_special_cond_5_condition_pl_0_54600000() {
    // Encoding: 0x54600000
    // Test aarch32_STRBT_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: Rt=0, cond=5, U=0, Rn=0, imm12=0
    let encoding: u32 = 0x54600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_strbt_a1_a_special_cond_6_condition_vs_0_64600000() {
    // Encoding: 0x64600000
    // Test aarch32_STRBT_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: cond=6, U=0, imm12=0, Rn=0, Rt=0
    let encoding: u32 = 0x64600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_strbt_a1_a_special_cond_7_condition_vc_0_74600000() {
    // Encoding: 0x74600000
    // Test aarch32_STRBT_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: U=0, Rn=0, cond=7, Rt=0, imm12=0
    let encoding: u32 = 0x74600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_strbt_a1_a_special_cond_8_condition_hi_0_84600000() {
    // Encoding: 0x84600000
    // Test aarch32_STRBT_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: imm12=0, Rt=0, cond=8, U=0, Rn=0
    let encoding: u32 = 0x84600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_strbt_a1_a_special_cond_9_condition_ls_0_94600000() {
    // Encoding: 0x94600000
    // Test aarch32_STRBT_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: Rn=0, Rt=0, imm12=0, cond=9, U=0
    let encoding: u32 = 0x94600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_strbt_a1_a_special_cond_10_condition_ge_0_a4600000() {
    // Encoding: 0xA4600000
    // Test aarch32_STRBT_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: Rn=0, Rt=0, U=0, cond=10, imm12=0
    let encoding: u32 = 0xA4600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_strbt_a1_a_special_cond_11_condition_lt_0_b4600000() {
    // Encoding: 0xB4600000
    // Test aarch32_STRBT_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: Rn=0, cond=11, imm12=0, U=0, Rt=0
    let encoding: u32 = 0xB4600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_strbt_a1_a_special_cond_12_condition_gt_0_c4600000() {
    // Encoding: 0xC4600000
    // Test aarch32_STRBT_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: imm12=0, U=0, Rn=0, cond=12, Rt=0
    let encoding: u32 = 0xC4600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_strbt_a1_a_special_cond_13_condition_le_0_d4600000() {
    // Encoding: 0xD4600000
    // Test aarch32_STRBT_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: U=0, cond=13, Rt=0, Rn=0, imm12=0
    let encoding: u32 = 0xD4600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_strbt_a1_a_special_cond_14_condition_al_0_e4600000() {
    // Encoding: 0xE4600000
    // Test aarch32_STRBT_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: cond=14, Rt=0, U=0, Rn=0, imm12=0
    let encoding: u32 = 0xE4600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_strbt_a1_a_special_cond_15_condition_nv_0_f4600000() {
    // Encoding: 0xF4600000
    // Test aarch32_STRBT_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: U=0, imm12=0, cond=15, Rt=0, Rn=0
    let encoding: u32 = 0xF4600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strbt_a1_a_invalid_0_0_04600000() {
    // Encoding: 0x04600000
    // Test aarch32_STRBT_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) }
    // ISET: A32
    // Fields: U=0, Rn=0, Rt=0, imm12=0, cond=0
    let encoding: u32 = 0x04600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STRBT_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strbt_a1_a_invalid_1_0_04600000() {
    // Encoding: 0x04600000
    // Test aarch32_STRBT_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Rn=0, cond=0, Rt=0, imm12=0, U=0
    let encoding: u32 = 0x04600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STRBT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_strbt_a2_a_field_cond_0_min_0_06600000() {
    // Encoding: 0x06600000
    // Test aarch32_STRBT_A2_A field cond = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, type1=0, cond=0, Rt=0, imm5=0, Rn=0, U=0
    let encoding: u32 = 0x06600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_strbt_a2_a_field_cond_1_poweroftwo_0_16600000() {
    // Encoding: 0x16600000
    // Test aarch32_STRBT_A2_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=1, Rm=0, imm5=0, Rn=0, type1=0, U=0, Rt=0
    let encoding: u32 = 0x16600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_strbt_a2_a_field_cond_2_poweroftwo_0_26600000() {
    // Encoding: 0x26600000
    // Test aarch32_STRBT_A2_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=2, Rn=0, Rt=0, U=0, imm5=0, type1=0, Rm=0
    let encoding: u32 = 0x26600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_strbt_a2_a_field_cond_3_poweroftwo_0_36600000() {
    // Encoding: 0x36600000
    // Test aarch32_STRBT_A2_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, U=0, cond=3, Rt=0, type1=0, imm5=0, Rn=0
    let encoding: u32 = 0x36600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_strbt_a2_a_field_cond_4_poweroftwo_0_46600000() {
    // Encoding: 0x46600000
    // Test aarch32_STRBT_A2_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, imm5=0, type1=0, Rn=0, Rm=0, cond=4, U=0
    let encoding: u32 = 0x46600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_strbt_a2_a_field_cond_5_poweroftwo_0_56600000() {
    // Encoding: 0x56600000
    // Test aarch32_STRBT_A2_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: imm5=0, Rt=0, Rn=0, U=0, type1=0, Rm=0, cond=5
    let encoding: u32 = 0x56600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_strbt_a2_a_field_cond_6_poweroftwo_0_66600000() {
    // Encoding: 0x66600000
    // Test aarch32_STRBT_A2_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=6, Rn=0, Rt=0, type1=0, Rm=0, U=0, imm5=0
    let encoding: u32 = 0x66600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_strbt_a2_a_field_cond_7_poweroftwo_0_76600000() {
    // Encoding: 0x76600000
    // Test aarch32_STRBT_A2_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: imm5=0, type1=0, Rm=0, cond=7, U=0, Rn=0, Rt=0
    let encoding: u32 = 0x76600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_strbt_a2_a_field_cond_8_poweroftwo_0_86600000() {
    // Encoding: 0x86600000
    // Test aarch32_STRBT_A2_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: imm5=0, Rm=0, type1=0, cond=8, U=0, Rn=0, Rt=0
    let encoding: u32 = 0x86600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_strbt_a2_a_field_cond_9_poweroftwo_0_96600000() {
    // Encoding: 0x96600000
    // Test aarch32_STRBT_A2_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, imm5=0, type1=0, Rm=0, Rn=0, cond=9, U=0
    let encoding: u32 = 0x96600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_strbt_a2_a_field_cond_10_poweroftwo_0_a6600000() {
    // Encoding: 0xA6600000
    // Test aarch32_STRBT_A2_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, imm5=0, U=0, Rn=0, cond=10, type1=0, Rm=0
    let encoding: u32 = 0xA6600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_strbt_a2_a_field_cond_11_poweroftwo_0_b6600000() {
    // Encoding: 0xB6600000
    // Test aarch32_STRBT_A2_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, U=0, imm5=0, type1=0, Rm=0, Rn=0, cond=11
    let encoding: u32 = 0xB6600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_strbt_a2_a_field_cond_12_poweroftwo_0_c6600000() {
    // Encoding: 0xC6600000
    // Test aarch32_STRBT_A2_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: type1=0, Rm=0, Rn=0, cond=12, U=0, imm5=0, Rt=0
    let encoding: u32 = 0xC6600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_strbt_a2_a_field_cond_13_poweroftwo_0_d6600000() {
    // Encoding: 0xD6600000
    // Test aarch32_STRBT_A2_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, Rm=0, imm5=0, U=0, cond=13, Rn=0, type1=0
    let encoding: u32 = 0xD6600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_strbt_a2_a_field_cond_14_poweroftwo_0_e6600000() {
    // Encoding: 0xE6600000
    // Test aarch32_STRBT_A2_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=14, Rt=0, imm5=0, type1=0, U=0, Rn=0, Rm=0
    let encoding: u32 = 0xE6600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_strbt_a2_a_field_cond_15_max_0_f6600000() {
    // Encoding: 0xF6600000
    // Test aarch32_STRBT_A2_A field cond = 15 (Max)
    // ISET: A32
    // Fields: Rt=0, type1=0, Rn=0, imm5=0, Rm=0, cond=15, U=0
    let encoding: u32 = 0xF6600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A2_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_strbt_a2_a_field_u_0_min_0_06600000() {
    // Encoding: 0x06600000
    // Test aarch32_STRBT_A2_A field U = 0 (Min)
    // ISET: A32
    // Fields: imm5=0, type1=0, Rn=0, U=0, cond=0, Rt=0, Rm=0
    let encoding: u32 = 0x06600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A2_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_strbt_a2_a_field_u_1_max_0_06e00000() {
    // Encoding: 0x06E00000
    // Test aarch32_STRBT_A2_A field U = 1 (Max)
    // ISET: A32
    // Fields: U=1, imm5=0, Rn=0, cond=0, type1=0, Rm=0, Rt=0
    let encoding: u32 = 0x06E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_strbt_a2_a_field_rn_0_min_0_06600000() {
    // Encoding: 0x06600000
    // Test aarch32_STRBT_A2_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: type1=0, Rn=0, Rm=0, imm5=0, cond=0, U=0, Rt=0
    let encoding: u32 = 0x06600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_strbt_a2_a_field_rn_1_poweroftwo_0_06610000() {
    // Encoding: 0x06610000
    // Test aarch32_STRBT_A2_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: imm5=0, type1=0, U=0, Rn=1, Rm=0, cond=0, Rt=0
    let encoding: u32 = 0x06610000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A2_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_strbt_a2_a_field_rt_0_min_0_06600000() {
    // Encoding: 0x06600000
    // Test aarch32_STRBT_A2_A field Rt = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, type1=0, U=0, Rt=0, imm5=0, Rm=0, cond=0
    let encoding: u32 = 0x06600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A2_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_strbt_a2_a_field_rt_1_poweroftwo_0_06601000() {
    // Encoding: 0x06601000
    // Test aarch32_STRBT_A2_A field Rt = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: imm5=0, Rt=1, U=0, cond=0, Rn=0, type1=0, Rm=0
    let encoding: u32 = 0x06601000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A2_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_strbt_a2_a_field_imm5_0_zero_0_06600000() {
    // Encoding: 0x06600000
    // Test aarch32_STRBT_A2_A field imm5 = 0 (Zero)
    // ISET: A32
    // Fields: type1=0, Rn=0, Rm=0, cond=0, U=0, imm5=0, Rt=0
    let encoding: u32 = 0x06600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A2_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_strbt_a2_a_field_imm5_1_poweroftwo_0_06600080() {
    // Encoding: 0x06600080
    // Test aarch32_STRBT_A2_A field imm5 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, Rn=0, cond=0, Rm=0, imm5=1, U=0, type1=0
    let encoding: u32 = 0x06600080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A2_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_strbt_a2_a_field_imm5_3_poweroftwominusone_0_06600180() {
    // Encoding: 0x06600180
    // Test aarch32_STRBT_A2_A field imm5 = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: U=0, Rm=0, cond=0, Rn=0, Rt=0, imm5=3, type1=0
    let encoding: u32 = 0x06600180;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A2_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_strbt_a2_a_field_imm5_4_poweroftwo_0_06600200() {
    // Encoding: 0x06600200
    // Test aarch32_STRBT_A2_A field imm5 = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: imm5=4, cond=0, U=0, Rn=0, type1=0, Rt=0, Rm=0
    let encoding: u32 = 0x06600200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A2_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_strbt_a2_a_field_imm5_7_poweroftwominusone_0_06600380() {
    // Encoding: 0x06600380
    // Test aarch32_STRBT_A2_A field imm5 = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rt=0, U=0, type1=0, Rm=0, imm5=7, cond=0, Rn=0
    let encoding: u32 = 0x06600380;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A2_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_strbt_a2_a_field_imm5_8_poweroftwo_0_06600400() {
    // Encoding: 0x06600400
    // Test aarch32_STRBT_A2_A field imm5 = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: type1=0, cond=0, Rm=0, U=0, Rn=0, Rt=0, imm5=8
    let encoding: u32 = 0x06600400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A2_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 15, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (15)
#[test]
fn test_aarch32_strbt_a2_a_field_imm5_15_poweroftwominusone_0_06600780() {
    // Encoding: 0x06600780
    // Test aarch32_STRBT_A2_A field imm5 = 15 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: U=0, Rm=0, Rt=0, cond=0, Rn=0, imm5=15, type1=0
    let encoding: u32 = 0x06600780;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A2_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_strbt_a2_a_field_imm5_16_poweroftwo_0_06600800() {
    // Encoding: 0x06600800
    // Test aarch32_STRBT_A2_A field imm5 = 16 (PowerOfTwo)
    // ISET: A32
    // Fields: imm5=16, cond=0, Rn=0, U=0, Rt=0, type1=0, Rm=0
    let encoding: u32 = 0x06600800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A2_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 31, boundary: Max }
/// maximum immediate (31)
#[test]
fn test_aarch32_strbt_a2_a_field_imm5_31_max_0_06600f80() {
    // Encoding: 0x06600F80
    // Test aarch32_STRBT_A2_A field imm5 = 31 (Max)
    // ISET: A32
    // Fields: Rn=0, cond=0, Rt=0, U=0, imm5=31, Rm=0, type1=0
    let encoding: u32 = 0x06600F80;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A2_A
/// ASL: `field type1 5 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_strbt_a2_a_field_type1_0_min_0_06600000() {
    // Encoding: 0x06600000
    // Test aarch32_STRBT_A2_A field type1 = 0 (Min)
    // ISET: A32
    // Fields: U=0, Rn=0, imm5=0, cond=0, Rt=0, type1=0, Rm=0
    let encoding: u32 = 0x06600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A2_A
/// ASL: `field type1 5 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_strbt_a2_a_field_type1_1_poweroftwo_0_06600020() {
    // Encoding: 0x06600020
    // Test aarch32_STRBT_A2_A field type1 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, Rm=0, type1=1, Rn=0, cond=0, Rt=0, imm5=0
    let encoding: u32 = 0x06600020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A2_A
/// ASL: `field type1 5 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_aarch32_strbt_a2_a_field_type1_3_max_0_06600060() {
    // Encoding: 0x06600060
    // Test aarch32_STRBT_A2_A field type1 = 3 (Max)
    // ISET: A32
    // Fields: Rm=0, cond=0, Rn=0, Rt=0, type1=3, U=0, imm5=0
    let encoding: u32 = 0x06600060;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_strbt_a2_a_field_rm_0_min_0_06600000() {
    // Encoding: 0x06600000
    // Test aarch32_STRBT_A2_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, Rn=0, U=0, cond=0, imm5=0, type1=0, Rt=0
    let encoding: u32 = 0x06600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_strbt_a2_a_field_rm_1_poweroftwo_0_06600001() {
    // Encoding: 0x06600001
    // Test aarch32_STRBT_A2_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: type1=0, U=0, Rn=0, imm5=0, Rt=0, Rm=1, cond=0
    let encoding: u32 = 0x06600001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A2_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_strbt_a2_a_combo_0_0_06600000() {
    // Encoding: 0x06600000
    // Test aarch32_STRBT_A2_A field combination: cond=0, U=0, Rn=0, Rt=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: cond=0, Rn=0, Rm=0, U=0, Rt=0, imm5=0, type1=0
    let encoding: u32 = 0x06600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A2_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=1 (condition NE (not equal))
#[test]
fn test_aarch32_strbt_a2_a_combo_1_0_16600000() {
    // Encoding: 0x16600000
    // Test aarch32_STRBT_A2_A field combination: cond=1, U=0, Rn=0, Rt=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: cond=1, Rn=0, Rm=0, Rt=0, U=0, imm5=0, type1=0
    let encoding: u32 = 0x16600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A2_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=2 (condition CS/HS (carry set))
#[test]
fn test_aarch32_strbt_a2_a_combo_2_0_26600000() {
    // Encoding: 0x26600000
    // Test aarch32_STRBT_A2_A field combination: cond=2, U=0, Rn=0, Rt=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: imm5=0, Rn=0, Rt=0, type1=0, cond=2, Rm=0, U=0
    let encoding: u32 = 0x26600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A2_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=3 (condition CC/LO (carry clear))
#[test]
fn test_aarch32_strbt_a2_a_combo_3_0_36600000() {
    // Encoding: 0x36600000
    // Test aarch32_STRBT_A2_A field combination: cond=3, U=0, Rn=0, Rt=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: cond=3, Rt=0, U=0, imm5=0, Rm=0, Rn=0, type1=0
    let encoding: u32 = 0x36600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A2_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=4 (condition MI (minus/negative))
#[test]
fn test_aarch32_strbt_a2_a_combo_4_0_46600000() {
    // Encoding: 0x46600000
    // Test aarch32_STRBT_A2_A field combination: cond=4, U=0, Rn=0, Rt=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: type1=0, Rm=0, cond=4, U=0, Rn=0, Rt=0, imm5=0
    let encoding: u32 = 0x46600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A2_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=5 (condition PL (plus/positive))
#[test]
fn test_aarch32_strbt_a2_a_combo_5_0_56600000() {
    // Encoding: 0x56600000
    // Test aarch32_STRBT_A2_A field combination: cond=5, U=0, Rn=0, Rt=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: Rn=0, cond=5, imm5=0, type1=0, Rm=0, Rt=0, U=0
    let encoding: u32 = 0x56600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A2_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=6 (condition VS (overflow set))
#[test]
fn test_aarch32_strbt_a2_a_combo_6_0_66600000() {
    // Encoding: 0x66600000
    // Test aarch32_STRBT_A2_A field combination: cond=6, U=0, Rn=0, Rt=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: imm5=0, type1=0, U=0, cond=6, Rn=0, Rt=0, Rm=0
    let encoding: u32 = 0x66600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A2_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=7 (condition VC (overflow clear))
#[test]
fn test_aarch32_strbt_a2_a_combo_7_0_76600000() {
    // Encoding: 0x76600000
    // Test aarch32_STRBT_A2_A field combination: cond=7, U=0, Rn=0, Rt=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: cond=7, type1=0, Rm=0, Rn=0, Rt=0, U=0, imm5=0
    let encoding: u32 = 0x76600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A2_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=8 (condition HI (unsigned higher))
#[test]
fn test_aarch32_strbt_a2_a_combo_8_0_86600000() {
    // Encoding: 0x86600000
    // Test aarch32_STRBT_A2_A field combination: cond=8, U=0, Rn=0, Rt=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: imm5=0, Rm=0, Rt=0, cond=8, U=0, type1=0, Rn=0
    let encoding: u32 = 0x86600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A2_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=9 (condition LS (unsigned lower or same))
#[test]
fn test_aarch32_strbt_a2_a_combo_9_0_96600000() {
    // Encoding: 0x96600000
    // Test aarch32_STRBT_A2_A field combination: cond=9, U=0, Rn=0, Rt=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: cond=9, Rm=0, U=0, Rn=0, Rt=0, imm5=0, type1=0
    let encoding: u32 = 0x96600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A2_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=10 (condition GE (signed >=))
#[test]
fn test_aarch32_strbt_a2_a_combo_10_0_a6600000() {
    // Encoding: 0xA6600000
    // Test aarch32_STRBT_A2_A field combination: cond=10, U=0, Rn=0, Rt=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: Rm=0, Rn=0, cond=10, type1=0, imm5=0, U=0, Rt=0
    let encoding: u32 = 0xA6600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A2_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=11 (condition LT (signed <))
#[test]
fn test_aarch32_strbt_a2_a_combo_11_0_b6600000() {
    // Encoding: 0xB6600000
    // Test aarch32_STRBT_A2_A field combination: cond=11, U=0, Rn=0, Rt=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: type1=0, Rm=0, imm5=0, Rt=0, Rn=0, cond=11, U=0
    let encoding: u32 = 0xB6600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A2_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=12 (condition GT (signed >))
#[test]
fn test_aarch32_strbt_a2_a_combo_12_0_c6600000() {
    // Encoding: 0xC6600000
    // Test aarch32_STRBT_A2_A field combination: cond=12, U=0, Rn=0, Rt=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: Rm=0, Rn=0, U=0, cond=12, Rt=0, type1=0, imm5=0
    let encoding: u32 = 0xC6600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A2_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=13 (condition LE (signed <=))
#[test]
fn test_aarch32_strbt_a2_a_combo_13_0_d6600000() {
    // Encoding: 0xD6600000
    // Test aarch32_STRBT_A2_A field combination: cond=13, U=0, Rn=0, Rt=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: Rm=0, Rt=0, cond=13, U=0, Rn=0, imm5=0, type1=0
    let encoding: u32 = 0xD6600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A2_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=14 (condition AL (always))
#[test]
fn test_aarch32_strbt_a2_a_combo_14_0_e6600000() {
    // Encoding: 0xE6600000
    // Test aarch32_STRBT_A2_A field combination: cond=14, U=0, Rn=0, Rt=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: imm5=0, Rt=0, U=0, cond=14, Rn=0, type1=0, Rm=0
    let encoding: u32 = 0xE6600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A2_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=15 (condition NV (never, reserved))
#[test]
fn test_aarch32_strbt_a2_a_combo_15_0_f6600000() {
    // Encoding: 0xF6600000
    // Test aarch32_STRBT_A2_A field combination: cond=15, U=0, Rn=0, Rt=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: cond=15, U=0, imm5=0, Rt=0, type1=0, Rm=0, Rn=0
    let encoding: u32 = 0xF6600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A2_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=0 (minimum value)
#[test]
fn test_aarch32_strbt_a2_a_combo_16_0_06600000() {
    // Encoding: 0x06600000
    // Test aarch32_STRBT_A2_A field combination: cond=0, U=0, Rn=0, Rt=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: U=0, Rn=0, cond=0, Rt=0, imm5=0, type1=0, Rm=0
    let encoding: u32 = 0x06600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A2_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=1 (maximum value (1))
#[test]
fn test_aarch32_strbt_a2_a_combo_17_0_06e00000() {
    // Encoding: 0x06E00000
    // Test aarch32_STRBT_A2_A field combination: cond=0, U=1, Rn=0, Rt=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: imm5=0, type1=0, Rm=0, U=1, cond=0, Rn=0, Rt=0
    let encoding: u32 = 0x06E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A2_A
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_strbt_a2_a_combo_18_0_06600000() {
    // Encoding: 0x06600000
    // Test aarch32_STRBT_A2_A field combination: cond=0, U=0, Rn=0, Rt=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: cond=0, imm5=0, type1=0, Rm=0, Rt=0, Rn=0, U=0
    let encoding: u32 = 0x06600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A2_A
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_strbt_a2_a_combo_19_0_06610000() {
    // Encoding: 0x06610000
    // Test aarch32_STRBT_A2_A field combination: cond=0, U=0, Rn=1, Rt=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: type1=0, Rm=0, cond=0, U=0, Rt=0, imm5=0, Rn=1
    let encoding: u32 = 0x06610000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A2_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_strbt_a2_a_special_cond_0_condition_eq_0_06600000() {
    // Encoding: 0x06600000
    // Test aarch32_STRBT_A2_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: U=0, cond=0, imm5=0, Rm=0, type1=0, Rt=0, Rn=0
    let encoding: u32 = 0x06600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A2_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_strbt_a2_a_special_cond_1_condition_ne_0_16600000() {
    // Encoding: 0x16600000
    // Test aarch32_STRBT_A2_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: Rt=0, type1=0, Rn=0, Rm=0, U=0, imm5=0, cond=1
    let encoding: u32 = 0x16600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A2_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_strbt_a2_a_special_cond_2_condition_cs_hs_0_26600000() {
    // Encoding: 0x26600000
    // Test aarch32_STRBT_A2_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: cond=2, Rn=0, Rt=0, U=0, imm5=0, type1=0, Rm=0
    let encoding: u32 = 0x26600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A2_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_strbt_a2_a_special_cond_3_condition_cc_lo_0_36600000() {
    // Encoding: 0x36600000
    // Test aarch32_STRBT_A2_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: Rn=0, imm5=0, Rm=0, Rt=0, type1=0, cond=3, U=0
    let encoding: u32 = 0x36600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A2_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_strbt_a2_a_special_cond_4_condition_mi_0_46600000() {
    // Encoding: 0x46600000
    // Test aarch32_STRBT_A2_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: Rm=0, U=0, Rt=0, imm5=0, Rn=0, cond=4, type1=0
    let encoding: u32 = 0x46600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A2_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_strbt_a2_a_special_cond_5_condition_pl_0_56600000() {
    // Encoding: 0x56600000
    // Test aarch32_STRBT_A2_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: cond=5, Rn=0, imm5=0, type1=0, Rm=0, Rt=0, U=0
    let encoding: u32 = 0x56600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A2_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_strbt_a2_a_special_cond_6_condition_vs_0_66600000() {
    // Encoding: 0x66600000
    // Test aarch32_STRBT_A2_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: U=0, cond=6, imm5=0, type1=0, Rt=0, Rn=0, Rm=0
    let encoding: u32 = 0x66600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A2_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_strbt_a2_a_special_cond_7_condition_vc_0_76600000() {
    // Encoding: 0x76600000
    // Test aarch32_STRBT_A2_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: cond=7, Rt=0, imm5=0, type1=0, U=0, Rm=0, Rn=0
    let encoding: u32 = 0x76600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A2_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_strbt_a2_a_special_cond_8_condition_hi_0_86600000() {
    // Encoding: 0x86600000
    // Test aarch32_STRBT_A2_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: cond=8, Rt=0, imm5=0, type1=0, Rm=0, U=0, Rn=0
    let encoding: u32 = 0x86600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A2_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_strbt_a2_a_special_cond_9_condition_ls_0_96600000() {
    // Encoding: 0x96600000
    // Test aarch32_STRBT_A2_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: type1=0, Rt=0, Rn=0, Rm=0, cond=9, U=0, imm5=0
    let encoding: u32 = 0x96600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A2_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_strbt_a2_a_special_cond_10_condition_ge_0_a6600000() {
    // Encoding: 0xA6600000
    // Test aarch32_STRBT_A2_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: cond=10, U=0, Rn=0, Rt=0, imm5=0, type1=0, Rm=0
    let encoding: u32 = 0xA6600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A2_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_strbt_a2_a_special_cond_11_condition_lt_0_b6600000() {
    // Encoding: 0xB6600000
    // Test aarch32_STRBT_A2_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: Rm=0, U=0, cond=11, imm5=0, Rn=0, Rt=0, type1=0
    let encoding: u32 = 0xB6600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A2_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_strbt_a2_a_special_cond_12_condition_gt_0_c6600000() {
    // Encoding: 0xC6600000
    // Test aarch32_STRBT_A2_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: Rn=0, imm5=0, Rt=0, cond=12, U=0, type1=0, Rm=0
    let encoding: u32 = 0xC6600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A2_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_strbt_a2_a_special_cond_13_condition_le_0_d6600000() {
    // Encoding: 0xD6600000
    // Test aarch32_STRBT_A2_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: Rm=0, cond=13, U=0, Rn=0, Rt=0, imm5=0, type1=0
    let encoding: u32 = 0xD6600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A2_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_strbt_a2_a_special_cond_14_condition_al_0_e6600000() {
    // Encoding: 0xE6600000
    // Test aarch32_STRBT_A2_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: Rm=0, cond=14, Rn=0, U=0, imm5=0, type1=0, Rt=0
    let encoding: u32 = 0xE6600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A2_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_strbt_a2_a_special_cond_15_condition_nv_0_f6600000() {
    // Encoding: 0xF6600000
    // Test aarch32_STRBT_A2_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: Rt=0, type1=0, cond=15, Rm=0, Rn=0, imm5=0, U=0
    let encoding: u32 = 0xF6600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRBT_A2_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strbt_a2_a_invalid_0_0_06600000() {
    // Encoding: 0x06600000
    // Test aarch32_STRBT_A2_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }
    // ISET: A32
    // Fields: cond=0, Rm=0, Rn=0, imm5=0, Rt=0, type1=0, U=0
    let encoding: u32 = 0x06600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STRBT_A2_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strbt_a2_a_invalid_1_0_06600000() {
    // Encoding: 0x06600000
    // Test aarch32_STRBT_A2_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: type1=0, Rm=0, Rt=0, Rn=0, imm5=0, U=0, cond=0
    let encoding: u32 = 0x06600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STRBT_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_strbt_t1_a_field_rn_0_min_e00_f8000e00() {
    // Thumb encoding (32): 0xF8000E00
    // Test aarch32_STRBT_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8000E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRBT_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_strbt_t1_a_field_rn_1_poweroftwo_e00_f8010e00() {
    // Thumb encoding (32): 0xF8010E00
    // Test aarch32_STRBT_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, imm8=0, Rn=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8010E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRBT_T1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_strbt_t1_a_field_rt_0_min_e00_f8000e00() {
    // Thumb encoding (32): 0xF8000E00
    // Test aarch32_STRBT_T1_A field Rt = 0 (Min)
    // ISET: T32
    // Fields: imm8=0, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8000E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRBT_T1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_strbt_t1_a_field_rt_1_poweroftwo_e00_f8001e00() {
    // Thumb encoding (32): 0xF8001E00
    // Test aarch32_STRBT_T1_A field Rt = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=1, imm8=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8001E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRBT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_strbt_t1_a_field_imm8_0_zero_e00_f8000e00() {
    // Thumb encoding (32): 0xF8000E00
    // Test aarch32_STRBT_T1_A field imm8 = 0 (Zero)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8000E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRBT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_strbt_t1_a_field_imm8_1_poweroftwo_e00_f8000e01() {
    // Thumb encoding (32): 0xF8000E01
    // Test aarch32_STRBT_T1_A field imm8 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm8=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8000E01;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRBT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_strbt_t1_a_field_imm8_3_poweroftwominusone_e00_f8000e03() {
    // Thumb encoding (32): 0xF8000E03
    // Test aarch32_STRBT_T1_A field imm8 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm8=3
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8000E03;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRBT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_strbt_t1_a_field_imm8_4_poweroftwo_e00_f8000e04() {
    // Thumb encoding (32): 0xF8000E04
    // Test aarch32_STRBT_T1_A field imm8 = 4 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=4, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8000E04;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRBT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_strbt_t1_a_field_imm8_7_poweroftwominusone_e00_f8000e07() {
    // Thumb encoding (32): 0xF8000E07
    // Test aarch32_STRBT_T1_A field imm8 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm8=7, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8000E07;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRBT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_strbt_t1_a_field_imm8_8_poweroftwo_e00_f8000e08() {
    // Thumb encoding (32): 0xF8000E08
    // Test aarch32_STRBT_T1_A field imm8 = 8 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, imm8=8, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8000E08;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRBT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_strbt_t1_a_field_imm8_15_poweroftwominusone_e00_f8000e0f() {
    // Thumb encoding (32): 0xF8000E0F
    // Test aarch32_STRBT_T1_A field imm8 = 15 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm8=15, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8000E0F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRBT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_strbt_t1_a_field_imm8_16_poweroftwo_e00_f8000e10() {
    // Thumb encoding (32): 0xF8000E10
    // Test aarch32_STRBT_T1_A field imm8 = 16 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm8=16
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8000E10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRBT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_strbt_t1_a_field_imm8_31_poweroftwominusone_e00_f8000e1f() {
    // Thumb encoding (32): 0xF8000E1F
    // Test aarch32_STRBT_T1_A field imm8 = 31 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm8=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8000E1F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRBT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_strbt_t1_a_field_imm8_32_poweroftwo_e00_f8000e20() {
    // Thumb encoding (32): 0xF8000E20
    // Test aarch32_STRBT_T1_A field imm8 = 32 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=32, Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8000E20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRBT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_strbt_t1_a_field_imm8_63_poweroftwominusone_e00_f8000e3f() {
    // Thumb encoding (32): 0xF8000E3F
    // Test aarch32_STRBT_T1_A field imm8 = 63 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm8=63, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8000E3F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRBT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_strbt_t1_a_field_imm8_64_poweroftwo_e00_f8000e40() {
    // Thumb encoding (32): 0xF8000E40
    // Test aarch32_STRBT_T1_A field imm8 = 64 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=64, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8000E40;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRBT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 127, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (127)
#[test]
fn test_aarch32_strbt_t1_a_field_imm8_127_poweroftwominusone_e00_f8000e7f() {
    // Thumb encoding (32): 0xF8000E7F
    // Test aarch32_STRBT_T1_A field imm8 = 127 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm8=127, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8000E7F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRBT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_strbt_t1_a_field_imm8_128_poweroftwo_e00_f8000e80() {
    // Thumb encoding (32): 0xF8000E80
    // Test aarch32_STRBT_T1_A field imm8 = 128 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, imm8=128, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8000E80;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRBT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 255, boundary: Max }
/// maximum immediate (255)
#[test]
fn test_aarch32_strbt_t1_a_field_imm8_255_max_e00_f8000eff() {
    // Thumb encoding (32): 0xF8000EFF
    // Test aarch32_STRBT_T1_A field imm8 = 255 (Max)
    // ISET: T32
    // Fields: imm8=255, Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8000EFF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRBT_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_strbt_t1_a_combo_0_e00_f8000e00() {
    // Thumb encoding (32): 0xF8000E00
    // Test aarch32_STRBT_T1_A field combination: Rn=0, Rt=0, imm8=0
    // ISET: T32
    // Fields: imm8=0, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8000E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRBT_T1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_strbt_t1_a_combo_1_e00_f8010e00() {
    // Thumb encoding (32): 0xF8010E00
    // Test aarch32_STRBT_T1_A field combination: Rn=1, Rt=0, imm8=0
    // ISET: T32
    // Fields: Rn=1, Rt=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8010E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRBT_T1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=0 (register index 0 (first register))
#[test]
fn test_aarch32_strbt_t1_a_combo_2_e00_f8000e00() {
    // Thumb encoding (32): 0xF8000E00
    // Test aarch32_STRBT_T1_A field combination: Rn=0, Rt=0, imm8=0
    // ISET: T32
    // Fields: Rt=0, Rn=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8000E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRBT_T1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=1 (register index 1 (second register))
#[test]
fn test_aarch32_strbt_t1_a_combo_3_e00_f8001e00() {
    // Thumb encoding (32): 0xF8001E00
    // Test aarch32_STRBT_T1_A field combination: Rn=0, Rt=1, imm8=0
    // ISET: T32
    // Fields: Rn=0, imm8=0, Rt=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8001E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRBT_T1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=0 (immediate value 0)
#[test]
fn test_aarch32_strbt_t1_a_combo_4_e00_f8000e00() {
    // Thumb encoding (32): 0xF8000E00
    // Test aarch32_STRBT_T1_A field combination: Rn=0, Rt=0, imm8=0
    // ISET: T32
    // Fields: Rn=0, imm8=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8000E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRBT_T1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=1 (immediate value 1)
#[test]
fn test_aarch32_strbt_t1_a_combo_5_e00_f8000e01() {
    // Thumb encoding (32): 0xF8000E01
    // Test aarch32_STRBT_T1_A field combination: Rn=0, Rt=0, imm8=1
    // ISET: T32
    // Fields: Rn=0, imm8=1, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8000E01;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRBT_T1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=3 (2^2 - 1 = 3)
#[test]
fn test_aarch32_strbt_t1_a_combo_6_e00_f8000e03() {
    // Thumb encoding (32): 0xF8000E03
    // Test aarch32_STRBT_T1_A field combination: Rn=0, Rt=0, imm8=3
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm8=3
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8000E03;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRBT_T1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=4 (power of 2 (2^2 = 4))
#[test]
fn test_aarch32_strbt_t1_a_combo_7_e00_f8000e04() {
    // Thumb encoding (32): 0xF8000E04
    // Test aarch32_STRBT_T1_A field combination: Rn=0, Rt=0, imm8=4
    // ISET: T32
    // Fields: imm8=4, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8000E04;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRBT_T1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=7 (2^3 - 1 = 7)
#[test]
fn test_aarch32_strbt_t1_a_combo_8_e00_f8000e07() {
    // Thumb encoding (32): 0xF8000E07
    // Test aarch32_STRBT_T1_A field combination: Rn=0, Rt=0, imm8=7
    // ISET: T32
    // Fields: imm8=7, Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8000E07;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRBT_T1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=8 (power of 2 (2^3 = 8))
#[test]
fn test_aarch32_strbt_t1_a_combo_9_e00_f8000e08() {
    // Thumb encoding (32): 0xF8000E08
    // Test aarch32_STRBT_T1_A field combination: Rn=0, Rt=0, imm8=8
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm8=8
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8000E08;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRBT_T1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=15 (2^4 - 1 = 15)
#[test]
fn test_aarch32_strbt_t1_a_combo_10_e00_f8000e0f() {
    // Thumb encoding (32): 0xF8000E0F
    // Test aarch32_STRBT_T1_A field combination: Rn=0, Rt=0, imm8=15
    // ISET: T32
    // Fields: Rt=0, imm8=15, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8000E0F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRBT_T1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=16 (power of 2 (2^4 = 16))
#[test]
fn test_aarch32_strbt_t1_a_combo_11_e00_f8000e10() {
    // Thumb encoding (32): 0xF8000E10
    // Test aarch32_STRBT_T1_A field combination: Rn=0, Rt=0, imm8=16
    // ISET: T32
    // Fields: Rt=0, imm8=16, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8000E10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRBT_T1_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=31 (2^5 - 1 = 31)
#[test]
fn test_aarch32_strbt_t1_a_combo_12_e00_f8000e1f() {
    // Thumb encoding (32): 0xF8000E1F
    // Test aarch32_STRBT_T1_A field combination: Rn=0, Rt=0, imm8=31
    // ISET: T32
    // Fields: Rt=0, Rn=0, imm8=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8000E1F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRBT_T1_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=32 (power of 2 (2^5 = 32))
#[test]
fn test_aarch32_strbt_t1_a_combo_13_e00_f8000e20() {
    // Thumb encoding (32): 0xF8000E20
    // Test aarch32_STRBT_T1_A field combination: Rn=0, Rt=0, imm8=32
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm8=32
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8000E20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRBT_T1_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=63 (2^6 - 1 = 63)
#[test]
fn test_aarch32_strbt_t1_a_combo_14_e00_f8000e3f() {
    // Thumb encoding (32): 0xF8000E3F
    // Test aarch32_STRBT_T1_A field combination: Rn=0, Rt=0, imm8=63
    // ISET: T32
    // Fields: Rt=0, Rn=0, imm8=63
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8000E3F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRBT_T1_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=64 (power of 2 (2^6 = 64))
#[test]
fn test_aarch32_strbt_t1_a_combo_15_e00_f8000e40() {
    // Thumb encoding (32): 0xF8000E40
    // Test aarch32_STRBT_T1_A field combination: Rn=0, Rt=0, imm8=64
    // ISET: T32
    // Fields: imm8=64, Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8000E40;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRBT_T1_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=127 (immediate midpoint (127))
#[test]
fn test_aarch32_strbt_t1_a_combo_16_e00_f8000e7f() {
    // Thumb encoding (32): 0xF8000E7F
    // Test aarch32_STRBT_T1_A field combination: Rn=0, Rt=0, imm8=127
    // ISET: T32
    // Fields: imm8=127, Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8000E7F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRBT_T1_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=128 (power of 2 (2^7 = 128))
#[test]
fn test_aarch32_strbt_t1_a_combo_17_e00_f8000e80() {
    // Thumb encoding (32): 0xF8000E80
    // Test aarch32_STRBT_T1_A field combination: Rn=0, Rt=0, imm8=128
    // ISET: T32
    // Fields: Rn=0, imm8=128, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8000E80;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRBT_T1_A
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=255 (maximum immediate (255))
#[test]
fn test_aarch32_strbt_t1_a_combo_18_e00_f8000eff() {
    // Thumb encoding (32): 0xF8000EFF
    // Test aarch32_STRBT_T1_A field combination: Rn=0, Rt=0, imm8=255
    // ISET: T32
    // Fields: Rt=0, imm8=255, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8000EFF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRBT_T1_A
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rt=1 (same register test (reg=1))
#[test]
fn test_aarch32_strbt_t1_a_combo_19_e00_f8011e00() {
    // Thumb encoding (32): 0xF8011E00
    // Test aarch32_STRBT_T1_A field combination: Rn=1, Rt=1, imm8=0
    // ISET: T32
    // Fields: imm8=0, Rn=1, Rt=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8011E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRBT_T1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rn" }), rhs: LitBits([true, true, true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Rn\" }), rhs: LitBits([true, true, true, true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_strbt_t1_a_invalid_0_e00_f8000e00() {
    // Thumb encoding (32): 0xF8000E00
    // Test aarch32_STRBT_T1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rn" }), rhs: LitBits([true, true, true, true]) }
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8000E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_STRBT_T1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_strbt_t1_a_invalid_1_e00_f8000e00() {
    // Thumb encoding (32): 0xF8000E00
    // Test aarch32_STRBT_T1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: Rt=0, imm8=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8000E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_STRBT_T1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strbt_t1_a_invalid_2_e00_f8000e00() {
    // Thumb encoding (32): 0xF8000E00
    // Test aarch32_STRBT_T1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: LitInt(15) }
    // ISET: T32
    // Fields: imm8=0, Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8000E00;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_STRBT_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strbt_t1_a_invalid_3_e00_f8000e00() {
    // Thumb encoding (32): 0xF8000E00
    // Test aarch32_STRBT_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rt=0, Rn=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8000E00;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_STRBT_A1_A
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strbt_a1_a_exception_0_04600000() {
    // Test aarch32_STRBT_A1_A exception: Unpredictable
    // Encoding: 0x04600000
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04600000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_STRBT_A2_A
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strbt_a2_a_exception_0_06600000() {
    // Test aarch32_STRBT_A2_A exception: Unpredictable
    // Encoding: 0x06600000
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x06600000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_STRBT_T1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple multiply (32)
#[test]
fn test_aarch32_strbt_t1_a_mul_oracle_32_0_1b027c20() {
    // Test MUL 32-bit: simple multiply (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x2);
    set_w(&mut cpu, 2, 0x3);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6, "W0 should be 0x00000006");
}

/// Provenance: aarch32_STRBT_T1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple multiply (64)
#[test]
fn test_aarch32_strbt_t1_a_mul_oracle_64_0_9b027c20() {
    // Test MUL 64-bit: simple multiply (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x2);
    set_w(&mut cpu, 2, 0x3);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6, "X0 should be 0x0000000000000006");
}

/// Provenance: aarch32_STRBT_T1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// multiply by zero (32)
#[test]
fn test_aarch32_strbt_t1_a_mul_oracle_32_1_1b027c20() {
    // Test MUL 32-bit: multiply by zero (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x64);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_STRBT_T1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// multiply by zero (64)
#[test]
fn test_aarch32_strbt_t1_a_mul_oracle_64_1_9b027c20() {
    // Test MUL 64-bit: multiply by zero (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x64);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_STRBT_T1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// multiply by one (32)
#[test]
fn test_aarch32_strbt_t1_a_mul_oracle_32_2_1b027c20() {
    // Test MUL 32-bit: multiply by one (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_STRBT_T1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// multiply by one (64)
#[test]
fn test_aarch32_strbt_t1_a_mul_oracle_64_2_9b027c20() {
    // Test MUL 64-bit: multiply by one (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x0000000000000001");
}

/// Provenance: aarch32_STRBT_T1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// 16-bit max * 16-bit max (32)
#[test]
fn test_aarch32_strbt_t1_a_mul_oracle_32_3_1b027c20() {
    // Test MUL 32-bit: 16-bit max * 16-bit max (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFF);
    set_w(&mut cpu, 2, 0xFFFF);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFE0001, "W0 should be 0xFFFE0001");
}

/// Provenance: aarch32_STRBT_T1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// 16-bit max * 16-bit max (64)
#[test]
fn test_aarch32_strbt_t1_a_mul_oracle_64_3_9b027c20() {
    // Test MUL 64-bit: 16-bit max * 16-bit max (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFF);
    set_w(&mut cpu, 2, 0xFFFF);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFE0001, "X0 should be 0x00000000FFFE0001");
}

/// Provenance: aarch32_STRBT_T1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift-like multiply (32)
#[test]
fn test_aarch32_strbt_t1_a_mul_oracle_32_4_1b027c20() {
    // Test MUL 32-bit: shift-like multiply (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x2468ACF0, "W0 should be 0x2468ACF0");
}

/// Provenance: aarch32_STRBT_T1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift-like multiply (64)
#[test]
fn test_aarch32_strbt_t1_a_mul_oracle_64_4_9b027c20() {
    // Test MUL 64-bit: shift-like multiply (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x2468ACF0, "X0 should be 0x000000002468ACF0");
}

/// Provenance: aarch32_STRBT_T1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// larger values (32)
#[test]
fn test_aarch32_strbt_t1_a_mul_oracle_32_5_1b027c20() {
    // Test MUL 32-bit: larger values (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0xC8);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4E20, "W0 should be 0x00004E20");
}

/// Provenance: aarch32_STRBT_T1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// larger values (64)
#[test]
fn test_aarch32_strbt_t1_a_mul_oracle_64_5_9b027c20() {
    // Test MUL 64-bit: larger values (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0xC8);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4E20, "X0 should be 0x0000000000004E20");
}

/// Provenance: aarch32_STRBT_T1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// 32-bit overflow (32)
#[test]
fn test_aarch32_strbt_t1_a_mul_oracle_32_6_1b027c20() {
    // Test MUL 32-bit: 32-bit overflow (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_STRBT_T1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// 32-bit overflow (64)
#[test]
fn test_aarch32_strbt_t1_a_mul_oracle_64_6_9b027c20() {
    // Test MUL 64-bit: 32-bit overflow (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0xFFFFFFFE00000001");
}

/// Provenance: aarch32_STRBT_T1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// prime numbers (32)
#[test]
fn test_aarch32_strbt_t1_a_mul_oracle_32_7_1b027c20() {
    // Test MUL 32-bit: prime numbers (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xB);
    set_w(&mut cpu, 1, 0x7);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4D, "W0 should be 0x0000004D");
}

/// Provenance: aarch32_STRBT_T1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// prime numbers (64)
#[test]
fn test_aarch32_strbt_t1_a_mul_oracle_64_7_9b027c20() {
    // Test MUL 64-bit: prime numbers (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7);
    set_w(&mut cpu, 2, 0xB);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4D, "X0 should be 0x000000000000004D");
}

/// Provenance: aarch32_STRBT_T1_A
/// ASL: `MUL R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple values
#[test]
fn test_aarch32_strbt_t1_a_t32_oracle_0_f8010e00() {
    // Test T32 MUL: simple values (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x32);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF8010E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1388, "R0 should be 0x00001388");
}

/// Provenance: aarch32_STRBT_T1_A
/// ASL: `MUL R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero values
#[test]
fn test_aarch32_strbt_t1_a_t32_oracle_1_f8010e00() {
    // Test T32 MUL: zero values (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF8010E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_STRBT_T1_A
/// ASL: `MUL R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max value
#[test]
fn test_aarch32_strbt_t1_a_t32_oracle_2_f8010e00() {
    // Test T32 MUL: max value (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0xF8010E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "R0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_STRBT_T1_A
/// ASL: `MUL R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// mixed pattern
#[test]
fn test_aarch32_strbt_t1_a_t32_oracle_3_f8010e00() {
    // Test T32 MUL: mixed pattern (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0xABCDEF01);
    let encoding: u32 = 0xF8010E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x55065E78, "R0 should be 0x55065E78");
}

/// Provenance: aarch32_STRBT_T1_A
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strbt_t1_a_exception_0_f8000e00() {
    // Test aarch32_STRBT_T1_A exception: Unpredictable
    // ISET: T32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF8000E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// aarch32_STREXD_A Tests
// ============================================================================

/// Provenance: aarch32_STREXD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_strexd_a1_a_field_cond_0_min_390_01a00390() {
    // Encoding: 0x01A00390
    // Test aarch32_STREXD_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=0, Rd=0
    let encoding: u32 = 0x01A00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_strexd_a1_a_field_cond_1_poweroftwo_390_11a00390() {
    // Encoding: 0x11A00390
    // Test aarch32_STREXD_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=1, Rn=0, Rt=0, Rd=0
    let encoding: u32 = 0x11A00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_strexd_a1_a_field_cond_2_poweroftwo_390_21a00390() {
    // Encoding: 0x21A00390
    // Test aarch32_STREXD_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=2, Rd=0, Rt=0, Rn=0
    let encoding: u32 = 0x21A00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_strexd_a1_a_field_cond_3_poweroftwo_390_31a00390() {
    // Encoding: 0x31A00390
    // Test aarch32_STREXD_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, cond=3, Rt=0, Rn=0
    let encoding: u32 = 0x31A00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_strexd_a1_a_field_cond_4_poweroftwo_390_41a00390() {
    // Encoding: 0x41A00390
    // Test aarch32_STREXD_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=4, Rt=0, Rd=0, Rn=0
    let encoding: u32 = 0x41A00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_strexd_a1_a_field_cond_5_poweroftwo_390_51a00390() {
    // Encoding: 0x51A00390
    // Test aarch32_STREXD_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, Rd=0, Rn=0, cond=5
    let encoding: u32 = 0x51A00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_strexd_a1_a_field_cond_6_poweroftwo_390_61a00390() {
    // Encoding: 0x61A00390
    // Test aarch32_STREXD_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=6, Rn=0, Rd=0, Rt=0
    let encoding: u32 = 0x61A00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_strexd_a1_a_field_cond_7_poweroftwo_390_71a00390() {
    // Encoding: 0x71A00390
    // Test aarch32_STREXD_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rt=0, cond=7, Rn=0
    let encoding: u32 = 0x71A00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_strexd_a1_a_field_cond_8_poweroftwo_390_81a00390() {
    // Encoding: 0x81A00390
    // Test aarch32_STREXD_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rn=0, Rt=0, cond=8
    let encoding: u32 = 0x81A00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_strexd_a1_a_field_cond_9_poweroftwo_390_91a00390() {
    // Encoding: 0x91A00390
    // Test aarch32_STREXD_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=9, Rt=0, Rd=0, Rn=0
    let encoding: u32 = 0x91A00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_strexd_a1_a_field_cond_10_poweroftwo_390_a1a00390() {
    // Encoding: 0xA1A00390
    // Test aarch32_STREXD_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=10, Rn=0, Rd=0, Rt=0
    let encoding: u32 = 0xA1A00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_strexd_a1_a_field_cond_11_poweroftwo_390_b1a00390() {
    // Encoding: 0xB1A00390
    // Test aarch32_STREXD_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, cond=11, Rn=0, Rd=0
    let encoding: u32 = 0xB1A00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_strexd_a1_a_field_cond_12_poweroftwo_390_c1a00390() {
    // Encoding: 0xC1A00390
    // Test aarch32_STREXD_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=12, Rd=0, Rt=0
    let encoding: u32 = 0xC1A00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_strexd_a1_a_field_cond_13_poweroftwo_390_d1a00390() {
    // Encoding: 0xD1A00390
    // Test aarch32_STREXD_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=13, Rt=0, Rn=0, Rd=0
    let encoding: u32 = 0xD1A00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_strexd_a1_a_field_cond_14_poweroftwo_390_e1a00390() {
    // Encoding: 0xE1A00390
    // Test aarch32_STREXD_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=14, Rd=0, Rt=0, Rn=0
    let encoding: u32 = 0xE1A00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_strexd_a1_a_field_cond_15_max_390_f1a00390() {
    // Encoding: 0xF1A00390
    // Test aarch32_STREXD_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: cond=15, Rn=0, Rd=0, Rt=0
    let encoding: u32 = 0xF1A00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXD_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_strexd_a1_a_field_rn_0_min_390_01a00390() {
    // Encoding: 0x01A00390
    // Test aarch32_STREXD_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: Rt=0, Rd=0, cond=0, Rn=0
    let encoding: u32 = 0x01A00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXD_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_strexd_a1_a_field_rn_1_poweroftwo_390_01a10390() {
    // Encoding: 0x01A10390
    // Test aarch32_STREXD_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=1, Rd=0, Rt=0, cond=0
    let encoding: u32 = 0x01A10390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXD_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_strexd_a1_a_field_rd_0_min_390_01a00390() {
    // Encoding: 0x01A00390
    // Test aarch32_STREXD_A1_A field Rd = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rd=0, Rn=0, Rt=0
    let encoding: u32 = 0x01A00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXD_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_strexd_a1_a_field_rd_1_poweroftwo_390_01a01390() {
    // Encoding: 0x01A01390
    // Test aarch32_STREXD_A1_A field Rd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, Rn=0, Rd=1, cond=0
    let encoding: u32 = 0x01A01390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXD_A1_A
/// ASL: `field Rt 0 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_strexd_a1_a_field_rt_0_min_390_01a00390() {
    // Encoding: 0x01A00390
    // Test aarch32_STREXD_A1_A field Rt = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, Rd=0, Rt=0, cond=0
    let encoding: u32 = 0x01A00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXD_A1_A
/// ASL: `field Rt 0 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_strexd_a1_a_field_rt_1_poweroftwo_390_01a00391() {
    // Encoding: 0x01A00391
    // Test aarch32_STREXD_A1_A field Rt = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=0, Rd=0, Rt=1
    let encoding: u32 = 0x01A00391;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXD_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_strexd_a1_a_combo_0_390_01a00390() {
    // Encoding: 0x01A00390
    // Test aarch32_STREXD_A1_A field combination: cond=0, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: cond=0, Rd=0, Rn=0, Rt=0
    let encoding: u32 = 0x01A00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXD_A1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=1 (condition NE (not equal))
#[test]
fn test_aarch32_strexd_a1_a_combo_1_390_11a00390() {
    // Encoding: 0x11A00390
    // Test aarch32_STREXD_A1_A field combination: cond=1, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rt=0, Rd=0, cond=1, Rn=0
    let encoding: u32 = 0x11A00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXD_A1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=2 (condition CS/HS (carry set))
#[test]
fn test_aarch32_strexd_a1_a_combo_2_390_21a00390() {
    // Encoding: 0x21A00390
    // Test aarch32_STREXD_A1_A field combination: cond=2, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rt=0, cond=2, Rn=0, Rd=0
    let encoding: u32 = 0x21A00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXD_A1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=3 (condition CC/LO (carry clear))
#[test]
fn test_aarch32_strexd_a1_a_combo_3_390_31a00390() {
    // Encoding: 0x31A00390
    // Test aarch32_STREXD_A1_A field combination: cond=3, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: cond=3, Rt=0, Rn=0, Rd=0
    let encoding: u32 = 0x31A00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXD_A1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=4 (condition MI (minus/negative))
#[test]
fn test_aarch32_strexd_a1_a_combo_4_390_41a00390() {
    // Encoding: 0x41A00390
    // Test aarch32_STREXD_A1_A field combination: cond=4, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: cond=4, Rn=0, Rd=0, Rt=0
    let encoding: u32 = 0x41A00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXD_A1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=5 (condition PL (plus/positive))
#[test]
fn test_aarch32_strexd_a1_a_combo_5_390_51a00390() {
    // Encoding: 0x51A00390
    // Test aarch32_STREXD_A1_A field combination: cond=5, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: cond=5, Rn=0, Rd=0, Rt=0
    let encoding: u32 = 0x51A00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXD_A1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=6 (condition VS (overflow set))
#[test]
fn test_aarch32_strexd_a1_a_combo_6_390_61a00390() {
    // Encoding: 0x61A00390
    // Test aarch32_STREXD_A1_A field combination: cond=6, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rt=0, cond=6, Rd=0, Rn=0
    let encoding: u32 = 0x61A00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXD_A1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=7 (condition VC (overflow clear))
#[test]
fn test_aarch32_strexd_a1_a_combo_7_390_71a00390() {
    // Encoding: 0x71A00390
    // Test aarch32_STREXD_A1_A field combination: cond=7, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rn=0, cond=7, Rd=0, Rt=0
    let encoding: u32 = 0x71A00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXD_A1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=8 (condition HI (unsigned higher))
#[test]
fn test_aarch32_strexd_a1_a_combo_8_390_81a00390() {
    // Encoding: 0x81A00390
    // Test aarch32_STREXD_A1_A field combination: cond=8, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rd=0, Rn=0, Rt=0, cond=8
    let encoding: u32 = 0x81A00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXD_A1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=9 (condition LS (unsigned lower or same))
#[test]
fn test_aarch32_strexd_a1_a_combo_9_390_91a00390() {
    // Encoding: 0x91A00390
    // Test aarch32_STREXD_A1_A field combination: cond=9, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: cond=9, Rt=0, Rn=0, Rd=0
    let encoding: u32 = 0x91A00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXD_A1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=10 (condition GE (signed >=))
#[test]
fn test_aarch32_strexd_a1_a_combo_10_390_a1a00390() {
    // Encoding: 0xA1A00390
    // Test aarch32_STREXD_A1_A field combination: cond=10, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rt=0, Rn=0, cond=10, Rd=0
    let encoding: u32 = 0xA1A00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXD_A1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=11 (condition LT (signed <))
#[test]
fn test_aarch32_strexd_a1_a_combo_11_390_b1a00390() {
    // Encoding: 0xB1A00390
    // Test aarch32_STREXD_A1_A field combination: cond=11, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: cond=11, Rn=0, Rt=0, Rd=0
    let encoding: u32 = 0xB1A00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXD_A1_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=12 (condition GT (signed >))
#[test]
fn test_aarch32_strexd_a1_a_combo_12_390_c1a00390() {
    // Encoding: 0xC1A00390
    // Test aarch32_STREXD_A1_A field combination: cond=12, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rn=0, cond=12, Rt=0, Rd=0
    let encoding: u32 = 0xC1A00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXD_A1_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=13 (condition LE (signed <=))
#[test]
fn test_aarch32_strexd_a1_a_combo_13_390_d1a00390() {
    // Encoding: 0xD1A00390
    // Test aarch32_STREXD_A1_A field combination: cond=13, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: cond=13, Rn=0, Rt=0, Rd=0
    let encoding: u32 = 0xD1A00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXD_A1_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=14 (condition AL (always))
#[test]
fn test_aarch32_strexd_a1_a_combo_14_390_e1a00390() {
    // Encoding: 0xE1A00390
    // Test aarch32_STREXD_A1_A field combination: cond=14, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rd=0, cond=14, Rt=0, Rn=0
    let encoding: u32 = 0xE1A00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXD_A1_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=15 (condition NV (never, reserved))
#[test]
fn test_aarch32_strexd_a1_a_combo_15_390_f1a00390() {
    // Encoding: 0xF1A00390
    // Test aarch32_STREXD_A1_A field combination: cond=15, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: cond=15, Rn=0, Rd=0, Rt=0
    let encoding: u32 = 0xF1A00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXD_A1_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_strexd_a1_a_combo_16_390_01a00390() {
    // Encoding: 0x01A00390
    // Test aarch32_STREXD_A1_A field combination: cond=0, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: cond=0, Rn=0, Rd=0, Rt=0
    let encoding: u32 = 0x01A00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXD_A1_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_strexd_a1_a_combo_17_390_01a10390() {
    // Encoding: 0x01A10390
    // Test aarch32_STREXD_A1_A field combination: cond=0, Rn=1, Rd=0, Rt=0
    // ISET: A32
    // Fields: cond=0, Rn=1, Rd=0, Rt=0
    let encoding: u32 = 0x01A10390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXD_A1_A
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch32_strexd_a1_a_combo_18_390_01a00390() {
    // Encoding: 0x01A00390
    // Test aarch32_STREXD_A1_A field combination: cond=0, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rd=0, Rt=0, cond=0, Rn=0
    let encoding: u32 = 0x01A00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXD_A1_A
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch32_strexd_a1_a_combo_19_390_01a01390() {
    // Encoding: 0x01A01390
    // Test aarch32_STREXD_A1_A field combination: cond=0, Rn=0, Rd=1, Rt=0
    // ISET: A32
    // Fields: cond=0, Rd=1, Rt=0, Rn=0
    let encoding: u32 = 0x01A01390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXD_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_strexd_a1_a_special_cond_0_condition_eq_912_01a00390() {
    // Encoding: 0x01A00390
    // Test aarch32_STREXD_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: Rt=0, Rn=0, Rd=0, cond=0
    let encoding: u32 = 0x01A00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXD_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_strexd_a1_a_special_cond_1_condition_ne_912_11a00390() {
    // Encoding: 0x11A00390
    // Test aarch32_STREXD_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: Rd=0, Rn=0, Rt=0, cond=1
    let encoding: u32 = 0x11A00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXD_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_strexd_a1_a_special_cond_2_condition_cs_hs_912_21a00390() {
    // Encoding: 0x21A00390
    // Test aarch32_STREXD_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: cond=2, Rn=0, Rd=0, Rt=0
    let encoding: u32 = 0x21A00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXD_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_strexd_a1_a_special_cond_3_condition_cc_lo_912_31a00390() {
    // Encoding: 0x31A00390
    // Test aarch32_STREXD_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: Rt=0, cond=3, Rd=0, Rn=0
    let encoding: u32 = 0x31A00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXD_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_strexd_a1_a_special_cond_4_condition_mi_912_41a00390() {
    // Encoding: 0x41A00390
    // Test aarch32_STREXD_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: Rd=0, Rn=0, cond=4, Rt=0
    let encoding: u32 = 0x41A00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXD_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_strexd_a1_a_special_cond_5_condition_pl_912_51a00390() {
    // Encoding: 0x51A00390
    // Test aarch32_STREXD_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: Rd=0, Rn=0, cond=5, Rt=0
    let encoding: u32 = 0x51A00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXD_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_strexd_a1_a_special_cond_6_condition_vs_912_61a00390() {
    // Encoding: 0x61A00390
    // Test aarch32_STREXD_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: Rn=0, Rd=0, Rt=0, cond=6
    let encoding: u32 = 0x61A00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXD_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_strexd_a1_a_special_cond_7_condition_vc_912_71a00390() {
    // Encoding: 0x71A00390
    // Test aarch32_STREXD_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: Rt=0, Rn=0, cond=7, Rd=0
    let encoding: u32 = 0x71A00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXD_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_strexd_a1_a_special_cond_8_condition_hi_912_81a00390() {
    // Encoding: 0x81A00390
    // Test aarch32_STREXD_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: cond=8, Rd=0, Rt=0, Rn=0
    let encoding: u32 = 0x81A00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXD_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_strexd_a1_a_special_cond_9_condition_ls_912_91a00390() {
    // Encoding: 0x91A00390
    // Test aarch32_STREXD_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: Rd=0, cond=9, Rn=0, Rt=0
    let encoding: u32 = 0x91A00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXD_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_strexd_a1_a_special_cond_10_condition_ge_912_a1a00390() {
    // Encoding: 0xA1A00390
    // Test aarch32_STREXD_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: Rd=0, Rt=0, Rn=0, cond=10
    let encoding: u32 = 0xA1A00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXD_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_strexd_a1_a_special_cond_11_condition_lt_912_b1a00390() {
    // Encoding: 0xB1A00390
    // Test aarch32_STREXD_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=11, Rd=0
    let encoding: u32 = 0xB1A00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXD_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_strexd_a1_a_special_cond_12_condition_gt_912_c1a00390() {
    // Encoding: 0xC1A00390
    // Test aarch32_STREXD_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: cond=12, Rd=0, Rn=0, Rt=0
    let encoding: u32 = 0xC1A00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXD_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_strexd_a1_a_special_cond_13_condition_le_912_d1a00390() {
    // Encoding: 0xD1A00390
    // Test aarch32_STREXD_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: Rn=0, Rd=0, cond=13, Rt=0
    let encoding: u32 = 0xD1A00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXD_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_strexd_a1_a_special_cond_14_condition_al_912_e1a00390() {
    // Encoding: 0xE1A00390
    // Test aarch32_STREXD_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: cond=14, Rd=0, Rn=0, Rt=0
    let encoding: u32 = 0xE1A00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXD_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_strexd_a1_a_special_cond_15_condition_nv_912_f1a00390() {
    // Encoding: 0xF1A00390
    // Test aarch32_STREXD_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: cond=15, Rd=0, Rt=0, Rn=0
    let encoding: u32 = 0xF1A00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STREXD_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Rt" }), indices: [Single(LitInt(0))] } } }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t2" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Rt\" }), indices: [Single(LitInt(0))] } } }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t2\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strexd_a1_a_invalid_0_390_01a00390() {
    // Encoding: 0x01A00390
    // Test aarch32_STREXD_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Rt" }), indices: [Single(LitInt(0))] } } }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t2" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }
    // ISET: A32
    // Fields: Rt=0, Rn=0, cond=0, Rd=0
    let encoding: u32 = 0x01A00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STREXD_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strexd_a1_a_invalid_1_390_01a00390() {
    // Encoding: 0x01A00390
    // Test aarch32_STREXD_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: cond=0, Rt=0, Rn=0, Rd=0
    let encoding: u32 = 0x01A00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STREXD_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }) } }, rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t2" }) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }) } }, rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t2\" }) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strexd_a1_a_invalid_2_390_01a00390() {
    // Encoding: 0x01A00390
    // Test aarch32_STREXD_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }) } }, rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t2" }) }
    // ISET: A32
    // Fields: Rd=0, Rn=0, cond=0, Rt=0
    let encoding: u32 = 0x01A00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STREXD_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strexd_a1_a_invalid_3_390_01a00390() {
    // Encoding: 0x01A00390
    // Test aarch32_STREXD_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Rt=0, Rn=0, cond=0, Rd=0
    let encoding: u32 = 0x01A00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STREXD_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_strexd_t1_a_field_rn_0_min_70_e8c00070() {
    // Thumb encoding (32): 0xE8C00070
    // Test aarch32_STREXD_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rd=0, Rn=0, Rt=0, Rt2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C00070;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREXD_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_strexd_t1_a_field_rn_1_poweroftwo_70_e8c10070() {
    // Thumb encoding (32): 0xE8C10070
    // Test aarch32_STREXD_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, Rd=0, Rt2=0, Rn=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C10070;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREXD_T1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_strexd_t1_a_field_rt_0_min_70_e8c00070() {
    // Thumb encoding (32): 0xE8C00070
    // Test aarch32_STREXD_T1_A field Rt = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rt=0, Rd=0, Rt2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C00070;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREXD_T1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_strexd_t1_a_field_rt_1_poweroftwo_70_e8c01070() {
    // Thumb encoding (32): 0xE8C01070
    // Test aarch32_STREXD_T1_A field Rt = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rd=0, Rn=0, Rt=1, Rt2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C01070;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREXD_T1_A
/// ASL: `field Rt2 8 +: 4`
/// Requirement: FieldBoundary { field: "Rt2", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_strexd_t1_a_field_rt2_0_min_70_e8c00070() {
    // Thumb encoding (32): 0xE8C00070
    // Test aarch32_STREXD_T1_A field Rt2 = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rt=0, Rt2=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C00070;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREXD_T1_A
/// ASL: `field Rt2 8 +: 4`
/// Requirement: FieldBoundary { field: "Rt2", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_strexd_t1_a_field_rt2_1_poweroftwo_70_e8c00170() {
    // Thumb encoding (32): 0xE8C00170
    // Test aarch32_STREXD_T1_A field Rt2 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rd=0, Rt=0, Rn=0, Rt2=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C00170;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREXD_T1_A
/// ASL: `field Rd 0 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_strexd_t1_a_field_rd_0_min_70_e8c00070() {
    // Thumb encoding (32): 0xE8C00070
    // Test aarch32_STREXD_T1_A field Rd = 0 (Min)
    // ISET: T32
    // Fields: Rt=0, Rt2=0, Rd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C00070;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREXD_T1_A
/// ASL: `field Rd 0 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_strexd_t1_a_field_rd_1_poweroftwo_70_e8c00071() {
    // Thumb encoding (32): 0xE8C00071
    // Test aarch32_STREXD_T1_A field Rd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rd=1, Rt2=0, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C00071;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREXD_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_strexd_t1_a_combo_0_70_e8c00070() {
    // Thumb encoding (32): 0xE8C00070
    // Test aarch32_STREXD_T1_A field combination: Rn=0, Rt=0, Rt2=0, Rd=0
    // ISET: T32
    // Fields: Rt2=0, Rt=0, Rn=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C00070;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREXD_T1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_strexd_t1_a_combo_1_70_e8c10070() {
    // Thumb encoding (32): 0xE8C10070
    // Test aarch32_STREXD_T1_A field combination: Rn=1, Rt=0, Rt2=0, Rd=0
    // ISET: T32
    // Fields: Rn=1, Rd=0, Rt=0, Rt2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C10070;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREXD_T1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=0 (register index 0 (first register))
#[test]
fn test_aarch32_strexd_t1_a_combo_2_70_e8c00070() {
    // Thumb encoding (32): 0xE8C00070
    // Test aarch32_STREXD_T1_A field combination: Rn=0, Rt=0, Rt2=0, Rd=0
    // ISET: T32
    // Fields: Rt=0, Rn=0, Rd=0, Rt2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C00070;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREXD_T1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=1 (register index 1 (second register))
#[test]
fn test_aarch32_strexd_t1_a_combo_3_70_e8c01070() {
    // Thumb encoding (32): 0xE8C01070
    // Test aarch32_STREXD_T1_A field combination: Rn=0, Rt=1, Rt2=0, Rd=0
    // ISET: T32
    // Fields: Rn=0, Rt=1, Rd=0, Rt2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C01070;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREXD_T1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt2=0 (register index 0 (first register))
#[test]
fn test_aarch32_strexd_t1_a_combo_4_70_e8c00070() {
    // Thumb encoding (32): 0xE8C00070
    // Test aarch32_STREXD_T1_A field combination: Rn=0, Rt=0, Rt2=0, Rd=0
    // ISET: T32
    // Fields: Rt2=0, Rd=0, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C00070;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREXD_T1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt2=1 (register index 1 (second register))
#[test]
fn test_aarch32_strexd_t1_a_combo_5_70_e8c00170() {
    // Thumb encoding (32): 0xE8C00170
    // Test aarch32_STREXD_T1_A field combination: Rn=0, Rt=0, Rt2=1, Rd=0
    // ISET: T32
    // Fields: Rt=0, Rt2=1, Rd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C00170;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREXD_T1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch32_strexd_t1_a_combo_6_70_e8c00070() {
    // Thumb encoding (32): 0xE8C00070
    // Test aarch32_STREXD_T1_A field combination: Rn=0, Rt=0, Rt2=0, Rd=0
    // ISET: T32
    // Fields: Rt=0, Rn=0, Rd=0, Rt2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C00070;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREXD_T1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch32_strexd_t1_a_combo_7_70_e8c00071() {
    // Thumb encoding (32): 0xE8C00071
    // Test aarch32_STREXD_T1_A field combination: Rn=0, Rt=0, Rt2=0, Rd=1
    // ISET: T32
    // Fields: Rt2=0, Rt=0, Rd=1, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C00071;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREXD_T1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rt=1 (same register test (reg=1))
#[test]
fn test_aarch32_strexd_t1_a_combo_8_70_e8c11070() {
    // Thumb encoding (32): 0xE8C11070
    // Test aarch32_STREXD_T1_A field combination: Rn=1, Rt=1, Rt2=0, Rd=0
    // ISET: T32
    // Fields: Rt2=0, Rd=0, Rt=1, Rn=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C11070;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREXD_T1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rt=31 (same register test (reg=31))
#[test]
fn test_aarch32_strexd_t1_a_combo_9_70_e8cff070() {
    // Thumb encoding (32): 0xE8CFF070
    // Test aarch32_STREXD_T1_A field combination: Rn=31, Rt=31, Rt2=0, Rd=0
    // ISET: T32
    // Fields: Rd=0, Rn=31, Rt2=0, Rt=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8CFF070;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREXD_T1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rt2=1 (same register test (reg=1))
#[test]
fn test_aarch32_strexd_t1_a_combo_10_70_e8c10170() {
    // Thumb encoding (32): 0xE8C10170
    // Test aarch32_STREXD_T1_A field combination: Rn=1, Rt=0, Rt2=1, Rd=0
    // ISET: T32
    // Fields: Rn=1, Rt=0, Rt2=1, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C10170;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREXD_T1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rt2=31 (same register test (reg=31))
#[test]
fn test_aarch32_strexd_t1_a_combo_11_70_e8cf0f70() {
    // Thumb encoding (32): 0xE8CF0F70
    // Test aarch32_STREXD_T1_A field combination: Rn=31, Rt=0, Rt2=31, Rd=0
    // ISET: T32
    // Fields: Rn=31, Rd=0, Rt=0, Rt2=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8CF0F70;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREXD_T1_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch32_strexd_t1_a_combo_12_70_e8c10071() {
    // Thumb encoding (32): 0xE8C10071
    // Test aarch32_STREXD_T1_A field combination: Rn=1, Rt=0, Rt2=0, Rd=1
    // ISET: T32
    // Fields: Rt2=0, Rt=0, Rd=1, Rn=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C10071;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREXD_T1_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch32_strexd_t1_a_combo_13_70_e8cf007f() {
    // Thumb encoding (32): 0xE8CF007F
    // Test aarch32_STREXD_T1_A field combination: Rn=31, Rt=0, Rt2=0, Rd=31
    // ISET: T32
    // Fields: Rt=0, Rn=31, Rd=31, Rt2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8CF007F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREXD_T1_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=1 (same register test (reg=1)), Rt2=1 (same register test (reg=1))
#[test]
fn test_aarch32_strexd_t1_a_combo_14_70_e8c01170() {
    // Thumb encoding (32): 0xE8C01170
    // Test aarch32_STREXD_T1_A field combination: Rn=0, Rt=1, Rt2=1, Rd=0
    // ISET: T32
    // Fields: Rn=0, Rt2=1, Rd=0, Rt=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C01170;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREXD_T1_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=31 (same register test (reg=31)), Rt2=31 (same register test (reg=31))
#[test]
fn test_aarch32_strexd_t1_a_combo_15_70_e8c0ff70() {
    // Thumb encoding (32): 0xE8C0FF70
    // Test aarch32_STREXD_T1_A field combination: Rn=0, Rt=31, Rt2=31, Rd=0
    // ISET: T32
    // Fields: Rn=0, Rt=31, Rt2=31, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C0FF70;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREXD_T1_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch32_strexd_t1_a_combo_16_70_e8c01071() {
    // Thumb encoding (32): 0xE8C01071
    // Test aarch32_STREXD_T1_A field combination: Rn=0, Rt=1, Rt2=0, Rd=1
    // ISET: T32
    // Fields: Rt=1, Rt2=0, Rd=1, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C01071;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREXD_T1_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch32_strexd_t1_a_combo_17_70_e8c0f07f() {
    // Thumb encoding (32): 0xE8C0F07F
    // Test aarch32_STREXD_T1_A field combination: Rn=0, Rt=31, Rt2=0, Rd=31
    // ISET: T32
    // Fields: Rt2=0, Rt=31, Rd=31, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C0F07F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREXD_T1_A
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt2=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch32_strexd_t1_a_combo_18_70_e8c00171() {
    // Thumb encoding (32): 0xE8C00171
    // Test aarch32_STREXD_T1_A field combination: Rn=0, Rt=0, Rt2=1, Rd=1
    // ISET: T32
    // Fields: Rn=0, Rd=1, Rt=0, Rt2=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C00171;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREXD_T1_A
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt2=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch32_strexd_t1_a_combo_19_70_e8c00f7f() {
    // Thumb encoding (32): 0xE8C00F7F
    // Test aarch32_STREXD_T1_A field combination: Rn=0, Rt=0, Rt2=31, Rd=31
    // ISET: T32
    // Fields: Rt=0, Rd=31, Rn=0, Rt2=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C00F7F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STREXD_T1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t2" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t2\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strexd_t1_a_invalid_0_70_e8c00070() {
    // Thumb encoding (32): 0xE8C00070
    // Test aarch32_STREXD_T1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t2" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }
    // ISET: T32
    // Fields: Rd=0, Rt=0, Rn=0, Rt2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C00070;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_STREXD_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strexd_t1_a_invalid_1_70_e8c00070() {
    // Thumb encoding (32): 0xE8C00070
    // Test aarch32_STREXD_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rt=0, Rn=0, Rd=0, Rt2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C00070;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_STREXD_T1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }) } }, rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t2" }) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }) } }, rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t2\" }) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strexd_t1_a_invalid_2_70_e8c00070() {
    // Thumb encoding (32): 0xE8C00070
    // Test aarch32_STREXD_T1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }) } }, rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t2" }) }
    // ISET: T32
    // Fields: Rt=0, Rd=0, Rn=0, Rt2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C00070;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_STREXD_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strexd_t1_a_invalid_3_70_e8c00070() {
    // Thumb encoding (32): 0xE8C00070
    // Test aarch32_STREXD_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rn=0, Rt=0, Rd=0, Rt2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C00070;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_STREXD_A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_strexd_a1_a_store_0_01a10390() {
    // Test aarch32_STREXD_A1_A memory store: 8 bytes
    // Encoding: 0x01A10390
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x01A10390;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_STREXD_T1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_strexd_t1_a_store_0_e8c10070() {
    // Test aarch32_STREXD_T1_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xE8C10070;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// aarch32_STRB_i_A Tests
// ============================================================================

/// Provenance: aarch32_STRB_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_strb_i_a1_a_field_cond_0_min_0_04400000() {
    // Encoding: 0x04400000
    // Test aarch32_STRB_i_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: U=0, Rn=0, Rt=0, P=0, imm12=0, W=0, cond=0
    let encoding: u32 = 0x04400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_strb_i_a1_a_field_cond_1_poweroftwo_0_14400000() {
    // Encoding: 0x14400000
    // Test aarch32_STRB_i_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, W=0, cond=1, U=0, Rn=0, Rt=0, imm12=0
    let encoding: u32 = 0x14400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_strb_i_a1_a_field_cond_2_poweroftwo_0_24400000() {
    // Encoding: 0x24400000
    // Test aarch32_STRB_i_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=2, P=0, W=0, Rn=0, Rt=0, U=0, imm12=0
    let encoding: u32 = 0x24400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_strb_i_a1_a_field_cond_3_poweroftwo_0_34400000() {
    // Encoding: 0x34400000
    // Test aarch32_STRB_i_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, imm12=0, cond=3, W=0, U=0, Rt=0, P=0
    let encoding: u32 = 0x34400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_strb_i_a1_a_field_cond_4_poweroftwo_0_44400000() {
    // Encoding: 0x44400000
    // Test aarch32_STRB_i_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, Rt=0, Rn=0, cond=4, U=0, P=0, imm12=0
    let encoding: u32 = 0x44400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_strb_i_a1_a_field_cond_5_poweroftwo_0_54400000() {
    // Encoding: 0x54400000
    // Test aarch32_STRB_i_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=5, P=0, W=0, Rn=0, Rt=0, imm12=0, U=0
    let encoding: u32 = 0x54400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_strb_i_a1_a_field_cond_6_poweroftwo_0_64400000() {
    // Encoding: 0x64400000
    // Test aarch32_STRB_i_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, imm12=0, Rn=0, cond=6, U=0, Rt=0, P=0
    let encoding: u32 = 0x64400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_strb_i_a1_a_field_cond_7_poweroftwo_0_74400000() {
    // Encoding: 0x74400000
    // Test aarch32_STRB_i_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, Rn=0, W=0, imm12=0, Rt=0, U=0, cond=7
    let encoding: u32 = 0x74400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_strb_i_a1_a_field_cond_8_poweroftwo_0_84400000() {
    // Encoding: 0x84400000
    // Test aarch32_STRB_i_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=8, U=0, Rt=0, imm12=0, P=0, W=0
    let encoding: u32 = 0x84400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_strb_i_a1_a_field_cond_9_poweroftwo_0_94400000() {
    // Encoding: 0x94400000
    // Test aarch32_STRB_i_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, imm12=0, cond=9, P=0, W=0, U=0, Rn=0
    let encoding: u32 = 0x94400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_strb_i_a1_a_field_cond_10_poweroftwo_0_a4400000() {
    // Encoding: 0xA4400000
    // Test aarch32_STRB_i_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, imm12=0, Rt=0, cond=10, W=0, U=0, P=0
    let encoding: u32 = 0xA4400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_strb_i_a1_a_field_cond_11_poweroftwo_0_b4400000() {
    // Encoding: 0xB4400000
    // Test aarch32_STRB_i_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=0, W=0, U=0, cond=11, Rt=0, P=0, Rn=0
    let encoding: u32 = 0xB4400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_strb_i_a1_a_field_cond_12_poweroftwo_0_c4400000() {
    // Encoding: 0xC4400000
    // Test aarch32_STRB_i_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=12, W=0, Rt=0, P=0, imm12=0, U=0, Rn=0
    let encoding: u32 = 0xC4400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_strb_i_a1_a_field_cond_13_poweroftwo_0_d4400000() {
    // Encoding: 0xD4400000
    // Test aarch32_STRB_i_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=13, P=0, U=0, W=0, Rn=0, Rt=0, imm12=0
    let encoding: u32 = 0xD4400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_strb_i_a1_a_field_cond_14_poweroftwo_0_e4400000() {
    // Encoding: 0xE4400000
    // Test aarch32_STRB_i_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, P=0, Rt=0, imm12=0, Rn=0, cond=14, U=0
    let encoding: u32 = 0xE4400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_strb_i_a1_a_field_cond_15_max_0_f4400000() {
    // Encoding: 0xF4400000
    // Test aarch32_STRB_i_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: W=0, Rn=0, U=0, cond=15, Rt=0, P=0, imm12=0
    let encoding: u32 = 0xF4400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_i_A1_A
/// ASL: `field P 24 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_strb_i_a1_a_field_p_0_min_0_04400000() {
    // Encoding: 0x04400000
    // Test aarch32_STRB_i_A1_A field P = 0 (Min)
    // ISET: A32
    // Fields: imm12=0, Rn=0, P=0, cond=0, W=0, Rt=0, U=0
    let encoding: u32 = 0x04400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_i_A1_A
/// ASL: `field P 24 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_strb_i_a1_a_field_p_1_max_0_05400000() {
    // Encoding: 0x05400000
    // Test aarch32_STRB_i_A1_A field P = 1 (Max)
    // ISET: A32
    // Fields: imm12=0, U=0, P=1, cond=0, W=0, Rn=0, Rt=0
    let encoding: u32 = 0x05400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_i_A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_strb_i_a1_a_field_u_0_min_0_04400000() {
    // Encoding: 0x04400000
    // Test aarch32_STRB_i_A1_A field U = 0 (Min)
    // ISET: A32
    // Fields: W=0, imm12=0, cond=0, P=0, U=0, Rn=0, Rt=0
    let encoding: u32 = 0x04400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_i_A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_strb_i_a1_a_field_u_1_max_0_04c00000() {
    // Encoding: 0x04C00000
    // Test aarch32_STRB_i_A1_A field U = 1 (Max)
    // ISET: A32
    // Fields: Rt=0, imm12=0, Rn=0, cond=0, U=1, W=0, P=0
    let encoding: u32 = 0x04C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_i_A1_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_strb_i_a1_a_field_w_0_min_0_04400000() {
    // Encoding: 0x04400000
    // Test aarch32_STRB_i_A1_A field W = 0 (Min)
    // ISET: A32
    // Fields: Rt=0, U=0, imm12=0, W=0, Rn=0, P=0, cond=0
    let encoding: u32 = 0x04400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_i_A1_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_strb_i_a1_a_field_w_1_max_0_04600000() {
    // Encoding: 0x04600000
    // Test aarch32_STRB_i_A1_A field W = 1 (Max)
    // ISET: A32
    // Fields: U=0, P=0, cond=0, Rn=0, Rt=0, imm12=0, W=1
    let encoding: u32 = 0x04600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_i_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_strb_i_a1_a_field_rn_0_min_0_04400000() {
    // Encoding: 0x04400000
    // Test aarch32_STRB_i_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: cond=0, U=0, Rt=0, P=0, Rn=0, imm12=0, W=0
    let encoding: u32 = 0x04400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_i_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_strb_i_a1_a_field_rn_1_poweroftwo_0_04410000() {
    // Encoding: 0x04410000
    // Test aarch32_STRB_i_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, imm12=0, P=0, Rn=1, U=0, cond=0, W=0
    let encoding: u32 = 0x04410000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_i_A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_strb_i_a1_a_field_rt_0_min_0_04400000() {
    // Encoding: 0x04400000
    // Test aarch32_STRB_i_A1_A field Rt = 0 (Min)
    // ISET: A32
    // Fields: U=0, P=0, W=0, Rt=0, cond=0, Rn=0, imm12=0
    let encoding: u32 = 0x04400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_i_A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_strb_i_a1_a_field_rt_1_poweroftwo_0_04401000() {
    // Encoding: 0x04401000
    // Test aarch32_STRB_i_A1_A field Rt = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, U=0, Rt=1, cond=0, W=0, Rn=0, imm12=0
    let encoding: u32 = 0x04401000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_strb_i_a1_a_field_imm12_0_zero_0_04400000() {
    // Encoding: 0x04400000
    // Test aarch32_STRB_i_A1_A field imm12 = 0 (Zero)
    // ISET: A32
    // Fields: imm12=0, Rt=0, U=0, P=0, Rn=0, cond=0, W=0
    let encoding: u32 = 0x04400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_strb_i_a1_a_field_imm12_1_poweroftwo_0_04400001() {
    // Encoding: 0x04400001
    // Test aarch32_STRB_i_A1_A field imm12 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=1, Rt=0, W=0, cond=0, P=0, U=0, Rn=0
    let encoding: u32 = 0x04400001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_strb_i_a1_a_field_imm12_3_poweroftwominusone_0_04400003() {
    // Encoding: 0x04400003
    // Test aarch32_STRB_i_A1_A field imm12 = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: P=0, cond=0, imm12=3, U=0, W=0, Rn=0, Rt=0
    let encoding: u32 = 0x04400003;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_strb_i_a1_a_field_imm12_4_poweroftwo_0_04400004() {
    // Encoding: 0x04400004
    // Test aarch32_STRB_i_A1_A field imm12 = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, P=0, cond=0, Rn=0, Rt=0, U=0, imm12=4
    let encoding: u32 = 0x04400004;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_strb_i_a1_a_field_imm12_7_poweroftwominusone_0_04400007() {
    // Encoding: 0x04400007
    // Test aarch32_STRB_i_A1_A field imm12 = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: U=0, W=0, Rn=0, Rt=0, cond=0, imm12=7, P=0
    let encoding: u32 = 0x04400007;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_strb_i_a1_a_field_imm12_8_poweroftwo_0_04400008() {
    // Encoding: 0x04400008
    // Test aarch32_STRB_i_A1_A field imm12 = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, W=0, P=0, Rn=0, U=0, Rt=0, imm12=8
    let encoding: u32 = 0x04400008;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_strb_i_a1_a_field_imm12_15_poweroftwominusone_0_0440000f() {
    // Encoding: 0x0440000F
    // Test aarch32_STRB_i_A1_A field imm12 = 15 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rn=0, Rt=0, W=0, imm12=15, P=0, cond=0, U=0
    let encoding: u32 = 0x0440000F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_strb_i_a1_a_field_imm12_16_poweroftwo_0_04400010() {
    // Encoding: 0x04400010
    // Test aarch32_STRB_i_A1_A field imm12 = 16 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, Rn=0, Rt=0, P=0, U=0, imm12=16, cond=0
    let encoding: u32 = 0x04400010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_strb_i_a1_a_field_imm12_31_poweroftwominusone_0_0440001f() {
    // Encoding: 0x0440001F
    // Test aarch32_STRB_i_A1_A field imm12 = 31 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm12=31, W=0, cond=0, P=0, Rn=0, U=0, Rt=0
    let encoding: u32 = 0x0440001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_strb_i_a1_a_field_imm12_32_poweroftwo_0_04400020() {
    // Encoding: 0x04400020
    // Test aarch32_STRB_i_A1_A field imm12 = 32 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, U=0, imm12=32, W=0, P=0, cond=0, Rn=0
    let encoding: u32 = 0x04400020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_strb_i_a1_a_field_imm12_63_poweroftwominusone_0_0440003f() {
    // Encoding: 0x0440003F
    // Test aarch32_STRB_i_A1_A field imm12 = 63 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rn=0, Rt=0, U=0, W=0, P=0, imm12=63, cond=0
    let encoding: u32 = 0x0440003F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_strb_i_a1_a_field_imm12_64_poweroftwo_0_04400040() {
    // Encoding: 0x04400040
    // Test aarch32_STRB_i_A1_A field imm12 = 64 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, imm12=64, Rt=0, cond=0, P=0, U=0, Rn=0
    let encoding: u32 = 0x04400040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 127, boundary: PowerOfTwoMinusOne }
/// 2^7 - 1 = 127
#[test]
fn test_aarch32_strb_i_a1_a_field_imm12_127_poweroftwominusone_0_0440007f() {
    // Encoding: 0x0440007F
    // Test aarch32_STRB_i_A1_A field imm12 = 127 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm12=127, U=0, P=0, W=0, Rn=0, Rt=0, cond=0
    let encoding: u32 = 0x0440007F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_strb_i_a1_a_field_imm12_128_poweroftwo_0_04400080() {
    // Encoding: 0x04400080
    // Test aarch32_STRB_i_A1_A field imm12 = 128 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, Rn=0, P=0, U=0, cond=0, Rt=0, imm12=128
    let encoding: u32 = 0x04400080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 255, boundary: PowerOfTwoMinusOne }
/// 2^8 - 1 = 255
#[test]
fn test_aarch32_strb_i_a1_a_field_imm12_255_poweroftwominusone_0_044000ff() {
    // Encoding: 0x044000FF
    // Test aarch32_STRB_i_A1_A field imm12 = 255 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rt=0, W=0, Rn=0, cond=0, U=0, imm12=255, P=0
    let encoding: u32 = 0x044000FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 256, boundary: PowerOfTwo }
/// power of 2 (2^8 = 256)
#[test]
fn test_aarch32_strb_i_a1_a_field_imm12_256_poweroftwo_0_04400100() {
    // Encoding: 0x04400100
    // Test aarch32_STRB_i_A1_A field imm12 = 256 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, Rt=0, imm12=256, W=0, Rn=0, U=0, cond=0
    let encoding: u32 = 0x04400100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 511, boundary: PowerOfTwoMinusOne }
/// 2^9 - 1 = 511
#[test]
fn test_aarch32_strb_i_a1_a_field_imm12_511_poweroftwominusone_0_044001ff() {
    // Encoding: 0x044001FF
    // Test aarch32_STRB_i_A1_A field imm12 = 511 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: U=0, Rt=0, W=0, cond=0, P=0, Rn=0, imm12=511
    let encoding: u32 = 0x044001FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 512, boundary: PowerOfTwo }
/// power of 2 (2^9 = 512)
#[test]
fn test_aarch32_strb_i_a1_a_field_imm12_512_poweroftwo_0_04400200() {
    // Encoding: 0x04400200
    // Test aarch32_STRB_i_A1_A field imm12 = 512 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, Rn=0, imm12=512, P=0, Rt=0, W=0, cond=0
    let encoding: u32 = 0x04400200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1023, boundary: PowerOfTwoMinusOne }
/// 2^10 - 1 = 1023
#[test]
fn test_aarch32_strb_i_a1_a_field_imm12_1023_poweroftwominusone_0_044003ff() {
    // Encoding: 0x044003FF
    // Test aarch32_STRB_i_A1_A field imm12 = 1023 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, W=0, imm12=1023, P=0, Rt=0, U=0, Rn=0
    let encoding: u32 = 0x044003FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1024, boundary: PowerOfTwo }
/// power of 2 (2^10 = 1024)
#[test]
fn test_aarch32_strb_i_a1_a_field_imm12_1024_poweroftwo_0_04400400() {
    // Encoding: 0x04400400
    // Test aarch32_STRB_i_A1_A field imm12 = 1024 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rt=0, imm12=1024, U=0, W=0, cond=0, P=0
    let encoding: u32 = 0x04400400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2047, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (2047)
#[test]
fn test_aarch32_strb_i_a1_a_field_imm12_2047_poweroftwominusone_0_044007ff() {
    // Encoding: 0x044007FF
    // Test aarch32_STRB_i_A1_A field imm12 = 2047 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rt=0, W=0, cond=0, P=0, Rn=0, imm12=2047, U=0
    let encoding: u32 = 0x044007FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2048, boundary: PowerOfTwo }
/// power of 2 (2^11 = 2048)
#[test]
fn test_aarch32_strb_i_a1_a_field_imm12_2048_poweroftwo_0_04400800() {
    // Encoding: 0x04400800
    // Test aarch32_STRB_i_A1_A field imm12 = 2048 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, cond=0, W=0, P=0, imm12=2048, Rn=0, U=0
    let encoding: u32 = 0x04400800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4095, boundary: Max }
/// maximum immediate (4095)
#[test]
fn test_aarch32_strb_i_a1_a_field_imm12_4095_max_0_04400fff() {
    // Encoding: 0x04400FFF
    // Test aarch32_STRB_i_A1_A field imm12 = 4095 (Max)
    // ISET: A32
    // Fields: Rt=0, imm12=4095, P=0, cond=0, U=0, W=0, Rn=0
    let encoding: u32 = 0x04400FFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_i_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_strb_i_a1_a_combo_0_0_04400000() {
    // Encoding: 0x04400000
    // Test aarch32_STRB_i_A1_A field combination: cond=0, P=0, U=0, W=0, Rn=0, Rt=0, imm12=0
    // ISET: A32
    // Fields: cond=0, P=0, W=0, Rn=0, imm12=0, U=0, Rt=0
    let encoding: u32 = 0x04400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_i_A1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=1 (condition NE (not equal))
#[test]
fn test_aarch32_strb_i_a1_a_combo_1_0_14400000() {
    // Encoding: 0x14400000
    // Test aarch32_STRB_i_A1_A field combination: cond=1, P=0, U=0, W=0, Rn=0, Rt=0, imm12=0
    // ISET: A32
    // Fields: P=0, Rt=0, W=0, imm12=0, cond=1, U=0, Rn=0
    let encoding: u32 = 0x14400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_i_A1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=2 (condition CS/HS (carry set))
#[test]
fn test_aarch32_strb_i_a1_a_combo_2_0_24400000() {
    // Encoding: 0x24400000
    // Test aarch32_STRB_i_A1_A field combination: cond=2, P=0, U=0, W=0, Rn=0, Rt=0, imm12=0
    // ISET: A32
    // Fields: Rt=0, U=0, Rn=0, imm12=0, cond=2, W=0, P=0
    let encoding: u32 = 0x24400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_i_A1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=3 (condition CC/LO (carry clear))
#[test]
fn test_aarch32_strb_i_a1_a_combo_3_0_34400000() {
    // Encoding: 0x34400000
    // Test aarch32_STRB_i_A1_A field combination: cond=3, P=0, U=0, W=0, Rn=0, Rt=0, imm12=0
    // ISET: A32
    // Fields: U=0, cond=3, P=0, Rn=0, Rt=0, imm12=0, W=0
    let encoding: u32 = 0x34400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_i_A1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=4 (condition MI (minus/negative))
#[test]
fn test_aarch32_strb_i_a1_a_combo_4_0_44400000() {
    // Encoding: 0x44400000
    // Test aarch32_STRB_i_A1_A field combination: cond=4, P=0, U=0, W=0, Rn=0, Rt=0, imm12=0
    // ISET: A32
    // Fields: imm12=0, U=0, cond=4, P=0, Rt=0, Rn=0, W=0
    let encoding: u32 = 0x44400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_i_A1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=5 (condition PL (plus/positive))
#[test]
fn test_aarch32_strb_i_a1_a_combo_5_0_54400000() {
    // Encoding: 0x54400000
    // Test aarch32_STRB_i_A1_A field combination: cond=5, P=0, U=0, W=0, Rn=0, Rt=0, imm12=0
    // ISET: A32
    // Fields: P=0, U=0, W=0, cond=5, Rt=0, Rn=0, imm12=0
    let encoding: u32 = 0x54400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_i_A1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=6 (condition VS (overflow set))
#[test]
fn test_aarch32_strb_i_a1_a_combo_6_0_64400000() {
    // Encoding: 0x64400000
    // Test aarch32_STRB_i_A1_A field combination: cond=6, P=0, U=0, W=0, Rn=0, Rt=0, imm12=0
    // ISET: A32
    // Fields: Rt=0, W=0, P=0, cond=6, Rn=0, U=0, imm12=0
    let encoding: u32 = 0x64400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_i_A1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=7 (condition VC (overflow clear))
#[test]
fn test_aarch32_strb_i_a1_a_combo_7_0_74400000() {
    // Encoding: 0x74400000
    // Test aarch32_STRB_i_A1_A field combination: cond=7, P=0, U=0, W=0, Rn=0, Rt=0, imm12=0
    // ISET: A32
    // Fields: cond=7, Rt=0, imm12=0, Rn=0, P=0, U=0, W=0
    let encoding: u32 = 0x74400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_i_A1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=8 (condition HI (unsigned higher))
#[test]
fn test_aarch32_strb_i_a1_a_combo_8_0_84400000() {
    // Encoding: 0x84400000
    // Test aarch32_STRB_i_A1_A field combination: cond=8, P=0, U=0, W=0, Rn=0, Rt=0, imm12=0
    // ISET: A32
    // Fields: cond=8, P=0, W=0, Rt=0, U=0, Rn=0, imm12=0
    let encoding: u32 = 0x84400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_i_A1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=9 (condition LS (unsigned lower or same))
#[test]
fn test_aarch32_strb_i_a1_a_combo_9_0_94400000() {
    // Encoding: 0x94400000
    // Test aarch32_STRB_i_A1_A field combination: cond=9, P=0, U=0, W=0, Rn=0, Rt=0, imm12=0
    // ISET: A32
    // Fields: W=0, imm12=0, U=0, cond=9, Rn=0, Rt=0, P=0
    let encoding: u32 = 0x94400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_i_A1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=10 (condition GE (signed >=))
#[test]
fn test_aarch32_strb_i_a1_a_combo_10_0_a4400000() {
    // Encoding: 0xA4400000
    // Test aarch32_STRB_i_A1_A field combination: cond=10, P=0, U=0, W=0, Rn=0, Rt=0, imm12=0
    // ISET: A32
    // Fields: W=0, U=0, Rn=0, Rt=0, imm12=0, P=0, cond=10
    let encoding: u32 = 0xA4400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_i_A1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=11 (condition LT (signed <))
#[test]
fn test_aarch32_strb_i_a1_a_combo_11_0_b4400000() {
    // Encoding: 0xB4400000
    // Test aarch32_STRB_i_A1_A field combination: cond=11, P=0, U=0, W=0, Rn=0, Rt=0, imm12=0
    // ISET: A32
    // Fields: U=0, cond=11, P=0, Rn=0, W=0, Rt=0, imm12=0
    let encoding: u32 = 0xB4400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_i_A1_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=12 (condition GT (signed >))
#[test]
fn test_aarch32_strb_i_a1_a_combo_12_0_c4400000() {
    // Encoding: 0xC4400000
    // Test aarch32_STRB_i_A1_A field combination: cond=12, P=0, U=0, W=0, Rn=0, Rt=0, imm12=0
    // ISET: A32
    // Fields: Rt=0, W=0, Rn=0, P=0, cond=12, U=0, imm12=0
    let encoding: u32 = 0xC4400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_i_A1_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=13 (condition LE (signed <=))
#[test]
fn test_aarch32_strb_i_a1_a_combo_13_0_d4400000() {
    // Encoding: 0xD4400000
    // Test aarch32_STRB_i_A1_A field combination: cond=13, P=0, U=0, W=0, Rn=0, Rt=0, imm12=0
    // ISET: A32
    // Fields: Rn=0, P=0, U=0, W=0, cond=13, Rt=0, imm12=0
    let encoding: u32 = 0xD4400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_i_A1_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=14 (condition AL (always))
#[test]
fn test_aarch32_strb_i_a1_a_combo_14_0_e4400000() {
    // Encoding: 0xE4400000
    // Test aarch32_STRB_i_A1_A field combination: cond=14, P=0, U=0, W=0, Rn=0, Rt=0, imm12=0
    // ISET: A32
    // Fields: cond=14, U=0, W=0, Rn=0, Rt=0, P=0, imm12=0
    let encoding: u32 = 0xE4400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_i_A1_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=15 (condition NV (never, reserved))
#[test]
fn test_aarch32_strb_i_a1_a_combo_15_0_f4400000() {
    // Encoding: 0xF4400000
    // Test aarch32_STRB_i_A1_A field combination: cond=15, P=0, U=0, W=0, Rn=0, Rt=0, imm12=0
    // ISET: A32
    // Fields: imm12=0, Rn=0, cond=15, W=0, P=0, Rt=0, U=0
    let encoding: u32 = 0xF4400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_i_A1_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// P=0 (minimum value)
#[test]
fn test_aarch32_strb_i_a1_a_combo_16_0_04400000() {
    // Encoding: 0x04400000
    // Test aarch32_STRB_i_A1_A field combination: cond=0, P=0, U=0, W=0, Rn=0, Rt=0, imm12=0
    // ISET: A32
    // Fields: W=0, P=0, Rt=0, imm12=0, Rn=0, cond=0, U=0
    let encoding: u32 = 0x04400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_i_A1_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// P=1 (maximum value (1))
#[test]
fn test_aarch32_strb_i_a1_a_combo_17_0_05400000() {
    // Encoding: 0x05400000
    // Test aarch32_STRB_i_A1_A field combination: cond=0, P=1, U=0, W=0, Rn=0, Rt=0, imm12=0
    // ISET: A32
    // Fields: cond=0, Rt=0, imm12=0, W=0, U=0, Rn=0, P=1
    let encoding: u32 = 0x05400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_i_A1_A
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=0 (minimum value)
#[test]
fn test_aarch32_strb_i_a1_a_combo_18_0_04400000() {
    // Encoding: 0x04400000
    // Test aarch32_STRB_i_A1_A field combination: cond=0, P=0, U=0, W=0, Rn=0, Rt=0, imm12=0
    // ISET: A32
    // Fields: W=0, U=0, cond=0, P=0, Rn=0, Rt=0, imm12=0
    let encoding: u32 = 0x04400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_i_A1_A
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=1 (maximum value (1))
#[test]
fn test_aarch32_strb_i_a1_a_combo_19_0_04c00000() {
    // Encoding: 0x04C00000
    // Test aarch32_STRB_i_A1_A field combination: cond=0, P=0, U=1, W=0, Rn=0, Rt=0, imm12=0
    // ISET: A32
    // Fields: imm12=0, Rt=0, cond=0, U=1, Rn=0, P=0, W=0
    let encoding: u32 = 0x04C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_i_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_strb_i_a1_a_special_cond_0_condition_eq_0_04400000() {
    // Encoding: 0x04400000
    // Test aarch32_STRB_i_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: cond=0, Rn=0, W=0, Rt=0, imm12=0, U=0, P=0
    let encoding: u32 = 0x04400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_i_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_strb_i_a1_a_special_cond_1_condition_ne_0_14400000() {
    // Encoding: 0x14400000
    // Test aarch32_STRB_i_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: cond=1, P=0, Rt=0, W=0, Rn=0, imm12=0, U=0
    let encoding: u32 = 0x14400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_i_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_strb_i_a1_a_special_cond_2_condition_cs_hs_0_24400000() {
    // Encoding: 0x24400000
    // Test aarch32_STRB_i_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: Rt=0, P=0, W=0, cond=2, Rn=0, imm12=0, U=0
    let encoding: u32 = 0x24400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_i_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_strb_i_a1_a_special_cond_3_condition_cc_lo_0_34400000() {
    // Encoding: 0x34400000
    // Test aarch32_STRB_i_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: Rn=0, U=0, Rt=0, cond=3, W=0, imm12=0, P=0
    let encoding: u32 = 0x34400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_i_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_strb_i_a1_a_special_cond_4_condition_mi_0_44400000() {
    // Encoding: 0x44400000
    // Test aarch32_STRB_i_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: cond=4, Rt=0, Rn=0, imm12=0, U=0, P=0, W=0
    let encoding: u32 = 0x44400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_i_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_strb_i_a1_a_special_cond_5_condition_pl_0_54400000() {
    // Encoding: 0x54400000
    // Test aarch32_STRB_i_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: W=0, cond=5, U=0, Rn=0, Rt=0, P=0, imm12=0
    let encoding: u32 = 0x54400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_i_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_strb_i_a1_a_special_cond_6_condition_vs_0_64400000() {
    // Encoding: 0x64400000
    // Test aarch32_STRB_i_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: cond=6, W=0, Rn=0, imm12=0, P=0, U=0, Rt=0
    let encoding: u32 = 0x64400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_i_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_strb_i_a1_a_special_cond_7_condition_vc_0_74400000() {
    // Encoding: 0x74400000
    // Test aarch32_STRB_i_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: imm12=0, Rt=0, W=0, U=0, cond=7, Rn=0, P=0
    let encoding: u32 = 0x74400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_i_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_strb_i_a1_a_special_cond_8_condition_hi_0_84400000() {
    // Encoding: 0x84400000
    // Test aarch32_STRB_i_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: U=0, Rt=0, imm12=0, P=0, cond=8, W=0, Rn=0
    let encoding: u32 = 0x84400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_i_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_strb_i_a1_a_special_cond_9_condition_ls_0_94400000() {
    // Encoding: 0x94400000
    // Test aarch32_STRB_i_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: U=0, Rn=0, cond=9, imm12=0, Rt=0, P=0, W=0
    let encoding: u32 = 0x94400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_i_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_strb_i_a1_a_special_cond_10_condition_ge_0_a4400000() {
    // Encoding: 0xA4400000
    // Test aarch32_STRB_i_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: P=0, U=0, imm12=0, W=0, Rt=0, cond=10, Rn=0
    let encoding: u32 = 0xA4400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_i_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_strb_i_a1_a_special_cond_11_condition_lt_0_b4400000() {
    // Encoding: 0xB4400000
    // Test aarch32_STRB_i_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: W=0, U=0, Rt=0, P=0, Rn=0, imm12=0, cond=11
    let encoding: u32 = 0xB4400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_i_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_strb_i_a1_a_special_cond_12_condition_gt_0_c4400000() {
    // Encoding: 0xC4400000
    // Test aarch32_STRB_i_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: U=0, W=0, Rt=0, P=0, Rn=0, cond=12, imm12=0
    let encoding: u32 = 0xC4400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_i_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_strb_i_a1_a_special_cond_13_condition_le_0_d4400000() {
    // Encoding: 0xD4400000
    // Test aarch32_STRB_i_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: Rn=0, Rt=0, imm12=0, cond=13, P=0, U=0, W=0
    let encoding: u32 = 0xD4400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_i_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_strb_i_a1_a_special_cond_14_condition_al_0_e4400000() {
    // Encoding: 0xE4400000
    // Test aarch32_STRB_i_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: U=0, imm12=0, cond=14, W=0, Rt=0, P=0, Rn=0
    let encoding: u32 = 0xE4400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_i_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_strb_i_a1_a_special_cond_15_condition_nv_0_f4400000() {
    // Encoding: 0xF4400000
    // Test aarch32_STRB_i_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: cond=15, U=0, W=0, P=0, Rn=0, Rt=0, imm12=0
    let encoding: u32 = 0xF4400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRB_i_A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strb_i_a1_a_invalid_0_0_04400000() {
    // Encoding: 0x04400000
    // Test aarch32_STRB_i_A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: LitInt(15) }
    // ISET: A32
    // Fields: W=0, Rt=0, cond=0, P=0, Rn=0, imm12=0, U=0
    let encoding: u32 = 0x04400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STRB_i_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strb_i_a1_a_invalid_1_0_04400000() {
    // Encoding: 0x04400000
    // Test aarch32_STRB_i_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: W=0, cond=0, Rn=0, P=0, Rt=0, U=0, imm12=0
    let encoding: u32 = 0x04400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STRB_i_A1_A
/// ASL: `Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"wback\" }), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }) } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strb_i_a1_a_invalid_2_0_04400000() {
    // Encoding: 0x04400000
    // Test aarch32_STRB_i_A1_A invalid encoding: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) } }
    // ISET: A32
    // Fields: Rt=0, W=0, Rn=0, cond=0, U=0, imm12=0, P=0
    let encoding: u32 = 0x04400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STRB_i_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strb_i_a1_a_invalid_3_0_04400000() {
    // Encoding: 0x04400000
    // Test aarch32_STRB_i_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: P=0, cond=0, Rn=0, Rt=0, U=0, imm12=0, W=0
    let encoding: u32 = 0x04400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STRB_i_T1_A
/// ASL: `field imm5 22 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_strb_i_t1_a_field_imm5_0_zero_0_70000000() {
    // Thumb encoding (32): 0x70000000
    // Test aarch32_STRB_i_T1_A field imm5 = 0 (Zero)
    // ISET: T32
    // Fields: imm5=0, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x70000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T1_A
/// ASL: `field imm5 22 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_strb_i_t1_a_field_imm5_1_poweroftwo_0_70400000() {
    // Thumb encoding (32): 0x70400000
    // Test aarch32_STRB_i_T1_A field imm5 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, imm5=1, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x70400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T1_A
/// ASL: `field imm5 22 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_strb_i_t1_a_field_imm5_3_poweroftwominusone_0_70c00000() {
    // Thumb encoding (32): 0x70C00000
    // Test aarch32_STRB_i_T1_A field imm5 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, imm5=3, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x70C00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T1_A
/// ASL: `field imm5 22 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_strb_i_t1_a_field_imm5_4_poweroftwo_0_71000000() {
    // Thumb encoding (32): 0x71000000
    // Test aarch32_STRB_i_T1_A field imm5 = 4 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, Rn=0, imm5=4
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x71000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T1_A
/// ASL: `field imm5 22 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_strb_i_t1_a_field_imm5_7_poweroftwominusone_0_71c00000() {
    // Thumb encoding (32): 0x71C00000
    // Test aarch32_STRB_i_T1_A field imm5 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, imm5=7, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x71C00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T1_A
/// ASL: `field imm5 22 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_strb_i_t1_a_field_imm5_8_poweroftwo_0_72000000() {
    // Thumb encoding (32): 0x72000000
    // Test aarch32_STRB_i_T1_A field imm5 = 8 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, imm5=8, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x72000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T1_A
/// ASL: `field imm5 22 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 15, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (15)
#[test]
fn test_aarch32_strb_i_t1_a_field_imm5_15_poweroftwominusone_0_73c00000() {
    // Thumb encoding (32): 0x73C00000
    // Test aarch32_STRB_i_T1_A field imm5 = 15 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm5=15, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x73C00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T1_A
/// ASL: `field imm5 22 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_strb_i_t1_a_field_imm5_16_poweroftwo_0_74000000() {
    // Thumb encoding (32): 0x74000000
    // Test aarch32_STRB_i_T1_A field imm5 = 16 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, imm5=16, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x74000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T1_A
/// ASL: `field imm5 22 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 31, boundary: Max }
/// maximum immediate (31)
#[test]
fn test_aarch32_strb_i_t1_a_field_imm5_31_max_0_77c00000() {
    // Thumb encoding (32): 0x77C00000
    // Test aarch32_STRB_i_T1_A field imm5 = 31 (Max)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm5=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x77C00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T1_A
/// ASL: `field Rn 19 +: 3`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_strb_i_t1_a_field_rn_0_min_0_70000000() {
    // Thumb encoding (32): 0x70000000
    // Test aarch32_STRB_i_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rt=0, imm5=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x70000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T1_A
/// ASL: `field Rn 19 +: 3`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_strb_i_t1_a_field_rn_1_poweroftwo_0_70080000() {
    // Thumb encoding (32): 0x70080000
    // Test aarch32_STRB_i_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=1, imm5=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x70080000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T1_A
/// ASL: `field Rt 16 +: 3`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_strb_i_t1_a_field_rt_0_min_0_70000000() {
    // Thumb encoding (32): 0x70000000
    // Test aarch32_STRB_i_T1_A field Rt = 0 (Min)
    // ISET: T32
    // Fields: imm5=0, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x70000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T1_A
/// ASL: `field Rt 16 +: 3`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_strb_i_t1_a_field_rt_1_poweroftwo_0_70010000() {
    // Thumb encoding (32): 0x70010000
    // Test aarch32_STRB_i_T1_A field Rt = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=1, imm5=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x70010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=0 (immediate value 0)
#[test]
fn test_aarch32_strb_i_t1_a_combo_0_0_70000000() {
    // Thumb encoding (32): 0x70000000
    // Test aarch32_STRB_i_T1_A field combination: imm5=0, Rn=0, Rt=0
    // ISET: T32
    // Fields: Rt=0, imm5=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x70000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=1 (immediate value 1)
#[test]
fn test_aarch32_strb_i_t1_a_combo_1_0_70400000() {
    // Thumb encoding (32): 0x70400000
    // Test aarch32_STRB_i_T1_A field combination: imm5=1, Rn=0, Rt=0
    // ISET: T32
    // Fields: Rt=0, imm5=1, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x70400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=3 (2^2 - 1 = 3)
#[test]
fn test_aarch32_strb_i_t1_a_combo_2_0_70c00000() {
    // Thumb encoding (32): 0x70C00000
    // Test aarch32_STRB_i_T1_A field combination: imm5=3, Rn=0, Rt=0
    // ISET: T32
    // Fields: imm5=3, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x70C00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=4 (power of 2 (2^2 = 4))
#[test]
fn test_aarch32_strb_i_t1_a_combo_3_0_71000000() {
    // Thumb encoding (32): 0x71000000
    // Test aarch32_STRB_i_T1_A field combination: imm5=4, Rn=0, Rt=0
    // ISET: T32
    // Fields: Rt=0, Rn=0, imm5=4
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x71000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=7 (2^3 - 1 = 7)
#[test]
fn test_aarch32_strb_i_t1_a_combo_4_0_71c00000() {
    // Thumb encoding (32): 0x71C00000
    // Test aarch32_STRB_i_T1_A field combination: imm5=7, Rn=0, Rt=0
    // ISET: T32
    // Fields: Rt=0, Rn=0, imm5=7
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x71C00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=8 (power of 2 (2^3 = 8))
#[test]
fn test_aarch32_strb_i_t1_a_combo_5_0_72000000() {
    // Thumb encoding (32): 0x72000000
    // Test aarch32_STRB_i_T1_A field combination: imm5=8, Rn=0, Rt=0
    // ISET: T32
    // Fields: imm5=8, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x72000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=15 (immediate midpoint (15))
#[test]
fn test_aarch32_strb_i_t1_a_combo_6_0_73c00000() {
    // Thumb encoding (32): 0x73C00000
    // Test aarch32_STRB_i_T1_A field combination: imm5=15, Rn=0, Rt=0
    // ISET: T32
    // Fields: Rt=0, Rn=0, imm5=15
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x73C00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=16 (power of 2 (2^4 = 16))
#[test]
fn test_aarch32_strb_i_t1_a_combo_7_0_74000000() {
    // Thumb encoding (32): 0x74000000
    // Test aarch32_STRB_i_T1_A field combination: imm5=16, Rn=0, Rt=0
    // ISET: T32
    // Fields: Rt=0, imm5=16, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x74000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=31 (maximum immediate (31))
#[test]
fn test_aarch32_strb_i_t1_a_combo_8_0_77c00000() {
    // Thumb encoding (32): 0x77C00000
    // Test aarch32_STRB_i_T1_A field combination: imm5=31, Rn=0, Rt=0
    // ISET: T32
    // Fields: Rt=0, imm5=31, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x77C00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_strb_i_t1_a_combo_9_0_70000000() {
    // Thumb encoding (32): 0x70000000
    // Test aarch32_STRB_i_T1_A field combination: imm5=0, Rn=0, Rt=0
    // ISET: T32
    // Fields: Rt=0, Rn=0, imm5=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x70000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_strb_i_t1_a_combo_10_0_70080000() {
    // Thumb encoding (32): 0x70080000
    // Test aarch32_STRB_i_T1_A field combination: imm5=0, Rn=1, Rt=0
    // ISET: T32
    // Fields: imm5=0, Rn=1, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x70080000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=0 (register index 0 (first register))
#[test]
fn test_aarch32_strb_i_t1_a_combo_11_0_70000000() {
    // Thumb encoding (32): 0x70000000
    // Test aarch32_STRB_i_T1_A field combination: imm5=0, Rn=0, Rt=0
    // ISET: T32
    // Fields: imm5=0, Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x70000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T1_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=1 (register index 1 (second register))
#[test]
fn test_aarch32_strb_i_t1_a_combo_12_0_70010000() {
    // Thumb encoding (32): 0x70010000
    // Test aarch32_STRB_i_T1_A field combination: imm5=0, Rn=0, Rt=1
    // ISET: T32
    // Fields: Rn=0, Rt=1, imm5=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x70010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T1_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rt=1 (same register test (reg=1))
#[test]
fn test_aarch32_strb_i_t1_a_combo_13_0_70090000() {
    // Thumb encoding (32): 0x70090000
    // Test aarch32_STRB_i_T1_A field combination: imm5=0, Rn=1, Rt=1
    // ISET: T32
    // Fields: imm5=0, Rt=1, Rn=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x70090000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T1_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rt=31 (same register test (reg=31))
#[test]
fn test_aarch32_strb_i_t1_a_combo_14_0_703f0000() {
    // Thumb encoding (32): 0x703F0000
    // Test aarch32_STRB_i_T1_A field combination: imm5=0, Rn=31, Rt=31
    // ISET: T32
    // Fields: Rt=31, imm5=0, Rn=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x703F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_strb_i_t2_a_field_rn_0_min_0_f8800000() {
    // Thumb encoding (32): 0xF8800000
    // Test aarch32_STRB_i_T2_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm12=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_strb_i_t2_a_field_rn_1_poweroftwo_0_f8810000() {
    // Thumb encoding (32): 0xF8810000
    // Test aarch32_STRB_i_T2_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm12=0, Rn=1, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T2_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_strb_i_t2_a_field_rt_0_min_0_f8800000() {
    // Thumb encoding (32): 0xF8800000
    // Test aarch32_STRB_i_T2_A field Rt = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, imm12=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T2_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_strb_i_t2_a_field_rt_1_poweroftwo_0_f8801000() {
    // Thumb encoding (32): 0xF8801000
    // Test aarch32_STRB_i_T2_A field Rt = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, imm12=0, Rt=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8801000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_strb_i_t2_a_field_imm12_0_zero_0_f8800000() {
    // Thumb encoding (32): 0xF8800000
    // Test aarch32_STRB_i_T2_A field imm12 = 0 (Zero)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm12=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_strb_i_t2_a_field_imm12_1_poweroftwo_0_f8800001() {
    // Thumb encoding (32): 0xF8800001
    // Test aarch32_STRB_i_T2_A field imm12 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm12=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8800001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_strb_i_t2_a_field_imm12_3_poweroftwominusone_0_f8800003() {
    // Thumb encoding (32): 0xF8800003
    // Test aarch32_STRB_i_T2_A field imm12 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, imm12=3, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8800003;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_strb_i_t2_a_field_imm12_4_poweroftwo_0_f8800004() {
    // Thumb encoding (32): 0xF8800004
    // Test aarch32_STRB_i_T2_A field imm12 = 4 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, Rn=0, imm12=4
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8800004;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_strb_i_t2_a_field_imm12_7_poweroftwominusone_0_f8800007() {
    // Thumb encoding (32): 0xF8800007
    // Test aarch32_STRB_i_T2_A field imm12 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm12=7, Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8800007;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_strb_i_t2_a_field_imm12_8_poweroftwo_0_f8800008() {
    // Thumb encoding (32): 0xF8800008
    // Test aarch32_STRB_i_T2_A field imm12 = 8 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, Rn=0, imm12=8
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8800008;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_strb_i_t2_a_field_imm12_15_poweroftwominusone_0_f880000f() {
    // Thumb encoding (32): 0xF880000F
    // Test aarch32_STRB_i_T2_A field imm12 = 15 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm12=15, Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF880000F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_strb_i_t2_a_field_imm12_16_poweroftwo_0_f8800010() {
    // Thumb encoding (32): 0xF8800010
    // Test aarch32_STRB_i_T2_A field imm12 = 16 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, imm12=16, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8800010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_strb_i_t2_a_field_imm12_31_poweroftwominusone_0_f880001f() {
    // Thumb encoding (32): 0xF880001F
    // Test aarch32_STRB_i_T2_A field imm12 = 31 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm12=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF880001F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_strb_i_t2_a_field_imm12_32_poweroftwo_0_f8800020() {
    // Thumb encoding (32): 0xF8800020
    // Test aarch32_STRB_i_T2_A field imm12 = 32 (PowerOfTwo)
    // ISET: T32
    // Fields: imm12=32, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8800020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_strb_i_t2_a_field_imm12_63_poweroftwominusone_0_f880003f() {
    // Thumb encoding (32): 0xF880003F
    // Test aarch32_STRB_i_T2_A field imm12 = 63 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, Rn=0, imm12=63
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF880003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_strb_i_t2_a_field_imm12_64_poweroftwo_0_f8800040() {
    // Thumb encoding (32): 0xF8800040
    // Test aarch32_STRB_i_T2_A field imm12 = 64 (PowerOfTwo)
    // ISET: T32
    // Fields: imm12=64, Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8800040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 127, boundary: PowerOfTwoMinusOne }
/// 2^7 - 1 = 127
#[test]
fn test_aarch32_strb_i_t2_a_field_imm12_127_poweroftwominusone_0_f880007f() {
    // Thumb encoding (32): 0xF880007F
    // Test aarch32_STRB_i_T2_A field imm12 = 127 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, Rn=0, imm12=127
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF880007F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_strb_i_t2_a_field_imm12_128_poweroftwo_0_f8800080() {
    // Thumb encoding (32): 0xF8800080
    // Test aarch32_STRB_i_T2_A field imm12 = 128 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, Rn=0, imm12=128
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8800080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 255, boundary: PowerOfTwoMinusOne }
/// 2^8 - 1 = 255
#[test]
fn test_aarch32_strb_i_t2_a_field_imm12_255_poweroftwominusone_0_f88000ff() {
    // Thumb encoding (32): 0xF88000FF
    // Test aarch32_STRB_i_T2_A field imm12 = 255 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm12=255, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF88000FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 256, boundary: PowerOfTwo }
/// power of 2 (2^8 = 256)
#[test]
fn test_aarch32_strb_i_t2_a_field_imm12_256_poweroftwo_0_f8800100() {
    // Thumb encoding (32): 0xF8800100
    // Test aarch32_STRB_i_T2_A field imm12 = 256 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, imm12=256, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8800100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 511, boundary: PowerOfTwoMinusOne }
/// 2^9 - 1 = 511
#[test]
fn test_aarch32_strb_i_t2_a_field_imm12_511_poweroftwominusone_0_f88001ff() {
    // Thumb encoding (32): 0xF88001FF
    // Test aarch32_STRB_i_T2_A field imm12 = 511 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm12=511, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF88001FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 512, boundary: PowerOfTwo }
/// power of 2 (2^9 = 512)
#[test]
fn test_aarch32_strb_i_t2_a_field_imm12_512_poweroftwo_0_f8800200() {
    // Thumb encoding (32): 0xF8800200
    // Test aarch32_STRB_i_T2_A field imm12 = 512 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, imm12=512, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8800200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1023, boundary: PowerOfTwoMinusOne }
/// 2^10 - 1 = 1023
#[test]
fn test_aarch32_strb_i_t2_a_field_imm12_1023_poweroftwominusone_0_f88003ff() {
    // Thumb encoding (32): 0xF88003FF
    // Test aarch32_STRB_i_T2_A field imm12 = 1023 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm12=1023, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF88003FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1024, boundary: PowerOfTwo }
/// power of 2 (2^10 = 1024)
#[test]
fn test_aarch32_strb_i_t2_a_field_imm12_1024_poweroftwo_0_f8800400() {
    // Thumb encoding (32): 0xF8800400
    // Test aarch32_STRB_i_T2_A field imm12 = 1024 (PowerOfTwo)
    // ISET: T32
    // Fields: imm12=1024, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8800400;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2047, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (2047)
#[test]
fn test_aarch32_strb_i_t2_a_field_imm12_2047_poweroftwominusone_0_f88007ff() {
    // Thumb encoding (32): 0xF88007FF
    // Test aarch32_STRB_i_T2_A field imm12 = 2047 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm12=2047
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF88007FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2048, boundary: PowerOfTwo }
/// power of 2 (2^11 = 2048)
#[test]
fn test_aarch32_strb_i_t2_a_field_imm12_2048_poweroftwo_0_f8800800() {
    // Thumb encoding (32): 0xF8800800
    // Test aarch32_STRB_i_T2_A field imm12 = 2048 (PowerOfTwo)
    // ISET: T32
    // Fields: imm12=2048, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8800800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T2_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4095, boundary: Max }
/// maximum immediate (4095)
#[test]
fn test_aarch32_strb_i_t2_a_field_imm12_4095_max_0_f8800fff() {
    // Thumb encoding (32): 0xF8800FFF
    // Test aarch32_STRB_i_T2_A field imm12 = 4095 (Max)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm12=4095
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8800FFF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T2_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_strb_i_t2_a_combo_0_0_f8800000() {
    // Thumb encoding (32): 0xF8800000
    // Test aarch32_STRB_i_T2_A field combination: Rn=0, Rt=0, imm12=0
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm12=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T2_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_strb_i_t2_a_combo_1_0_f8810000() {
    // Thumb encoding (32): 0xF8810000
    // Test aarch32_STRB_i_T2_A field combination: Rn=1, Rt=0, imm12=0
    // ISET: T32
    // Fields: Rn=1, Rt=0, imm12=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T2_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=0 (register index 0 (first register))
#[test]
fn test_aarch32_strb_i_t2_a_combo_2_0_f8800000() {
    // Thumb encoding (32): 0xF8800000
    // Test aarch32_STRB_i_T2_A field combination: Rn=0, Rt=0, imm12=0
    // ISET: T32
    // Fields: imm12=0, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T2_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=1 (register index 1 (second register))
#[test]
fn test_aarch32_strb_i_t2_a_combo_3_0_f8801000() {
    // Thumb encoding (32): 0xF8801000
    // Test aarch32_STRB_i_T2_A field combination: Rn=0, Rt=1, imm12=0
    // ISET: T32
    // Fields: Rt=1, Rn=0, imm12=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8801000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T2_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm12=0 (immediate value 0)
#[test]
fn test_aarch32_strb_i_t2_a_combo_4_0_f8800000() {
    // Thumb encoding (32): 0xF8800000
    // Test aarch32_STRB_i_T2_A field combination: Rn=0, Rt=0, imm12=0
    // ISET: T32
    // Fields: imm12=0, Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T2_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm12=1 (immediate value 1)
#[test]
fn test_aarch32_strb_i_t2_a_combo_5_0_f8800001() {
    // Thumb encoding (32): 0xF8800001
    // Test aarch32_STRB_i_T2_A field combination: Rn=0, Rt=0, imm12=1
    // ISET: T32
    // Fields: Rt=0, imm12=1, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8800001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T2_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm12=3 (2^2 - 1 = 3)
#[test]
fn test_aarch32_strb_i_t2_a_combo_6_0_f8800003() {
    // Thumb encoding (32): 0xF8800003
    // Test aarch32_STRB_i_T2_A field combination: Rn=0, Rt=0, imm12=3
    // ISET: T32
    // Fields: Rt=0, imm12=3, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8800003;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T2_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm12=4 (power of 2 (2^2 = 4))
#[test]
fn test_aarch32_strb_i_t2_a_combo_7_0_f8800004() {
    // Thumb encoding (32): 0xF8800004
    // Test aarch32_STRB_i_T2_A field combination: Rn=0, Rt=0, imm12=4
    // ISET: T32
    // Fields: Rt=0, imm12=4, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8800004;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T2_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm12=7 (2^3 - 1 = 7)
#[test]
fn test_aarch32_strb_i_t2_a_combo_8_0_f8800007() {
    // Thumb encoding (32): 0xF8800007
    // Test aarch32_STRB_i_T2_A field combination: Rn=0, Rt=0, imm12=7
    // ISET: T32
    // Fields: Rt=0, imm12=7, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8800007;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T2_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm12=8 (power of 2 (2^3 = 8))
#[test]
fn test_aarch32_strb_i_t2_a_combo_9_0_f8800008() {
    // Thumb encoding (32): 0xF8800008
    // Test aarch32_STRB_i_T2_A field combination: Rn=0, Rt=0, imm12=8
    // ISET: T32
    // Fields: Rn=0, imm12=8, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8800008;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T2_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm12=15 (2^4 - 1 = 15)
#[test]
fn test_aarch32_strb_i_t2_a_combo_10_0_f880000f() {
    // Thumb encoding (32): 0xF880000F
    // Test aarch32_STRB_i_T2_A field combination: Rn=0, Rt=0, imm12=15
    // ISET: T32
    // Fields: Rn=0, imm12=15, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF880000F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T2_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm12=16 (power of 2 (2^4 = 16))
#[test]
fn test_aarch32_strb_i_t2_a_combo_11_0_f8800010() {
    // Thumb encoding (32): 0xF8800010
    // Test aarch32_STRB_i_T2_A field combination: Rn=0, Rt=0, imm12=16
    // ISET: T32
    // Fields: Rt=0, Rn=0, imm12=16
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8800010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T2_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm12=31 (2^5 - 1 = 31)
#[test]
fn test_aarch32_strb_i_t2_a_combo_12_0_f880001f() {
    // Thumb encoding (32): 0xF880001F
    // Test aarch32_STRB_i_T2_A field combination: Rn=0, Rt=0, imm12=31
    // ISET: T32
    // Fields: Rn=0, imm12=31, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF880001F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T2_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm12=32 (power of 2 (2^5 = 32))
#[test]
fn test_aarch32_strb_i_t2_a_combo_13_0_f8800020() {
    // Thumb encoding (32): 0xF8800020
    // Test aarch32_STRB_i_T2_A field combination: Rn=0, Rt=0, imm12=32
    // ISET: T32
    // Fields: imm12=32, Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8800020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T2_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm12=63 (2^6 - 1 = 63)
#[test]
fn test_aarch32_strb_i_t2_a_combo_14_0_f880003f() {
    // Thumb encoding (32): 0xF880003F
    // Test aarch32_STRB_i_T2_A field combination: Rn=0, Rt=0, imm12=63
    // ISET: T32
    // Fields: Rt=0, imm12=63, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF880003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T2_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm12=64 (power of 2 (2^6 = 64))
#[test]
fn test_aarch32_strb_i_t2_a_combo_15_0_f8800040() {
    // Thumb encoding (32): 0xF8800040
    // Test aarch32_STRB_i_T2_A field combination: Rn=0, Rt=0, imm12=64
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm12=64
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8800040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T2_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm12=127 (2^7 - 1 = 127)
#[test]
fn test_aarch32_strb_i_t2_a_combo_16_0_f880007f() {
    // Thumb encoding (32): 0xF880007F
    // Test aarch32_STRB_i_T2_A field combination: Rn=0, Rt=0, imm12=127
    // ISET: T32
    // Fields: Rt=0, imm12=127, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF880007F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T2_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm12=128 (power of 2 (2^7 = 128))
#[test]
fn test_aarch32_strb_i_t2_a_combo_17_0_f8800080() {
    // Thumb encoding (32): 0xF8800080
    // Test aarch32_STRB_i_T2_A field combination: Rn=0, Rt=0, imm12=128
    // ISET: T32
    // Fields: imm12=128, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8800080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T2_A
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm12=255 (2^8 - 1 = 255)
#[test]
fn test_aarch32_strb_i_t2_a_combo_18_0_f88000ff() {
    // Thumb encoding (32): 0xF88000FF
    // Test aarch32_STRB_i_T2_A field combination: Rn=0, Rt=0, imm12=255
    // ISET: T32
    // Fields: imm12=255, Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF88000FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T2_A
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm12=256 (power of 2 (2^8 = 256))
#[test]
fn test_aarch32_strb_i_t2_a_combo_19_0_f8800100() {
    // Thumb encoding (32): 0xF8800100
    // Test aarch32_STRB_i_T2_A field combination: Rn=0, Rt=0, imm12=256
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm12=256
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8800100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T2_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rn" }), rhs: LitBits([true, true, true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Rn\" }), rhs: LitBits([true, true, true, true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_strb_i_t2_a_invalid_0_0_f8800000() {
    // Thumb encoding (32): 0xF8800000
    // Test aarch32_STRB_i_T2_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rn" }), rhs: LitBits([true, true, true, true]) }
    // ISET: T32
    // Fields: Rt=0, Rn=0, imm12=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_STRB_i_T2_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_strb_i_t2_a_invalid_1_0_f8800000() {
    // Thumb encoding (32): 0xF8800000
    // Test aarch32_STRB_i_T2_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: Rt=0, imm12=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_STRB_i_T2_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strb_i_t2_a_invalid_2_0_f8800000() {
    // Thumb encoding (32): 0xF8800000
    // Test aarch32_STRB_i_T2_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: LitInt(15) }
    // ISET: T32
    // Fields: Rn=0, imm12=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8800000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_STRB_i_T2_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strb_i_t2_a_invalid_3_0_f8800000() {
    // Thumb encoding (32): 0xF8800000
    // Test aarch32_STRB_i_T2_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rt=0, imm12=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8800000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_STRB_i_T3_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_strb_i_t3_a_field_rn_0_min_800_f8000800() {
    // Thumb encoding (32): 0xF8000800
    // Test aarch32_STRB_i_T3_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, U=0, W=0, P=0, Rt=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8000800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T3_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_strb_i_t3_a_field_rn_1_poweroftwo_800_f8010800() {
    // Thumb encoding (32): 0xF8010800
    // Test aarch32_STRB_i_T3_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=1, U=0, P=0, W=0, Rt=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8010800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T3_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_strb_i_t3_a_field_rt_0_min_800_f8000800() {
    // Thumb encoding (32): 0xF8000800
    // Test aarch32_STRB_i_T3_A field Rt = 0 (Min)
    // ISET: T32
    // Fields: U=0, Rn=0, P=0, W=0, Rt=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8000800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T3_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_strb_i_t3_a_field_rt_1_poweroftwo_800_f8001800() {
    // Thumb encoding (32): 0xF8001800
    // Test aarch32_STRB_i_T3_A field Rt = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, imm8=0, W=0, Rt=1, U=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8001800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T3_A
/// ASL: `field P 10 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_strb_i_t3_a_field_p_0_min_800_f8000800() {
    // Thumb encoding (32): 0xF8000800
    // Test aarch32_STRB_i_T3_A field P = 0 (Min)
    // ISET: T32
    // Fields: P=0, Rt=0, imm8=0, W=0, Rn=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8000800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T3_A
/// ASL: `field P 10 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_strb_i_t3_a_field_p_1_max_800_f8000c00() {
    // Thumb encoding (32): 0xF8000C00
    // Test aarch32_STRB_i_T3_A field P = 1 (Max)
    // ISET: T32
    // Fields: P=1, U=0, imm8=0, Rn=0, W=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8000C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T3_A
/// ASL: `field U 9 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_strb_i_t3_a_field_u_0_min_800_f8000800() {
    // Thumb encoding (32): 0xF8000800
    // Test aarch32_STRB_i_T3_A field U = 0 (Min)
    // ISET: T32
    // Fields: W=0, P=0, Rn=0, Rt=0, imm8=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8000800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T3_A
/// ASL: `field U 9 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_strb_i_t3_a_field_u_1_max_800_f8000a00() {
    // Thumb encoding (32): 0xF8000A00
    // Test aarch32_STRB_i_T3_A field U = 1 (Max)
    // ISET: T32
    // Fields: imm8=0, W=0, Rn=0, U=1, Rt=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8000A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T3_A
/// ASL: `field W 8 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_strb_i_t3_a_field_w_0_min_800_f8000800() {
    // Thumb encoding (32): 0xF8000800
    // Test aarch32_STRB_i_T3_A field W = 0 (Min)
    // ISET: T32
    // Fields: W=0, imm8=0, Rt=0, Rn=0, U=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8000800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T3_A
/// ASL: `field W 8 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_strb_i_t3_a_field_w_1_max_800_f8000900() {
    // Thumb encoding (32): 0xF8000900
    // Test aarch32_STRB_i_T3_A field W = 1 (Max)
    // ISET: T32
    // Fields: Rt=0, Rn=0, W=1, imm8=0, P=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8000900;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_strb_i_t3_a_field_imm8_0_zero_800_f8000800() {
    // Thumb encoding (32): 0xF8000800
    // Test aarch32_STRB_i_T3_A field imm8 = 0 (Zero)
    // ISET: T32
    // Fields: P=0, Rt=0, Rn=0, W=0, U=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8000800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_strb_i_t3_a_field_imm8_1_poweroftwo_800_f8000801() {
    // Thumb encoding (32): 0xF8000801
    // Test aarch32_STRB_i_T3_A field imm8 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: U=0, W=0, Rt=0, P=0, imm8=1, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8000801;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_strb_i_t3_a_field_imm8_3_poweroftwominusone_800_f8000803() {
    // Thumb encoding (32): 0xF8000803
    // Test aarch32_STRB_i_T3_A field imm8 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: U=0, W=0, Rn=0, Rt=0, P=0, imm8=3
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8000803;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_strb_i_t3_a_field_imm8_4_poweroftwo_800_f8000804() {
    // Thumb encoding (32): 0xF8000804
    // Test aarch32_STRB_i_T3_A field imm8 = 4 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, U=0, W=0, imm8=4, Rt=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8000804;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_strb_i_t3_a_field_imm8_7_poweroftwominusone_800_f8000807() {
    // Thumb encoding (32): 0xF8000807
    // Test aarch32_STRB_i_T3_A field imm8 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: U=0, Rn=0, Rt=0, P=0, W=0, imm8=7
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8000807;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_strb_i_t3_a_field_imm8_8_poweroftwo_800_f8000808() {
    // Thumb encoding (32): 0xF8000808
    // Test aarch32_STRB_i_T3_A field imm8 = 8 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, P=0, W=0, imm8=8, Rn=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8000808;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_strb_i_t3_a_field_imm8_15_poweroftwominusone_800_f800080f() {
    // Thumb encoding (32): 0xF800080F
    // Test aarch32_STRB_i_T3_A field imm8 = 15 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, P=0, Rn=0, U=0, W=0, imm8=15
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF800080F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_strb_i_t3_a_field_imm8_16_poweroftwo_800_f8000810() {
    // Thumb encoding (32): 0xF8000810
    // Test aarch32_STRB_i_T3_A field imm8 = 16 (PowerOfTwo)
    // ISET: T32
    // Fields: W=0, P=0, imm8=16, Rn=0, U=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8000810;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_strb_i_t3_a_field_imm8_31_poweroftwominusone_800_f800081f() {
    // Thumb encoding (32): 0xF800081F
    // Test aarch32_STRB_i_T3_A field imm8 = 31 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: P=0, U=0, Rn=0, Rt=0, W=0, imm8=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF800081F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_strb_i_t3_a_field_imm8_32_poweroftwo_800_f8000820() {
    // Thumb encoding (32): 0xF8000820
    // Test aarch32_STRB_i_T3_A field imm8 = 32 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Rt=0, P=0, W=0, imm8=32, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8000820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_strb_i_t3_a_field_imm8_63_poweroftwominusone_800_f800083f() {
    // Thumb encoding (32): 0xF800083F
    // Test aarch32_STRB_i_T3_A field imm8 = 63 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: W=0, P=0, imm8=63, U=0, Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF800083F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_strb_i_t3_a_field_imm8_64_poweroftwo_800_f8000840() {
    // Thumb encoding (32): 0xF8000840
    // Test aarch32_STRB_i_T3_A field imm8 = 64 (PowerOfTwo)
    // ISET: T32
    // Fields: U=0, W=0, Rn=0, P=0, imm8=64, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8000840;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 127, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (127)
#[test]
fn test_aarch32_strb_i_t3_a_field_imm8_127_poweroftwominusone_800_f800087f() {
    // Thumb encoding (32): 0xF800087F
    // Test aarch32_STRB_i_T3_A field imm8 = 127 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: W=0, P=0, Rt=0, U=0, Rn=0, imm8=127
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF800087F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_strb_i_t3_a_field_imm8_128_poweroftwo_800_f8000880() {
    // Thumb encoding (32): 0xF8000880
    // Test aarch32_STRB_i_T3_A field imm8 = 128 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=128, Rn=0, U=0, P=0, Rt=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8000880;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 255, boundary: Max }
/// maximum immediate (255)
#[test]
fn test_aarch32_strb_i_t3_a_field_imm8_255_max_800_f80008ff() {
    // Thumb encoding (32): 0xF80008FF
    // Test aarch32_STRB_i_T3_A field imm8 = 255 (Max)
    // ISET: T32
    // Fields: P=0, Rn=0, imm8=255, W=0, Rt=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF80008FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T3_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_strb_i_t3_a_combo_0_800_f8000800() {
    // Thumb encoding (32): 0xF8000800
    // Test aarch32_STRB_i_T3_A field combination: Rn=0, Rt=0, P=0, U=0, W=0, imm8=0
    // ISET: T32
    // Fields: Rn=0, Rt=0, W=0, P=0, U=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8000800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T3_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_strb_i_t3_a_combo_1_800_f8010800() {
    // Thumb encoding (32): 0xF8010800
    // Test aarch32_STRB_i_T3_A field combination: Rn=1, Rt=0, P=0, U=0, W=0, imm8=0
    // ISET: T32
    // Fields: W=0, Rt=0, imm8=0, Rn=1, P=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8010800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T3_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=0 (register index 0 (first register))
#[test]
fn test_aarch32_strb_i_t3_a_combo_2_800_f8000800() {
    // Thumb encoding (32): 0xF8000800
    // Test aarch32_STRB_i_T3_A field combination: Rn=0, Rt=0, P=0, U=0, W=0, imm8=0
    // ISET: T32
    // Fields: Rt=0, Rn=0, U=0, W=0, imm8=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8000800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T3_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=1 (register index 1 (second register))
#[test]
fn test_aarch32_strb_i_t3_a_combo_3_800_f8001800() {
    // Thumb encoding (32): 0xF8001800
    // Test aarch32_STRB_i_T3_A field combination: Rn=0, Rt=1, P=0, U=0, W=0, imm8=0
    // ISET: T32
    // Fields: Rt=1, U=0, W=0, imm8=0, P=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8001800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T3_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// P=0 (minimum value)
#[test]
fn test_aarch32_strb_i_t3_a_combo_4_800_f8000800() {
    // Thumb encoding (32): 0xF8000800
    // Test aarch32_STRB_i_T3_A field combination: Rn=0, Rt=0, P=0, U=0, W=0, imm8=0
    // ISET: T32
    // Fields: P=0, Rn=0, W=0, imm8=0, U=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8000800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T3_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// P=1 (maximum value (1))
#[test]
fn test_aarch32_strb_i_t3_a_combo_5_800_f8000c00() {
    // Thumb encoding (32): 0xF8000C00
    // Test aarch32_STRB_i_T3_A field combination: Rn=0, Rt=0, P=1, U=0, W=0, imm8=0
    // ISET: T32
    // Fields: W=0, Rt=0, Rn=0, P=1, U=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8000C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T3_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=0 (minimum value)
#[test]
fn test_aarch32_strb_i_t3_a_combo_6_800_f8000800() {
    // Thumb encoding (32): 0xF8000800
    // Test aarch32_STRB_i_T3_A field combination: Rn=0, Rt=0, P=0, U=0, W=0, imm8=0
    // ISET: T32
    // Fields: Rt=0, W=0, imm8=0, Rn=0, P=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8000800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T3_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=1 (maximum value (1))
#[test]
fn test_aarch32_strb_i_t3_a_combo_7_800_f8000a00() {
    // Thumb encoding (32): 0xF8000A00
    // Test aarch32_STRB_i_T3_A field combination: Rn=0, Rt=0, P=0, U=1, W=0, imm8=0
    // ISET: T32
    // Fields: U=1, Rt=0, W=0, Rn=0, imm8=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8000A00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T3_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// W=0 (minimum value)
#[test]
fn test_aarch32_strb_i_t3_a_combo_8_800_f8000800() {
    // Thumb encoding (32): 0xF8000800
    // Test aarch32_STRB_i_T3_A field combination: Rn=0, Rt=0, P=0, U=0, W=0, imm8=0
    // ISET: T32
    // Fields: imm8=0, Rt=0, P=0, W=0, Rn=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8000800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T3_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// W=1 (maximum value (1))
#[test]
fn test_aarch32_strb_i_t3_a_combo_9_800_f8000900() {
    // Thumb encoding (32): 0xF8000900
    // Test aarch32_STRB_i_T3_A field combination: Rn=0, Rt=0, P=0, U=0, W=1, imm8=0
    // ISET: T32
    // Fields: U=0, imm8=0, W=1, Rn=0, Rt=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8000900;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T3_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=0 (immediate value 0)
#[test]
fn test_aarch32_strb_i_t3_a_combo_10_800_f8000800() {
    // Thumb encoding (32): 0xF8000800
    // Test aarch32_STRB_i_T3_A field combination: Rn=0, Rt=0, P=0, U=0, W=0, imm8=0
    // ISET: T32
    // Fields: Rn=0, Rt=0, P=0, W=0, imm8=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8000800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T3_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=1 (immediate value 1)
#[test]
fn test_aarch32_strb_i_t3_a_combo_11_800_f8000801() {
    // Thumb encoding (32): 0xF8000801
    // Test aarch32_STRB_i_T3_A field combination: Rn=0, Rt=0, P=0, U=0, W=0, imm8=1
    // ISET: T32
    // Fields: Rn=0, imm8=1, U=0, Rt=0, W=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8000801;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T3_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=3 (2^2 - 1 = 3)
#[test]
fn test_aarch32_strb_i_t3_a_combo_12_800_f8000803() {
    // Thumb encoding (32): 0xF8000803
    // Test aarch32_STRB_i_T3_A field combination: Rn=0, Rt=0, P=0, U=0, W=0, imm8=3
    // ISET: T32
    // Fields: P=0, U=0, W=0, Rn=0, Rt=0, imm8=3
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8000803;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T3_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=4 (power of 2 (2^2 = 4))
#[test]
fn test_aarch32_strb_i_t3_a_combo_13_800_f8000804() {
    // Thumb encoding (32): 0xF8000804
    // Test aarch32_STRB_i_T3_A field combination: Rn=0, Rt=0, P=0, U=0, W=0, imm8=4
    // ISET: T32
    // Fields: U=0, W=0, Rt=0, imm8=4, P=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8000804;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T3_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=7 (2^3 - 1 = 7)
#[test]
fn test_aarch32_strb_i_t3_a_combo_14_800_f8000807() {
    // Thumb encoding (32): 0xF8000807
    // Test aarch32_STRB_i_T3_A field combination: Rn=0, Rt=0, P=0, U=0, W=0, imm8=7
    // ISET: T32
    // Fields: Rt=0, W=0, imm8=7, Rn=0, U=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8000807;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T3_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=8 (power of 2 (2^3 = 8))
#[test]
fn test_aarch32_strb_i_t3_a_combo_15_800_f8000808() {
    // Thumb encoding (32): 0xF8000808
    // Test aarch32_STRB_i_T3_A field combination: Rn=0, Rt=0, P=0, U=0, W=0, imm8=8
    // ISET: T32
    // Fields: P=0, Rn=0, Rt=0, W=0, U=0, imm8=8
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8000808;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T3_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=15 (2^4 - 1 = 15)
#[test]
fn test_aarch32_strb_i_t3_a_combo_16_800_f800080f() {
    // Thumb encoding (32): 0xF800080F
    // Test aarch32_STRB_i_T3_A field combination: Rn=0, Rt=0, P=0, U=0, W=0, imm8=15
    // ISET: T32
    // Fields: Rt=0, U=0, Rn=0, W=0, imm8=15, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF800080F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T3_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=16 (power of 2 (2^4 = 16))
#[test]
fn test_aarch32_strb_i_t3_a_combo_17_800_f8000810() {
    // Thumb encoding (32): 0xF8000810
    // Test aarch32_STRB_i_T3_A field combination: Rn=0, Rt=0, P=0, U=0, W=0, imm8=16
    // ISET: T32
    // Fields: imm8=16, P=0, W=0, Rt=0, Rn=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8000810;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T3_A
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=31 (2^5 - 1 = 31)
#[test]
fn test_aarch32_strb_i_t3_a_combo_18_800_f800081f() {
    // Thumb encoding (32): 0xF800081F
    // Test aarch32_STRB_i_T3_A field combination: Rn=0, Rt=0, P=0, U=0, W=0, imm8=31
    // ISET: T32
    // Fields: Rt=0, U=0, Rn=0, W=0, imm8=31, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF800081F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T3_A
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=32 (power of 2 (2^5 = 32))
#[test]
fn test_aarch32_strb_i_t3_a_combo_19_800_f8000820() {
    // Thumb encoding (32): 0xF8000820
    // Test aarch32_STRB_i_T3_A field combination: Rn=0, Rt=0, P=0, U=0, W=0, imm8=32
    // ISET: T32
    // Fields: W=0, imm8=32, Rn=0, P=0, Rt=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8000820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRB_i_T3_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rn" }), rhs: Binary { op: Or, lhs: LitBits([true, true, true, true]), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "P" }), rhs: Binary { op: And, lhs: LitBits([false]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "W" }) } }, rhs: LitBits([false]) } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Rn\" }), rhs: Binary { op: Or, lhs: LitBits([true, true, true, true]), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"P\" }), rhs: Binary { op: And, lhs: LitBits([false]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"W\" }) } }, rhs: LitBits([false]) } } }" }
/// triggers Undefined
#[test]
fn test_aarch32_strb_i_t3_a_invalid_0_800_f8000800() {
    // Thumb encoding (32): 0xF8000800
    // Test aarch32_STRB_i_T3_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rn" }), rhs: Binary { op: Or, lhs: LitBits([true, true, true, true]), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "P" }), rhs: Binary { op: And, lhs: LitBits([false]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "W" }) } }, rhs: LitBits([false]) } } }
    // ISET: T32
    // Fields: Rt=0, P=0, U=0, W=0, imm8=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8000800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_STRB_i_T3_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_strb_i_t3_a_invalid_1_800_f8000800() {
    // Thumb encoding (32): 0xF8000800
    // Test aarch32_STRB_i_T3_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: Rt=0, W=0, U=0, P=0, imm8=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8000800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_STRB_i_T3_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Binary { op: Eq, lhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Binary { op: Eq, lhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"wback\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }) } } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strb_i_t3_a_invalid_2_800_f8000800() {
    // Thumb encoding (32): 0xF8000800
    // Test aarch32_STRB_i_T3_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Binary { op: Eq, lhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) } } }
    // ISET: T32
    // Fields: Rn=0, P=0, W=0, Rt=0, imm8=0, U=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8000800;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_STRB_i_T3_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strb_i_t3_a_invalid_3_800_f8000800() {
    // Thumb encoding (32): 0xF8000800
    // Test aarch32_STRB_i_T3_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: W=0, P=0, Rt=0, U=0, imm8=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8000800;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_STRB_i_A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_strb_i_a1_a_store_0_04410000() {
    // Test aarch32_STRB_i_A1_A memory store: 8 bytes
    // Encoding: 0x04410000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x04410000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_STRB_i_A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_strb_i_a1_a_store_1_04410000() {
    // Test aarch32_STRB_i_A1_A memory store: 8 bytes
    // Encoding: 0x04410000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0x04410000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_STRB_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 0 (32)
#[test]
fn test_aarch32_strb_i_t1_a_lslv_oracle_32_0_70020020() {
    // Test LSLV 32-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x12345678, "W0 should be 0x12345678");
}

/// Provenance: aarch32_STRB_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 0 (64)
#[test]
fn test_aarch32_strb_i_t1_a_lslv_oracle_64_0_f0020020() {
    // Test LSLV 64-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x12345678, "X0 should be 0x0000000012345678");
}

/// Provenance: aarch32_STRB_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4 (32)
#[test]
fn test_aarch32_strb_i_t1_a_lslv_oracle_32_1_70020020() {
    // Test LSLV 32-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x4);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x23456780, "W0 should be 0x23456780");
}

/// Provenance: aarch32_STRB_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 4 (64)
#[test]
fn test_aarch32_strb_i_t1_a_lslv_oracle_64_1_f0020020() {
    // Test LSLV 64-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x4);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x23456780, "X0 should be 0x0000000123456780");
}

/// Provenance: aarch32_STRB_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 8 (32)
#[test]
fn test_aarch32_strb_i_t1_a_lslv_oracle_32_2_70020020() {
    // Test LSLV 32-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x8);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x34567800, "W0 should be 0x34567800");
}

/// Provenance: aarch32_STRB_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 8 (64)
#[test]
fn test_aarch32_strb_i_t1_a_lslv_oracle_64_2_f0020020() {
    // Test LSLV 64-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x8);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x34567800, "X0 should be 0x0000001234567800");
}

/// Provenance: aarch32_STRB_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1 (32)
#[test]
fn test_aarch32_strb_i_t1_a_lslv_oracle_32_3_70020020() {
    // Test LSLV 32-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_STRB_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// MSB set, shift 1 (64)
#[test]
fn test_aarch32_strb_i_t1_a_lslv_oracle_64_3_f0020020() {
    // Test LSLV 64-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_STRB_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// LSB set, max shift (32)
#[test]
fn test_aarch32_strb_i_t1_a_lslv_oracle_32_4_70020020() {
    // Test LSLV 32-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x3F);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "W0 should be 0x80000000");
}

/// Provenance: aarch32_STRB_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// LSB set, max shift (64)
#[test]
fn test_aarch32_strb_i_t1_a_lslv_oracle_64_4_f0020020() {
    // Test LSLV 64-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x3F);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x8000000000000000");
}

/// Provenance: aarch32_STRB_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// all ones, shift 32 (32)
#[test]
fn test_aarch32_strb_i_t1_a_lslv_oracle_32_5_70020020() {
    // Test LSLV 32-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x20);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "W0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_STRB_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// all ones, shift 32 (64)
#[test]
fn test_aarch32_strb_i_t1_a_lslv_oracle_64_5_f0020020() {
    // Test LSLV 64-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x20);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0xFFFFFFFF00000000");
}

/// Provenance: aarch32_STRB_i_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// no shift
#[test]
fn test_aarch32_strb_i_t1_a_t16_oracle_0_70080000() {
    // Test T16 LSLS: no shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_STRB_i_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4
#[test]
fn test_aarch32_strb_i_t1_a_t16_oracle_1_70080000() {
    // Test T16 LSLS: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    set_w(&mut cpu, 2, 0x4);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF0, "R0 should be 0x00000FF0");
}

/// Provenance: aarch32_STRB_i_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1
#[test]
fn test_aarch32_strb_i_t1_a_t16_oracle_2_70080000() {
    // Test T16 LSLS: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_STRB_i_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift to MSB
#[test]
fn test_aarch32_strb_i_t1_a_t16_oracle_3_70080000() {
    // Test T16 LSLS: shift to MSB (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1F);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "R0 should be 0x80000000");
}

/// Provenance: aarch32_STRB_i_T1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_strb_i_t1_a_store_0_70080000() {
    // Test aarch32_STRB_i_T1_A memory store: 8 bytes
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_STRB_i_T1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_strb_i_t1_a_store_1_70080000() {
    // Test aarch32_STRB_i_T1_A memory store: 8 bytes
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_STRB_i_T2_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_strb_i_t2_a_store_0_f8810000() {
    // Test aarch32_STRB_i_T2_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0xF8810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_STRB_i_T2_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_strb_i_t2_a_store_1_f8810000() {
    // Test aarch32_STRB_i_T2_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0xF8810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_STRB_i_T3_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple multiply (32)
#[test]
fn test_aarch32_strb_i_t3_a_mul_oracle_32_0_1b027c20() {
    // Test MUL 32-bit: simple multiply (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x2);
    set_w(&mut cpu, 2, 0x3);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6, "W0 should be 0x00000006");
}

/// Provenance: aarch32_STRB_i_T3_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple multiply (64)
#[test]
fn test_aarch32_strb_i_t3_a_mul_oracle_64_0_9b027c20() {
    // Test MUL 64-bit: simple multiply (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x2);
    set_w(&mut cpu, 2, 0x3);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6, "X0 should be 0x0000000000000006");
}

/// Provenance: aarch32_STRB_i_T3_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// multiply by zero (32)
#[test]
fn test_aarch32_strb_i_t3_a_mul_oracle_32_1_1b027c20() {
    // Test MUL 32-bit: multiply by zero (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x64);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_STRB_i_T3_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// multiply by zero (64)
#[test]
fn test_aarch32_strb_i_t3_a_mul_oracle_64_1_9b027c20() {
    // Test MUL 64-bit: multiply by zero (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x64);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_STRB_i_T3_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// multiply by one (32)
#[test]
fn test_aarch32_strb_i_t3_a_mul_oracle_32_2_1b027c20() {
    // Test MUL 32-bit: multiply by one (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_STRB_i_T3_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// multiply by one (64)
#[test]
fn test_aarch32_strb_i_t3_a_mul_oracle_64_2_9b027c20() {
    // Test MUL 64-bit: multiply by one (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x0000000000000001");
}

/// Provenance: aarch32_STRB_i_T3_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// 16-bit max * 16-bit max (32)
#[test]
fn test_aarch32_strb_i_t3_a_mul_oracle_32_3_1b027c20() {
    // Test MUL 32-bit: 16-bit max * 16-bit max (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFF);
    set_w(&mut cpu, 2, 0xFFFF);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFE0001, "W0 should be 0xFFFE0001");
}

/// Provenance: aarch32_STRB_i_T3_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// 16-bit max * 16-bit max (64)
#[test]
fn test_aarch32_strb_i_t3_a_mul_oracle_64_3_9b027c20() {
    // Test MUL 64-bit: 16-bit max * 16-bit max (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFF);
    set_w(&mut cpu, 2, 0xFFFF);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFE0001, "X0 should be 0x00000000FFFE0001");
}

/// Provenance: aarch32_STRB_i_T3_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift-like multiply (32)
#[test]
fn test_aarch32_strb_i_t3_a_mul_oracle_32_4_1b027c20() {
    // Test MUL 32-bit: shift-like multiply (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x2468ACF0, "W0 should be 0x2468ACF0");
}

/// Provenance: aarch32_STRB_i_T3_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift-like multiply (64)
#[test]
fn test_aarch32_strb_i_t3_a_mul_oracle_64_4_9b027c20() {
    // Test MUL 64-bit: shift-like multiply (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x2468ACF0, "X0 should be 0x000000002468ACF0");
}

/// Provenance: aarch32_STRB_i_T3_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// larger values (32)
#[test]
fn test_aarch32_strb_i_t3_a_mul_oracle_32_5_1b027c20() {
    // Test MUL 32-bit: larger values (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xC8);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4E20, "W0 should be 0x00004E20");
}

/// Provenance: aarch32_STRB_i_T3_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// larger values (64)
#[test]
fn test_aarch32_strb_i_t3_a_mul_oracle_64_5_9b027c20() {
    // Test MUL 64-bit: larger values (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0xC8);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4E20, "X0 should be 0x0000000000004E20");
}

/// Provenance: aarch32_STRB_i_T3_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// 32-bit overflow (32)
#[test]
fn test_aarch32_strb_i_t3_a_mul_oracle_32_6_1b027c20() {
    // Test MUL 32-bit: 32-bit overflow (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_STRB_i_T3_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// 32-bit overflow (64)
#[test]
fn test_aarch32_strb_i_t3_a_mul_oracle_64_6_9b027c20() {
    // Test MUL 64-bit: 32-bit overflow (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0xFFFFFFFE00000001");
}

/// Provenance: aarch32_STRB_i_T3_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// prime numbers (32)
#[test]
fn test_aarch32_strb_i_t3_a_mul_oracle_32_7_1b027c20() {
    // Test MUL 32-bit: prime numbers (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7);
    set_w(&mut cpu, 2, 0xB);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4D, "W0 should be 0x0000004D");
}

/// Provenance: aarch32_STRB_i_T3_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// prime numbers (64)
#[test]
fn test_aarch32_strb_i_t3_a_mul_oracle_64_7_9b027c20() {
    // Test MUL 64-bit: prime numbers (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7);
    set_w(&mut cpu, 2, 0xB);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4D, "X0 should be 0x000000000000004D");
}

/// Provenance: aarch32_STRB_i_T3_A
/// ASL: `MUL R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple values
#[test]
fn test_aarch32_strb_i_t3_a_t32_oracle_0_f8010800() {
    // Test T32 MUL: simple values (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x32);
    let encoding: u32 = 0xF8010800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1388, "R0 should be 0x00001388");
}

/// Provenance: aarch32_STRB_i_T3_A
/// ASL: `MUL R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero values
#[test]
fn test_aarch32_strb_i_t3_a_t32_oracle_1_f8010800() {
    // Test T32 MUL: zero values (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xF8010800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_STRB_i_T3_A
/// ASL: `MUL R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max value
#[test]
fn test_aarch32_strb_i_t3_a_t32_oracle_2_f8010800() {
    // Test T32 MUL: max value (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0xF8010800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "R0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_STRB_i_T3_A
/// ASL: `MUL R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// mixed pattern
#[test]
fn test_aarch32_strb_i_t3_a_t32_oracle_3_f8010800() {
    // Test T32 MUL: mixed pattern (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0xABCDEF01);
    let encoding: u32 = 0xF8010800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x55065E78, "R0 should be 0x55065E78");
}

/// Provenance: aarch32_STRB_i_T3_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_strb_i_t3_a_store_0_f8010800() {
    // Test aarch32_STRB_i_T3_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF8010800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_STRB_i_T3_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_strb_i_t3_a_store_1_f8010800() {
    // Test aarch32_STRB_i_T3_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0xF8010800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// aarch32_STRT_A Tests
// ============================================================================

/// Provenance: aarch32_STRT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_strt_a1_a_field_cond_0_min_0_04200000() {
    // Encoding: 0x04200000
    // Test aarch32_STRT_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, Rt=0, U=0, cond=0, imm12=0
    let encoding: u32 = 0x04200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_strt_a1_a_field_cond_1_poweroftwo_0_14200000() {
    // Encoding: 0x14200000
    // Test aarch32_STRT_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, Rn=0, Rt=0, imm12=0, cond=1
    let encoding: u32 = 0x14200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_strt_a1_a_field_cond_2_poweroftwo_0_24200000() {
    // Encoding: 0x24200000
    // Test aarch32_STRT_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=0, U=0, Rt=0, Rn=0, cond=2
    let encoding: u32 = 0x24200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_strt_a1_a_field_cond_3_poweroftwo_0_34200000() {
    // Encoding: 0x34200000
    // Test aarch32_STRT_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=3, U=0, Rt=0, Rn=0, imm12=0
    let encoding: u32 = 0x34200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_strt_a1_a_field_cond_4_poweroftwo_0_44200000() {
    // Encoding: 0x44200000
    // Test aarch32_STRT_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, imm12=0, U=0, cond=4, Rt=0
    let encoding: u32 = 0x44200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_strt_a1_a_field_cond_5_poweroftwo_0_54200000() {
    // Encoding: 0x54200000
    // Test aarch32_STRT_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, U=0, imm12=0, cond=5, Rn=0
    let encoding: u32 = 0x54200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_strt_a1_a_field_cond_6_poweroftwo_0_64200000() {
    // Encoding: 0x64200000
    // Test aarch32_STRT_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, imm12=0, cond=6, U=0, Rn=0
    let encoding: u32 = 0x64200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_strt_a1_a_field_cond_7_poweroftwo_0_74200000() {
    // Encoding: 0x74200000
    // Test aarch32_STRT_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, cond=7, Rn=0, imm12=0, U=0
    let encoding: u32 = 0x74200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_strt_a1_a_field_cond_8_poweroftwo_0_84200000() {
    // Encoding: 0x84200000
    // Test aarch32_STRT_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, imm12=0, Rn=0, Rt=0, cond=8
    let encoding: u32 = 0x84200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_strt_a1_a_field_cond_9_poweroftwo_0_94200000() {
    // Encoding: 0x94200000
    // Test aarch32_STRT_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, Rt=0, imm12=0, Rn=0, cond=9
    let encoding: u32 = 0x94200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_strt_a1_a_field_cond_10_poweroftwo_0_a4200000() {
    // Encoding: 0xA4200000
    // Test aarch32_STRT_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=10, Rt=0, U=0, Rn=0, imm12=0
    let encoding: u32 = 0xA4200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_strt_a1_a_field_cond_11_poweroftwo_0_b4200000() {
    // Encoding: 0xB4200000
    // Test aarch32_STRT_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, U=0, Rt=0, cond=11, imm12=0
    let encoding: u32 = 0xB4200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_strt_a1_a_field_cond_12_poweroftwo_0_c4200000() {
    // Encoding: 0xC4200000
    // Test aarch32_STRT_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=0, Rn=0, U=0, cond=12, Rt=0
    let encoding: u32 = 0xC4200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_strt_a1_a_field_cond_13_poweroftwo_0_d4200000() {
    // Encoding: 0xD4200000
    // Test aarch32_STRT_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=0, U=0, Rt=0, Rn=0, cond=13
    let encoding: u32 = 0xD4200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_strt_a1_a_field_cond_14_poweroftwo_0_e4200000() {
    // Encoding: 0xE4200000
    // Test aarch32_STRT_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=0, cond=14, Rt=0, Rn=0, U=0
    let encoding: u32 = 0xE4200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_strt_a1_a_field_cond_15_max_0_f4200000() {
    // Encoding: 0xF4200000
    // Test aarch32_STRT_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: U=0, Rn=0, imm12=0, cond=15, Rt=0
    let encoding: u32 = 0xF4200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_strt_a1_a_field_u_0_min_0_04200000() {
    // Encoding: 0x04200000
    // Test aarch32_STRT_A1_A field U = 0 (Min)
    // ISET: A32
    // Fields: U=0, cond=0, Rt=0, imm12=0, Rn=0
    let encoding: u32 = 0x04200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_strt_a1_a_field_u_1_max_0_04a00000() {
    // Encoding: 0x04A00000
    // Test aarch32_STRT_A1_A field U = 1 (Max)
    // ISET: A32
    // Fields: Rt=0, imm12=0, cond=0, U=1, Rn=0
    let encoding: u32 = 0x04A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_strt_a1_a_field_rn_0_min_0_04200000() {
    // Encoding: 0x04200000
    // Test aarch32_STRT_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rt=0, Rn=0, imm12=0, U=0
    let encoding: u32 = 0x04200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_strt_a1_a_field_rn_1_poweroftwo_0_04210000() {
    // Encoding: 0x04210000
    // Test aarch32_STRT_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Rt=0, Rn=1, imm12=0, U=0
    let encoding: u32 = 0x04210000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_strt_a1_a_field_rt_0_min_0_04200000() {
    // Encoding: 0x04200000
    // Test aarch32_STRT_A1_A field Rt = 0 (Min)
    // ISET: A32
    // Fields: U=0, cond=0, Rn=0, Rt=0, imm12=0
    let encoding: u32 = 0x04200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_strt_a1_a_field_rt_1_poweroftwo_0_04201000() {
    // Encoding: 0x04201000
    // Test aarch32_STRT_A1_A field Rt = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=0, U=0, Rt=1, cond=0, Rn=0
    let encoding: u32 = 0x04201000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_strt_a1_a_field_imm12_0_zero_0_04200000() {
    // Encoding: 0x04200000
    // Test aarch32_STRT_A1_A field imm12 = 0 (Zero)
    // ISET: A32
    // Fields: Rn=0, U=0, cond=0, Rt=0, imm12=0
    let encoding: u32 = 0x04200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_strt_a1_a_field_imm12_1_poweroftwo_0_04200001() {
    // Encoding: 0x04200001
    // Test aarch32_STRT_A1_A field imm12 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, Rn=0, cond=0, Rt=0, imm12=1
    let encoding: u32 = 0x04200001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_strt_a1_a_field_imm12_3_poweroftwominusone_0_04200003() {
    // Encoding: 0x04200003
    // Test aarch32_STRT_A1_A field imm12 = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm12=3, cond=0, U=0, Rt=0, Rn=0
    let encoding: u32 = 0x04200003;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_strt_a1_a_field_imm12_4_poweroftwo_0_04200004() {
    // Encoding: 0x04200004
    // Test aarch32_STRT_A1_A field imm12 = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, cond=0, Rn=0, U=0, imm12=4
    let encoding: u32 = 0x04200004;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_strt_a1_a_field_imm12_7_poweroftwominusone_0_04200007() {
    // Encoding: 0x04200007
    // Test aarch32_STRT_A1_A field imm12 = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: U=0, Rn=0, imm12=7, Rt=0, cond=0
    let encoding: u32 = 0x04200007;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_strt_a1_a_field_imm12_8_poweroftwo_0_04200008() {
    // Encoding: 0x04200008
    // Test aarch32_STRT_A1_A field imm12 = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, U=0, Rn=0, imm12=8, Rt=0
    let encoding: u32 = 0x04200008;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_strt_a1_a_field_imm12_15_poweroftwominusone_0_0420000f() {
    // Encoding: 0x0420000F
    // Test aarch32_STRT_A1_A field imm12 = 15 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rt=0, Rn=0, U=0, imm12=15, cond=0
    let encoding: u32 = 0x0420000F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_strt_a1_a_field_imm12_16_poweroftwo_0_04200010() {
    // Encoding: 0x04200010
    // Test aarch32_STRT_A1_A field imm12 = 16 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, U=0, Rt=0, imm12=16, Rn=0
    let encoding: u32 = 0x04200010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_strt_a1_a_field_imm12_31_poweroftwominusone_0_0420001f() {
    // Encoding: 0x0420001F
    // Test aarch32_STRT_A1_A field imm12 = 31 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rt=0, imm12=31, U=0, cond=0, Rn=0
    let encoding: u32 = 0x0420001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_strt_a1_a_field_imm12_32_poweroftwo_0_04200020() {
    // Encoding: 0x04200020
    // Test aarch32_STRT_A1_A field imm12 = 32 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, U=0, Rn=0, cond=0, imm12=32
    let encoding: u32 = 0x04200020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_strt_a1_a_field_imm12_63_poweroftwominusone_0_0420003f() {
    // Encoding: 0x0420003F
    // Test aarch32_STRT_A1_A field imm12 = 63 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rn=0, cond=0, Rt=0, imm12=63, U=0
    let encoding: u32 = 0x0420003F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_strt_a1_a_field_imm12_64_poweroftwo_0_04200040() {
    // Encoding: 0x04200040
    // Test aarch32_STRT_A1_A field imm12 = 64 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rt=0, U=0, cond=0, imm12=64
    let encoding: u32 = 0x04200040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 127, boundary: PowerOfTwoMinusOne }
/// 2^7 - 1 = 127
#[test]
fn test_aarch32_strt_a1_a_field_imm12_127_poweroftwominusone_0_0420007f() {
    // Encoding: 0x0420007F
    // Test aarch32_STRT_A1_A field imm12 = 127 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: U=0, cond=0, Rt=0, imm12=127, Rn=0
    let encoding: u32 = 0x0420007F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_strt_a1_a_field_imm12_128_poweroftwo_0_04200080() {
    // Encoding: 0x04200080
    // Test aarch32_STRT_A1_A field imm12 = 128 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, Rn=0, imm12=128, U=0, cond=0
    let encoding: u32 = 0x04200080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 255, boundary: PowerOfTwoMinusOne }
/// 2^8 - 1 = 255
#[test]
fn test_aarch32_strt_a1_a_field_imm12_255_poweroftwominusone_0_042000ff() {
    // Encoding: 0x042000FF
    // Test aarch32_STRT_A1_A field imm12 = 255 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rt=0, imm12=255, cond=0, U=0, Rn=0
    let encoding: u32 = 0x042000FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 256, boundary: PowerOfTwo }
/// power of 2 (2^8 = 256)
#[test]
fn test_aarch32_strt_a1_a_field_imm12_256_poweroftwo_0_04200100() {
    // Encoding: 0x04200100
    // Test aarch32_STRT_A1_A field imm12 = 256 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Rt=0, imm12=256, U=0, Rn=0
    let encoding: u32 = 0x04200100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 511, boundary: PowerOfTwoMinusOne }
/// 2^9 - 1 = 511
#[test]
fn test_aarch32_strt_a1_a_field_imm12_511_poweroftwominusone_0_042001ff() {
    // Encoding: 0x042001FF
    // Test aarch32_STRT_A1_A field imm12 = 511 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: U=0, imm12=511, cond=0, Rn=0, Rt=0
    let encoding: u32 = 0x042001FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 512, boundary: PowerOfTwo }
/// power of 2 (2^9 = 512)
#[test]
fn test_aarch32_strt_a1_a_field_imm12_512_poweroftwo_0_04200200() {
    // Encoding: 0x04200200
    // Test aarch32_STRT_A1_A field imm12 = 512 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, cond=0, Rt=0, Rn=0, imm12=512
    let encoding: u32 = 0x04200200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1023, boundary: PowerOfTwoMinusOne }
/// 2^10 - 1 = 1023
#[test]
fn test_aarch32_strt_a1_a_field_imm12_1023_poweroftwominusone_0_042003ff() {
    // Encoding: 0x042003FF
    // Test aarch32_STRT_A1_A field imm12 = 1023 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: U=0, cond=0, Rn=0, Rt=0, imm12=1023
    let encoding: u32 = 0x042003FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1024, boundary: PowerOfTwo }
/// power of 2 (2^10 = 1024)
#[test]
fn test_aarch32_strt_a1_a_field_imm12_1024_poweroftwo_0_04200400() {
    // Encoding: 0x04200400
    // Test aarch32_STRT_A1_A field imm12 = 1024 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=1024, U=0, cond=0, Rn=0, Rt=0
    let encoding: u32 = 0x04200400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2047, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (2047)
#[test]
fn test_aarch32_strt_a1_a_field_imm12_2047_poweroftwominusone_0_042007ff() {
    // Encoding: 0x042007FF
    // Test aarch32_STRT_A1_A field imm12 = 2047 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, Rn=0, Rt=0, U=0, imm12=2047
    let encoding: u32 = 0x042007FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2048, boundary: PowerOfTwo }
/// power of 2 (2^11 = 2048)
#[test]
fn test_aarch32_strt_a1_a_field_imm12_2048_poweroftwo_0_04200800() {
    // Encoding: 0x04200800
    // Test aarch32_STRT_A1_A field imm12 = 2048 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, Rn=0, imm12=2048, cond=0, U=0
    let encoding: u32 = 0x04200800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4095, boundary: Max }
/// maximum immediate (4095)
#[test]
fn test_aarch32_strt_a1_a_field_imm12_4095_max_0_04200fff() {
    // Encoding: 0x04200FFF
    // Test aarch32_STRT_A1_A field imm12 = 4095 (Max)
    // ISET: A32
    // Fields: cond=0, U=0, imm12=4095, Rn=0, Rt=0
    let encoding: u32 = 0x04200FFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_strt_a1_a_combo_0_0_04200000() {
    // Encoding: 0x04200000
    // Test aarch32_STRT_A1_A field combination: cond=0, U=0, Rn=0, Rt=0, imm12=0
    // ISET: A32
    // Fields: cond=0, U=0, Rn=0, imm12=0, Rt=0
    let encoding: u32 = 0x04200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=1 (condition NE (not equal))
#[test]
fn test_aarch32_strt_a1_a_combo_1_0_14200000() {
    // Encoding: 0x14200000
    // Test aarch32_STRT_A1_A field combination: cond=1, U=0, Rn=0, Rt=0, imm12=0
    // ISET: A32
    // Fields: U=0, Rt=0, cond=1, Rn=0, imm12=0
    let encoding: u32 = 0x14200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=2 (condition CS/HS (carry set))
#[test]
fn test_aarch32_strt_a1_a_combo_2_0_24200000() {
    // Encoding: 0x24200000
    // Test aarch32_STRT_A1_A field combination: cond=2, U=0, Rn=0, Rt=0, imm12=0
    // ISET: A32
    // Fields: cond=2, U=0, Rn=0, imm12=0, Rt=0
    let encoding: u32 = 0x24200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=3 (condition CC/LO (carry clear))
#[test]
fn test_aarch32_strt_a1_a_combo_3_0_34200000() {
    // Encoding: 0x34200000
    // Test aarch32_STRT_A1_A field combination: cond=3, U=0, Rn=0, Rt=0, imm12=0
    // ISET: A32
    // Fields: U=0, Rn=0, cond=3, Rt=0, imm12=0
    let encoding: u32 = 0x34200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=4 (condition MI (minus/negative))
#[test]
fn test_aarch32_strt_a1_a_combo_4_0_44200000() {
    // Encoding: 0x44200000
    // Test aarch32_STRT_A1_A field combination: cond=4, U=0, Rn=0, Rt=0, imm12=0
    // ISET: A32
    // Fields: cond=4, Rn=0, imm12=0, Rt=0, U=0
    let encoding: u32 = 0x44200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=5 (condition PL (plus/positive))
#[test]
fn test_aarch32_strt_a1_a_combo_5_0_54200000() {
    // Encoding: 0x54200000
    // Test aarch32_STRT_A1_A field combination: cond=5, U=0, Rn=0, Rt=0, imm12=0
    // ISET: A32
    // Fields: cond=5, Rn=0, imm12=0, U=0, Rt=0
    let encoding: u32 = 0x54200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=6 (condition VS (overflow set))
#[test]
fn test_aarch32_strt_a1_a_combo_6_0_64200000() {
    // Encoding: 0x64200000
    // Test aarch32_STRT_A1_A field combination: cond=6, U=0, Rn=0, Rt=0, imm12=0
    // ISET: A32
    // Fields: U=0, cond=6, Rt=0, imm12=0, Rn=0
    let encoding: u32 = 0x64200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=7 (condition VC (overflow clear))
#[test]
fn test_aarch32_strt_a1_a_combo_7_0_74200000() {
    // Encoding: 0x74200000
    // Test aarch32_STRT_A1_A field combination: cond=7, U=0, Rn=0, Rt=0, imm12=0
    // ISET: A32
    // Fields: cond=7, Rn=0, imm12=0, U=0, Rt=0
    let encoding: u32 = 0x74200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=8 (condition HI (unsigned higher))
#[test]
fn test_aarch32_strt_a1_a_combo_8_0_84200000() {
    // Encoding: 0x84200000
    // Test aarch32_STRT_A1_A field combination: cond=8, U=0, Rn=0, Rt=0, imm12=0
    // ISET: A32
    // Fields: cond=8, Rn=0, imm12=0, U=0, Rt=0
    let encoding: u32 = 0x84200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=9 (condition LS (unsigned lower or same))
#[test]
fn test_aarch32_strt_a1_a_combo_9_0_94200000() {
    // Encoding: 0x94200000
    // Test aarch32_STRT_A1_A field combination: cond=9, U=0, Rn=0, Rt=0, imm12=0
    // ISET: A32
    // Fields: Rn=0, imm12=0, Rt=0, cond=9, U=0
    let encoding: u32 = 0x94200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=10 (condition GE (signed >=))
#[test]
fn test_aarch32_strt_a1_a_combo_10_0_a4200000() {
    // Encoding: 0xA4200000
    // Test aarch32_STRT_A1_A field combination: cond=10, U=0, Rn=0, Rt=0, imm12=0
    // ISET: A32
    // Fields: Rt=0, U=0, cond=10, Rn=0, imm12=0
    let encoding: u32 = 0xA4200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=11 (condition LT (signed <))
#[test]
fn test_aarch32_strt_a1_a_combo_11_0_b4200000() {
    // Encoding: 0xB4200000
    // Test aarch32_STRT_A1_A field combination: cond=11, U=0, Rn=0, Rt=0, imm12=0
    // ISET: A32
    // Fields: cond=11, Rn=0, Rt=0, U=0, imm12=0
    let encoding: u32 = 0xB4200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A1_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=12 (condition GT (signed >))
#[test]
fn test_aarch32_strt_a1_a_combo_12_0_c4200000() {
    // Encoding: 0xC4200000
    // Test aarch32_STRT_A1_A field combination: cond=12, U=0, Rn=0, Rt=0, imm12=0
    // ISET: A32
    // Fields: imm12=0, cond=12, Rn=0, Rt=0, U=0
    let encoding: u32 = 0xC4200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A1_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=13 (condition LE (signed <=))
#[test]
fn test_aarch32_strt_a1_a_combo_13_0_d4200000() {
    // Encoding: 0xD4200000
    // Test aarch32_STRT_A1_A field combination: cond=13, U=0, Rn=0, Rt=0, imm12=0
    // ISET: A32
    // Fields: cond=13, U=0, Rt=0, imm12=0, Rn=0
    let encoding: u32 = 0xD4200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A1_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=14 (condition AL (always))
#[test]
fn test_aarch32_strt_a1_a_combo_14_0_e4200000() {
    // Encoding: 0xE4200000
    // Test aarch32_STRT_A1_A field combination: cond=14, U=0, Rn=0, Rt=0, imm12=0
    // ISET: A32
    // Fields: cond=14, imm12=0, Rt=0, U=0, Rn=0
    let encoding: u32 = 0xE4200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A1_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=15 (condition NV (never, reserved))
#[test]
fn test_aarch32_strt_a1_a_combo_15_0_f4200000() {
    // Encoding: 0xF4200000
    // Test aarch32_STRT_A1_A field combination: cond=15, U=0, Rn=0, Rt=0, imm12=0
    // ISET: A32
    // Fields: U=0, Rt=0, cond=15, imm12=0, Rn=0
    let encoding: u32 = 0xF4200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A1_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=0 (minimum value)
#[test]
fn test_aarch32_strt_a1_a_combo_16_0_04200000() {
    // Encoding: 0x04200000
    // Test aarch32_STRT_A1_A field combination: cond=0, U=0, Rn=0, Rt=0, imm12=0
    // ISET: A32
    // Fields: U=0, Rn=0, imm12=0, Rt=0, cond=0
    let encoding: u32 = 0x04200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A1_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=1 (maximum value (1))
#[test]
fn test_aarch32_strt_a1_a_combo_17_0_04a00000() {
    // Encoding: 0x04A00000
    // Test aarch32_STRT_A1_A field combination: cond=0, U=1, Rn=0, Rt=0, imm12=0
    // ISET: A32
    // Fields: Rt=0, imm12=0, U=1, cond=0, Rn=0
    let encoding: u32 = 0x04A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A1_A
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_strt_a1_a_combo_18_0_04200000() {
    // Encoding: 0x04200000
    // Test aarch32_STRT_A1_A field combination: cond=0, U=0, Rn=0, Rt=0, imm12=0
    // ISET: A32
    // Fields: cond=0, imm12=0, Rn=0, Rt=0, U=0
    let encoding: u32 = 0x04200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A1_A
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_strt_a1_a_combo_19_0_04210000() {
    // Encoding: 0x04210000
    // Test aarch32_STRT_A1_A field combination: cond=0, U=0, Rn=1, Rt=0, imm12=0
    // ISET: A32
    // Fields: U=0, imm12=0, cond=0, Rn=1, Rt=0
    let encoding: u32 = 0x04210000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_strt_a1_a_special_cond_0_condition_eq_0_04200000() {
    // Encoding: 0x04200000
    // Test aarch32_STRT_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: Rt=0, U=0, Rn=0, cond=0, imm12=0
    let encoding: u32 = 0x04200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_strt_a1_a_special_cond_1_condition_ne_0_14200000() {
    // Encoding: 0x14200000
    // Test aarch32_STRT_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: cond=1, Rn=0, U=0, Rt=0, imm12=0
    let encoding: u32 = 0x14200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_strt_a1_a_special_cond_2_condition_cs_hs_0_24200000() {
    // Encoding: 0x24200000
    // Test aarch32_STRT_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: U=0, imm12=0, cond=2, Rt=0, Rn=0
    let encoding: u32 = 0x24200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_strt_a1_a_special_cond_3_condition_cc_lo_0_34200000() {
    // Encoding: 0x34200000
    // Test aarch32_STRT_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: Rt=0, imm12=0, cond=3, Rn=0, U=0
    let encoding: u32 = 0x34200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_strt_a1_a_special_cond_4_condition_mi_0_44200000() {
    // Encoding: 0x44200000
    // Test aarch32_STRT_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: cond=4, imm12=0, Rt=0, Rn=0, U=0
    let encoding: u32 = 0x44200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_strt_a1_a_special_cond_5_condition_pl_0_54200000() {
    // Encoding: 0x54200000
    // Test aarch32_STRT_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: cond=5, imm12=0, U=0, Rt=0, Rn=0
    let encoding: u32 = 0x54200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_strt_a1_a_special_cond_6_condition_vs_0_64200000() {
    // Encoding: 0x64200000
    // Test aarch32_STRT_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: cond=6, Rt=0, imm12=0, U=0, Rn=0
    let encoding: u32 = 0x64200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_strt_a1_a_special_cond_7_condition_vc_0_74200000() {
    // Encoding: 0x74200000
    // Test aarch32_STRT_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: Rt=0, cond=7, U=0, Rn=0, imm12=0
    let encoding: u32 = 0x74200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_strt_a1_a_special_cond_8_condition_hi_0_84200000() {
    // Encoding: 0x84200000
    // Test aarch32_STRT_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: Rn=0, U=0, Rt=0, cond=8, imm12=0
    let encoding: u32 = 0x84200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_strt_a1_a_special_cond_9_condition_ls_0_94200000() {
    // Encoding: 0x94200000
    // Test aarch32_STRT_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: Rn=0, Rt=0, imm12=0, cond=9, U=0
    let encoding: u32 = 0x94200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_strt_a1_a_special_cond_10_condition_ge_0_a4200000() {
    // Encoding: 0xA4200000
    // Test aarch32_STRT_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: imm12=0, Rt=0, cond=10, U=0, Rn=0
    let encoding: u32 = 0xA4200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_strt_a1_a_special_cond_11_condition_lt_0_b4200000() {
    // Encoding: 0xB4200000
    // Test aarch32_STRT_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: cond=11, Rn=0, Rt=0, imm12=0, U=0
    let encoding: u32 = 0xB4200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_strt_a1_a_special_cond_12_condition_gt_0_c4200000() {
    // Encoding: 0xC4200000
    // Test aarch32_STRT_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: cond=12, U=0, Rt=0, Rn=0, imm12=0
    let encoding: u32 = 0xC4200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_strt_a1_a_special_cond_13_condition_le_0_d4200000() {
    // Encoding: 0xD4200000
    // Test aarch32_STRT_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: cond=13, Rt=0, U=0, imm12=0, Rn=0
    let encoding: u32 = 0xD4200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_strt_a1_a_special_cond_14_condition_al_0_e4200000() {
    // Encoding: 0xE4200000
    // Test aarch32_STRT_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: imm12=0, cond=14, U=0, Rn=0, Rt=0
    let encoding: u32 = 0xE4200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_strt_a1_a_special_cond_15_condition_nv_0_f4200000() {
    // Encoding: 0xF4200000
    // Test aarch32_STRT_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: imm12=0, U=0, Rt=0, Rn=0, cond=15
    let encoding: u32 = 0xF4200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strt_a1_a_invalid_0_0_04200000() {
    // Encoding: 0x04200000
    // Test aarch32_STRT_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) }
    // ISET: A32
    // Fields: cond=0, U=0, Rt=0, Rn=0, imm12=0
    let encoding: u32 = 0x04200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STRT_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strt_a1_a_invalid_1_0_04200000() {
    // Encoding: 0x04200000
    // Test aarch32_STRT_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: U=0, Rt=0, imm12=0, Rn=0, cond=0
    let encoding: u32 = 0x04200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STRT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_strt_a2_a_field_cond_0_min_0_06200000() {
    // Encoding: 0x06200000
    // Test aarch32_STRT_A2_A field cond = 0 (Min)
    // ISET: A32
    // Fields: type1=0, cond=0, Rm=0, U=0, Rn=0, Rt=0, imm5=0
    let encoding: u32 = 0x06200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_strt_a2_a_field_cond_1_poweroftwo_0_16200000() {
    // Encoding: 0x16200000
    // Test aarch32_STRT_A2_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=1, U=0, Rt=0, imm5=0, Rn=0, type1=0, Rm=0
    let encoding: u32 = 0x16200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_strt_a2_a_field_cond_2_poweroftwo_0_26200000() {
    // Encoding: 0x26200000
    // Test aarch32_STRT_A2_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: type1=0, cond=2, Rt=0, imm5=0, U=0, Rn=0, Rm=0
    let encoding: u32 = 0x26200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_strt_a2_a_field_cond_3_poweroftwo_0_36200000() {
    // Encoding: 0x36200000
    // Test aarch32_STRT_A2_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: imm5=0, cond=3, Rm=0, type1=0, U=0, Rn=0, Rt=0
    let encoding: u32 = 0x36200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_strt_a2_a_field_cond_4_poweroftwo_0_46200000() {
    // Encoding: 0x46200000
    // Test aarch32_STRT_A2_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: type1=0, Rm=0, Rt=0, cond=4, U=0, imm5=0, Rn=0
    let encoding: u32 = 0x46200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_strt_a2_a_field_cond_5_poweroftwo_0_56200000() {
    // Encoding: 0x56200000
    // Test aarch32_STRT_A2_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: type1=0, Rn=0, Rm=0, imm5=0, U=0, Rt=0, cond=5
    let encoding: u32 = 0x56200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_strt_a2_a_field_cond_6_poweroftwo_0_66200000() {
    // Encoding: 0x66200000
    // Test aarch32_STRT_A2_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=6, U=0, Rn=0, Rt=0, imm5=0, type1=0, Rm=0
    let encoding: u32 = 0x66200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_strt_a2_a_field_cond_7_poweroftwo_0_76200000() {
    // Encoding: 0x76200000
    // Test aarch32_STRT_A2_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, cond=7, Rn=0, type1=0, Rt=0, U=0, imm5=0
    let encoding: u32 = 0x76200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_strt_a2_a_field_cond_8_poweroftwo_0_86200000() {
    // Encoding: 0x86200000
    // Test aarch32_STRT_A2_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, Rm=0, U=0, Rn=0, type1=0, cond=8, imm5=0
    let encoding: u32 = 0x86200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_strt_a2_a_field_cond_9_poweroftwo_0_96200000() {
    // Encoding: 0x96200000
    // Test aarch32_STRT_A2_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=9, U=0, Rt=0, Rm=0, type1=0, imm5=0
    let encoding: u32 = 0x96200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_strt_a2_a_field_cond_10_poweroftwo_0_a6200000() {
    // Encoding: 0xA6200000
    // Test aarch32_STRT_A2_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: imm5=0, cond=10, Rn=0, type1=0, Rm=0, U=0, Rt=0
    let encoding: u32 = 0xA6200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_strt_a2_a_field_cond_11_poweroftwo_0_b6200000() {
    // Encoding: 0xB6200000
    // Test aarch32_STRT_A2_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rt=0, Rm=0, U=0, imm5=0, cond=11, type1=0
    let encoding: u32 = 0xB6200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_strt_a2_a_field_cond_12_poweroftwo_0_c6200000() {
    // Encoding: 0xC6200000
    // Test aarch32_STRT_A2_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, Rm=0, Rt=0, cond=12, type1=0, imm5=0, Rn=0
    let encoding: u32 = 0xC6200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_strt_a2_a_field_cond_13_poweroftwo_0_d6200000() {
    // Encoding: 0xD6200000
    // Test aarch32_STRT_A2_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=13, type1=0, imm5=0, Rm=0, U=0
    let encoding: u32 = 0xD6200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_strt_a2_a_field_cond_14_poweroftwo_0_e6200000() {
    // Encoding: 0xE6200000
    // Test aarch32_STRT_A2_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rt=0, U=0, imm5=0, cond=14, type1=0, Rm=0
    let encoding: u32 = 0xE6200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_strt_a2_a_field_cond_15_max_0_f6200000() {
    // Encoding: 0xF6200000
    // Test aarch32_STRT_A2_A field cond = 15 (Max)
    // ISET: A32
    // Fields: cond=15, Rm=0, Rn=0, Rt=0, imm5=0, type1=0, U=0
    let encoding: u32 = 0xF6200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A2_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_strt_a2_a_field_u_0_min_0_06200000() {
    // Encoding: 0x06200000
    // Test aarch32_STRT_A2_A field U = 0 (Min)
    // ISET: A32
    // Fields: imm5=0, type1=0, Rm=0, Rt=0, U=0, cond=0, Rn=0
    let encoding: u32 = 0x06200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A2_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_strt_a2_a_field_u_1_max_0_06a00000() {
    // Encoding: 0x06A00000
    // Test aarch32_STRT_A2_A field U = 1 (Max)
    // ISET: A32
    // Fields: Rt=0, U=1, cond=0, Rn=0, imm5=0, type1=0, Rm=0
    let encoding: u32 = 0x06A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_strt_a2_a_field_rn_0_min_0_06200000() {
    // Encoding: 0x06200000
    // Test aarch32_STRT_A2_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: imm5=0, Rm=0, type1=0, Rn=0, U=0, cond=0, Rt=0
    let encoding: u32 = 0x06200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_strt_a2_a_field_rn_1_poweroftwo_0_06210000() {
    // Encoding: 0x06210000
    // Test aarch32_STRT_A2_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: imm5=0, type1=0, U=0, Rt=0, Rm=0, cond=0, Rn=1
    let encoding: u32 = 0x06210000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A2_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_strt_a2_a_field_rt_0_min_0_06200000() {
    // Encoding: 0x06200000
    // Test aarch32_STRT_A2_A field Rt = 0 (Min)
    // ISET: A32
    // Fields: type1=0, Rm=0, U=0, cond=0, Rn=0, Rt=0, imm5=0
    let encoding: u32 = 0x06200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A2_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_strt_a2_a_field_rt_1_poweroftwo_0_06201000() {
    // Encoding: 0x06201000
    // Test aarch32_STRT_A2_A field Rt = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: imm5=0, Rm=0, type1=0, Rn=0, U=0, cond=0, Rt=1
    let encoding: u32 = 0x06201000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A2_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_strt_a2_a_field_imm5_0_zero_0_06200000() {
    // Encoding: 0x06200000
    // Test aarch32_STRT_A2_A field imm5 = 0 (Zero)
    // ISET: A32
    // Fields: type1=0, Rt=0, Rm=0, cond=0, U=0, Rn=0, imm5=0
    let encoding: u32 = 0x06200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A2_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_strt_a2_a_field_imm5_1_poweroftwo_0_06200080() {
    // Encoding: 0x06200080
    // Test aarch32_STRT_A2_A field imm5 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, imm5=1, Rm=0, U=0, Rn=0, type1=0, cond=0
    let encoding: u32 = 0x06200080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A2_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_strt_a2_a_field_imm5_3_poweroftwominusone_0_06200180() {
    // Encoding: 0x06200180
    // Test aarch32_STRT_A2_A field imm5 = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rt=0, imm5=3, cond=0, U=0, type1=0, Rn=0, Rm=0
    let encoding: u32 = 0x06200180;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A2_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_strt_a2_a_field_imm5_4_poweroftwo_0_06200200() {
    // Encoding: 0x06200200
    // Test aarch32_STRT_A2_A field imm5 = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, type1=0, Rn=0, Rt=0, Rm=0, U=0, imm5=4
    let encoding: u32 = 0x06200200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A2_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_strt_a2_a_field_imm5_7_poweroftwominusone_0_06200380() {
    // Encoding: 0x06200380
    // Test aarch32_STRT_A2_A field imm5 = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, U=0, imm5=7, Rt=0, type1=0, Rn=0, Rm=0
    let encoding: u32 = 0x06200380;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A2_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_strt_a2_a_field_imm5_8_poweroftwo_0_06200400() {
    // Encoding: 0x06200400
    // Test aarch32_STRT_A2_A field imm5 = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, U=0, cond=0, imm5=8, Rn=0, Rt=0, type1=0
    let encoding: u32 = 0x06200400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A2_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 15, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (15)
#[test]
fn test_aarch32_strt_a2_a_field_imm5_15_poweroftwominusone_0_06200780() {
    // Encoding: 0x06200780
    // Test aarch32_STRT_A2_A field imm5 = 15 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: U=0, Rn=0, imm5=15, Rt=0, cond=0, type1=0, Rm=0
    let encoding: u32 = 0x06200780;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A2_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_strt_a2_a_field_imm5_16_poweroftwo_0_06200800() {
    // Encoding: 0x06200800
    // Test aarch32_STRT_A2_A field imm5 = 16 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, cond=0, Rn=0, imm5=16, type1=0, Rt=0, Rm=0
    let encoding: u32 = 0x06200800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A2_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 31, boundary: Max }
/// maximum immediate (31)
#[test]
fn test_aarch32_strt_a2_a_field_imm5_31_max_0_06200f80() {
    // Encoding: 0x06200F80
    // Test aarch32_STRT_A2_A field imm5 = 31 (Max)
    // ISET: A32
    // Fields: type1=0, Rt=0, imm5=31, U=0, Rm=0, cond=0, Rn=0
    let encoding: u32 = 0x06200F80;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A2_A
/// ASL: `field type1 5 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_strt_a2_a_field_type1_0_min_0_06200000() {
    // Encoding: 0x06200000
    // Test aarch32_STRT_A2_A field type1 = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rt=0, Rm=0, U=0, Rn=0, imm5=0, type1=0
    let encoding: u32 = 0x06200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A2_A
/// ASL: `field type1 5 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_strt_a2_a_field_type1_1_poweroftwo_0_06200020() {
    // Encoding: 0x06200020
    // Test aarch32_STRT_A2_A field type1 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, U=0, cond=0, Rn=0, Rt=0, imm5=0, type1=1
    let encoding: u32 = 0x06200020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A2_A
/// ASL: `field type1 5 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_aarch32_strt_a2_a_field_type1_3_max_0_06200060() {
    // Encoding: 0x06200060
    // Test aarch32_STRT_A2_A field type1 = 3 (Max)
    // ISET: A32
    // Fields: Rm=0, U=0, Rt=0, Rn=0, imm5=0, cond=0, type1=3
    let encoding: u32 = 0x06200060;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_strt_a2_a_field_rm_0_min_0_06200000() {
    // Encoding: 0x06200000
    // Test aarch32_STRT_A2_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: U=0, imm5=0, type1=0, Rt=0, Rm=0, cond=0, Rn=0
    let encoding: u32 = 0x06200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_strt_a2_a_field_rm_1_poweroftwo_0_06200001() {
    // Encoding: 0x06200001
    // Test aarch32_STRT_A2_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, cond=0, Rt=0, imm5=0, type1=0, Rm=1, Rn=0
    let encoding: u32 = 0x06200001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A2_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_strt_a2_a_combo_0_0_06200000() {
    // Encoding: 0x06200000
    // Test aarch32_STRT_A2_A field combination: cond=0, U=0, Rn=0, Rt=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: type1=0, Rm=0, U=0, cond=0, Rt=0, Rn=0, imm5=0
    let encoding: u32 = 0x06200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A2_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=1 (condition NE (not equal))
#[test]
fn test_aarch32_strt_a2_a_combo_1_0_16200000() {
    // Encoding: 0x16200000
    // Test aarch32_STRT_A2_A field combination: cond=1, U=0, Rn=0, Rt=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: Rt=0, Rm=0, type1=0, U=0, Rn=0, cond=1, imm5=0
    let encoding: u32 = 0x16200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A2_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=2 (condition CS/HS (carry set))
#[test]
fn test_aarch32_strt_a2_a_combo_2_0_26200000() {
    // Encoding: 0x26200000
    // Test aarch32_STRT_A2_A field combination: cond=2, U=0, Rn=0, Rt=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: U=0, imm5=0, Rn=0, Rt=0, type1=0, cond=2, Rm=0
    let encoding: u32 = 0x26200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A2_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=3 (condition CC/LO (carry clear))
#[test]
fn test_aarch32_strt_a2_a_combo_3_0_36200000() {
    // Encoding: 0x36200000
    // Test aarch32_STRT_A2_A field combination: cond=3, U=0, Rn=0, Rt=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: cond=3, Rn=0, Rt=0, imm5=0, U=0, type1=0, Rm=0
    let encoding: u32 = 0x36200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A2_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=4 (condition MI (minus/negative))
#[test]
fn test_aarch32_strt_a2_a_combo_4_0_46200000() {
    // Encoding: 0x46200000
    // Test aarch32_STRT_A2_A field combination: cond=4, U=0, Rn=0, Rt=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: cond=4, U=0, Rm=0, Rt=0, type1=0, imm5=0, Rn=0
    let encoding: u32 = 0x46200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A2_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=5 (condition PL (plus/positive))
#[test]
fn test_aarch32_strt_a2_a_combo_5_0_56200000() {
    // Encoding: 0x56200000
    // Test aarch32_STRT_A2_A field combination: cond=5, U=0, Rn=0, Rt=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: imm5=0, Rn=0, type1=0, U=0, Rt=0, Rm=0, cond=5
    let encoding: u32 = 0x56200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A2_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=6 (condition VS (overflow set))
#[test]
fn test_aarch32_strt_a2_a_combo_6_0_66200000() {
    // Encoding: 0x66200000
    // Test aarch32_STRT_A2_A field combination: cond=6, U=0, Rn=0, Rt=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: cond=6, U=0, Rt=0, Rn=0, imm5=0, type1=0, Rm=0
    let encoding: u32 = 0x66200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A2_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=7 (condition VC (overflow clear))
#[test]
fn test_aarch32_strt_a2_a_combo_7_0_76200000() {
    // Encoding: 0x76200000
    // Test aarch32_STRT_A2_A field combination: cond=7, U=0, Rn=0, Rt=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: imm5=0, type1=0, Rn=0, cond=7, Rt=0, Rm=0, U=0
    let encoding: u32 = 0x76200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A2_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=8 (condition HI (unsigned higher))
#[test]
fn test_aarch32_strt_a2_a_combo_8_0_86200000() {
    // Encoding: 0x86200000
    // Test aarch32_STRT_A2_A field combination: cond=8, U=0, Rn=0, Rt=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: Rn=0, Rm=0, cond=8, Rt=0, imm5=0, U=0, type1=0
    let encoding: u32 = 0x86200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A2_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=9 (condition LS (unsigned lower or same))
#[test]
fn test_aarch32_strt_a2_a_combo_9_0_96200000() {
    // Encoding: 0x96200000
    // Test aarch32_STRT_A2_A field combination: cond=9, U=0, Rn=0, Rt=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: cond=9, type1=0, Rt=0, Rn=0, Rm=0, imm5=0, U=0
    let encoding: u32 = 0x96200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A2_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=10 (condition GE (signed >=))
#[test]
fn test_aarch32_strt_a2_a_combo_10_0_a6200000() {
    // Encoding: 0xA6200000
    // Test aarch32_STRT_A2_A field combination: cond=10, U=0, Rn=0, Rt=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: Rt=0, Rm=0, Rn=0, imm5=0, type1=0, cond=10, U=0
    let encoding: u32 = 0xA6200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A2_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=11 (condition LT (signed <))
#[test]
fn test_aarch32_strt_a2_a_combo_11_0_b6200000() {
    // Encoding: 0xB6200000
    // Test aarch32_STRT_A2_A field combination: cond=11, U=0, Rn=0, Rt=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: Rn=0, Rm=0, U=0, Rt=0, cond=11, type1=0, imm5=0
    let encoding: u32 = 0xB6200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A2_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=12 (condition GT (signed >))
#[test]
fn test_aarch32_strt_a2_a_combo_12_0_c6200000() {
    // Encoding: 0xC6200000
    // Test aarch32_STRT_A2_A field combination: cond=12, U=0, Rn=0, Rt=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: Rn=0, cond=12, Rt=0, imm5=0, type1=0, U=0, Rm=0
    let encoding: u32 = 0xC6200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A2_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=13 (condition LE (signed <=))
#[test]
fn test_aarch32_strt_a2_a_combo_13_0_d6200000() {
    // Encoding: 0xD6200000
    // Test aarch32_STRT_A2_A field combination: cond=13, U=0, Rn=0, Rt=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: Rm=0, cond=13, Rn=0, Rt=0, imm5=0, type1=0, U=0
    let encoding: u32 = 0xD6200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A2_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=14 (condition AL (always))
#[test]
fn test_aarch32_strt_a2_a_combo_14_0_e6200000() {
    // Encoding: 0xE6200000
    // Test aarch32_STRT_A2_A field combination: cond=14, U=0, Rn=0, Rt=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: Rm=0, Rt=0, type1=0, cond=14, U=0, Rn=0, imm5=0
    let encoding: u32 = 0xE6200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A2_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=15 (condition NV (never, reserved))
#[test]
fn test_aarch32_strt_a2_a_combo_15_0_f6200000() {
    // Encoding: 0xF6200000
    // Test aarch32_STRT_A2_A field combination: cond=15, U=0, Rn=0, Rt=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: imm5=0, cond=15, Rt=0, U=0, Rm=0, type1=0, Rn=0
    let encoding: u32 = 0xF6200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A2_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=0 (minimum value)
#[test]
fn test_aarch32_strt_a2_a_combo_16_0_06200000() {
    // Encoding: 0x06200000
    // Test aarch32_STRT_A2_A field combination: cond=0, U=0, Rn=0, Rt=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: U=0, cond=0, Rt=0, Rm=0, type1=0, Rn=0, imm5=0
    let encoding: u32 = 0x06200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A2_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=1 (maximum value (1))
#[test]
fn test_aarch32_strt_a2_a_combo_17_0_06a00000() {
    // Encoding: 0x06A00000
    // Test aarch32_STRT_A2_A field combination: cond=0, U=1, Rn=0, Rt=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: Rt=0, type1=0, Rm=0, cond=0, U=1, imm5=0, Rn=0
    let encoding: u32 = 0x06A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A2_A
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_strt_a2_a_combo_18_0_06200000() {
    // Encoding: 0x06200000
    // Test aarch32_STRT_A2_A field combination: cond=0, U=0, Rn=0, Rt=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: imm5=0, type1=0, Rm=0, cond=0, U=0, Rt=0, Rn=0
    let encoding: u32 = 0x06200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A2_A
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_strt_a2_a_combo_19_0_06210000() {
    // Encoding: 0x06210000
    // Test aarch32_STRT_A2_A field combination: cond=0, U=0, Rn=1, Rt=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: type1=0, Rm=0, cond=0, Rn=1, Rt=0, U=0, imm5=0
    let encoding: u32 = 0x06210000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A2_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_strt_a2_a_special_cond_0_condition_eq_0_06200000() {
    // Encoding: 0x06200000
    // Test aarch32_STRT_A2_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: U=0, imm5=0, cond=0, Rt=0, type1=0, Rm=0, Rn=0
    let encoding: u32 = 0x06200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A2_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_strt_a2_a_special_cond_1_condition_ne_0_16200000() {
    // Encoding: 0x16200000
    // Test aarch32_STRT_A2_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: imm5=0, U=0, Rt=0, cond=1, Rm=0, Rn=0, type1=0
    let encoding: u32 = 0x16200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A2_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_strt_a2_a_special_cond_2_condition_cs_hs_0_26200000() {
    // Encoding: 0x26200000
    // Test aarch32_STRT_A2_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: Rm=0, Rn=0, imm5=0, U=0, Rt=0, cond=2, type1=0
    let encoding: u32 = 0x26200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A2_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_strt_a2_a_special_cond_3_condition_cc_lo_0_36200000() {
    // Encoding: 0x36200000
    // Test aarch32_STRT_A2_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: type1=0, Rt=0, Rm=0, cond=3, U=0, Rn=0, imm5=0
    let encoding: u32 = 0x36200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A2_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_strt_a2_a_special_cond_4_condition_mi_0_46200000() {
    // Encoding: 0x46200000
    // Test aarch32_STRT_A2_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: imm5=0, type1=0, Rn=0, cond=4, Rm=0, Rt=0, U=0
    let encoding: u32 = 0x46200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A2_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_strt_a2_a_special_cond_5_condition_pl_0_56200000() {
    // Encoding: 0x56200000
    // Test aarch32_STRT_A2_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: Rn=0, Rt=0, type1=0, cond=5, imm5=0, Rm=0, U=0
    let encoding: u32 = 0x56200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A2_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_strt_a2_a_special_cond_6_condition_vs_0_66200000() {
    // Encoding: 0x66200000
    // Test aarch32_STRT_A2_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: U=0, type1=0, cond=6, Rn=0, Rt=0, imm5=0, Rm=0
    let encoding: u32 = 0x66200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A2_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_strt_a2_a_special_cond_7_condition_vc_0_76200000() {
    // Encoding: 0x76200000
    // Test aarch32_STRT_A2_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: Rt=0, cond=7, U=0, Rn=0, type1=0, Rm=0, imm5=0
    let encoding: u32 = 0x76200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A2_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_strt_a2_a_special_cond_8_condition_hi_0_86200000() {
    // Encoding: 0x86200000
    // Test aarch32_STRT_A2_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: Rt=0, imm5=0, cond=8, Rn=0, type1=0, Rm=0, U=0
    let encoding: u32 = 0x86200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A2_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_strt_a2_a_special_cond_9_condition_ls_0_96200000() {
    // Encoding: 0x96200000
    // Test aarch32_STRT_A2_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: type1=0, U=0, Rt=0, Rm=0, Rn=0, imm5=0, cond=9
    let encoding: u32 = 0x96200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A2_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_strt_a2_a_special_cond_10_condition_ge_0_a6200000() {
    // Encoding: 0xA6200000
    // Test aarch32_STRT_A2_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: cond=10, Rt=0, U=0, Rn=0, imm5=0, type1=0, Rm=0
    let encoding: u32 = 0xA6200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A2_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_strt_a2_a_special_cond_11_condition_lt_0_b6200000() {
    // Encoding: 0xB6200000
    // Test aarch32_STRT_A2_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: Rn=0, Rt=0, U=0, type1=0, Rm=0, cond=11, imm5=0
    let encoding: u32 = 0xB6200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A2_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_strt_a2_a_special_cond_12_condition_gt_0_c6200000() {
    // Encoding: 0xC6200000
    // Test aarch32_STRT_A2_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: Rn=0, Rm=0, U=0, cond=12, Rt=0, type1=0, imm5=0
    let encoding: u32 = 0xC6200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A2_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_strt_a2_a_special_cond_13_condition_le_0_d6200000() {
    // Encoding: 0xD6200000
    // Test aarch32_STRT_A2_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: cond=13, Rm=0, Rn=0, Rt=0, imm5=0, type1=0, U=0
    let encoding: u32 = 0xD6200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A2_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_strt_a2_a_special_cond_14_condition_al_0_e6200000() {
    // Encoding: 0xE6200000
    // Test aarch32_STRT_A2_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: Rn=0, type1=0, U=0, Rt=0, cond=14, imm5=0, Rm=0
    let encoding: u32 = 0xE6200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A2_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_strt_a2_a_special_cond_15_condition_nv_0_f6200000() {
    // Encoding: 0xF6200000
    // Test aarch32_STRT_A2_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: U=0, Rn=0, Rt=0, cond=15, imm5=0, Rm=0, type1=0
    let encoding: u32 = 0xF6200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRT_A2_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strt_a2_a_invalid_0_0_06200000() {
    // Encoding: 0x06200000
    // Test aarch32_STRT_A2_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }
    // ISET: A32
    // Fields: cond=0, U=0, Rn=0, Rt=0, imm5=0, type1=0, Rm=0
    let encoding: u32 = 0x06200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STRT_A2_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strt_a2_a_invalid_1_0_06200000() {
    // Encoding: 0x06200000
    // Test aarch32_STRT_A2_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: imm5=0, Rt=0, Rm=0, U=0, Rn=0, cond=0, type1=0
    let encoding: u32 = 0x06200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STRT_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_strt_t1_a_field_rn_0_min_e00_f8400e00() {
    // Thumb encoding (32): 0xF8400E00
    // Test aarch32_STRT_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, imm8=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8400E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRT_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_strt_t1_a_field_rn_1_poweroftwo_e00_f8410e00() {
    // Thumb encoding (32): 0xF8410E00
    // Test aarch32_STRT_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=0, Rt=0, Rn=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8410E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRT_T1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_strt_t1_a_field_rt_0_min_e00_f8400e00() {
    // Thumb encoding (32): 0xF8400E00
    // Test aarch32_STRT_T1_A field Rt = 0 (Min)
    // ISET: T32
    // Fields: imm8=0, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8400E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRT_T1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_strt_t1_a_field_rt_1_poweroftwo_e00_f8401e00() {
    // Thumb encoding (32): 0xF8401E00
    // Test aarch32_STRT_T1_A field Rt = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=0, Rn=0, Rt=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8401E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_strt_t1_a_field_imm8_0_zero_e00_f8400e00() {
    // Thumb encoding (32): 0xF8400E00
    // Test aarch32_STRT_T1_A field imm8 = 0 (Zero)
    // ISET: T32
    // Fields: imm8=0, Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8400E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_strt_t1_a_field_imm8_1_poweroftwo_e00_f8400e01() {
    // Thumb encoding (32): 0xF8400E01
    // Test aarch32_STRT_T1_A field imm8 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, Rn=0, imm8=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8400E01;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_strt_t1_a_field_imm8_3_poweroftwominusone_e00_f8400e03() {
    // Thumb encoding (32): 0xF8400E03
    // Test aarch32_STRT_T1_A field imm8 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, imm8=3, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8400E03;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_strt_t1_a_field_imm8_4_poweroftwo_e00_f8400e04() {
    // Thumb encoding (32): 0xF8400E04
    // Test aarch32_STRT_T1_A field imm8 = 4 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, imm8=4, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8400E04;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_strt_t1_a_field_imm8_7_poweroftwominusone_e00_f8400e07() {
    // Thumb encoding (32): 0xF8400E07
    // Test aarch32_STRT_T1_A field imm8 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, Rn=0, imm8=7
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8400E07;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_strt_t1_a_field_imm8_8_poweroftwo_e00_f8400e08() {
    // Thumb encoding (32): 0xF8400E08
    // Test aarch32_STRT_T1_A field imm8 = 8 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=8, Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8400E08;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_strt_t1_a_field_imm8_15_poweroftwominusone_e00_f8400e0f() {
    // Thumb encoding (32): 0xF8400E0F
    // Test aarch32_STRT_T1_A field imm8 = 15 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm8=15, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8400E0F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_strt_t1_a_field_imm8_16_poweroftwo_e00_f8400e10() {
    // Thumb encoding (32): 0xF8400E10
    // Test aarch32_STRT_T1_A field imm8 = 16 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm8=16
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8400E10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_strt_t1_a_field_imm8_31_poweroftwominusone_e00_f8400e1f() {
    // Thumb encoding (32): 0xF8400E1F
    // Test aarch32_STRT_T1_A field imm8 = 31 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, Rn=0, imm8=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8400E1F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_strt_t1_a_field_imm8_32_poweroftwo_e00_f8400e20() {
    // Thumb encoding (32): 0xF8400E20
    // Test aarch32_STRT_T1_A field imm8 = 32 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm8=32
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8400E20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_strt_t1_a_field_imm8_63_poweroftwominusone_e00_f8400e3f() {
    // Thumb encoding (32): 0xF8400E3F
    // Test aarch32_STRT_T1_A field imm8 = 63 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm8=63, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8400E3F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_strt_t1_a_field_imm8_64_poweroftwo_e00_f8400e40() {
    // Thumb encoding (32): 0xF8400E40
    // Test aarch32_STRT_T1_A field imm8 = 64 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=64, Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8400E40;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 127, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (127)
#[test]
fn test_aarch32_strt_t1_a_field_imm8_127_poweroftwominusone_e00_f8400e7f() {
    // Thumb encoding (32): 0xF8400E7F
    // Test aarch32_STRT_T1_A field imm8 = 127 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, imm8=127, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8400E7F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_strt_t1_a_field_imm8_128_poweroftwo_e00_f8400e80() {
    // Thumb encoding (32): 0xF8400E80
    // Test aarch32_STRT_T1_A field imm8 = 128 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm8=128
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8400E80;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 255, boundary: Max }
/// maximum immediate (255)
#[test]
fn test_aarch32_strt_t1_a_field_imm8_255_max_e00_f8400eff() {
    // Thumb encoding (32): 0xF8400EFF
    // Test aarch32_STRT_T1_A field imm8 = 255 (Max)
    // ISET: T32
    // Fields: Rt=0, imm8=255, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8400EFF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRT_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_strt_t1_a_combo_0_e00_f8400e00() {
    // Thumb encoding (32): 0xF8400E00
    // Test aarch32_STRT_T1_A field combination: Rn=0, Rt=0, imm8=0
    // ISET: T32
    // Fields: imm8=0, Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8400E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRT_T1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_strt_t1_a_combo_1_e00_f8410e00() {
    // Thumb encoding (32): 0xF8410E00
    // Test aarch32_STRT_T1_A field combination: Rn=1, Rt=0, imm8=0
    // ISET: T32
    // Fields: Rn=1, imm8=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8410E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRT_T1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=0 (register index 0 (first register))
#[test]
fn test_aarch32_strt_t1_a_combo_2_e00_f8400e00() {
    // Thumb encoding (32): 0xF8400E00
    // Test aarch32_STRT_T1_A field combination: Rn=0, Rt=0, imm8=0
    // ISET: T32
    // Fields: Rn=0, imm8=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8400E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRT_T1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=1 (register index 1 (second register))
#[test]
fn test_aarch32_strt_t1_a_combo_3_e00_f8401e00() {
    // Thumb encoding (32): 0xF8401E00
    // Test aarch32_STRT_T1_A field combination: Rn=0, Rt=1, imm8=0
    // ISET: T32
    // Fields: Rn=0, Rt=1, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8401E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRT_T1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=0 (immediate value 0)
#[test]
fn test_aarch32_strt_t1_a_combo_4_e00_f8400e00() {
    // Thumb encoding (32): 0xF8400E00
    // Test aarch32_STRT_T1_A field combination: Rn=0, Rt=0, imm8=0
    // ISET: T32
    // Fields: Rt=0, imm8=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8400E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRT_T1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=1 (immediate value 1)
#[test]
fn test_aarch32_strt_t1_a_combo_5_e00_f8400e01() {
    // Thumb encoding (32): 0xF8400E01
    // Test aarch32_STRT_T1_A field combination: Rn=0, Rt=0, imm8=1
    // ISET: T32
    // Fields: Rt=0, imm8=1, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8400E01;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRT_T1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=3 (2^2 - 1 = 3)
#[test]
fn test_aarch32_strt_t1_a_combo_6_e00_f8400e03() {
    // Thumb encoding (32): 0xF8400E03
    // Test aarch32_STRT_T1_A field combination: Rn=0, Rt=0, imm8=3
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm8=3
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8400E03;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRT_T1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=4 (power of 2 (2^2 = 4))
#[test]
fn test_aarch32_strt_t1_a_combo_7_e00_f8400e04() {
    // Thumb encoding (32): 0xF8400E04
    // Test aarch32_STRT_T1_A field combination: Rn=0, Rt=0, imm8=4
    // ISET: T32
    // Fields: Rn=0, imm8=4, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8400E04;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRT_T1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=7 (2^3 - 1 = 7)
#[test]
fn test_aarch32_strt_t1_a_combo_8_e00_f8400e07() {
    // Thumb encoding (32): 0xF8400E07
    // Test aarch32_STRT_T1_A field combination: Rn=0, Rt=0, imm8=7
    // ISET: T32
    // Fields: imm8=7, Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8400E07;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRT_T1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=8 (power of 2 (2^3 = 8))
#[test]
fn test_aarch32_strt_t1_a_combo_9_e00_f8400e08() {
    // Thumb encoding (32): 0xF8400E08
    // Test aarch32_STRT_T1_A field combination: Rn=0, Rt=0, imm8=8
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm8=8
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8400E08;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRT_T1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=15 (2^4 - 1 = 15)
#[test]
fn test_aarch32_strt_t1_a_combo_10_e00_f8400e0f() {
    // Thumb encoding (32): 0xF8400E0F
    // Test aarch32_STRT_T1_A field combination: Rn=0, Rt=0, imm8=15
    // ISET: T32
    // Fields: Rn=0, imm8=15, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8400E0F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRT_T1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=16 (power of 2 (2^4 = 16))
#[test]
fn test_aarch32_strt_t1_a_combo_11_e00_f8400e10() {
    // Thumb encoding (32): 0xF8400E10
    // Test aarch32_STRT_T1_A field combination: Rn=0, Rt=0, imm8=16
    // ISET: T32
    // Fields: Rn=0, imm8=16, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8400E10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRT_T1_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=31 (2^5 - 1 = 31)
#[test]
fn test_aarch32_strt_t1_a_combo_12_e00_f8400e1f() {
    // Thumb encoding (32): 0xF8400E1F
    // Test aarch32_STRT_T1_A field combination: Rn=0, Rt=0, imm8=31
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm8=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8400E1F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRT_T1_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=32 (power of 2 (2^5 = 32))
#[test]
fn test_aarch32_strt_t1_a_combo_13_e00_f8400e20() {
    // Thumb encoding (32): 0xF8400E20
    // Test aarch32_STRT_T1_A field combination: Rn=0, Rt=0, imm8=32
    // ISET: T32
    // Fields: Rn=0, imm8=32, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8400E20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRT_T1_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=63 (2^6 - 1 = 63)
#[test]
fn test_aarch32_strt_t1_a_combo_14_e00_f8400e3f() {
    // Thumb encoding (32): 0xF8400E3F
    // Test aarch32_STRT_T1_A field combination: Rn=0, Rt=0, imm8=63
    // ISET: T32
    // Fields: Rt=0, imm8=63, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8400E3F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRT_T1_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=64 (power of 2 (2^6 = 64))
#[test]
fn test_aarch32_strt_t1_a_combo_15_e00_f8400e40() {
    // Thumb encoding (32): 0xF8400E40
    // Test aarch32_STRT_T1_A field combination: Rn=0, Rt=0, imm8=64
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm8=64
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8400E40;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRT_T1_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=127 (immediate midpoint (127))
#[test]
fn test_aarch32_strt_t1_a_combo_16_e00_f8400e7f() {
    // Thumb encoding (32): 0xF8400E7F
    // Test aarch32_STRT_T1_A field combination: Rn=0, Rt=0, imm8=127
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm8=127
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8400E7F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRT_T1_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=128 (power of 2 (2^7 = 128))
#[test]
fn test_aarch32_strt_t1_a_combo_17_e00_f8400e80() {
    // Thumb encoding (32): 0xF8400E80
    // Test aarch32_STRT_T1_A field combination: Rn=0, Rt=0, imm8=128
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm8=128
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8400E80;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRT_T1_A
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=255 (maximum immediate (255))
#[test]
fn test_aarch32_strt_t1_a_combo_18_e00_f8400eff() {
    // Thumb encoding (32): 0xF8400EFF
    // Test aarch32_STRT_T1_A field combination: Rn=0, Rt=0, imm8=255
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm8=255
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8400EFF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRT_T1_A
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rt=1 (same register test (reg=1))
#[test]
fn test_aarch32_strt_t1_a_combo_19_e00_f8411e00() {
    // Thumb encoding (32): 0xF8411E00
    // Test aarch32_STRT_T1_A field combination: Rn=1, Rt=1, imm8=0
    // ISET: T32
    // Fields: Rn=1, Rt=1, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8411E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRT_T1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rn" }), rhs: LitBits([true, true, true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Rn\" }), rhs: LitBits([true, true, true, true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_strt_t1_a_invalid_0_e00_f8400e00() {
    // Thumb encoding (32): 0xF8400E00
    // Test aarch32_STRT_T1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rn" }), rhs: LitBits([true, true, true, true]) }
    // ISET: T32
    // Fields: Rt=0, imm8=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8400E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_STRT_T1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_strt_t1_a_invalid_1_e00_f8400e00() {
    // Thumb encoding (32): 0xF8400E00
    // Test aarch32_STRT_T1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: Rn=0, imm8=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8400E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_STRT_T1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strt_t1_a_invalid_2_e00_f8400e00() {
    // Thumb encoding (32): 0xF8400E00
    // Test aarch32_STRT_T1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: LitInt(15) }
    // ISET: T32
    // Fields: imm8=0, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8400E00;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_STRT_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strt_t1_a_invalid_3_e00_f8400e00() {
    // Thumb encoding (32): 0xF8400E00
    // Test aarch32_STRT_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rt=0, imm8=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8400E00;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_STRT_A1_A
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strt_a1_a_exception_0_04200000() {
    // Test aarch32_STRT_A1_A exception: Unpredictable
    // Encoding: 0x04200000
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_STRT_A2_A
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strt_a2_a_exception_0_06200000() {
    // Test aarch32_STRT_A2_A exception: Unpredictable
    // Encoding: 0x06200000
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x06200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_STRT_T1_A
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strt_t1_a_exception_0_f8400e00() {
    // Test aarch32_STRT_T1_A exception: Unpredictable
    // ISET: T32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF8400E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// aarch32_STM_u_AS Tests
// ============================================================================

/// Provenance: aarch32_STM_u_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_stm_u_a1_as_field_cond_0_min_0_08400000() {
    // Encoding: 0x08400000
    // Test aarch32_STM_u_A1_AS field cond = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, cond=0, register_list=0, U=0, P=0
    let encoding: u32 = 0x08400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_u_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_stm_u_a1_as_field_cond_1_poweroftwo_0_18400000() {
    // Encoding: 0x18400000
    // Test aarch32_STM_u_A1_AS field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=1, P=0, register_list=0, Rn=0, U=0
    let encoding: u32 = 0x18400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_u_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_stm_u_a1_as_field_cond_2_poweroftwo_0_28400000() {
    // Encoding: 0x28400000
    // Test aarch32_STM_u_A1_AS field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=2, Rn=0, P=0, U=0, register_list=0
    let encoding: u32 = 0x28400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_u_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_stm_u_a1_as_field_cond_3_poweroftwo_0_38400000() {
    // Encoding: 0x38400000
    // Test aarch32_STM_u_A1_AS field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, cond=3, register_list=0, Rn=0, U=0
    let encoding: u32 = 0x38400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_u_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_stm_u_a1_as_field_cond_4_poweroftwo_0_48400000() {
    // Encoding: 0x48400000
    // Test aarch32_STM_u_A1_AS field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, P=0, register_list=0, cond=4, Rn=0
    let encoding: u32 = 0x48400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_u_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_stm_u_a1_as_field_cond_5_poweroftwo_0_58400000() {
    // Encoding: 0x58400000
    // Test aarch32_STM_u_A1_AS field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: register_list=0, U=0, Rn=0, P=0, cond=5
    let encoding: u32 = 0x58400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_u_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_stm_u_a1_as_field_cond_6_poweroftwo_0_68400000() {
    // Encoding: 0x68400000
    // Test aarch32_STM_u_A1_AS field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, Rn=0, register_list=0, cond=6, P=0
    let encoding: u32 = 0x68400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_u_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_stm_u_a1_as_field_cond_7_poweroftwo_0_78400000() {
    // Encoding: 0x78400000
    // Test aarch32_STM_u_A1_AS field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=7, register_list=0, U=0, P=0, Rn=0
    let encoding: u32 = 0x78400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_u_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_stm_u_a1_as_field_cond_8_poweroftwo_0_88400000() {
    // Encoding: 0x88400000
    // Test aarch32_STM_u_A1_AS field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, Rn=0, cond=8, P=0, register_list=0
    let encoding: u32 = 0x88400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_u_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_stm_u_a1_as_field_cond_9_poweroftwo_0_98400000() {
    // Encoding: 0x98400000
    // Test aarch32_STM_u_A1_AS field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: register_list=0, U=0, cond=9, Rn=0, P=0
    let encoding: u32 = 0x98400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_u_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_stm_u_a1_as_field_cond_10_poweroftwo_0_a8400000() {
    // Encoding: 0xA8400000
    // Test aarch32_STM_u_A1_AS field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, Rn=0, cond=10, register_list=0, U=0
    let encoding: u32 = 0xA8400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_u_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_stm_u_a1_as_field_cond_11_poweroftwo_0_b8400000() {
    // Encoding: 0xB8400000
    // Test aarch32_STM_u_A1_AS field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=11, U=0, P=0, Rn=0, register_list=0
    let encoding: u32 = 0xB8400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_u_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_stm_u_a1_as_field_cond_12_poweroftwo_0_c8400000() {
    // Encoding: 0xC8400000
    // Test aarch32_STM_u_A1_AS field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, Rn=0, cond=12, register_list=0, P=0
    let encoding: u32 = 0xC8400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_u_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_stm_u_a1_as_field_cond_13_poweroftwo_0_d8400000() {
    // Encoding: 0xD8400000
    // Test aarch32_STM_u_A1_AS field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, cond=13, Rn=0, U=0, register_list=0
    let encoding: u32 = 0xD8400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_u_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_stm_u_a1_as_field_cond_14_poweroftwo_0_e8400000() {
    // Encoding: 0xE8400000
    // Test aarch32_STM_u_A1_AS field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=14, P=0, Rn=0, U=0, register_list=0
    let encoding: u32 = 0xE8400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_u_A1_AS
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_stm_u_a1_as_field_cond_15_max_0_f8400000() {
    // Encoding: 0xF8400000
    // Test aarch32_STM_u_A1_AS field cond = 15 (Max)
    // ISET: A32
    // Fields: cond=15, Rn=0, U=0, P=0, register_list=0
    let encoding: u32 = 0xF8400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_u_A1_AS
/// ASL: `field P 24 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_stm_u_a1_as_field_p_0_min_0_08400000() {
    // Encoding: 0x08400000
    // Test aarch32_STM_u_A1_AS field P = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, cond=0, P=0, U=0, register_list=0
    let encoding: u32 = 0x08400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_u_A1_AS
/// ASL: `field P 24 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_stm_u_a1_as_field_p_1_max_0_09400000() {
    // Encoding: 0x09400000
    // Test aarch32_STM_u_A1_AS field P = 1 (Max)
    // ISET: A32
    // Fields: cond=0, U=0, Rn=0, register_list=0, P=1
    let encoding: u32 = 0x09400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_u_A1_AS
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_stm_u_a1_as_field_u_0_min_0_08400000() {
    // Encoding: 0x08400000
    // Test aarch32_STM_u_A1_AS field U = 0 (Min)
    // ISET: A32
    // Fields: cond=0, P=0, U=0, Rn=0, register_list=0
    let encoding: u32 = 0x08400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_u_A1_AS
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_stm_u_a1_as_field_u_1_max_0_08c00000() {
    // Encoding: 0x08C00000
    // Test aarch32_STM_u_A1_AS field U = 1 (Max)
    // ISET: A32
    // Fields: U=1, cond=0, Rn=0, P=0, register_list=0
    let encoding: u32 = 0x08C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_u_A1_AS
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_stm_u_a1_as_field_rn_0_min_0_08400000() {
    // Encoding: 0x08400000
    // Test aarch32_STM_u_A1_AS field Rn = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, register_list=0, cond=0, P=0, U=0
    let encoding: u32 = 0x08400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_u_A1_AS
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_stm_u_a1_as_field_rn_1_poweroftwo_0_08410000() {
    // Encoding: 0x08410000
    // Test aarch32_STM_u_A1_AS field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=1, U=0, P=0, cond=0, register_list=0
    let encoding: u32 = 0x08410000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_u_A1_AS
/// ASL: `field register_list 0 +: 16`
/// Requirement: FieldBoundary { field: "register_list", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_stm_u_a1_as_field_register_list_0_min_0_08400000() {
    // Encoding: 0x08400000
    // Test aarch32_STM_u_A1_AS field register_list = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, cond=0, U=0, P=0, register_list=0
    let encoding: u32 = 0x08400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_u_A1_AS
/// ASL: `field register_list 0 +: 16`
/// Requirement: FieldBoundary { field: "register_list", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_stm_u_a1_as_field_register_list_1_poweroftwo_0_08400001() {
    // Encoding: 0x08400001
    // Test aarch32_STM_u_A1_AS field register_list = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=0, U=0, P=0, register_list=1
    let encoding: u32 = 0x08400001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_u_A1_AS
/// ASL: `field register_list 0 +: 16`
/// Requirement: FieldBoundary { field: "register_list", value: 32767, boundary: PowerOfTwoMinusOne }
/// midpoint (32767)
#[test]
fn test_aarch32_stm_u_a1_as_field_register_list_32767_poweroftwominusone_0_08407fff() {
    // Encoding: 0x08407FFF
    // Test aarch32_STM_u_A1_AS field register_list = 32767 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, Rn=0, register_list=32767, P=0, U=0
    let encoding: u32 = 0x08407FFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_u_A1_AS
/// ASL: `field register_list 0 +: 16`
/// Requirement: FieldBoundary { field: "register_list", value: 65535, boundary: Max }
/// maximum value (65535)
#[test]
fn test_aarch32_stm_u_a1_as_field_register_list_65535_max_0_0840ffff() {
    // Encoding: 0x0840FFFF
    // Test aarch32_STM_u_A1_AS field register_list = 65535 (Max)
    // ISET: A32
    // Fields: P=0, register_list=65535, U=0, cond=0, Rn=0
    let encoding: u32 = 0x0840FFFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_u_A1_AS
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_stm_u_a1_as_combo_0_0_08400000() {
    // Encoding: 0x08400000
    // Test aarch32_STM_u_A1_AS field combination: cond=0, P=0, U=0, Rn=0, register_list=0
    // ISET: A32
    // Fields: Rn=0, register_list=0, P=0, U=0, cond=0
    let encoding: u32 = 0x08400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_u_A1_AS
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=1 (condition NE (not equal))
#[test]
fn test_aarch32_stm_u_a1_as_combo_1_0_18400000() {
    // Encoding: 0x18400000
    // Test aarch32_STM_u_A1_AS field combination: cond=1, P=0, U=0, Rn=0, register_list=0
    // ISET: A32
    // Fields: U=0, register_list=0, P=0, Rn=0, cond=1
    let encoding: u32 = 0x18400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_u_A1_AS
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=2 (condition CS/HS (carry set))
#[test]
fn test_aarch32_stm_u_a1_as_combo_2_0_28400000() {
    // Encoding: 0x28400000
    // Test aarch32_STM_u_A1_AS field combination: cond=2, P=0, U=0, Rn=0, register_list=0
    // ISET: A32
    // Fields: Rn=0, register_list=0, P=0, U=0, cond=2
    let encoding: u32 = 0x28400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_u_A1_AS
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=3 (condition CC/LO (carry clear))
#[test]
fn test_aarch32_stm_u_a1_as_combo_3_0_38400000() {
    // Encoding: 0x38400000
    // Test aarch32_STM_u_A1_AS field combination: cond=3, P=0, U=0, Rn=0, register_list=0
    // ISET: A32
    // Fields: Rn=0, register_list=0, P=0, cond=3, U=0
    let encoding: u32 = 0x38400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_u_A1_AS
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=4 (condition MI (minus/negative))
#[test]
fn test_aarch32_stm_u_a1_as_combo_4_0_48400000() {
    // Encoding: 0x48400000
    // Test aarch32_STM_u_A1_AS field combination: cond=4, P=0, U=0, Rn=0, register_list=0
    // ISET: A32
    // Fields: P=0, U=0, cond=4, Rn=0, register_list=0
    let encoding: u32 = 0x48400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_u_A1_AS
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=5 (condition PL (plus/positive))
#[test]
fn test_aarch32_stm_u_a1_as_combo_5_0_58400000() {
    // Encoding: 0x58400000
    // Test aarch32_STM_u_A1_AS field combination: cond=5, P=0, U=0, Rn=0, register_list=0
    // ISET: A32
    // Fields: P=0, Rn=0, register_list=0, cond=5, U=0
    let encoding: u32 = 0x58400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_u_A1_AS
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=6 (condition VS (overflow set))
#[test]
fn test_aarch32_stm_u_a1_as_combo_6_0_68400000() {
    // Encoding: 0x68400000
    // Test aarch32_STM_u_A1_AS field combination: cond=6, P=0, U=0, Rn=0, register_list=0
    // ISET: A32
    // Fields: register_list=0, Rn=0, cond=6, U=0, P=0
    let encoding: u32 = 0x68400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_u_A1_AS
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=7 (condition VC (overflow clear))
#[test]
fn test_aarch32_stm_u_a1_as_combo_7_0_78400000() {
    // Encoding: 0x78400000
    // Test aarch32_STM_u_A1_AS field combination: cond=7, P=0, U=0, Rn=0, register_list=0
    // ISET: A32
    // Fields: Rn=0, U=0, cond=7, P=0, register_list=0
    let encoding: u32 = 0x78400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_u_A1_AS
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=8 (condition HI (unsigned higher))
#[test]
fn test_aarch32_stm_u_a1_as_combo_8_0_88400000() {
    // Encoding: 0x88400000
    // Test aarch32_STM_u_A1_AS field combination: cond=8, P=0, U=0, Rn=0, register_list=0
    // ISET: A32
    // Fields: cond=8, U=0, register_list=0, P=0, Rn=0
    let encoding: u32 = 0x88400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_u_A1_AS
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=9 (condition LS (unsigned lower or same))
#[test]
fn test_aarch32_stm_u_a1_as_combo_9_0_98400000() {
    // Encoding: 0x98400000
    // Test aarch32_STM_u_A1_AS field combination: cond=9, P=0, U=0, Rn=0, register_list=0
    // ISET: A32
    // Fields: register_list=0, cond=9, P=0, U=0, Rn=0
    let encoding: u32 = 0x98400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_u_A1_AS
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=10 (condition GE (signed >=))
#[test]
fn test_aarch32_stm_u_a1_as_combo_10_0_a8400000() {
    // Encoding: 0xA8400000
    // Test aarch32_STM_u_A1_AS field combination: cond=10, P=0, U=0, Rn=0, register_list=0
    // ISET: A32
    // Fields: cond=10, U=0, register_list=0, Rn=0, P=0
    let encoding: u32 = 0xA8400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_u_A1_AS
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=11 (condition LT (signed <))
#[test]
fn test_aarch32_stm_u_a1_as_combo_11_0_b8400000() {
    // Encoding: 0xB8400000
    // Test aarch32_STM_u_A1_AS field combination: cond=11, P=0, U=0, Rn=0, register_list=0
    // ISET: A32
    // Fields: cond=11, U=0, P=0, Rn=0, register_list=0
    let encoding: u32 = 0xB8400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_u_A1_AS
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=12 (condition GT (signed >))
#[test]
fn test_aarch32_stm_u_a1_as_combo_12_0_c8400000() {
    // Encoding: 0xC8400000
    // Test aarch32_STM_u_A1_AS field combination: cond=12, P=0, U=0, Rn=0, register_list=0
    // ISET: A32
    // Fields: register_list=0, P=0, Rn=0, U=0, cond=12
    let encoding: u32 = 0xC8400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_u_A1_AS
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=13 (condition LE (signed <=))
#[test]
fn test_aarch32_stm_u_a1_as_combo_13_0_d8400000() {
    // Encoding: 0xD8400000
    // Test aarch32_STM_u_A1_AS field combination: cond=13, P=0, U=0, Rn=0, register_list=0
    // ISET: A32
    // Fields: P=0, cond=13, U=0, register_list=0, Rn=0
    let encoding: u32 = 0xD8400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_u_A1_AS
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=14 (condition AL (always))
#[test]
fn test_aarch32_stm_u_a1_as_combo_14_0_e8400000() {
    // Encoding: 0xE8400000
    // Test aarch32_STM_u_A1_AS field combination: cond=14, P=0, U=0, Rn=0, register_list=0
    // ISET: A32
    // Fields: cond=14, Rn=0, P=0, register_list=0, U=0
    let encoding: u32 = 0xE8400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_u_A1_AS
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=15 (condition NV (never, reserved))
#[test]
fn test_aarch32_stm_u_a1_as_combo_15_0_f8400000() {
    // Encoding: 0xF8400000
    // Test aarch32_STM_u_A1_AS field combination: cond=15, P=0, U=0, Rn=0, register_list=0
    // ISET: A32
    // Fields: P=0, cond=15, Rn=0, register_list=0, U=0
    let encoding: u32 = 0xF8400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_u_A1_AS
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// P=0 (minimum value)
#[test]
fn test_aarch32_stm_u_a1_as_combo_16_0_08400000() {
    // Encoding: 0x08400000
    // Test aarch32_STM_u_A1_AS field combination: cond=0, P=0, U=0, Rn=0, register_list=0
    // ISET: A32
    // Fields: register_list=0, Rn=0, cond=0, P=0, U=0
    let encoding: u32 = 0x08400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_u_A1_AS
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// P=1 (maximum value (1))
#[test]
fn test_aarch32_stm_u_a1_as_combo_17_0_09400000() {
    // Encoding: 0x09400000
    // Test aarch32_STM_u_A1_AS field combination: cond=0, P=1, U=0, Rn=0, register_list=0
    // ISET: A32
    // Fields: cond=0, P=1, Rn=0, register_list=0, U=0
    let encoding: u32 = 0x09400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_u_A1_AS
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=0 (minimum value)
#[test]
fn test_aarch32_stm_u_a1_as_combo_18_0_08400000() {
    // Encoding: 0x08400000
    // Test aarch32_STM_u_A1_AS field combination: cond=0, P=0, U=0, Rn=0, register_list=0
    // ISET: A32
    // Fields: Rn=0, register_list=0, cond=0, P=0, U=0
    let encoding: u32 = 0x08400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_u_A1_AS
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=1 (maximum value (1))
#[test]
fn test_aarch32_stm_u_a1_as_combo_19_0_08c00000() {
    // Encoding: 0x08C00000
    // Test aarch32_STM_u_A1_AS field combination: cond=0, P=0, U=1, Rn=0, register_list=0
    // ISET: A32
    // Fields: U=1, cond=0, P=0, Rn=0, register_list=0
    let encoding: u32 = 0x08C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_u_A1_AS
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_stm_u_a1_as_special_cond_0_condition_eq_0_08400000() {
    // Encoding: 0x08400000
    // Test aarch32_STM_u_A1_AS special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: U=0, P=0, register_list=0, cond=0, Rn=0
    let encoding: u32 = 0x08400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_u_A1_AS
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_stm_u_a1_as_special_cond_1_condition_ne_0_18400000() {
    // Encoding: 0x18400000
    // Test aarch32_STM_u_A1_AS special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: U=0, P=0, cond=1, Rn=0, register_list=0
    let encoding: u32 = 0x18400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_u_A1_AS
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_stm_u_a1_as_special_cond_2_condition_cs_hs_0_28400000() {
    // Encoding: 0x28400000
    // Test aarch32_STM_u_A1_AS special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: cond=2, P=0, U=0, register_list=0, Rn=0
    let encoding: u32 = 0x28400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_u_A1_AS
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_stm_u_a1_as_special_cond_3_condition_cc_lo_0_38400000() {
    // Encoding: 0x38400000
    // Test aarch32_STM_u_A1_AS special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: cond=3, P=0, U=0, Rn=0, register_list=0
    let encoding: u32 = 0x38400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_u_A1_AS
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_stm_u_a1_as_special_cond_4_condition_mi_0_48400000() {
    // Encoding: 0x48400000
    // Test aarch32_STM_u_A1_AS special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: P=0, U=0, Rn=0, cond=4, register_list=0
    let encoding: u32 = 0x48400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_u_A1_AS
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_stm_u_a1_as_special_cond_5_condition_pl_0_58400000() {
    // Encoding: 0x58400000
    // Test aarch32_STM_u_A1_AS special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: register_list=0, P=0, Rn=0, U=0, cond=5
    let encoding: u32 = 0x58400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_u_A1_AS
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_stm_u_a1_as_special_cond_6_condition_vs_0_68400000() {
    // Encoding: 0x68400000
    // Test aarch32_STM_u_A1_AS special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: P=0, Rn=0, register_list=0, cond=6, U=0
    let encoding: u32 = 0x68400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_u_A1_AS
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_stm_u_a1_as_special_cond_7_condition_vc_0_78400000() {
    // Encoding: 0x78400000
    // Test aarch32_STM_u_A1_AS special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: Rn=0, U=0, cond=7, P=0, register_list=0
    let encoding: u32 = 0x78400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_u_A1_AS
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_stm_u_a1_as_special_cond_8_condition_hi_0_88400000() {
    // Encoding: 0x88400000
    // Test aarch32_STM_u_A1_AS special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: U=0, P=0, cond=8, Rn=0, register_list=0
    let encoding: u32 = 0x88400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_u_A1_AS
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_stm_u_a1_as_special_cond_9_condition_ls_0_98400000() {
    // Encoding: 0x98400000
    // Test aarch32_STM_u_A1_AS special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: U=0, Rn=0, P=0, register_list=0, cond=9
    let encoding: u32 = 0x98400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_u_A1_AS
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_stm_u_a1_as_special_cond_10_condition_ge_0_a8400000() {
    // Encoding: 0xA8400000
    // Test aarch32_STM_u_A1_AS special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: register_list=0, U=0, cond=10, P=0, Rn=0
    let encoding: u32 = 0xA8400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_u_A1_AS
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_stm_u_a1_as_special_cond_11_condition_lt_0_b8400000() {
    // Encoding: 0xB8400000
    // Test aarch32_STM_u_A1_AS special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: U=0, Rn=0, register_list=0, cond=11, P=0
    let encoding: u32 = 0xB8400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_u_A1_AS
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_stm_u_a1_as_special_cond_12_condition_gt_0_c8400000() {
    // Encoding: 0xC8400000
    // Test aarch32_STM_u_A1_AS special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: cond=12, P=0, Rn=0, register_list=0, U=0
    let encoding: u32 = 0xC8400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_u_A1_AS
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_stm_u_a1_as_special_cond_13_condition_le_0_d8400000() {
    // Encoding: 0xD8400000
    // Test aarch32_STM_u_A1_AS special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: U=0, register_list=0, cond=13, P=0, Rn=0
    let encoding: u32 = 0xD8400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_u_A1_AS
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_stm_u_a1_as_special_cond_14_condition_al_0_e8400000() {
    // Encoding: 0xE8400000
    // Test aarch32_STM_u_A1_AS special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: P=0, U=0, cond=14, Rn=0, register_list=0
    let encoding: u32 = 0xE8400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_u_A1_AS
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_stm_u_a1_as_special_cond_15_condition_nv_0_f8400000() {
    // Encoding: 0xF8400000
    // Test aarch32_STM_u_A1_AS special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: U=0, register_list=0, P=0, Rn=0, cond=15
    let encoding: u32 = 0xF8400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_u_A1_AS
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Binary { op: Lt, lhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "BitCount" }, args: [Var(QualifiedIdentifier { qualifier: Any, name: "registers" })] }, rhs: LitInt(1) } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Binary { op: Lt, lhs: Call { name: QualifiedIdentifier { qualifier: Any, name: \"BitCount\" }, args: [Var(QualifiedIdentifier { qualifier: Any, name: \"registers\" })] }, rhs: LitInt(1) } } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_stm_u_a1_as_invalid_0_0_08400000() {
    // Encoding: 0x08400000
    // Test aarch32_STM_u_A1_AS invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Binary { op: Lt, lhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "BitCount" }, args: [Var(QualifiedIdentifier { qualifier: Any, name: "registers" })] }, rhs: LitInt(1) } } }
    // ISET: A32
    // Fields: cond=0, P=0, Rn=0, register_list=0, U=0
    let encoding: u32 = 0x08400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STM_u_A1_AS
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_stm_u_a1_as_invalid_1_0_08400000() {
    // Encoding: 0x08400000
    // Test aarch32_STM_u_A1_AS invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: P=0, Rn=0, cond=0, register_list=0, U=0
    let encoding: u32 = 0x08400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STM_u_A1_AS
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_stm_u_a1_as_store_0_08410000() {
    // Test aarch32_STM_u_A1_AS memory store: 8 bytes
    // Encoding: 0x08410000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x08410000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_STM_u_A1_AS
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_stm_u_a1_as_store_1_08410000() {
    // Test aarch32_STM_u_A1_AS memory store: 8 bytes
    // Encoding: 0x08410000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0x08410000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_STM_u_A1_AS
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Undefined
#[test]
fn test_aarch32_stm_u_a1_as_exception_0_08400000() {
    // Test aarch32_STM_u_A1_AS exception: Undefined
    // Encoding: 0x08400000
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x08400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_STM_u_A1_AS
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Unpredictable
#[test]
fn test_aarch32_stm_u_a1_as_exception_1_08400000() {
    // Test aarch32_STM_u_A1_AS exception: Unpredictable
    // Encoding: 0x08400000
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x08400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// aarch32_STMIB_A Tests
// ============================================================================

/// Provenance: aarch32_STMIB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_stmib_a1_a_field_cond_0_min_0_09800000() {
    // Encoding: 0x09800000
    // Test aarch32_STMIB_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: register_list=0, cond=0, W=0, Rn=0
    let encoding: u32 = 0x09800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMIB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_stmib_a1_a_field_cond_1_poweroftwo_0_19800000() {
    // Encoding: 0x19800000
    // Test aarch32_STMIB_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=1, Rn=0, register_list=0, W=0
    let encoding: u32 = 0x19800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMIB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_stmib_a1_a_field_cond_2_poweroftwo_0_29800000() {
    // Encoding: 0x29800000
    // Test aarch32_STMIB_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, W=0, register_list=0, cond=2
    let encoding: u32 = 0x29800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMIB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_stmib_a1_a_field_cond_3_poweroftwo_0_39800000() {
    // Encoding: 0x39800000
    // Test aarch32_STMIB_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: register_list=0, W=0, Rn=0, cond=3
    let encoding: u32 = 0x39800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMIB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_stmib_a1_a_field_cond_4_poweroftwo_0_49800000() {
    // Encoding: 0x49800000
    // Test aarch32_STMIB_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=4, Rn=0, W=0, register_list=0
    let encoding: u32 = 0x49800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMIB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_stmib_a1_a_field_cond_5_poweroftwo_0_59800000() {
    // Encoding: 0x59800000
    // Test aarch32_STMIB_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=5, register_list=0, W=0, Rn=0
    let encoding: u32 = 0x59800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMIB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_stmib_a1_a_field_cond_6_poweroftwo_0_69800000() {
    // Encoding: 0x69800000
    // Test aarch32_STMIB_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=6, register_list=0, W=0
    let encoding: u32 = 0x69800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMIB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_stmib_a1_a_field_cond_7_poweroftwo_0_79800000() {
    // Encoding: 0x79800000
    // Test aarch32_STMIB_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, Rn=0, register_list=0, cond=7
    let encoding: u32 = 0x79800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMIB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_stmib_a1_a_field_cond_8_poweroftwo_0_89800000() {
    // Encoding: 0x89800000
    // Test aarch32_STMIB_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, Rn=0, register_list=0, cond=8
    let encoding: u32 = 0x89800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMIB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_stmib_a1_a_field_cond_9_poweroftwo_0_99800000() {
    // Encoding: 0x99800000
    // Test aarch32_STMIB_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=9, register_list=0, W=0
    let encoding: u32 = 0x99800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMIB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_stmib_a1_a_field_cond_10_poweroftwo_0_a9800000() {
    // Encoding: 0xA9800000
    // Test aarch32_STMIB_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: register_list=0, W=0, cond=10, Rn=0
    let encoding: u32 = 0xA9800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMIB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_stmib_a1_a_field_cond_11_poweroftwo_0_b9800000() {
    // Encoding: 0xB9800000
    // Test aarch32_STMIB_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, Rn=0, cond=11, register_list=0
    let encoding: u32 = 0xB9800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMIB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_stmib_a1_a_field_cond_12_poweroftwo_0_c9800000() {
    // Encoding: 0xC9800000
    // Test aarch32_STMIB_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=12, Rn=0, register_list=0, W=0
    let encoding: u32 = 0xC9800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMIB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_stmib_a1_a_field_cond_13_poweroftwo_0_d9800000() {
    // Encoding: 0xD9800000
    // Test aarch32_STMIB_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=13, W=0, register_list=0, Rn=0
    let encoding: u32 = 0xD9800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMIB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_stmib_a1_a_field_cond_14_poweroftwo_0_e9800000() {
    // Encoding: 0xE9800000
    // Test aarch32_STMIB_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=14, register_list=0, Rn=0, W=0
    let encoding: u32 = 0xE9800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMIB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_stmib_a1_a_field_cond_15_max_0_f9800000() {
    // Encoding: 0xF9800000
    // Test aarch32_STMIB_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: Rn=0, cond=15, register_list=0, W=0
    let encoding: u32 = 0xF9800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMIB_A1_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_stmib_a1_a_field_w_0_min_0_09800000() {
    // Encoding: 0x09800000
    // Test aarch32_STMIB_A1_A field W = 0 (Min)
    // ISET: A32
    // Fields: cond=0, register_list=0, W=0, Rn=0
    let encoding: u32 = 0x09800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMIB_A1_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_stmib_a1_a_field_w_1_max_0_09a00000() {
    // Encoding: 0x09A00000
    // Test aarch32_STMIB_A1_A field W = 1 (Max)
    // ISET: A32
    // Fields: W=1, cond=0, register_list=0, Rn=0
    let encoding: u32 = 0x09A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMIB_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_stmib_a1_a_field_rn_0_min_0_09800000() {
    // Encoding: 0x09800000
    // Test aarch32_STMIB_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, register_list=0, cond=0, W=0
    let encoding: u32 = 0x09800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMIB_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_stmib_a1_a_field_rn_1_poweroftwo_0_09810000() {
    // Encoding: 0x09810000
    // Test aarch32_STMIB_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=1, cond=0, W=0, register_list=0
    let encoding: u32 = 0x09810000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMIB_A1_A
/// ASL: `field register_list 0 +: 16`
/// Requirement: FieldBoundary { field: "register_list", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_stmib_a1_a_field_register_list_0_min_0_09800000() {
    // Encoding: 0x09800000
    // Test aarch32_STMIB_A1_A field register_list = 0 (Min)
    // ISET: A32
    // Fields: W=0, Rn=0, register_list=0, cond=0
    let encoding: u32 = 0x09800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMIB_A1_A
/// ASL: `field register_list 0 +: 16`
/// Requirement: FieldBoundary { field: "register_list", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_stmib_a1_a_field_register_list_1_poweroftwo_0_09800001() {
    // Encoding: 0x09800001
    // Test aarch32_STMIB_A1_A field register_list = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: register_list=1, Rn=0, W=0, cond=0
    let encoding: u32 = 0x09800001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMIB_A1_A
/// ASL: `field register_list 0 +: 16`
/// Requirement: FieldBoundary { field: "register_list", value: 32767, boundary: PowerOfTwoMinusOne }
/// midpoint (32767)
#[test]
fn test_aarch32_stmib_a1_a_field_register_list_32767_poweroftwominusone_0_09807fff() {
    // Encoding: 0x09807FFF
    // Test aarch32_STMIB_A1_A field register_list = 32767 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, Rn=0, W=0, register_list=32767
    let encoding: u32 = 0x09807FFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMIB_A1_A
/// ASL: `field register_list 0 +: 16`
/// Requirement: FieldBoundary { field: "register_list", value: 65535, boundary: Max }
/// maximum value (65535)
#[test]
fn test_aarch32_stmib_a1_a_field_register_list_65535_max_0_0980ffff() {
    // Encoding: 0x0980FFFF
    // Test aarch32_STMIB_A1_A field register_list = 65535 (Max)
    // ISET: A32
    // Fields: Rn=0, register_list=65535, cond=0, W=0
    let encoding: u32 = 0x0980FFFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMIB_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_stmib_a1_a_combo_0_0_09800000() {
    // Encoding: 0x09800000
    // Test aarch32_STMIB_A1_A field combination: cond=0, W=0, Rn=0, register_list=0
    // ISET: A32
    // Fields: Rn=0, W=0, cond=0, register_list=0
    let encoding: u32 = 0x09800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMIB_A1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=1 (condition NE (not equal))
#[test]
fn test_aarch32_stmib_a1_a_combo_1_0_19800000() {
    // Encoding: 0x19800000
    // Test aarch32_STMIB_A1_A field combination: cond=1, W=0, Rn=0, register_list=0
    // ISET: A32
    // Fields: register_list=0, Rn=0, cond=1, W=0
    let encoding: u32 = 0x19800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMIB_A1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=2 (condition CS/HS (carry set))
#[test]
fn test_aarch32_stmib_a1_a_combo_2_0_29800000() {
    // Encoding: 0x29800000
    // Test aarch32_STMIB_A1_A field combination: cond=2, W=0, Rn=0, register_list=0
    // ISET: A32
    // Fields: cond=2, register_list=0, Rn=0, W=0
    let encoding: u32 = 0x29800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMIB_A1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=3 (condition CC/LO (carry clear))
#[test]
fn test_aarch32_stmib_a1_a_combo_3_0_39800000() {
    // Encoding: 0x39800000
    // Test aarch32_STMIB_A1_A field combination: cond=3, W=0, Rn=0, register_list=0
    // ISET: A32
    // Fields: cond=3, Rn=0, register_list=0, W=0
    let encoding: u32 = 0x39800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMIB_A1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=4 (condition MI (minus/negative))
#[test]
fn test_aarch32_stmib_a1_a_combo_4_0_49800000() {
    // Encoding: 0x49800000
    // Test aarch32_STMIB_A1_A field combination: cond=4, W=0, Rn=0, register_list=0
    // ISET: A32
    // Fields: W=0, Rn=0, register_list=0, cond=4
    let encoding: u32 = 0x49800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMIB_A1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=5 (condition PL (plus/positive))
#[test]
fn test_aarch32_stmib_a1_a_combo_5_0_59800000() {
    // Encoding: 0x59800000
    // Test aarch32_STMIB_A1_A field combination: cond=5, W=0, Rn=0, register_list=0
    // ISET: A32
    // Fields: register_list=0, W=0, cond=5, Rn=0
    let encoding: u32 = 0x59800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMIB_A1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=6 (condition VS (overflow set))
#[test]
fn test_aarch32_stmib_a1_a_combo_6_0_69800000() {
    // Encoding: 0x69800000
    // Test aarch32_STMIB_A1_A field combination: cond=6, W=0, Rn=0, register_list=0
    // ISET: A32
    // Fields: cond=6, W=0, Rn=0, register_list=0
    let encoding: u32 = 0x69800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMIB_A1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=7 (condition VC (overflow clear))
#[test]
fn test_aarch32_stmib_a1_a_combo_7_0_79800000() {
    // Encoding: 0x79800000
    // Test aarch32_STMIB_A1_A field combination: cond=7, W=0, Rn=0, register_list=0
    // ISET: A32
    // Fields: cond=7, register_list=0, W=0, Rn=0
    let encoding: u32 = 0x79800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMIB_A1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=8 (condition HI (unsigned higher))
#[test]
fn test_aarch32_stmib_a1_a_combo_8_0_89800000() {
    // Encoding: 0x89800000
    // Test aarch32_STMIB_A1_A field combination: cond=8, W=0, Rn=0, register_list=0
    // ISET: A32
    // Fields: Rn=0, cond=8, register_list=0, W=0
    let encoding: u32 = 0x89800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMIB_A1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=9 (condition LS (unsigned lower or same))
#[test]
fn test_aarch32_stmib_a1_a_combo_9_0_99800000() {
    // Encoding: 0x99800000
    // Test aarch32_STMIB_A1_A field combination: cond=9, W=0, Rn=0, register_list=0
    // ISET: A32
    // Fields: W=0, cond=9, register_list=0, Rn=0
    let encoding: u32 = 0x99800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMIB_A1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=10 (condition GE (signed >=))
#[test]
fn test_aarch32_stmib_a1_a_combo_10_0_a9800000() {
    // Encoding: 0xA9800000
    // Test aarch32_STMIB_A1_A field combination: cond=10, W=0, Rn=0, register_list=0
    // ISET: A32
    // Fields: W=0, Rn=0, cond=10, register_list=0
    let encoding: u32 = 0xA9800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMIB_A1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=11 (condition LT (signed <))
#[test]
fn test_aarch32_stmib_a1_a_combo_11_0_b9800000() {
    // Encoding: 0xB9800000
    // Test aarch32_STMIB_A1_A field combination: cond=11, W=0, Rn=0, register_list=0
    // ISET: A32
    // Fields: W=0, Rn=0, register_list=0, cond=11
    let encoding: u32 = 0xB9800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMIB_A1_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=12 (condition GT (signed >))
#[test]
fn test_aarch32_stmib_a1_a_combo_12_0_c9800000() {
    // Encoding: 0xC9800000
    // Test aarch32_STMIB_A1_A field combination: cond=12, W=0, Rn=0, register_list=0
    // ISET: A32
    // Fields: cond=12, W=0, register_list=0, Rn=0
    let encoding: u32 = 0xC9800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMIB_A1_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=13 (condition LE (signed <=))
#[test]
fn test_aarch32_stmib_a1_a_combo_13_0_d9800000() {
    // Encoding: 0xD9800000
    // Test aarch32_STMIB_A1_A field combination: cond=13, W=0, Rn=0, register_list=0
    // ISET: A32
    // Fields: cond=13, Rn=0, W=0, register_list=0
    let encoding: u32 = 0xD9800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMIB_A1_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=14 (condition AL (always))
#[test]
fn test_aarch32_stmib_a1_a_combo_14_0_e9800000() {
    // Encoding: 0xE9800000
    // Test aarch32_STMIB_A1_A field combination: cond=14, W=0, Rn=0, register_list=0
    // ISET: A32
    // Fields: Rn=0, cond=14, W=0, register_list=0
    let encoding: u32 = 0xE9800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMIB_A1_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=15 (condition NV (never, reserved))
#[test]
fn test_aarch32_stmib_a1_a_combo_15_0_f9800000() {
    // Encoding: 0xF9800000
    // Test aarch32_STMIB_A1_A field combination: cond=15, W=0, Rn=0, register_list=0
    // ISET: A32
    // Fields: Rn=0, cond=15, W=0, register_list=0
    let encoding: u32 = 0xF9800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMIB_A1_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// W=0 (minimum value)
#[test]
fn test_aarch32_stmib_a1_a_combo_16_0_09800000() {
    // Encoding: 0x09800000
    // Test aarch32_STMIB_A1_A field combination: cond=0, W=0, Rn=0, register_list=0
    // ISET: A32
    // Fields: cond=0, Rn=0, W=0, register_list=0
    let encoding: u32 = 0x09800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMIB_A1_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// W=1 (maximum value (1))
#[test]
fn test_aarch32_stmib_a1_a_combo_17_0_09a00000() {
    // Encoding: 0x09A00000
    // Test aarch32_STMIB_A1_A field combination: cond=0, W=1, Rn=0, register_list=0
    // ISET: A32
    // Fields: cond=0, W=1, Rn=0, register_list=0
    let encoding: u32 = 0x09A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMIB_A1_A
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_stmib_a1_a_combo_18_0_09800000() {
    // Encoding: 0x09800000
    // Test aarch32_STMIB_A1_A field combination: cond=0, W=0, Rn=0, register_list=0
    // ISET: A32
    // Fields: Rn=0, W=0, cond=0, register_list=0
    let encoding: u32 = 0x09800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMIB_A1_A
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_stmib_a1_a_combo_19_0_09810000() {
    // Encoding: 0x09810000
    // Test aarch32_STMIB_A1_A field combination: cond=0, W=0, Rn=1, register_list=0
    // ISET: A32
    // Fields: Rn=1, register_list=0, cond=0, W=0
    let encoding: u32 = 0x09810000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMIB_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_stmib_a1_a_special_cond_0_condition_eq_0_09800000() {
    // Encoding: 0x09800000
    // Test aarch32_STMIB_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: register_list=0, cond=0, Rn=0, W=0
    let encoding: u32 = 0x09800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMIB_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_stmib_a1_a_special_cond_1_condition_ne_0_19800000() {
    // Encoding: 0x19800000
    // Test aarch32_STMIB_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: Rn=0, W=0, cond=1, register_list=0
    let encoding: u32 = 0x19800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMIB_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_stmib_a1_a_special_cond_2_condition_cs_hs_0_29800000() {
    // Encoding: 0x29800000
    // Test aarch32_STMIB_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: cond=2, Rn=0, register_list=0, W=0
    let encoding: u32 = 0x29800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMIB_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_stmib_a1_a_special_cond_3_condition_cc_lo_0_39800000() {
    // Encoding: 0x39800000
    // Test aarch32_STMIB_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: register_list=0, Rn=0, cond=3, W=0
    let encoding: u32 = 0x39800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMIB_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_stmib_a1_a_special_cond_4_condition_mi_0_49800000() {
    // Encoding: 0x49800000
    // Test aarch32_STMIB_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: register_list=0, W=0, cond=4, Rn=0
    let encoding: u32 = 0x49800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMIB_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_stmib_a1_a_special_cond_5_condition_pl_0_59800000() {
    // Encoding: 0x59800000
    // Test aarch32_STMIB_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: Rn=0, register_list=0, cond=5, W=0
    let encoding: u32 = 0x59800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMIB_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_stmib_a1_a_special_cond_6_condition_vs_0_69800000() {
    // Encoding: 0x69800000
    // Test aarch32_STMIB_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: W=0, register_list=0, cond=6, Rn=0
    let encoding: u32 = 0x69800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMIB_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_stmib_a1_a_special_cond_7_condition_vc_0_79800000() {
    // Encoding: 0x79800000
    // Test aarch32_STMIB_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: register_list=0, W=0, cond=7, Rn=0
    let encoding: u32 = 0x79800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMIB_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_stmib_a1_a_special_cond_8_condition_hi_0_89800000() {
    // Encoding: 0x89800000
    // Test aarch32_STMIB_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: Rn=0, cond=8, register_list=0, W=0
    let encoding: u32 = 0x89800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMIB_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_stmib_a1_a_special_cond_9_condition_ls_0_99800000() {
    // Encoding: 0x99800000
    // Test aarch32_STMIB_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: register_list=0, cond=9, Rn=0, W=0
    let encoding: u32 = 0x99800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMIB_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_stmib_a1_a_special_cond_10_condition_ge_0_a9800000() {
    // Encoding: 0xA9800000
    // Test aarch32_STMIB_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: cond=10, W=0, Rn=0, register_list=0
    let encoding: u32 = 0xA9800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMIB_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_stmib_a1_a_special_cond_11_condition_lt_0_b9800000() {
    // Encoding: 0xB9800000
    // Test aarch32_STMIB_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: register_list=0, cond=11, W=0, Rn=0
    let encoding: u32 = 0xB9800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMIB_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_stmib_a1_a_special_cond_12_condition_gt_0_c9800000() {
    // Encoding: 0xC9800000
    // Test aarch32_STMIB_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: Rn=0, register_list=0, cond=12, W=0
    let encoding: u32 = 0xC9800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMIB_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_stmib_a1_a_special_cond_13_condition_le_0_d9800000() {
    // Encoding: 0xD9800000
    // Test aarch32_STMIB_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: register_list=0, W=0, Rn=0, cond=13
    let encoding: u32 = 0xD9800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMIB_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_stmib_a1_a_special_cond_14_condition_al_0_e9800000() {
    // Encoding: 0xE9800000
    // Test aarch32_STMIB_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: W=0, Rn=0, cond=14, register_list=0
    let encoding: u32 = 0xE9800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMIB_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_stmib_a1_a_special_cond_15_condition_nv_0_f9800000() {
    // Encoding: 0xF9800000
    // Test aarch32_STMIB_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: W=0, Rn=0, register_list=0, cond=15
    let encoding: u32 = 0xF9800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMIB_A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Binary { op: Lt, lhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "BitCount" }, args: [Var(QualifiedIdentifier { qualifier: Any, name: "registers" })] }, rhs: LitInt(1) } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Binary { op: Lt, lhs: Call { name: QualifiedIdentifier { qualifier: Any, name: \"BitCount\" }, args: [Var(QualifiedIdentifier { qualifier: Any, name: \"registers\" })] }, rhs: LitInt(1) } } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_stmib_a1_a_invalid_0_0_09800000() {
    // Encoding: 0x09800000
    // Test aarch32_STMIB_A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Binary { op: Lt, lhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "BitCount" }, args: [Var(QualifiedIdentifier { qualifier: Any, name: "registers" })] }, rhs: LitInt(1) } } }
    // ISET: A32
    // Fields: Rn=0, W=0, register_list=0, cond=0
    let encoding: u32 = 0x09800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STMIB_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_stmib_a1_a_invalid_1_0_09800000() {
    // Encoding: 0x09800000
    // Test aarch32_STMIB_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: cond=0, Rn=0, W=0, register_list=0
    let encoding: u32 = 0x09800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STMIB_A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_stmib_a1_a_store_0_09810000() {
    // Test aarch32_STMIB_A1_A memory store: 8 bytes
    // Encoding: 0x09810000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x09810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_STMIB_A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_stmib_a1_a_store_1_09810000() {
    // Test aarch32_STMIB_A1_A memory store: 8 bytes
    // Encoding: 0x09810000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x09810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_STMIB_A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_stmib_a1_a_store_2_09810000() {
    // Test aarch32_STMIB_A1_A memory store: 8 bytes
    // Encoding: 0x09810000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0x09810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// aarch32_STR_r_A Tests
// ============================================================================

/// Provenance: aarch32_STR_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_str_r_a1_a_field_cond_0_min_0_06000000() {
    // Encoding: 0x06000000
    // Test aarch32_STR_r_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, Rt=0, type1=0, W=0, imm5=0, cond=0, Rm=0, U=0, P=0
    let encoding: u32 = 0x06000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_str_r_a1_a_field_cond_1_poweroftwo_0_16000000() {
    // Encoding: 0x16000000
    // Test aarch32_STR_r_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, Rn=0, U=0, W=0, imm5=0, type1=0, Rt=0, cond=1, Rm=0
    let encoding: u32 = 0x16000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_str_r_a1_a_field_cond_2_poweroftwo_0_26000000() {
    // Encoding: 0x26000000
    // Test aarch32_STR_r_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, type1=0, Rm=0, P=0, imm5=0, W=0, Rn=0, cond=2, Rt=0
    let encoding: u32 = 0x26000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_str_r_a1_a_field_cond_3_poweroftwo_0_36000000() {
    // Encoding: 0x36000000
    // Test aarch32_STR_r_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=3, Rm=0, W=0, Rt=0, U=0, imm5=0, Rn=0, P=0, type1=0
    let encoding: u32 = 0x36000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_str_r_a1_a_field_cond_4_poweroftwo_0_46000000() {
    // Encoding: 0x46000000
    // Test aarch32_STR_r_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Rn=0, W=0, cond=4, P=0, U=0, imm5=0, Rt=0, type1=0
    let encoding: u32 = 0x46000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_str_r_a1_a_field_cond_5_poweroftwo_0_56000000() {
    // Encoding: 0x56000000
    // Test aarch32_STR_r_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, Rt=0, type1=0, Rm=0, imm5=0, P=0, U=0, cond=5, Rn=0
    let encoding: u32 = 0x56000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_str_r_a1_a_field_cond_6_poweroftwo_0_66000000() {
    // Encoding: 0x66000000
    // Test aarch32_STR_r_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, imm5=0, type1=0, Rm=0, Rt=0, P=0, cond=6, Rn=0, W=0
    let encoding: u32 = 0x66000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_str_r_a1_a_field_cond_7_poweroftwo_0_76000000() {
    // Encoding: 0x76000000
    // Test aarch32_STR_r_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, W=0, imm5=0, Rn=0, U=0, P=0, cond=7, Rm=0, type1=0
    let encoding: u32 = 0x76000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_str_r_a1_a_field_cond_8_poweroftwo_0_86000000() {
    // Encoding: 0x86000000
    // Test aarch32_STR_r_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=8, Rn=0, U=0, W=0, Rt=0, imm5=0, P=0, type1=0, Rm=0
    let encoding: u32 = 0x86000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_str_r_a1_a_field_cond_9_poweroftwo_0_96000000() {
    // Encoding: 0x96000000
    // Test aarch32_STR_r_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=9, Rn=0, Rm=0, imm5=0, Rt=0, U=0, W=0, type1=0, P=0
    let encoding: u32 = 0x96000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_str_r_a1_a_field_cond_10_poweroftwo_0_a6000000() {
    // Encoding: 0xA6000000
    // Test aarch32_STR_r_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, Rt=0, P=0, U=0, Rn=0, imm5=0, cond=10, type1=0, Rm=0
    let encoding: u32 = 0xA6000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_str_r_a1_a_field_cond_11_poweroftwo_0_b6000000() {
    // Encoding: 0xB6000000
    // Test aarch32_STR_r_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, P=0, type1=0, Rn=0, U=0, Rm=0, cond=11, imm5=0, W=0
    let encoding: u32 = 0xB6000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_str_r_a1_a_field_cond_12_poweroftwo_0_c6000000() {
    // Encoding: 0xC6000000
    // Test aarch32_STR_r_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, Rt=0, imm5=0, Rn=0, cond=12, U=0, type1=0, W=0, Rm=0
    let encoding: u32 = 0xC6000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_str_r_a1_a_field_cond_13_poweroftwo_0_d6000000() {
    // Encoding: 0xD6000000
    // Test aarch32_STR_r_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: type1=0, W=0, U=0, P=0, Rn=0, imm5=0, Rm=0, cond=13, Rt=0
    let encoding: u32 = 0xD6000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_str_r_a1_a_field_cond_14_poweroftwo_0_e6000000() {
    // Encoding: 0xE6000000
    // Test aarch32_STR_r_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: imm5=0, Rn=0, type1=0, Rm=0, Rt=0, W=0, P=0, U=0, cond=14
    let encoding: u32 = 0xE6000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_str_r_a1_a_field_cond_15_max_0_f6000000() {
    // Encoding: 0xF6000000
    // Test aarch32_STR_r_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: cond=15, U=0, Rn=0, type1=0, P=0, W=0, imm5=0, Rt=0, Rm=0
    let encoding: u32 = 0xF6000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_r_A1_A
/// ASL: `field P 24 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_str_r_a1_a_field_p_0_min_0_06000000() {
    // Encoding: 0x06000000
    // Test aarch32_STR_r_A1_A field P = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rt=0, Rn=0, W=0, imm5=0, P=0, Rm=0, U=0, type1=0
    let encoding: u32 = 0x06000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_r_A1_A
/// ASL: `field P 24 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_str_r_a1_a_field_p_1_max_0_07000000() {
    // Encoding: 0x07000000
    // Test aarch32_STR_r_A1_A field P = 1 (Max)
    // ISET: A32
    // Fields: W=0, P=1, Rm=0, Rt=0, cond=0, type1=0, Rn=0, imm5=0, U=0
    let encoding: u32 = 0x07000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_r_A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_str_r_a1_a_field_u_0_min_0_06000000() {
    // Encoding: 0x06000000
    // Test aarch32_STR_r_A1_A field U = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, imm5=0, Rt=0, U=0, cond=0, W=0, type1=0, P=0, Rm=0
    let encoding: u32 = 0x06000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_r_A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_str_r_a1_a_field_u_1_max_0_06800000() {
    // Encoding: 0x06800000
    // Test aarch32_STR_r_A1_A field U = 1 (Max)
    // ISET: A32
    // Fields: imm5=0, P=0, cond=0, Rn=0, W=0, type1=0, Rt=0, U=1, Rm=0
    let encoding: u32 = 0x06800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_r_A1_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_str_r_a1_a_field_w_0_min_0_06000000() {
    // Encoding: 0x06000000
    // Test aarch32_STR_r_A1_A field W = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, imm5=0, P=0, Rt=0, U=0, W=0, cond=0, type1=0, Rn=0
    let encoding: u32 = 0x06000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_r_A1_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_str_r_a1_a_field_w_1_max_0_06200000() {
    // Encoding: 0x06200000
    // Test aarch32_STR_r_A1_A field W = 1 (Max)
    // ISET: A32
    // Fields: imm5=0, cond=0, Rn=0, type1=0, Rt=0, U=0, Rm=0, P=0, W=1
    let encoding: u32 = 0x06200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_r_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_str_r_a1_a_field_rn_0_min_0_06000000() {
    // Encoding: 0x06000000
    // Test aarch32_STR_r_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, cond=0, Rt=0, type1=0, P=0, W=0, Rn=0, imm5=0, U=0
    let encoding: u32 = 0x06000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_r_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_str_r_a1_a_field_rn_1_poweroftwo_0_06010000() {
    // Encoding: 0x06010000
    // Test aarch32_STR_r_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, Rt=0, cond=0, U=0, Rn=1, imm5=0, Rm=0, type1=0, P=0
    let encoding: u32 = 0x06010000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_r_A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_str_r_a1_a_field_rt_0_min_0_06000000() {
    // Encoding: 0x06000000
    // Test aarch32_STR_r_A1_A field Rt = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, U=0, cond=0, Rm=0, Rt=0, W=0, P=0, imm5=0, type1=0
    let encoding: u32 = 0x06000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_r_A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_str_r_a1_a_field_rt_1_poweroftwo_0_06001000() {
    // Encoding: 0x06001000
    // Test aarch32_STR_r_A1_A field Rt = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, P=0, type1=0, Rt=1, Rm=0, U=0, Rn=0, imm5=0, W=0
    let encoding: u32 = 0x06001000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_str_r_a1_a_field_imm5_0_zero_0_06000000() {
    // Encoding: 0x06000000
    // Test aarch32_STR_r_A1_A field imm5 = 0 (Zero)
    // ISET: A32
    // Fields: type1=0, W=0, cond=0, P=0, Rn=0, imm5=0, Rm=0, Rt=0, U=0
    let encoding: u32 = 0x06000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_str_r_a1_a_field_imm5_1_poweroftwo_0_06000080() {
    // Encoding: 0x06000080
    // Test aarch32_STR_r_A1_A field imm5 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, U=0, cond=0, Rt=0, W=0, imm5=1, type1=0, P=0, Rm=0
    let encoding: u32 = 0x06000080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_str_r_a1_a_field_imm5_3_poweroftwominusone_0_06000180() {
    // Encoding: 0x06000180
    // Test aarch32_STR_r_A1_A field imm5 = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: P=0, U=0, Rm=0, imm5=3, cond=0, Rt=0, W=0, type1=0, Rn=0
    let encoding: u32 = 0x06000180;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_str_r_a1_a_field_imm5_4_poweroftwo_0_06000200() {
    // Encoding: 0x06000200
    // Test aarch32_STR_r_A1_A field imm5 = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, Rn=0, Rt=0, imm5=4, type1=0, U=0, cond=0, W=0, Rm=0
    let encoding: u32 = 0x06000200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_str_r_a1_a_field_imm5_7_poweroftwominusone_0_06000380() {
    // Encoding: 0x06000380
    // Test aarch32_STR_r_A1_A field imm5 = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rm=0, Rt=0, W=0, P=0, cond=0, Rn=0, type1=0, U=0, imm5=7
    let encoding: u32 = 0x06000380;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_str_r_a1_a_field_imm5_8_poweroftwo_0_06000400() {
    // Encoding: 0x06000400
    // Test aarch32_STR_r_A1_A field imm5 = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, P=0, Rt=0, imm5=8, Rm=0, W=0, Rn=0, U=0, type1=0
    let encoding: u32 = 0x06000400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 15, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (15)
#[test]
fn test_aarch32_str_r_a1_a_field_imm5_15_poweroftwominusone_0_06000780() {
    // Encoding: 0x06000780
    // Test aarch32_STR_r_A1_A field imm5 = 15 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: U=0, W=0, imm5=15, Rm=0, P=0, type1=0, Rt=0, cond=0, Rn=0
    let encoding: u32 = 0x06000780;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_str_r_a1_a_field_imm5_16_poweroftwo_0_06000800() {
    // Encoding: 0x06000800
    // Test aarch32_STR_r_A1_A field imm5 = 16 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, Rt=0, U=0, cond=0, P=0, type1=0, imm5=16, Rn=0, Rm=0
    let encoding: u32 = 0x06000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 31, boundary: Max }
/// maximum immediate (31)
#[test]
fn test_aarch32_str_r_a1_a_field_imm5_31_max_0_06000f80() {
    // Encoding: 0x06000F80
    // Test aarch32_STR_r_A1_A field imm5 = 31 (Max)
    // ISET: A32
    // Fields: Rt=0, type1=0, U=0, Rn=0, imm5=31, cond=0, W=0, Rm=0, P=0
    let encoding: u32 = 0x06000F80;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_r_A1_A
/// ASL: `field type1 5 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_str_r_a1_a_field_type1_0_min_0_06000000() {
    // Encoding: 0x06000000
    // Test aarch32_STR_r_A1_A field type1 = 0 (Min)
    // ISET: A32
    // Fields: Rt=0, imm5=0, U=0, cond=0, Rn=0, type1=0, P=0, Rm=0, W=0
    let encoding: u32 = 0x06000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_r_A1_A
/// ASL: `field type1 5 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_str_r_a1_a_field_type1_1_poweroftwo_0_06000020() {
    // Encoding: 0x06000020
    // Test aarch32_STR_r_A1_A field type1 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: P=0, W=0, type1=1, Rt=0, Rm=0, imm5=0, cond=0, U=0, Rn=0
    let encoding: u32 = 0x06000020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_r_A1_A
/// ASL: `field type1 5 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_aarch32_str_r_a1_a_field_type1_3_max_0_06000060() {
    // Encoding: 0x06000060
    // Test aarch32_STR_r_A1_A field type1 = 3 (Max)
    // ISET: A32
    // Fields: W=0, imm5=0, cond=0, type1=3, P=0, U=0, Rn=0, Rt=0, Rm=0
    let encoding: u32 = 0x06000060;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_r_A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_str_r_a1_a_field_rm_0_min_0_06000000() {
    // Encoding: 0x06000000
    // Test aarch32_STR_r_A1_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, cond=0, P=0, imm5=0, type1=0, Rm=0, Rt=0, U=0, W=0
    let encoding: u32 = 0x06000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_r_A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_str_r_a1_a_field_rm_1_poweroftwo_0_06000001() {
    // Encoding: 0x06000001
    // Test aarch32_STR_r_A1_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: imm5=0, Rn=0, U=0, Rt=0, type1=0, W=0, P=0, cond=0, Rm=1
    let encoding: u32 = 0x06000001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_r_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_str_r_a1_a_combo_0_0_06000000() {
    // Encoding: 0x06000000
    // Test aarch32_STR_r_A1_A field combination: cond=0, P=0, U=0, W=0, Rn=0, Rt=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: cond=0, W=0, Rn=0, Rt=0, imm5=0, type1=0, P=0, Rm=0, U=0
    let encoding: u32 = 0x06000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_r_A1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=1 (condition NE (not equal))
#[test]
fn test_aarch32_str_r_a1_a_combo_1_0_16000000() {
    // Encoding: 0x16000000
    // Test aarch32_STR_r_A1_A field combination: cond=1, P=0, U=0, W=0, Rn=0, Rt=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: Rm=0, type1=0, Rn=0, Rt=0, imm5=0, U=0, cond=1, P=0, W=0
    let encoding: u32 = 0x16000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_r_A1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=2 (condition CS/HS (carry set))
#[test]
fn test_aarch32_str_r_a1_a_combo_2_0_26000000() {
    // Encoding: 0x26000000
    // Test aarch32_STR_r_A1_A field combination: cond=2, P=0, U=0, W=0, Rn=0, Rt=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: W=0, imm5=0, cond=2, P=0, type1=0, Rn=0, Rt=0, U=0, Rm=0
    let encoding: u32 = 0x26000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_r_A1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=3 (condition CC/LO (carry clear))
#[test]
fn test_aarch32_str_r_a1_a_combo_3_0_36000000() {
    // Encoding: 0x36000000
    // Test aarch32_STR_r_A1_A field combination: cond=3, P=0, U=0, W=0, Rn=0, Rt=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: Rn=0, Rt=0, W=0, U=0, type1=0, Rm=0, P=0, cond=3, imm5=0
    let encoding: u32 = 0x36000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_r_A1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=4 (condition MI (minus/negative))
#[test]
fn test_aarch32_str_r_a1_a_combo_4_0_46000000() {
    // Encoding: 0x46000000
    // Test aarch32_STR_r_A1_A field combination: cond=4, P=0, U=0, W=0, Rn=0, Rt=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: W=0, U=0, Rm=0, imm5=0, cond=4, Rn=0, type1=0, Rt=0, P=0
    let encoding: u32 = 0x46000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_r_A1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=5 (condition PL (plus/positive))
#[test]
fn test_aarch32_str_r_a1_a_combo_5_0_56000000() {
    // Encoding: 0x56000000
    // Test aarch32_STR_r_A1_A field combination: cond=5, P=0, U=0, W=0, Rn=0, Rt=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: Rn=0, cond=5, imm5=0, W=0, Rt=0, U=0, Rm=0, type1=0, P=0
    let encoding: u32 = 0x56000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_r_A1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=6 (condition VS (overflow set))
#[test]
fn test_aarch32_str_r_a1_a_combo_6_0_66000000() {
    // Encoding: 0x66000000
    // Test aarch32_STR_r_A1_A field combination: cond=6, P=0, U=0, W=0, Rn=0, Rt=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: P=0, U=0, Rn=0, W=0, type1=0, Rm=0, imm5=0, cond=6, Rt=0
    let encoding: u32 = 0x66000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_r_A1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=7 (condition VC (overflow clear))
#[test]
fn test_aarch32_str_r_a1_a_combo_7_0_76000000() {
    // Encoding: 0x76000000
    // Test aarch32_STR_r_A1_A field combination: cond=7, P=0, U=0, W=0, Rn=0, Rt=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: W=0, P=0, Rt=0, U=0, Rm=0, cond=7, imm5=0, Rn=0, type1=0
    let encoding: u32 = 0x76000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_r_A1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=8 (condition HI (unsigned higher))
#[test]
fn test_aarch32_str_r_a1_a_combo_8_0_86000000() {
    // Encoding: 0x86000000
    // Test aarch32_STR_r_A1_A field combination: cond=8, P=0, U=0, W=0, Rn=0, Rt=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: Rn=0, Rt=0, imm5=0, U=0, cond=8, P=0, Rm=0, type1=0, W=0
    let encoding: u32 = 0x86000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_r_A1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=9 (condition LS (unsigned lower or same))
#[test]
fn test_aarch32_str_r_a1_a_combo_9_0_96000000() {
    // Encoding: 0x96000000
    // Test aarch32_STR_r_A1_A field combination: cond=9, P=0, U=0, W=0, Rn=0, Rt=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: P=0, U=0, cond=9, W=0, imm5=0, Rn=0, type1=0, Rt=0, Rm=0
    let encoding: u32 = 0x96000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_r_A1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=10 (condition GE (signed >=))
#[test]
fn test_aarch32_str_r_a1_a_combo_10_0_a6000000() {
    // Encoding: 0xA6000000
    // Test aarch32_STR_r_A1_A field combination: cond=10, P=0, U=0, W=0, Rn=0, Rt=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: W=0, cond=10, Rn=0, Rm=0, U=0, type1=0, imm5=0, P=0, Rt=0
    let encoding: u32 = 0xA6000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_r_A1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=11 (condition LT (signed <))
#[test]
fn test_aarch32_str_r_a1_a_combo_11_0_b6000000() {
    // Encoding: 0xB6000000
    // Test aarch32_STR_r_A1_A field combination: cond=11, P=0, U=0, W=0, Rn=0, Rt=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: Rm=0, P=0, U=0, Rt=0, cond=11, Rn=0, imm5=0, W=0, type1=0
    let encoding: u32 = 0xB6000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_r_A1_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=12 (condition GT (signed >))
#[test]
fn test_aarch32_str_r_a1_a_combo_12_0_c6000000() {
    // Encoding: 0xC6000000
    // Test aarch32_STR_r_A1_A field combination: cond=12, P=0, U=0, W=0, Rn=0, Rt=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: cond=12, type1=0, W=0, U=0, Rn=0, P=0, Rt=0, imm5=0, Rm=0
    let encoding: u32 = 0xC6000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_r_A1_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=13 (condition LE (signed <=))
#[test]
fn test_aarch32_str_r_a1_a_combo_13_0_d6000000() {
    // Encoding: 0xD6000000
    // Test aarch32_STR_r_A1_A field combination: cond=13, P=0, U=0, W=0, Rn=0, Rt=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: imm5=0, U=0, cond=13, W=0, P=0, Rm=0, type1=0, Rt=0, Rn=0
    let encoding: u32 = 0xD6000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_r_A1_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=14 (condition AL (always))
#[test]
fn test_aarch32_str_r_a1_a_combo_14_0_e6000000() {
    // Encoding: 0xE6000000
    // Test aarch32_STR_r_A1_A field combination: cond=14, P=0, U=0, W=0, Rn=0, Rt=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: Rm=0, cond=14, U=0, Rn=0, Rt=0, P=0, type1=0, imm5=0, W=0
    let encoding: u32 = 0xE6000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_r_A1_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=15 (condition NV (never, reserved))
#[test]
fn test_aarch32_str_r_a1_a_combo_15_0_f6000000() {
    // Encoding: 0xF6000000
    // Test aarch32_STR_r_A1_A field combination: cond=15, P=0, U=0, W=0, Rn=0, Rt=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: Rn=0, imm5=0, W=0, Rt=0, cond=15, Rm=0, type1=0, P=0, U=0
    let encoding: u32 = 0xF6000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_r_A1_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// P=0 (minimum value)
#[test]
fn test_aarch32_str_r_a1_a_combo_16_0_06000000() {
    // Encoding: 0x06000000
    // Test aarch32_STR_r_A1_A field combination: cond=0, P=0, U=0, W=0, Rn=0, Rt=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: imm5=0, Rt=0, P=0, type1=0, Rm=0, U=0, cond=0, W=0, Rn=0
    let encoding: u32 = 0x06000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_r_A1_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// P=1 (maximum value (1))
#[test]
fn test_aarch32_str_r_a1_a_combo_17_0_07000000() {
    // Encoding: 0x07000000
    // Test aarch32_STR_r_A1_A field combination: cond=0, P=1, U=0, W=0, Rn=0, Rt=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: U=0, Rm=0, Rn=0, W=0, imm5=0, type1=0, cond=0, P=1, Rt=0
    let encoding: u32 = 0x07000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_r_A1_A
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=0 (minimum value)
#[test]
fn test_aarch32_str_r_a1_a_combo_18_0_06000000() {
    // Encoding: 0x06000000
    // Test aarch32_STR_r_A1_A field combination: cond=0, P=0, U=0, W=0, Rn=0, Rt=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: P=0, Rt=0, cond=0, Rm=0, Rn=0, type1=0, W=0, imm5=0, U=0
    let encoding: u32 = 0x06000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_r_A1_A
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=1 (maximum value (1))
#[test]
fn test_aarch32_str_r_a1_a_combo_19_0_06800000() {
    // Encoding: 0x06800000
    // Test aarch32_STR_r_A1_A field combination: cond=0, P=0, U=1, W=0, Rn=0, Rt=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: imm5=0, cond=0, type1=0, Rt=0, U=1, Rn=0, Rm=0, W=0, P=0
    let encoding: u32 = 0x06800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_r_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_str_r_a1_a_special_cond_0_condition_eq_0_06000000() {
    // Encoding: 0x06000000
    // Test aarch32_STR_r_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: U=0, Rm=0, imm5=0, W=0, Rn=0, Rt=0, cond=0, P=0, type1=0
    let encoding: u32 = 0x06000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_r_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_str_r_a1_a_special_cond_1_condition_ne_0_16000000() {
    // Encoding: 0x16000000
    // Test aarch32_STR_r_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: P=0, type1=0, Rm=0, cond=1, U=0, W=0, Rt=0, Rn=0, imm5=0
    let encoding: u32 = 0x16000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_r_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_str_r_a1_a_special_cond_2_condition_cs_hs_0_26000000() {
    // Encoding: 0x26000000
    // Test aarch32_STR_r_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: W=0, imm5=0, Rm=0, cond=2, Rn=0, type1=0, P=0, U=0, Rt=0
    let encoding: u32 = 0x26000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_r_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_str_r_a1_a_special_cond_3_condition_cc_lo_0_36000000() {
    // Encoding: 0x36000000
    // Test aarch32_STR_r_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: type1=0, cond=3, U=0, P=0, imm5=0, Rm=0, W=0, Rn=0, Rt=0
    let encoding: u32 = 0x36000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_r_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_str_r_a1_a_special_cond_4_condition_mi_0_46000000() {
    // Encoding: 0x46000000
    // Test aarch32_STR_r_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: cond=4, imm5=0, P=0, Rn=0, Rt=0, type1=0, Rm=0, W=0, U=0
    let encoding: u32 = 0x46000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_r_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_str_r_a1_a_special_cond_5_condition_pl_0_56000000() {
    // Encoding: 0x56000000
    // Test aarch32_STR_r_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: cond=5, W=0, Rn=0, P=0, U=0, type1=0, imm5=0, Rt=0, Rm=0
    let encoding: u32 = 0x56000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_r_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_str_r_a1_a_special_cond_6_condition_vs_0_66000000() {
    // Encoding: 0x66000000
    // Test aarch32_STR_r_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: Rt=0, type1=0, U=0, Rm=0, W=0, P=0, imm5=0, Rn=0, cond=6
    let encoding: u32 = 0x66000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_r_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_str_r_a1_a_special_cond_7_condition_vc_0_76000000() {
    // Encoding: 0x76000000
    // Test aarch32_STR_r_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: type1=0, Rn=0, Rm=0, P=0, Rt=0, imm5=0, U=0, cond=7, W=0
    let encoding: u32 = 0x76000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_r_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_str_r_a1_a_special_cond_8_condition_hi_0_86000000() {
    // Encoding: 0x86000000
    // Test aarch32_STR_r_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: P=0, W=0, type1=0, Rt=0, U=0, Rm=0, Rn=0, imm5=0, cond=8
    let encoding: u32 = 0x86000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_r_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_str_r_a1_a_special_cond_9_condition_ls_0_96000000() {
    // Encoding: 0x96000000
    // Test aarch32_STR_r_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: Rt=0, Rm=0, P=0, Rn=0, U=0, type1=0, imm5=0, cond=9, W=0
    let encoding: u32 = 0x96000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_r_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_str_r_a1_a_special_cond_10_condition_ge_0_a6000000() {
    // Encoding: 0xA6000000
    // Test aarch32_STR_r_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: Rt=0, P=0, U=0, W=0, Rn=0, imm5=0, cond=10, type1=0, Rm=0
    let encoding: u32 = 0xA6000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_r_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_str_r_a1_a_special_cond_11_condition_lt_0_b6000000() {
    // Encoding: 0xB6000000
    // Test aarch32_STR_r_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: cond=11, P=0, type1=0, Rn=0, imm5=0, U=0, Rm=0, Rt=0, W=0
    let encoding: u32 = 0xB6000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_r_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_str_r_a1_a_special_cond_12_condition_gt_0_c6000000() {
    // Encoding: 0xC6000000
    // Test aarch32_STR_r_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: W=0, type1=0, U=0, P=0, imm5=0, Rt=0, Rn=0, Rm=0, cond=12
    let encoding: u32 = 0xC6000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_r_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_str_r_a1_a_special_cond_13_condition_le_0_d6000000() {
    // Encoding: 0xD6000000
    // Test aarch32_STR_r_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: W=0, P=0, imm5=0, U=0, Rn=0, cond=13, Rt=0, type1=0, Rm=0
    let encoding: u32 = 0xD6000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_r_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_str_r_a1_a_special_cond_14_condition_al_0_e6000000() {
    // Encoding: 0xE6000000
    // Test aarch32_STR_r_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: P=0, cond=14, Rm=0, type1=0, W=0, U=0, Rn=0, imm5=0, Rt=0
    let encoding: u32 = 0xE6000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_r_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_str_r_a1_a_special_cond_15_condition_nv_0_f6000000() {
    // Encoding: 0xF6000000
    // Test aarch32_STR_r_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: U=0, imm5=0, Rn=0, type1=0, cond=15, Rt=0, Rm=0, P=0, W=0
    let encoding: u32 = 0xF6000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STR_r_A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }), rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }), rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_str_r_a1_a_invalid_0_0_06000000() {
    // Encoding: 0x06000000
    // Test aarch32_STR_r_A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }), rhs: LitInt(15) }
    // ISET: A32
    // Fields: W=0, Rn=0, P=0, cond=0, U=0, type1=0, Rt=0, imm5=0, Rm=0
    let encoding: u32 = 0x06000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STR_r_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_str_r_a1_a_invalid_1_0_06000000() {
    // Encoding: 0x06000000
    // Test aarch32_STR_r_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: U=0, Rt=0, Rn=0, P=0, W=0, imm5=0, Rm=0, cond=0, type1=0
    let encoding: u32 = 0x06000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STR_r_A1_A
/// ASL: `Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"wback\" }), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }) } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_str_r_a1_a_invalid_2_0_06000000() {
    // Encoding: 0x06000000
    // Test aarch32_STR_r_A1_A invalid encoding: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) } }
    // ISET: A32
    // Fields: Rn=0, cond=0, U=0, imm5=0, Rt=0, type1=0, W=0, P=0, Rm=0
    let encoding: u32 = 0x06000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STR_r_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_str_r_a1_a_invalid_3_0_06000000() {
    // Encoding: 0x06000000
    // Test aarch32_STR_r_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: U=0, type1=0, Rn=0, W=0, Rm=0, Rt=0, imm5=0, cond=0, P=0
    let encoding: u32 = 0x06000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STR_r_T1_A
/// ASL: `field Rm 22 +: 3`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_str_r_t1_a_field_rm_0_min_0_50000000() {
    // Thumb encoding (32): 0x50000000
    // Test aarch32_STR_r_T1_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rt=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x50000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_r_T1_A
/// ASL: `field Rm 22 +: 3`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_str_r_t1_a_field_rm_1_poweroftwo_0_50400000() {
    // Thumb encoding (32): 0x50400000
    // Test aarch32_STR_r_T1_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, Rm=1, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x50400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_r_T1_A
/// ASL: `field Rn 19 +: 3`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_str_r_t1_a_field_rn_0_min_0_50000000() {
    // Thumb encoding (32): 0x50000000
    // Test aarch32_STR_r_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rt=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x50000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_r_T1_A
/// ASL: `field Rn 19 +: 3`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_str_r_t1_a_field_rn_1_poweroftwo_0_50080000() {
    // Thumb encoding (32): 0x50080000
    // Test aarch32_STR_r_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=1, Rt=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x50080000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_r_T1_A
/// ASL: `field Rt 16 +: 3`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_str_r_t1_a_field_rt_0_min_0_50000000() {
    // Thumb encoding (32): 0x50000000
    // Test aarch32_STR_r_T1_A field Rt = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rm=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x50000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_r_T1_A
/// ASL: `field Rt 16 +: 3`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_str_r_t1_a_field_rt_1_poweroftwo_0_50010000() {
    // Thumb encoding (32): 0x50010000
    // Test aarch32_STR_r_T1_A field Rt = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=1, Rn=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x50010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_r_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch32_str_r_t1_a_combo_0_0_50000000() {
    // Thumb encoding (32): 0x50000000
    // Test aarch32_STR_r_T1_A field combination: Rm=0, Rn=0, Rt=0
    // ISET: T32
    // Fields: Rt=0, Rm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x50000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_r_T1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_aarch32_str_r_t1_a_combo_1_0_50400000() {
    // Thumb encoding (32): 0x50400000
    // Test aarch32_STR_r_T1_A field combination: Rm=1, Rn=0, Rt=0
    // ISET: T32
    // Fields: Rt=0, Rm=1, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x50400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_r_T1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_str_r_t1_a_combo_2_0_50000000() {
    // Thumb encoding (32): 0x50000000
    // Test aarch32_STR_r_T1_A field combination: Rm=0, Rn=0, Rt=0
    // ISET: T32
    // Fields: Rt=0, Rm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x50000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_r_T1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_str_r_t1_a_combo_3_0_50080000() {
    // Thumb encoding (32): 0x50080000
    // Test aarch32_STR_r_T1_A field combination: Rm=0, Rn=1, Rt=0
    // ISET: T32
    // Fields: Rt=0, Rm=0, Rn=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x50080000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_r_T1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=0 (register index 0 (first register))
#[test]
fn test_aarch32_str_r_t1_a_combo_4_0_50000000() {
    // Thumb encoding (32): 0x50000000
    // Test aarch32_STR_r_T1_A field combination: Rm=0, Rn=0, Rt=0
    // ISET: T32
    // Fields: Rm=0, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x50000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_r_T1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=1 (register index 1 (second register))
#[test]
fn test_aarch32_str_r_t1_a_combo_5_0_50010000() {
    // Thumb encoding (32): 0x50010000
    // Test aarch32_STR_r_T1_A field combination: Rm=0, Rn=0, Rt=1
    // ISET: T32
    // Fields: Rn=0, Rt=1, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x50010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_r_T1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (same register test (reg=1)), Rn=1 (same register test (reg=1))
#[test]
fn test_aarch32_str_r_t1_a_combo_6_0_50480000() {
    // Thumb encoding (32): 0x50480000
    // Test aarch32_STR_r_T1_A field combination: Rm=1, Rn=1, Rt=0
    // ISET: T32
    // Fields: Rm=1, Rn=1, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x50480000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_r_T1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (same register test (reg=31)), Rn=31 (same register test (reg=31))
#[test]
fn test_aarch32_str_r_t1_a_combo_7_0_51f80000() {
    // Thumb encoding (32): 0x51F80000
    // Test aarch32_STR_r_T1_A field combination: Rm=31, Rn=31, Rt=0
    // ISET: T32
    // Fields: Rn=31, Rt=0, Rm=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x51F80000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_r_T1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (same register test (reg=1)), Rt=1 (same register test (reg=1))
#[test]
fn test_aarch32_str_r_t1_a_combo_8_0_50410000() {
    // Thumb encoding (32): 0x50410000
    // Test aarch32_STR_r_T1_A field combination: Rm=1, Rn=0, Rt=1
    // ISET: T32
    // Fields: Rn=0, Rt=1, Rm=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x50410000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_r_T1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (same register test (reg=31)), Rt=31 (same register test (reg=31))
#[test]
fn test_aarch32_str_r_t1_a_combo_9_0_51c70000() {
    // Thumb encoding (32): 0x51C70000
    // Test aarch32_STR_r_T1_A field combination: Rm=31, Rn=0, Rt=31
    // ISET: T32
    // Fields: Rm=31, Rn=0, Rt=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x51C70000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_r_T1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rt=1 (same register test (reg=1))
#[test]
fn test_aarch32_str_r_t1_a_combo_10_0_50090000() {
    // Thumb encoding (32): 0x50090000
    // Test aarch32_STR_r_T1_A field combination: Rm=0, Rn=1, Rt=1
    // ISET: T32
    // Fields: Rt=1, Rn=1, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x50090000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_r_T1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rt=31 (same register test (reg=31))
#[test]
fn test_aarch32_str_r_t1_a_combo_11_0_503f0000() {
    // Thumb encoding (32): 0x503F0000
    // Test aarch32_STR_r_T1_A field combination: Rm=0, Rn=31, Rt=31
    // ISET: T32
    // Fields: Rm=0, Rt=31, Rn=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x503F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_r_T2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_str_r_t2_a_field_rn_0_min_0_f8400000() {
    // Thumb encoding (32): 0xF8400000
    // Test aarch32_STR_r_T2_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rm=0, Rn=0, Rt=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_r_T2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_str_r_t2_a_field_rn_1_poweroftwo_0_f8410000() {
    // Thumb encoding (32): 0xF8410000
    // Test aarch32_STR_r_T2_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=1, Rt=0, imm2=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8410000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_r_T2_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_str_r_t2_a_field_rt_0_min_0_f8400000() {
    // Thumb encoding (32): 0xF8400000
    // Test aarch32_STR_r_T2_A field Rt = 0 (Min)
    // ISET: T32
    // Fields: imm2=0, Rm=0, Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_r_T2_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_str_r_t2_a_field_rt_1_poweroftwo_0_f8401000() {
    // Thumb encoding (32): 0xF8401000
    // Test aarch32_STR_r_T2_A field Rt = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=1, imm2=0, Rn=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8401000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_r_T2_A
/// ASL: `field imm2 4 +: 2`
/// Requirement: FieldBoundary { field: "imm2", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_str_r_t2_a_field_imm2_0_zero_0_f8400000() {
    // Thumb encoding (32): 0xF8400000
    // Test aarch32_STR_r_T2_A field imm2 = 0 (Zero)
    // ISET: T32
    // Fields: imm2=0, Rt=0, Rm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_r_T2_A
/// ASL: `field imm2 4 +: 2`
/// Requirement: FieldBoundary { field: "imm2", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_str_r_t2_a_field_imm2_1_poweroftwo_0_f8400010() {
    // Thumb encoding (32): 0xF8400010
    // Test aarch32_STR_r_T2_A field imm2 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm2=1, Rm=0, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8400010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_r_T2_A
/// ASL: `field imm2 4 +: 2`
/// Requirement: FieldBoundary { field: "imm2", value: 3, boundary: Max }
/// maximum immediate (3)
#[test]
fn test_aarch32_str_r_t2_a_field_imm2_3_max_0_f8400030() {
    // Thumb encoding (32): 0xF8400030
    // Test aarch32_STR_r_T2_A field imm2 = 3 (Max)
    // ISET: T32
    // Fields: Rm=0, Rt=0, Rn=0, imm2=3
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8400030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_r_T2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_str_r_t2_a_field_rm_0_min_0_f8400000() {
    // Thumb encoding (32): 0xF8400000
    // Test aarch32_STR_r_T2_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rt=0, Rm=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_r_T2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_str_r_t2_a_field_rm_1_poweroftwo_0_f8400001() {
    // Thumb encoding (32): 0xF8400001
    // Test aarch32_STR_r_T2_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm2=0, Rm=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8400001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_r_T2_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_str_r_t2_a_combo_0_0_f8400000() {
    // Thumb encoding (32): 0xF8400000
    // Test aarch32_STR_r_T2_A field combination: Rn=0, Rt=0, imm2=0, Rm=0
    // ISET: T32
    // Fields: Rm=0, imm2=0, Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_r_T2_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_str_r_t2_a_combo_1_0_f8410000() {
    // Thumb encoding (32): 0xF8410000
    // Test aarch32_STR_r_T2_A field combination: Rn=1, Rt=0, imm2=0, Rm=0
    // ISET: T32
    // Fields: imm2=0, Rn=1, Rm=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8410000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_r_T2_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=0 (register index 0 (first register))
#[test]
fn test_aarch32_str_r_t2_a_combo_2_0_f8400000() {
    // Thumb encoding (32): 0xF8400000
    // Test aarch32_STR_r_T2_A field combination: Rn=0, Rt=0, imm2=0, Rm=0
    // ISET: T32
    // Fields: Rm=0, Rt=0, Rn=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_r_T2_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=1 (register index 1 (second register))
#[test]
fn test_aarch32_str_r_t2_a_combo_3_0_f8401000() {
    // Thumb encoding (32): 0xF8401000
    // Test aarch32_STR_r_T2_A field combination: Rn=0, Rt=1, imm2=0, Rm=0
    // ISET: T32
    // Fields: imm2=0, Rn=0, Rm=0, Rt=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8401000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_r_T2_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm2=0 (immediate value 0)
#[test]
fn test_aarch32_str_r_t2_a_combo_4_0_f8400000() {
    // Thumb encoding (32): 0xF8400000
    // Test aarch32_STR_r_T2_A field combination: Rn=0, Rt=0, imm2=0, Rm=0
    // ISET: T32
    // Fields: Rm=0, Rn=0, imm2=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_r_T2_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm2=1 (immediate value 1)
#[test]
fn test_aarch32_str_r_t2_a_combo_5_0_f8400010() {
    // Thumb encoding (32): 0xF8400010
    // Test aarch32_STR_r_T2_A field combination: Rn=0, Rt=0, imm2=1, Rm=0
    // ISET: T32
    // Fields: Rt=0, Rn=0, imm2=1, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8400010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_r_T2_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm2=3 (maximum immediate (3))
#[test]
fn test_aarch32_str_r_t2_a_combo_6_0_f8400030() {
    // Thumb encoding (32): 0xF8400030
    // Test aarch32_STR_r_T2_A field combination: Rn=0, Rt=0, imm2=3, Rm=0
    // ISET: T32
    // Fields: Rt=0, Rm=0, imm2=3, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8400030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_r_T2_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch32_str_r_t2_a_combo_7_0_f8400000() {
    // Thumb encoding (32): 0xF8400000
    // Test aarch32_STR_r_T2_A field combination: Rn=0, Rt=0, imm2=0, Rm=0
    // ISET: T32
    // Fields: Rn=0, Rt=0, Rm=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_r_T2_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_aarch32_str_r_t2_a_combo_8_0_f8400001() {
    // Thumb encoding (32): 0xF8400001
    // Test aarch32_STR_r_T2_A field combination: Rn=0, Rt=0, imm2=0, Rm=1
    // ISET: T32
    // Fields: imm2=0, Rn=0, Rt=0, Rm=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8400001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_r_T2_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rt=1 (same register test (reg=1))
#[test]
fn test_aarch32_str_r_t2_a_combo_9_0_f8411000() {
    // Thumb encoding (32): 0xF8411000
    // Test aarch32_STR_r_T2_A field combination: Rn=1, Rt=1, imm2=0, Rm=0
    // ISET: T32
    // Fields: Rn=1, Rt=1, imm2=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8411000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_r_T2_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rt=31 (same register test (reg=31))
#[test]
fn test_aarch32_str_r_t2_a_combo_10_0_f84ff000() {
    // Thumb encoding (32): 0xF84FF000
    // Test aarch32_STR_r_T2_A field combination: Rn=31, Rt=31, imm2=0, Rm=0
    // ISET: T32
    // Fields: Rn=31, Rm=0, Rt=31, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF84FF000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_r_T2_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rm=1 (same register test (reg=1))
#[test]
fn test_aarch32_str_r_t2_a_combo_11_0_f8410001() {
    // Thumb encoding (32): 0xF8410001
    // Test aarch32_STR_r_T2_A field combination: Rn=1, Rt=0, imm2=0, Rm=1
    // ISET: T32
    // Fields: Rm=1, imm2=0, Rn=1, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8410001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_r_T2_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rm=31 (same register test (reg=31))
#[test]
fn test_aarch32_str_r_t2_a_combo_12_0_f84f000f() {
    // Thumb encoding (32): 0xF84F000F
    // Test aarch32_STR_r_T2_A field combination: Rn=31, Rt=0, imm2=0, Rm=31
    // ISET: T32
    // Fields: Rn=31, Rt=0, imm2=0, Rm=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF84F000F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_r_T2_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=1 (same register test (reg=1)), Rm=1 (same register test (reg=1))
#[test]
fn test_aarch32_str_r_t2_a_combo_13_0_f8401001() {
    // Thumb encoding (32): 0xF8401001
    // Test aarch32_STR_r_T2_A field combination: Rn=0, Rt=1, imm2=0, Rm=1
    // ISET: T32
    // Fields: Rn=0, imm2=0, Rt=1, Rm=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8401001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_r_T2_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=31 (same register test (reg=31)), Rm=31 (same register test (reg=31))
#[test]
fn test_aarch32_str_r_t2_a_combo_14_0_f840f00f() {
    // Thumb encoding (32): 0xF840F00F
    // Test aarch32_STR_r_T2_A field combination: Rn=0, Rt=31, imm2=0, Rm=31
    // ISET: T32
    // Fields: Rn=0, imm2=0, Rm=31, Rt=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF840F00F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STR_r_T2_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rn" }), rhs: LitBits([true, true, true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Rn\" }), rhs: LitBits([true, true, true, true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_str_r_t2_a_invalid_0_0_f8400000() {
    // Thumb encoding (32): 0xF8400000
    // Test aarch32_STR_r_T2_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rn" }), rhs: LitBits([true, true, true, true]) }
    // ISET: T32
    // Fields: Rm=0, Rt=0, Rn=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_STR_r_T2_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_str_r_t2_a_invalid_1_0_f8400000() {
    // Thumb encoding (32): 0xF8400000
    // Test aarch32_STR_r_T2_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: imm2=0, Rm=0, Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_STR_r_T2_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_str_r_t2_a_invalid_2_0_f8400000() {
    // Thumb encoding (32): 0xF8400000
    // Test aarch32_STR_r_T2_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm2=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8400000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_STR_r_T2_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_str_r_t2_a_invalid_3_0_f8400000() {
    // Thumb encoding (32): 0xF8400000
    // Test aarch32_STR_r_T2_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rt=0, Rm=0, imm2=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8400000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_STR_r_A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_str_r_a1_a_store_0_06010000() {
    // Test aarch32_STR_r_A1_A memory store: 8 bytes
    // Encoding: 0x06010000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0x06010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_STR_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 0 (32)
#[test]
fn test_aarch32_str_r_t1_a_lslv_oracle_32_0_50020020() {
    // Test LSLV 32-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x12345678, "W0 should be 0x12345678");
}

/// Provenance: aarch32_STR_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 0 (64)
#[test]
fn test_aarch32_str_r_t1_a_lslv_oracle_64_0_d0020020() {
    // Test LSLV 64-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x12345678, "X0 should be 0x0000000012345678");
}

/// Provenance: aarch32_STR_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4 (32)
#[test]
fn test_aarch32_str_r_t1_a_lslv_oracle_32_1_50020020() {
    // Test LSLV 32-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x4);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x23456780, "W0 should be 0x23456780");
}

/// Provenance: aarch32_STR_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 4 (64)
#[test]
fn test_aarch32_str_r_t1_a_lslv_oracle_64_1_d0020020() {
    // Test LSLV 64-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x4);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x23456780, "X0 should be 0x0000000123456780");
}

/// Provenance: aarch32_STR_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 8 (32)
#[test]
fn test_aarch32_str_r_t1_a_lslv_oracle_32_2_50020020() {
    // Test LSLV 32-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x8);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x34567800, "W0 should be 0x34567800");
}

/// Provenance: aarch32_STR_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 8 (64)
#[test]
fn test_aarch32_str_r_t1_a_lslv_oracle_64_2_d0020020() {
    // Test LSLV 64-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x8);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x34567800, "X0 should be 0x0000001234567800");
}

/// Provenance: aarch32_STR_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1 (32)
#[test]
fn test_aarch32_str_r_t1_a_lslv_oracle_32_3_50020020() {
    // Test LSLV 32-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_STR_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// MSB set, shift 1 (64)
#[test]
fn test_aarch32_str_r_t1_a_lslv_oracle_64_3_d0020020() {
    // Test LSLV 64-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_STR_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// LSB set, max shift (32)
#[test]
fn test_aarch32_str_r_t1_a_lslv_oracle_32_4_50020020() {
    // Test LSLV 32-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x3F);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "W0 should be 0x80000000");
}

/// Provenance: aarch32_STR_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// LSB set, max shift (64)
#[test]
fn test_aarch32_str_r_t1_a_lslv_oracle_64_4_d0020020() {
    // Test LSLV 64-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3F);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x8000000000000000");
}

/// Provenance: aarch32_STR_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// all ones, shift 32 (32)
#[test]
fn test_aarch32_str_r_t1_a_lslv_oracle_32_5_50020020() {
    // Test LSLV 32-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x20);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "W0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_STR_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// all ones, shift 32 (64)
#[test]
fn test_aarch32_str_r_t1_a_lslv_oracle_64_5_d0020020() {
    // Test LSLV 64-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x20);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0xFFFFFFFF00000000");
}

/// Provenance: aarch32_STR_r_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// no shift
#[test]
fn test_aarch32_str_r_t1_a_t16_oracle_0_50880000() {
    // Test T16 LSLS: no shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_STR_r_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4
#[test]
fn test_aarch32_str_r_t1_a_t16_oracle_1_50880000() {
    // Test T16 LSLS: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x4);
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF0, "R0 should be 0x00000FF0");
}

/// Provenance: aarch32_STR_r_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1
#[test]
fn test_aarch32_str_r_t1_a_t16_oracle_2_50880000() {
    // Test T16 LSLS: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_STR_r_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift to MSB
#[test]
fn test_aarch32_str_r_t1_a_t16_oracle_3_50880000() {
    // Test T16 LSLS: shift to MSB (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x1F);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "R0 should be 0x80000000");
}

/// Provenance: aarch32_STR_r_T1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_str_r_t1_a_store_0_50080000() {
    // Test aarch32_STR_r_T1_A memory store: 8 bytes
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_STR_r_T2_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_str_r_t2_a_store_0_f8410000() {
    // Test aarch32_STR_r_T2_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF8410000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// aarch32_STLEXB_A Tests
// ============================================================================

/// Provenance: aarch32_STLEXB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_stlexb_a1_a_field_cond_0_min_290_01c00290() {
    // Encoding: 0x01C00290
    // Test aarch32_STLEXB_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, Rd=0, Rt=0, cond=0
    let encoding: u32 = 0x01C00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_stlexb_a1_a_field_cond_1_poweroftwo_290_11c00290() {
    // Encoding: 0x11C00290
    // Test aarch32_STLEXB_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rn=0, Rt=0, cond=1
    let encoding: u32 = 0x11C00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_stlexb_a1_a_field_cond_2_poweroftwo_290_21c00290() {
    // Encoding: 0x21C00290
    // Test aarch32_STLEXB_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rt=0, Rd=0, cond=2
    let encoding: u32 = 0x21C00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_stlexb_a1_a_field_cond_3_poweroftwo_290_31c00290() {
    // Encoding: 0x31C00290
    // Test aarch32_STLEXB_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, cond=3, Rn=0, Rt=0
    let encoding: u32 = 0x31C00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_stlexb_a1_a_field_cond_4_poweroftwo_290_41c00290() {
    // Encoding: 0x41C00290
    // Test aarch32_STLEXB_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rt=0, cond=4, Rn=0
    let encoding: u32 = 0x41C00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_stlexb_a1_a_field_cond_5_poweroftwo_290_51c00290() {
    // Encoding: 0x51C00290
    // Test aarch32_STLEXB_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=5, Rn=0, Rt=0, Rd=0
    let encoding: u32 = 0x51C00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_stlexb_a1_a_field_cond_6_poweroftwo_290_61c00290() {
    // Encoding: 0x61C00290
    // Test aarch32_STLEXB_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=6, Rt=0, Rn=0, Rd=0
    let encoding: u32 = 0x61C00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_stlexb_a1_a_field_cond_7_poweroftwo_290_71c00290() {
    // Encoding: 0x71C00290
    // Test aarch32_STLEXB_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, Rn=0, Rd=0, cond=7
    let encoding: u32 = 0x71C00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_stlexb_a1_a_field_cond_8_poweroftwo_290_81c00290() {
    // Encoding: 0x81C00290
    // Test aarch32_STLEXB_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=8, Rt=0, Rd=0
    let encoding: u32 = 0x81C00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_stlexb_a1_a_field_cond_9_poweroftwo_290_91c00290() {
    // Encoding: 0x91C00290
    // Test aarch32_STLEXB_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=9, Rd=0, Rt=0
    let encoding: u32 = 0x91C00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_stlexb_a1_a_field_cond_10_poweroftwo_290_a1c00290() {
    // Encoding: 0xA1C00290
    // Test aarch32_STLEXB_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, cond=10, Rn=0, Rt=0
    let encoding: u32 = 0xA1C00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_stlexb_a1_a_field_cond_11_poweroftwo_290_b1c00290() {
    // Encoding: 0xB1C00290
    // Test aarch32_STLEXB_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=11, Rd=0, Rn=0, Rt=0
    let encoding: u32 = 0xB1C00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_stlexb_a1_a_field_cond_12_poweroftwo_290_c1c00290() {
    // Encoding: 0xC1C00290
    // Test aarch32_STLEXB_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, cond=12, Rt=0, Rn=0
    let encoding: u32 = 0xC1C00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_stlexb_a1_a_field_cond_13_poweroftwo_290_d1c00290() {
    // Encoding: 0xD1C00290
    // Test aarch32_STLEXB_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, Rd=0, cond=13, Rn=0
    let encoding: u32 = 0xD1C00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_stlexb_a1_a_field_cond_14_poweroftwo_290_e1c00290() {
    // Encoding: 0xE1C00290
    // Test aarch32_STLEXB_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rd=0, cond=14, Rt=0
    let encoding: u32 = 0xE1C00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_stlexb_a1_a_field_cond_15_max_290_f1c00290() {
    // Encoding: 0xF1C00290
    // Test aarch32_STLEXB_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: cond=15, Rt=0, Rd=0, Rn=0
    let encoding: u32 = 0xF1C00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXB_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_stlexb_a1_a_field_rn_0_min_290_01c00290() {
    // Encoding: 0x01C00290
    // Test aarch32_STLEXB_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: Rd=0, cond=0, Rt=0, Rn=0
    let encoding: u32 = 0x01C00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXB_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_stlexb_a1_a_field_rn_1_poweroftwo_290_01c10290() {
    // Encoding: 0x01C10290
    // Test aarch32_STLEXB_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rn=1, cond=0, Rt=0
    let encoding: u32 = 0x01C10290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXB_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_stlexb_a1_a_field_rd_0_min_290_01c00290() {
    // Encoding: 0x01C00290
    // Test aarch32_STLEXB_A1_A field Rd = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, Rd=0, Rt=0, cond=0
    let encoding: u32 = 0x01C00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXB_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_stlexb_a1_a_field_rd_1_poweroftwo_290_01c01290() {
    // Encoding: 0x01C01290
    // Test aarch32_STLEXB_A1_A field Rd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Rd=1, Rn=0, Rt=0
    let encoding: u32 = 0x01C01290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXB_A1_A
/// ASL: `field Rt 0 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_stlexb_a1_a_field_rt_0_min_290_01c00290() {
    // Encoding: 0x01C00290
    // Test aarch32_STLEXB_A1_A field Rt = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, Rd=0, Rt=0, cond=0
    let encoding: u32 = 0x01C00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXB_A1_A
/// ASL: `field Rt 0 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_stlexb_a1_a_field_rt_1_poweroftwo_290_01c00291() {
    // Encoding: 0x01C00291
    // Test aarch32_STLEXB_A1_A field Rt = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Rn=0, Rd=0, Rt=1
    let encoding: u32 = 0x01C00291;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXB_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_stlexb_a1_a_combo_0_290_01c00290() {
    // Encoding: 0x01C00290
    // Test aarch32_STLEXB_A1_A field combination: cond=0, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: cond=0, Rn=0, Rd=0, Rt=0
    let encoding: u32 = 0x01C00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXB_A1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=1 (condition NE (not equal))
#[test]
fn test_aarch32_stlexb_a1_a_combo_1_290_11c00290() {
    // Encoding: 0x11C00290
    // Test aarch32_STLEXB_A1_A field combination: cond=1, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rt=0, cond=1, Rn=0, Rd=0
    let encoding: u32 = 0x11C00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXB_A1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=2 (condition CS/HS (carry set))
#[test]
fn test_aarch32_stlexb_a1_a_combo_2_290_21c00290() {
    // Encoding: 0x21C00290
    // Test aarch32_STLEXB_A1_A field combination: cond=2, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rt=0, cond=2, Rn=0, Rd=0
    let encoding: u32 = 0x21C00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXB_A1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=3 (condition CC/LO (carry clear))
#[test]
fn test_aarch32_stlexb_a1_a_combo_3_290_31c00290() {
    // Encoding: 0x31C00290
    // Test aarch32_STLEXB_A1_A field combination: cond=3, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rn=0, cond=3, Rd=0, Rt=0
    let encoding: u32 = 0x31C00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXB_A1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=4 (condition MI (minus/negative))
#[test]
fn test_aarch32_stlexb_a1_a_combo_4_290_41c00290() {
    // Encoding: 0x41C00290
    // Test aarch32_STLEXB_A1_A field combination: cond=4, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rn=0, cond=4, Rd=0, Rt=0
    let encoding: u32 = 0x41C00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXB_A1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=5 (condition PL (plus/positive))
#[test]
fn test_aarch32_stlexb_a1_a_combo_5_290_51c00290() {
    // Encoding: 0x51C00290
    // Test aarch32_STLEXB_A1_A field combination: cond=5, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rt=0, Rn=0, Rd=0, cond=5
    let encoding: u32 = 0x51C00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXB_A1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=6 (condition VS (overflow set))
#[test]
fn test_aarch32_stlexb_a1_a_combo_6_290_61c00290() {
    // Encoding: 0x61C00290
    // Test aarch32_STLEXB_A1_A field combination: cond=6, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: cond=6, Rn=0, Rt=0, Rd=0
    let encoding: u32 = 0x61C00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXB_A1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=7 (condition VC (overflow clear))
#[test]
fn test_aarch32_stlexb_a1_a_combo_7_290_71c00290() {
    // Encoding: 0x71C00290
    // Test aarch32_STLEXB_A1_A field combination: cond=7, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rt=0, Rd=0, cond=7, Rn=0
    let encoding: u32 = 0x71C00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXB_A1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=8 (condition HI (unsigned higher))
#[test]
fn test_aarch32_stlexb_a1_a_combo_8_290_81c00290() {
    // Encoding: 0x81C00290
    // Test aarch32_STLEXB_A1_A field combination: cond=8, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: cond=8, Rd=0, Rt=0, Rn=0
    let encoding: u32 = 0x81C00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXB_A1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=9 (condition LS (unsigned lower or same))
#[test]
fn test_aarch32_stlexb_a1_a_combo_9_290_91c00290() {
    // Encoding: 0x91C00290
    // Test aarch32_STLEXB_A1_A field combination: cond=9, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rn=0, cond=9, Rt=0, Rd=0
    let encoding: u32 = 0x91C00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXB_A1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=10 (condition GE (signed >=))
#[test]
fn test_aarch32_stlexb_a1_a_combo_10_290_a1c00290() {
    // Encoding: 0xA1C00290
    // Test aarch32_STLEXB_A1_A field combination: cond=10, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rn=0, Rd=0, cond=10, Rt=0
    let encoding: u32 = 0xA1C00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXB_A1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=11 (condition LT (signed <))
#[test]
fn test_aarch32_stlexb_a1_a_combo_11_290_b1c00290() {
    // Encoding: 0xB1C00290
    // Test aarch32_STLEXB_A1_A field combination: cond=11, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rn=0, cond=11, Rd=0, Rt=0
    let encoding: u32 = 0xB1C00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXB_A1_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=12 (condition GT (signed >))
#[test]
fn test_aarch32_stlexb_a1_a_combo_12_290_c1c00290() {
    // Encoding: 0xC1C00290
    // Test aarch32_STLEXB_A1_A field combination: cond=12, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rd=0, cond=12, Rt=0, Rn=0
    let encoding: u32 = 0xC1C00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXB_A1_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=13 (condition LE (signed <=))
#[test]
fn test_aarch32_stlexb_a1_a_combo_13_290_d1c00290() {
    // Encoding: 0xD1C00290
    // Test aarch32_STLEXB_A1_A field combination: cond=13, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: cond=13, Rd=0, Rn=0, Rt=0
    let encoding: u32 = 0xD1C00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXB_A1_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=14 (condition AL (always))
#[test]
fn test_aarch32_stlexb_a1_a_combo_14_290_e1c00290() {
    // Encoding: 0xE1C00290
    // Test aarch32_STLEXB_A1_A field combination: cond=14, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: cond=14, Rt=0, Rd=0, Rn=0
    let encoding: u32 = 0xE1C00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXB_A1_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=15 (condition NV (never, reserved))
#[test]
fn test_aarch32_stlexb_a1_a_combo_15_290_f1c00290() {
    // Encoding: 0xF1C00290
    // Test aarch32_STLEXB_A1_A field combination: cond=15, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: cond=15, Rn=0, Rd=0, Rt=0
    let encoding: u32 = 0xF1C00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXB_A1_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_stlexb_a1_a_combo_16_290_01c00290() {
    // Encoding: 0x01C00290
    // Test aarch32_STLEXB_A1_A field combination: cond=0, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rt=0, Rn=0, cond=0, Rd=0
    let encoding: u32 = 0x01C00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXB_A1_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_stlexb_a1_a_combo_17_290_01c10290() {
    // Encoding: 0x01C10290
    // Test aarch32_STLEXB_A1_A field combination: cond=0, Rn=1, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rd=0, cond=0, Rn=1, Rt=0
    let encoding: u32 = 0x01C10290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXB_A1_A
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch32_stlexb_a1_a_combo_18_290_01c00290() {
    // Encoding: 0x01C00290
    // Test aarch32_STLEXB_A1_A field combination: cond=0, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: cond=0, Rn=0, Rt=0, Rd=0
    let encoding: u32 = 0x01C00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXB_A1_A
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch32_stlexb_a1_a_combo_19_290_01c01290() {
    // Encoding: 0x01C01290
    // Test aarch32_STLEXB_A1_A field combination: cond=0, Rn=0, Rd=1, Rt=0
    // ISET: A32
    // Fields: cond=0, Rn=0, Rd=1, Rt=0
    let encoding: u32 = 0x01C01290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXB_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_stlexb_a1_a_special_cond_0_condition_eq_656_01c00290() {
    // Encoding: 0x01C00290
    // Test aarch32_STLEXB_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: Rn=0, cond=0, Rt=0, Rd=0
    let encoding: u32 = 0x01C00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXB_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_stlexb_a1_a_special_cond_1_condition_ne_656_11c00290() {
    // Encoding: 0x11C00290
    // Test aarch32_STLEXB_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: cond=1, Rn=0, Rd=0, Rt=0
    let encoding: u32 = 0x11C00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXB_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_stlexb_a1_a_special_cond_2_condition_cs_hs_656_21c00290() {
    // Encoding: 0x21C00290
    // Test aarch32_STLEXB_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: Rn=0, Rt=0, Rd=0, cond=2
    let encoding: u32 = 0x21C00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXB_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_stlexb_a1_a_special_cond_3_condition_cc_lo_656_31c00290() {
    // Encoding: 0x31C00290
    // Test aarch32_STLEXB_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: Rt=0, Rd=0, Rn=0, cond=3
    let encoding: u32 = 0x31C00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXB_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_stlexb_a1_a_special_cond_4_condition_mi_656_41c00290() {
    // Encoding: 0x41C00290
    // Test aarch32_STLEXB_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: cond=4, Rn=0, Rd=0, Rt=0
    let encoding: u32 = 0x41C00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXB_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_stlexb_a1_a_special_cond_5_condition_pl_656_51c00290() {
    // Encoding: 0x51C00290
    // Test aarch32_STLEXB_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: cond=5, Rt=0, Rd=0, Rn=0
    let encoding: u32 = 0x51C00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXB_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_stlexb_a1_a_special_cond_6_condition_vs_656_61c00290() {
    // Encoding: 0x61C00290
    // Test aarch32_STLEXB_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: Rn=0, Rt=0, Rd=0, cond=6
    let encoding: u32 = 0x61C00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXB_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_stlexb_a1_a_special_cond_7_condition_vc_656_71c00290() {
    // Encoding: 0x71C00290
    // Test aarch32_STLEXB_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: Rn=0, Rd=0, Rt=0, cond=7
    let encoding: u32 = 0x71C00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXB_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_stlexb_a1_a_special_cond_8_condition_hi_656_81c00290() {
    // Encoding: 0x81C00290
    // Test aarch32_STLEXB_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: cond=8, Rt=0, Rn=0, Rd=0
    let encoding: u32 = 0x81C00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXB_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_stlexb_a1_a_special_cond_9_condition_ls_656_91c00290() {
    // Encoding: 0x91C00290
    // Test aarch32_STLEXB_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: cond=9, Rt=0, Rd=0, Rn=0
    let encoding: u32 = 0x91C00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXB_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_stlexb_a1_a_special_cond_10_condition_ge_656_a1c00290() {
    // Encoding: 0xA1C00290
    // Test aarch32_STLEXB_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: cond=10, Rd=0, Rt=0, Rn=0
    let encoding: u32 = 0xA1C00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXB_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_stlexb_a1_a_special_cond_11_condition_lt_656_b1c00290() {
    // Encoding: 0xB1C00290
    // Test aarch32_STLEXB_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: cond=11, Rt=0, Rd=0, Rn=0
    let encoding: u32 = 0xB1C00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXB_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_stlexb_a1_a_special_cond_12_condition_gt_656_c1c00290() {
    // Encoding: 0xC1C00290
    // Test aarch32_STLEXB_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: Rt=0, Rn=0, Rd=0, cond=12
    let encoding: u32 = 0xC1C00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXB_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_stlexb_a1_a_special_cond_13_condition_le_656_d1c00290() {
    // Encoding: 0xD1C00290
    // Test aarch32_STLEXB_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: cond=13, Rn=0, Rd=0, Rt=0
    let encoding: u32 = 0xD1C00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXB_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_stlexb_a1_a_special_cond_14_condition_al_656_e1c00290() {
    // Encoding: 0xE1C00290
    // Test aarch32_STLEXB_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: Rt=0, Rn=0, cond=14, Rd=0
    let encoding: u32 = 0xE1C00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXB_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_stlexb_a1_a_special_cond_15_condition_nv_656_f1c00290() {
    // Encoding: 0xF1C00290
    // Test aarch32_STLEXB_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: Rt=0, Rd=0, cond=15, Rn=0
    let encoding: u32 = 0xF1C00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXB_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_stlexb_a1_a_invalid_0_290_01c00290() {
    // Encoding: 0x01C00290
    // Test aarch32_STLEXB_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=0, Rd=0
    let encoding: u32 = 0x01C00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STLEXB_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_stlexb_a1_a_invalid_1_290_01c00290() {
    // Encoding: 0x01C00290
    // Test aarch32_STLEXB_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Rt=0, Rn=0, Rd=0, cond=0
    let encoding: u32 = 0x01C00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STLEXB_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_stlexb_a1_a_invalid_2_290_01c00290() {
    // Encoding: 0x01C00290
    // Test aarch32_STLEXB_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) }
    // ISET: A32
    // Fields: Rn=0, cond=0, Rt=0, Rd=0
    let encoding: u32 = 0x01C00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STLEXB_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_stlexb_a1_a_invalid_3_290_01c00290() {
    // Encoding: 0x01C00290
    // Test aarch32_STLEXB_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: cond=0, Rn=0, Rt=0, Rd=0
    let encoding: u32 = 0x01C00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STLEXB_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_stlexb_t1_a_field_rn_0_min_c0_e8c000c0() {
    // Thumb encoding (32): 0xE8C000C0
    // Test aarch32_STLEXB_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rd=0, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C000C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLEXB_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_stlexb_t1_a_field_rn_1_poweroftwo_c0_e8c100c0() {
    // Thumb encoding (32): 0xE8C100C0
    // Test aarch32_STLEXB_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=1, Rt=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C100C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLEXB_T1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_stlexb_t1_a_field_rt_0_min_c0_e8c000c0() {
    // Thumb encoding (32): 0xE8C000C0
    // Test aarch32_STLEXB_T1_A field Rt = 0 (Min)
    // ISET: T32
    // Fields: Rt=0, Rd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C000C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLEXB_T1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_stlexb_t1_a_field_rt_1_poweroftwo_c0_e8c010c0() {
    // Thumb encoding (32): 0xE8C010C0
    // Test aarch32_STLEXB_T1_A field Rt = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=1, Rn=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C010C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLEXB_T1_A
/// ASL: `field Rd 0 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_stlexb_t1_a_field_rd_0_min_c0_e8c000c0() {
    // Thumb encoding (32): 0xE8C000C0
    // Test aarch32_STLEXB_T1_A field Rd = 0 (Min)
    // ISET: T32
    // Fields: Rd=0, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C000C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLEXB_T1_A
/// ASL: `field Rd 0 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_stlexb_t1_a_field_rd_1_poweroftwo_c0_e8c000c1() {
    // Thumb encoding (32): 0xE8C000C1
    // Test aarch32_STLEXB_T1_A field Rd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Rt=0, Rd=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C000C1;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLEXB_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_stlexb_t1_a_combo_0_c0_e8c000c0() {
    // Thumb encoding (32): 0xE8C000C0
    // Test aarch32_STLEXB_T1_A field combination: Rn=0, Rt=0, Rd=0
    // ISET: T32
    // Fields: Rt=0, Rd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C000C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLEXB_T1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_stlexb_t1_a_combo_1_c0_e8c100c0() {
    // Thumb encoding (32): 0xE8C100C0
    // Test aarch32_STLEXB_T1_A field combination: Rn=1, Rt=0, Rd=0
    // ISET: T32
    // Fields: Rn=1, Rt=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C100C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLEXB_T1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=0 (register index 0 (first register))
#[test]
fn test_aarch32_stlexb_t1_a_combo_2_c0_e8c000c0() {
    // Thumb encoding (32): 0xE8C000C0
    // Test aarch32_STLEXB_T1_A field combination: Rn=0, Rt=0, Rd=0
    // ISET: T32
    // Fields: Rt=0, Rd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C000C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLEXB_T1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=1 (register index 1 (second register))
#[test]
fn test_aarch32_stlexb_t1_a_combo_3_c0_e8c010c0() {
    // Thumb encoding (32): 0xE8C010C0
    // Test aarch32_STLEXB_T1_A field combination: Rn=0, Rt=1, Rd=0
    // ISET: T32
    // Fields: Rd=0, Rn=0, Rt=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C010C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLEXB_T1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch32_stlexb_t1_a_combo_4_c0_e8c000c0() {
    // Thumb encoding (32): 0xE8C000C0
    // Test aarch32_STLEXB_T1_A field combination: Rn=0, Rt=0, Rd=0
    // ISET: T32
    // Fields: Rd=0, Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C000C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLEXB_T1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch32_stlexb_t1_a_combo_5_c0_e8c000c1() {
    // Thumb encoding (32): 0xE8C000C1
    // Test aarch32_STLEXB_T1_A field combination: Rn=0, Rt=0, Rd=1
    // ISET: T32
    // Fields: Rd=1, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C000C1;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLEXB_T1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rt=1 (same register test (reg=1))
#[test]
fn test_aarch32_stlexb_t1_a_combo_6_c0_e8c110c0() {
    // Thumb encoding (32): 0xE8C110C0
    // Test aarch32_STLEXB_T1_A field combination: Rn=1, Rt=1, Rd=0
    // ISET: T32
    // Fields: Rt=1, Rn=1, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C110C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLEXB_T1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rt=31 (same register test (reg=31))
#[test]
fn test_aarch32_stlexb_t1_a_combo_7_c0_e8cff0c0() {
    // Thumb encoding (32): 0xE8CFF0C0
    // Test aarch32_STLEXB_T1_A field combination: Rn=31, Rt=31, Rd=0
    // ISET: T32
    // Fields: Rt=31, Rn=31, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8CFF0C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLEXB_T1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch32_stlexb_t1_a_combo_8_c0_e8c100c1() {
    // Thumb encoding (32): 0xE8C100C1
    // Test aarch32_STLEXB_T1_A field combination: Rn=1, Rt=0, Rd=1
    // ISET: T32
    // Fields: Rd=1, Rn=1, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C100C1;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLEXB_T1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch32_stlexb_t1_a_combo_9_c0_e8cf00cf() {
    // Thumb encoding (32): 0xE8CF00CF
    // Test aarch32_STLEXB_T1_A field combination: Rn=31, Rt=0, Rd=31
    // ISET: T32
    // Fields: Rn=31, Rd=31, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8CF00CF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLEXB_T1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch32_stlexb_t1_a_combo_10_c0_e8c010c1() {
    // Thumb encoding (32): 0xE8C010C1
    // Test aarch32_STLEXB_T1_A field combination: Rn=0, Rt=1, Rd=1
    // ISET: T32
    // Fields: Rn=0, Rt=1, Rd=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C010C1;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLEXB_T1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch32_stlexb_t1_a_combo_11_c0_e8c0f0cf() {
    // Thumb encoding (32): 0xE8C0F0CF
    // Test aarch32_STLEXB_T1_A field combination: Rn=0, Rt=31, Rd=31
    // ISET: T32
    // Fields: Rn=0, Rt=31, Rd=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C0F0CF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLEXB_T1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_stlexb_t1_a_invalid_0_c0_e8c000c0() {
    // Thumb encoding (32): 0xE8C000C0
    // Test aarch32_STLEXB_T1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }
    // ISET: T32
    // Fields: Rn=0, Rd=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C000C0;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_STLEXB_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_stlexb_t1_a_invalid_1_c0_e8c000c0() {
    // Thumb encoding (32): 0xE8C000C0
    // Test aarch32_STLEXB_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rt=0, Rn=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C000C0;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_STLEXB_T1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_stlexb_t1_a_invalid_2_c0_e8c000c0() {
    // Thumb encoding (32): 0xE8C000C0
    // Test aarch32_STLEXB_T1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) }
    // ISET: T32
    // Fields: Rd=0, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C000C0;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_STLEXB_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_stlexb_t1_a_invalid_3_c0_e8c000c0() {
    // Thumb encoding (32): 0xE8C000C0
    // Test aarch32_STLEXB_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rt=0, Rd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C000C0;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_STLEXB_A1_A
/// ASL: `SMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple multiply
#[test]
fn test_aarch32_stlexb_a1_a_smull_oracle_0_9b227c20() {
    // Test SMULL: simple multiply (oracle)
    // Encoding: 0x9B227C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3);
    set_w(&mut cpu, 1, 0x2);
    let encoding: u32 = 0x9B227C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6, "X0 should be 0x0000000000000006");
}

/// Provenance: aarch32_STLEXB_A1_A
/// ASL: `SMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max 32-bit * 2
#[test]
fn test_aarch32_stlexb_a1_a_smull_oracle_1_9b227c20() {
    // Test SMULL: max 32-bit * 2 (oracle)
    // Encoding: 0x9B227C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x9B227C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFE, "X0 should be 0xFFFFFFFFFFFFFFFE");
}

/// Provenance: aarch32_STLEXB_A1_A
/// ASL: `SMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// large positive * large positive
#[test]
fn test_aarch32_stlexb_a1_a_smull_oracle_2_9b227c20() {
    // Test SMULL: large positive * large positive (oracle)
    // Encoding: 0x9B227C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x7FFFFFFF);
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x9B227C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x3FFFFFFF00000001");
}

/// Provenance: aarch32_STLEXB_A1_A
/// ASL: `SMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max unsigned * max unsigned
#[test]
fn test_aarch32_stlexb_a1_a_smull_oracle_3_9b227c20() {
    // Test SMULL: max unsigned * max unsigned (oracle)
    // Encoding: 0x9B227C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x9B227C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x0000000000000001");
}

/// Provenance: aarch32_STLEXB_A1_A
/// ASL: `SMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// medium values
#[test]
fn test_aarch32_stlexb_a1_a_smull_oracle_4_9b227c20() {
    // Test SMULL: medium values (oracle)
    // Encoding: 0x9B227C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xC8);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x9B227C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4E20, "X0 should be 0x0000000000004E20");
}

/// Provenance: aarch32_STLEXB_A1_A
/// ASL: `SMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// 16-bit values
#[test]
fn test_aarch32_stlexb_a1_a_smull_oracle_5_9b227c20() {
    // Test SMULL: 16-bit values (oracle)
    // Encoding: 0x9B227C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x5678);
    set_w(&mut cpu, 1, 0x1234);
    let encoding: u32 = 0x9B227C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6260060, "X0 should be 0x0000000006260060");
}

/// Provenance: aarch32_STLEXB_A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_stlexb_a1_a_store_0_01c10290() {
    // Test aarch32_STLEXB_A1_A memory store: 8 bytes
    // Encoding: 0x01C10290
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0x01C10290;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_STLEXB_T1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_stlexb_t1_a_store_0_e8c100c0() {
    // Test aarch32_STLEXB_T1_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xE8C100C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// aarch32_STLB_A Tests
// ============================================================================

/// Provenance: aarch32_STLB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_stlb_a1_a_field_cond_0_min_90_01c00090() {
    // Encoding: 0x01C00090
    // Test aarch32_STLB_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: Rt=0, cond=0, Rn=0
    let encoding: u32 = 0x01C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_stlb_a1_a_field_cond_1_poweroftwo_90_11c00090() {
    // Encoding: 0x11C00090
    // Test aarch32_STLB_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, cond=1, Rn=0
    let encoding: u32 = 0x11C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_stlb_a1_a_field_cond_2_poweroftwo_90_21c00090() {
    // Encoding: 0x21C00090
    // Test aarch32_STLB_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=2, Rt=0
    let encoding: u32 = 0x21C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_stlb_a1_a_field_cond_3_poweroftwo_90_31c00090() {
    // Encoding: 0x31C00090
    // Test aarch32_STLB_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=3, Rn=0, Rt=0
    let encoding: u32 = 0x31C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_stlb_a1_a_field_cond_4_poweroftwo_90_41c00090() {
    // Encoding: 0x41C00090
    // Test aarch32_STLB_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=4, Rt=0
    let encoding: u32 = 0x41C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_stlb_a1_a_field_cond_5_poweroftwo_90_51c00090() {
    // Encoding: 0x51C00090
    // Test aarch32_STLB_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=5, Rn=0, Rt=0
    let encoding: u32 = 0x51C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_stlb_a1_a_field_cond_6_poweroftwo_90_61c00090() {
    // Encoding: 0x61C00090
    // Test aarch32_STLB_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=6, Rn=0, Rt=0
    let encoding: u32 = 0x61C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_stlb_a1_a_field_cond_7_poweroftwo_90_71c00090() {
    // Encoding: 0x71C00090
    // Test aarch32_STLB_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=7, Rt=0
    let encoding: u32 = 0x71C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_stlb_a1_a_field_cond_8_poweroftwo_90_81c00090() {
    // Encoding: 0x81C00090
    // Test aarch32_STLB_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=8, Rt=0
    let encoding: u32 = 0x81C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_stlb_a1_a_field_cond_9_poweroftwo_90_91c00090() {
    // Encoding: 0x91C00090
    // Test aarch32_STLB_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=9, Rt=0
    let encoding: u32 = 0x91C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_stlb_a1_a_field_cond_10_poweroftwo_90_a1c00090() {
    // Encoding: 0xA1C00090
    // Test aarch32_STLB_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, cond=10, Rn=0
    let encoding: u32 = 0xA1C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_stlb_a1_a_field_cond_11_poweroftwo_90_b1c00090() {
    // Encoding: 0xB1C00090
    // Test aarch32_STLB_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=11, Rn=0, Rt=0
    let encoding: u32 = 0xB1C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_stlb_a1_a_field_cond_12_poweroftwo_90_c1c00090() {
    // Encoding: 0xC1C00090
    // Test aarch32_STLB_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=12, Rt=0, Rn=0
    let encoding: u32 = 0xC1C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_stlb_a1_a_field_cond_13_poweroftwo_90_d1c00090() {
    // Encoding: 0xD1C00090
    // Test aarch32_STLB_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=13
    let encoding: u32 = 0xD1C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_stlb_a1_a_field_cond_14_poweroftwo_90_e1c00090() {
    // Encoding: 0xE1C00090
    // Test aarch32_STLB_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=14, Rn=0, Rt=0
    let encoding: u32 = 0xE1C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_stlb_a1_a_field_cond_15_max_90_f1c00090() {
    // Encoding: 0xF1C00090
    // Test aarch32_STLB_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=15
    let encoding: u32 = 0xF1C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLB_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_stlb_a1_a_field_rn_0_min_90_01c00090() {
    // Encoding: 0x01C00090
    // Test aarch32_STLB_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: Rt=0, cond=0, Rn=0
    let encoding: u32 = 0x01C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLB_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_stlb_a1_a_field_rn_1_poweroftwo_90_01c10090() {
    // Encoding: 0x01C10090
    // Test aarch32_STLB_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Rn=1, Rt=0
    let encoding: u32 = 0x01C10090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLB_A1_A
/// ASL: `field Rt 0 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_stlb_a1_a_field_rt_0_min_90_01c00090() {
    // Encoding: 0x01C00090
    // Test aarch32_STLB_A1_A field Rt = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=0
    let encoding: u32 = 0x01C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLB_A1_A
/// ASL: `field Rt 0 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_stlb_a1_a_field_rt_1_poweroftwo_90_01c00091() {
    // Encoding: 0x01C00091
    // Test aarch32_STLB_A1_A field Rt = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=1, cond=0, Rn=0
    let encoding: u32 = 0x01C00091;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLB_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_stlb_a1_a_combo_0_90_01c00090() {
    // Encoding: 0x01C00090
    // Test aarch32_STLB_A1_A field combination: cond=0, Rn=0, Rt=0
    // ISET: A32
    // Fields: cond=0, Rt=0, Rn=0
    let encoding: u32 = 0x01C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLB_A1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=1 (condition NE (not equal))
#[test]
fn test_aarch32_stlb_a1_a_combo_1_90_11c00090() {
    // Encoding: 0x11C00090
    // Test aarch32_STLB_A1_A field combination: cond=1, Rn=0, Rt=0
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=1
    let encoding: u32 = 0x11C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLB_A1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=2 (condition CS/HS (carry set))
#[test]
fn test_aarch32_stlb_a1_a_combo_2_90_21c00090() {
    // Encoding: 0x21C00090
    // Test aarch32_STLB_A1_A field combination: cond=2, Rn=0, Rt=0
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=2
    let encoding: u32 = 0x21C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLB_A1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=3 (condition CC/LO (carry clear))
#[test]
fn test_aarch32_stlb_a1_a_combo_3_90_31c00090() {
    // Encoding: 0x31C00090
    // Test aarch32_STLB_A1_A field combination: cond=3, Rn=0, Rt=0
    // ISET: A32
    // Fields: Rt=0, cond=3, Rn=0
    let encoding: u32 = 0x31C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLB_A1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=4 (condition MI (minus/negative))
#[test]
fn test_aarch32_stlb_a1_a_combo_4_90_41c00090() {
    // Encoding: 0x41C00090
    // Test aarch32_STLB_A1_A field combination: cond=4, Rn=0, Rt=0
    // ISET: A32
    // Fields: Rn=0, cond=4, Rt=0
    let encoding: u32 = 0x41C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLB_A1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=5 (condition PL (plus/positive))
#[test]
fn test_aarch32_stlb_a1_a_combo_5_90_51c00090() {
    // Encoding: 0x51C00090
    // Test aarch32_STLB_A1_A field combination: cond=5, Rn=0, Rt=0
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=5
    let encoding: u32 = 0x51C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLB_A1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=6 (condition VS (overflow set))
#[test]
fn test_aarch32_stlb_a1_a_combo_6_90_61c00090() {
    // Encoding: 0x61C00090
    // Test aarch32_STLB_A1_A field combination: cond=6, Rn=0, Rt=0
    // ISET: A32
    // Fields: Rt=0, cond=6, Rn=0
    let encoding: u32 = 0x61C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLB_A1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=7 (condition VC (overflow clear))
#[test]
fn test_aarch32_stlb_a1_a_combo_7_90_71c00090() {
    // Encoding: 0x71C00090
    // Test aarch32_STLB_A1_A field combination: cond=7, Rn=0, Rt=0
    // ISET: A32
    // Fields: Rn=0, cond=7, Rt=0
    let encoding: u32 = 0x71C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLB_A1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=8 (condition HI (unsigned higher))
#[test]
fn test_aarch32_stlb_a1_a_combo_8_90_81c00090() {
    // Encoding: 0x81C00090
    // Test aarch32_STLB_A1_A field combination: cond=8, Rn=0, Rt=0
    // ISET: A32
    // Fields: cond=8, Rn=0, Rt=0
    let encoding: u32 = 0x81C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLB_A1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=9 (condition LS (unsigned lower or same))
#[test]
fn test_aarch32_stlb_a1_a_combo_9_90_91c00090() {
    // Encoding: 0x91C00090
    // Test aarch32_STLB_A1_A field combination: cond=9, Rn=0, Rt=0
    // ISET: A32
    // Fields: cond=9, Rn=0, Rt=0
    let encoding: u32 = 0x91C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLB_A1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=10 (condition GE (signed >=))
#[test]
fn test_aarch32_stlb_a1_a_combo_10_90_a1c00090() {
    // Encoding: 0xA1C00090
    // Test aarch32_STLB_A1_A field combination: cond=10, Rn=0, Rt=0
    // ISET: A32
    // Fields: cond=10, Rn=0, Rt=0
    let encoding: u32 = 0xA1C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLB_A1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=11 (condition LT (signed <))
#[test]
fn test_aarch32_stlb_a1_a_combo_11_90_b1c00090() {
    // Encoding: 0xB1C00090
    // Test aarch32_STLB_A1_A field combination: cond=11, Rn=0, Rt=0
    // ISET: A32
    // Fields: Rn=0, cond=11, Rt=0
    let encoding: u32 = 0xB1C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLB_A1_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=12 (condition GT (signed >))
#[test]
fn test_aarch32_stlb_a1_a_combo_12_90_c1c00090() {
    // Encoding: 0xC1C00090
    // Test aarch32_STLB_A1_A field combination: cond=12, Rn=0, Rt=0
    // ISET: A32
    // Fields: cond=12, Rn=0, Rt=0
    let encoding: u32 = 0xC1C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLB_A1_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=13 (condition LE (signed <=))
#[test]
fn test_aarch32_stlb_a1_a_combo_13_90_d1c00090() {
    // Encoding: 0xD1C00090
    // Test aarch32_STLB_A1_A field combination: cond=13, Rn=0, Rt=0
    // ISET: A32
    // Fields: cond=13, Rn=0, Rt=0
    let encoding: u32 = 0xD1C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLB_A1_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=14 (condition AL (always))
#[test]
fn test_aarch32_stlb_a1_a_combo_14_90_e1c00090() {
    // Encoding: 0xE1C00090
    // Test aarch32_STLB_A1_A field combination: cond=14, Rn=0, Rt=0
    // ISET: A32
    // Fields: Rt=0, cond=14, Rn=0
    let encoding: u32 = 0xE1C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLB_A1_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=15 (condition NV (never, reserved))
#[test]
fn test_aarch32_stlb_a1_a_combo_15_90_f1c00090() {
    // Encoding: 0xF1C00090
    // Test aarch32_STLB_A1_A field combination: cond=15, Rn=0, Rt=0
    // ISET: A32
    // Fields: Rt=0, Rn=0, cond=15
    let encoding: u32 = 0xF1C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLB_A1_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_stlb_a1_a_combo_16_90_01c00090() {
    // Encoding: 0x01C00090
    // Test aarch32_STLB_A1_A field combination: cond=0, Rn=0, Rt=0
    // ISET: A32
    // Fields: Rt=0, cond=0, Rn=0
    let encoding: u32 = 0x01C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLB_A1_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_stlb_a1_a_combo_17_90_01c10090() {
    // Encoding: 0x01C10090
    // Test aarch32_STLB_A1_A field combination: cond=0, Rn=1, Rt=0
    // ISET: A32
    // Fields: Rn=1, cond=0, Rt=0
    let encoding: u32 = 0x01C10090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLB_A1_A
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=0 (register index 0 (first register))
#[test]
fn test_aarch32_stlb_a1_a_combo_18_90_01c00090() {
    // Encoding: 0x01C00090
    // Test aarch32_STLB_A1_A field combination: cond=0, Rn=0, Rt=0
    // ISET: A32
    // Fields: Rt=0, Rn=0, cond=0
    let encoding: u32 = 0x01C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLB_A1_A
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=1 (register index 1 (second register))
#[test]
fn test_aarch32_stlb_a1_a_combo_19_90_01c00091() {
    // Encoding: 0x01C00091
    // Test aarch32_STLB_A1_A field combination: cond=0, Rn=0, Rt=1
    // ISET: A32
    // Fields: Rt=1, Rn=0, cond=0
    let encoding: u32 = 0x01C00091;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLB_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_stlb_a1_a_special_cond_0_condition_eq_144_01c00090() {
    // Encoding: 0x01C00090
    // Test aarch32_STLB_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: Rn=0, cond=0, Rt=0
    let encoding: u32 = 0x01C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLB_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_stlb_a1_a_special_cond_1_condition_ne_144_11c00090() {
    // Encoding: 0x11C00090
    // Test aarch32_STLB_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: cond=1, Rn=0, Rt=0
    let encoding: u32 = 0x11C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLB_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_stlb_a1_a_special_cond_2_condition_cs_hs_144_21c00090() {
    // Encoding: 0x21C00090
    // Test aarch32_STLB_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: Rt=0, cond=2, Rn=0
    let encoding: u32 = 0x21C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLB_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_stlb_a1_a_special_cond_3_condition_cc_lo_144_31c00090() {
    // Encoding: 0x31C00090
    // Test aarch32_STLB_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: cond=3, Rt=0, Rn=0
    let encoding: u32 = 0x31C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLB_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_stlb_a1_a_special_cond_4_condition_mi_144_41c00090() {
    // Encoding: 0x41C00090
    // Test aarch32_STLB_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: Rn=0, cond=4, Rt=0
    let encoding: u32 = 0x41C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLB_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_stlb_a1_a_special_cond_5_condition_pl_144_51c00090() {
    // Encoding: 0x51C00090
    // Test aarch32_STLB_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: cond=5, Rn=0, Rt=0
    let encoding: u32 = 0x51C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLB_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_stlb_a1_a_special_cond_6_condition_vs_144_61c00090() {
    // Encoding: 0x61C00090
    // Test aarch32_STLB_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: cond=6, Rt=0, Rn=0
    let encoding: u32 = 0x61C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLB_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_stlb_a1_a_special_cond_7_condition_vc_144_71c00090() {
    // Encoding: 0x71C00090
    // Test aarch32_STLB_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: cond=7, Rn=0, Rt=0
    let encoding: u32 = 0x71C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLB_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_stlb_a1_a_special_cond_8_condition_hi_144_81c00090() {
    // Encoding: 0x81C00090
    // Test aarch32_STLB_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: Rt=0, cond=8, Rn=0
    let encoding: u32 = 0x81C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLB_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_stlb_a1_a_special_cond_9_condition_ls_144_91c00090() {
    // Encoding: 0x91C00090
    // Test aarch32_STLB_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: cond=9, Rn=0, Rt=0
    let encoding: u32 = 0x91C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLB_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_stlb_a1_a_special_cond_10_condition_ge_144_a1c00090() {
    // Encoding: 0xA1C00090
    // Test aarch32_STLB_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: Rt=0, Rn=0, cond=10
    let encoding: u32 = 0xA1C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLB_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_stlb_a1_a_special_cond_11_condition_lt_144_b1c00090() {
    // Encoding: 0xB1C00090
    // Test aarch32_STLB_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: Rn=0, cond=11, Rt=0
    let encoding: u32 = 0xB1C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLB_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_stlb_a1_a_special_cond_12_condition_gt_144_c1c00090() {
    // Encoding: 0xC1C00090
    // Test aarch32_STLB_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: Rt=0, cond=12, Rn=0
    let encoding: u32 = 0xC1C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLB_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_stlb_a1_a_special_cond_13_condition_le_144_d1c00090() {
    // Encoding: 0xD1C00090
    // Test aarch32_STLB_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: cond=13, Rn=0, Rt=0
    let encoding: u32 = 0xD1C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLB_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_stlb_a1_a_special_cond_14_condition_al_144_e1c00090() {
    // Encoding: 0xE1C00090
    // Test aarch32_STLB_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: Rt=0, cond=14, Rn=0
    let encoding: u32 = 0xE1C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLB_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_stlb_a1_a_special_cond_15_condition_nv_144_f1c00090() {
    // Encoding: 0xF1C00090
    // Test aarch32_STLB_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: Rn=0, cond=15, Rt=0
    let encoding: u32 = 0xF1C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLB_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_stlb_a1_a_invalid_0_90_01c00090() {
    // Encoding: 0x01C00090
    // Test aarch32_STLB_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }
    // ISET: A32
    // Fields: Rt=0, cond=0, Rn=0
    let encoding: u32 = 0x01C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STLB_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_stlb_a1_a_invalid_1_90_01c00090() {
    // Encoding: 0x01C00090
    // Test aarch32_STLB_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: cond=0, Rt=0, Rn=0
    let encoding: u32 = 0x01C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STLB_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_stlb_t1_a_field_rn_0_min_80_e8c00080() {
    // Thumb encoding (32): 0xE8C00080
    // Test aarch32_STLB_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C00080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLB_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_stlb_t1_a_field_rn_1_poweroftwo_80_e8c10080() {
    // Thumb encoding (32): 0xE8C10080
    // Test aarch32_STLB_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, Rn=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C10080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLB_T1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_stlb_t1_a_field_rt_0_min_80_e8c00080() {
    // Thumb encoding (32): 0xE8C00080
    // Test aarch32_STLB_T1_A field Rt = 0 (Min)
    // ISET: T32
    // Fields: Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C00080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLB_T1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_stlb_t1_a_field_rt_1_poweroftwo_80_e8c01080() {
    // Thumb encoding (32): 0xE8C01080
    // Test aarch32_STLB_T1_A field Rt = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Rt=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C01080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLB_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_stlb_t1_a_combo_0_80_e8c00080() {
    // Thumb encoding (32): 0xE8C00080
    // Test aarch32_STLB_T1_A field combination: Rn=0, Rt=0
    // ISET: T32
    // Fields: Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C00080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLB_T1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_stlb_t1_a_combo_1_80_e8c10080() {
    // Thumb encoding (32): 0xE8C10080
    // Test aarch32_STLB_T1_A field combination: Rn=1, Rt=0
    // ISET: T32
    // Fields: Rt=0, Rn=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C10080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLB_T1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=0 (register index 0 (first register))
#[test]
fn test_aarch32_stlb_t1_a_combo_2_80_e8c00080() {
    // Thumb encoding (32): 0xE8C00080
    // Test aarch32_STLB_T1_A field combination: Rn=0, Rt=0
    // ISET: T32
    // Fields: Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C00080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLB_T1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=1 (register index 1 (second register))
#[test]
fn test_aarch32_stlb_t1_a_combo_3_80_e8c01080() {
    // Thumb encoding (32): 0xE8C01080
    // Test aarch32_STLB_T1_A field combination: Rn=0, Rt=1
    // ISET: T32
    // Fields: Rt=1, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C01080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLB_T1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rt=1 (same register test (reg=1))
#[test]
fn test_aarch32_stlb_t1_a_combo_4_80_e8c11080() {
    // Thumb encoding (32): 0xE8C11080
    // Test aarch32_STLB_T1_A field combination: Rn=1, Rt=1
    // ISET: T32
    // Fields: Rn=1, Rt=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C11080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLB_T1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rt=31 (same register test (reg=31))
#[test]
fn test_aarch32_stlb_t1_a_combo_5_80_e8cff080() {
    // Thumb encoding (32): 0xE8CFF080
    // Test aarch32_STLB_T1_A field combination: Rn=31, Rt=31
    // ISET: T32
    // Fields: Rn=31, Rt=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8CFF080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLB_T1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_stlb_t1_a_invalid_0_80_e8c00080() {
    // Thumb encoding (32): 0xE8C00080
    // Test aarch32_STLB_T1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }
    // ISET: T32
    // Fields: Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C00080;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_STLB_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_stlb_t1_a_invalid_1_80_e8c00080() {
    // Thumb encoding (32): 0xE8C00080
    // Test aarch32_STLB_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C00080;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_STLB_A1_A
/// ASL: `SMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple multiply
#[test]
fn test_aarch32_stlb_a1_a_smull_oracle_0_9b227c20() {
    // Test SMULL: simple multiply (oracle)
    // Encoding: 0x9B227C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x2);
    set_w(&mut cpu, 2, 0x3);
    let encoding: u32 = 0x9B227C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6, "X0 should be 0x0000000000000006");
}

/// Provenance: aarch32_STLB_A1_A
/// ASL: `SMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max 32-bit * 2
#[test]
fn test_aarch32_stlb_a1_a_smull_oracle_1_9b227c20() {
    // Test SMULL: max 32-bit * 2 (oracle)
    // Encoding: 0x9B227C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x9B227C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFE, "X0 should be 0xFFFFFFFFFFFFFFFE");
}

/// Provenance: aarch32_STLB_A1_A
/// ASL: `SMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// large positive * large positive
#[test]
fn test_aarch32_stlb_a1_a_smull_oracle_2_9b227c20() {
    // Test SMULL: large positive * large positive (oracle)
    // Encoding: 0x9B227C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    set_w(&mut cpu, 2, 0x7FFFFFFF);
    let encoding: u32 = 0x9B227C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x3FFFFFFF00000001");
}

/// Provenance: aarch32_STLB_A1_A
/// ASL: `SMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max unsigned * max unsigned
#[test]
fn test_aarch32_stlb_a1_a_smull_oracle_3_9b227c20() {
    // Test SMULL: max unsigned * max unsigned (oracle)
    // Encoding: 0x9B227C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x9B227C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x0000000000000001");
}

/// Provenance: aarch32_STLB_A1_A
/// ASL: `SMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// medium values
#[test]
fn test_aarch32_stlb_a1_a_smull_oracle_4_9b227c20() {
    // Test SMULL: medium values (oracle)
    // Encoding: 0x9B227C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0xC8);
    let encoding: u32 = 0x9B227C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4E20, "X0 should be 0x0000000000004E20");
}

/// Provenance: aarch32_STLB_A1_A
/// ASL: `SMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// 16-bit values
#[test]
fn test_aarch32_stlb_a1_a_smull_oracle_5_9b227c20() {
    // Test SMULL: 16-bit values (oracle)
    // Encoding: 0x9B227C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1234);
    set_w(&mut cpu, 2, 0x5678);
    let encoding: u32 = 0x9B227C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6260060, "X0 should be 0x0000000006260060");
}

/// Provenance: aarch32_STLB_A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_stlb_a1_a_store_0_01c10090() {
    // Test aarch32_STLB_A1_A memory store: 8 bytes
    // Encoding: 0x01C10090
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x01C10090;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_STLB_T1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_stlb_t1_a_store_0_e8c10080() {
    // Test aarch32_STLB_T1_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0xE8C10080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// aarch32_STRHT_A Tests
// ============================================================================

/// Provenance: aarch32_STRHT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_strht_a1_a_field_cond_0_min_b0_006000b0() {
    // Encoding: 0x006000B0
    // Test aarch32_STRHT_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, U=0, imm4H=0, imm4L=0, cond=0, Rt=0
    let encoding: u32 = 0x006000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_strht_a1_a_field_cond_1_poweroftwo_b0_106000b0() {
    // Encoding: 0x106000B0
    // Test aarch32_STRHT_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, U=0, Rn=0, imm4L=0, cond=1, imm4H=0
    let encoding: u32 = 0x106000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_strht_a1_a_field_cond_2_poweroftwo_b0_206000b0() {
    // Encoding: 0x206000B0
    // Test aarch32_STRHT_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4H=0, imm4L=0, Rt=0, cond=2, U=0, Rn=0
    let encoding: u32 = 0x206000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_strht_a1_a_field_cond_3_poweroftwo_b0_306000b0() {
    // Encoding: 0x306000B0
    // Test aarch32_STRHT_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=3, imm4L=0, Rn=0, Rt=0, U=0, imm4H=0
    let encoding: u32 = 0x306000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_strht_a1_a_field_cond_4_poweroftwo_b0_406000b0() {
    // Encoding: 0x406000B0
    // Test aarch32_STRHT_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4L=0, U=0, Rt=0, cond=4, imm4H=0, Rn=0
    let encoding: u32 = 0x406000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_strht_a1_a_field_cond_5_poweroftwo_b0_506000b0() {
    // Encoding: 0x506000B0
    // Test aarch32_STRHT_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=5, U=0, Rt=0, imm4H=0, imm4L=0, Rn=0
    let encoding: u32 = 0x506000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_strht_a1_a_field_cond_6_poweroftwo_b0_606000b0() {
    // Encoding: 0x606000B0
    // Test aarch32_STRHT_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, imm4H=0, imm4L=0, Rt=0, Rn=0, cond=6
    let encoding: u32 = 0x606000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_strht_a1_a_field_cond_7_poweroftwo_b0_706000b0() {
    // Encoding: 0x706000B0
    // Test aarch32_STRHT_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, Rn=0, Rt=0, imm4L=0, imm4H=0, cond=7
    let encoding: u32 = 0x706000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_strht_a1_a_field_cond_8_poweroftwo_b0_806000b0() {
    // Encoding: 0x806000B0
    // Test aarch32_STRHT_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=8, imm4H=0, U=0, Rn=0, Rt=0, imm4L=0
    let encoding: u32 = 0x806000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_strht_a1_a_field_cond_9_poweroftwo_b0_906000b0() {
    // Encoding: 0x906000B0
    // Test aarch32_STRHT_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, imm4H=0, cond=9, U=0, Rt=0, imm4L=0
    let encoding: u32 = 0x906000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_strht_a1_a_field_cond_10_poweroftwo_b0_a06000b0() {
    // Encoding: 0xA06000B0
    // Test aarch32_STRHT_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4L=0, imm4H=0, Rn=0, Rt=0, cond=10, U=0
    let encoding: u32 = 0xA06000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_strht_a1_a_field_cond_11_poweroftwo_b0_b06000b0() {
    // Encoding: 0xB06000B0
    // Test aarch32_STRHT_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4H=0, cond=11, Rn=0, Rt=0, U=0, imm4L=0
    let encoding: u32 = 0xB06000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_strht_a1_a_field_cond_12_poweroftwo_b0_c06000b0() {
    // Encoding: 0xC06000B0
    // Test aarch32_STRHT_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=12, Rt=0, imm4L=0, Rn=0, U=0, imm4H=0
    let encoding: u32 = 0xC06000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_strht_a1_a_field_cond_13_poweroftwo_b0_d06000b0() {
    // Encoding: 0xD06000B0
    // Test aarch32_STRHT_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=13, Rt=0, imm4H=0, Rn=0, imm4L=0, U=0
    let encoding: u32 = 0xD06000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_strht_a1_a_field_cond_14_poweroftwo_b0_e06000b0() {
    // Encoding: 0xE06000B0
    // Test aarch32_STRHT_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=14, Rn=0, Rt=0, imm4L=0, U=0, imm4H=0
    let encoding: u32 = 0xE06000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_strht_a1_a_field_cond_15_max_b0_f06000b0() {
    // Encoding: 0xF06000B0
    // Test aarch32_STRHT_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: imm4H=0, U=0, Rt=0, cond=15, Rn=0, imm4L=0
    let encoding: u32 = 0xF06000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_strht_a1_a_field_u_0_min_b0_006000b0() {
    // Encoding: 0x006000B0
    // Test aarch32_STRHT_A1_A field U = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, cond=0, U=0, imm4H=0, Rt=0, imm4L=0
    let encoding: u32 = 0x006000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A1_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_strht_a1_a_field_u_1_max_b0_00e000b0() {
    // Encoding: 0x00E000B0
    // Test aarch32_STRHT_A1_A field U = 1 (Max)
    // ISET: A32
    // Fields: U=1, Rt=0, Rn=0, cond=0, imm4H=0, imm4L=0
    let encoding: u32 = 0x00E000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_strht_a1_a_field_rn_0_min_b0_006000b0() {
    // Encoding: 0x006000B0
    // Test aarch32_STRHT_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: cond=0, U=0, imm4H=0, imm4L=0, Rn=0, Rt=0
    let encoding: u32 = 0x006000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_strht_a1_a_field_rn_1_poweroftwo_b0_006100b0() {
    // Encoding: 0x006100B0
    // Test aarch32_STRHT_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4L=0, Rn=1, Rt=0, cond=0, U=0, imm4H=0
    let encoding: u32 = 0x006100B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_strht_a1_a_field_rt_0_min_b0_006000b0() {
    // Encoding: 0x006000B0
    // Test aarch32_STRHT_A1_A field Rt = 0 (Min)
    // ISET: A32
    // Fields: cond=0, imm4H=0, imm4L=0, U=0, Rn=0, Rt=0
    let encoding: u32 = 0x006000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_strht_a1_a_field_rt_1_poweroftwo_b0_006010b0() {
    // Encoding: 0x006010B0
    // Test aarch32_STRHT_A1_A field Rt = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4L=0, cond=0, Rn=0, imm4H=0, U=0, Rt=1
    let encoding: u32 = 0x006010B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_strht_a1_a_field_imm4h_0_zero_b0_006000b0() {
    // Encoding: 0x006000B0
    // Test aarch32_STRHT_A1_A field imm4H = 0 (Zero)
    // ISET: A32
    // Fields: imm4H=0, Rn=0, U=0, Rt=0, cond=0, imm4L=0
    let encoding: u32 = 0x006000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_strht_a1_a_field_imm4h_1_poweroftwo_b0_006001b0() {
    // Encoding: 0x006001B0
    // Test aarch32_STRHT_A1_A field imm4H = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, cond=0, Rn=0, imm4H=1, imm4L=0, U=0
    let encoding: u32 = 0x006001B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_strht_a1_a_field_imm4h_3_poweroftwominusone_b0_006003b0() {
    // Encoding: 0x006003B0
    // Test aarch32_STRHT_A1_A field imm4H = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, U=0, Rt=0, imm4H=3, Rn=0, imm4L=0
    let encoding: u32 = 0x006003B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_strht_a1_a_field_imm4h_4_poweroftwo_b0_006004b0() {
    // Encoding: 0x006004B0
    // Test aarch32_STRHT_A1_A field imm4H = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, cond=0, U=0, imm4H=4, imm4L=0, Rn=0
    let encoding: u32 = 0x006004B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_aarch32_strht_a1_a_field_imm4h_7_poweroftwominusone_b0_006007b0() {
    // Encoding: 0x006007B0
    // Test aarch32_STRHT_A1_A field imm4H = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rn=0, Rt=0, imm4H=7, imm4L=0, U=0, cond=0
    let encoding: u32 = 0x006007B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_strht_a1_a_field_imm4h_8_poweroftwo_b0_006008b0() {
    // Encoding: 0x006008B0
    // Test aarch32_STRHT_A1_A field imm4H = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, imm4L=0, imm4H=8, cond=0, Rn=0, U=0
    let encoding: u32 = 0x006008B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A1_A
/// ASL: `field imm4H 8 +: 4`
/// Requirement: FieldBoundary { field: "imm4H", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_aarch32_strht_a1_a_field_imm4h_15_max_b0_00600fb0() {
    // Encoding: 0x00600FB0
    // Test aarch32_STRHT_A1_A field imm4H = 15 (Max)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=0, U=0, imm4L=0, imm4H=15
    let encoding: u32 = 0x00600FB0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_strht_a1_a_field_imm4l_0_zero_b0_006000b0() {
    // Encoding: 0x006000B0
    // Test aarch32_STRHT_A1_A field imm4L = 0 (Zero)
    // ISET: A32
    // Fields: Rt=0, imm4H=0, imm4L=0, cond=0, Rn=0, U=0
    let encoding: u32 = 0x006000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_strht_a1_a_field_imm4l_1_poweroftwo_b0_006000b1() {
    // Encoding: 0x006000B1
    // Test aarch32_STRHT_A1_A field imm4L = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: imm4H=0, Rn=0, Rt=0, U=0, cond=0, imm4L=1
    let encoding: u32 = 0x006000B1;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_strht_a1_a_field_imm4l_3_poweroftwominusone_b0_006000b3() {
    // Encoding: 0x006000B3
    // Test aarch32_STRHT_A1_A field imm4L = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rt=0, imm4H=0, cond=0, imm4L=3, U=0, Rn=0
    let encoding: u32 = 0x006000B3;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_strht_a1_a_field_imm4l_4_poweroftwo_b0_006000b4() {
    // Encoding: 0x006000B4
    // Test aarch32_STRHT_A1_A field imm4L = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, U=0, cond=0, imm4H=0, Rt=0, imm4L=4
    let encoding: u32 = 0x006000B4;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_aarch32_strht_a1_a_field_imm4l_7_poweroftwominusone_b0_006000b7() {
    // Encoding: 0x006000B7
    // Test aarch32_STRHT_A1_A field imm4L = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, Rt=0, Rn=0, imm4H=0, imm4L=7, U=0
    let encoding: u32 = 0x006000B7;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_strht_a1_a_field_imm4l_8_poweroftwo_b0_006000b8() {
    // Encoding: 0x006000B8
    // Test aarch32_STRHT_A1_A field imm4L = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, imm4H=0, imm4L=8, cond=0, U=0, Rt=0
    let encoding: u32 = 0x006000B8;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A1_A
/// ASL: `field imm4L 0 +: 4`
/// Requirement: FieldBoundary { field: "imm4L", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_aarch32_strht_a1_a_field_imm4l_15_max_b0_006000bf() {
    // Encoding: 0x006000BF
    // Test aarch32_STRHT_A1_A field imm4L = 15 (Max)
    // ISET: A32
    // Fields: imm4L=15, U=0, imm4H=0, cond=0, Rt=0, Rn=0
    let encoding: u32 = 0x006000BF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_strht_a1_a_combo_0_b0_006000b0() {
    // Encoding: 0x006000B0
    // Test aarch32_STRHT_A1_A field combination: cond=0, U=0, Rn=0, Rt=0, imm4H=0, imm4L=0
    // ISET: A32
    // Fields: imm4H=0, imm4L=0, cond=0, Rn=0, U=0, Rt=0
    let encoding: u32 = 0x006000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=1 (condition NE (not equal))
#[test]
fn test_aarch32_strht_a1_a_combo_1_b0_106000b0() {
    // Encoding: 0x106000B0
    // Test aarch32_STRHT_A1_A field combination: cond=1, U=0, Rn=0, Rt=0, imm4H=0, imm4L=0
    // ISET: A32
    // Fields: U=0, Rt=0, cond=1, imm4H=0, Rn=0, imm4L=0
    let encoding: u32 = 0x106000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=2 (condition CS/HS (carry set))
#[test]
fn test_aarch32_strht_a1_a_combo_2_b0_206000b0() {
    // Encoding: 0x206000B0
    // Test aarch32_STRHT_A1_A field combination: cond=2, U=0, Rn=0, Rt=0, imm4H=0, imm4L=0
    // ISET: A32
    // Fields: U=0, Rn=0, imm4L=0, imm4H=0, cond=2, Rt=0
    let encoding: u32 = 0x206000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=3 (condition CC/LO (carry clear))
#[test]
fn test_aarch32_strht_a1_a_combo_3_b0_306000b0() {
    // Encoding: 0x306000B0
    // Test aarch32_STRHT_A1_A field combination: cond=3, U=0, Rn=0, Rt=0, imm4H=0, imm4L=0
    // ISET: A32
    // Fields: U=0, Rn=0, Rt=0, imm4H=0, cond=3, imm4L=0
    let encoding: u32 = 0x306000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=4 (condition MI (minus/negative))
#[test]
fn test_aarch32_strht_a1_a_combo_4_b0_406000b0() {
    // Encoding: 0x406000B0
    // Test aarch32_STRHT_A1_A field combination: cond=4, U=0, Rn=0, Rt=0, imm4H=0, imm4L=0
    // ISET: A32
    // Fields: Rn=0, imm4L=0, U=0, Rt=0, imm4H=0, cond=4
    let encoding: u32 = 0x406000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=5 (condition PL (plus/positive))
#[test]
fn test_aarch32_strht_a1_a_combo_5_b0_506000b0() {
    // Encoding: 0x506000B0
    // Test aarch32_STRHT_A1_A field combination: cond=5, U=0, Rn=0, Rt=0, imm4H=0, imm4L=0
    // ISET: A32
    // Fields: cond=5, U=0, Rt=0, imm4L=0, imm4H=0, Rn=0
    let encoding: u32 = 0x506000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=6 (condition VS (overflow set))
#[test]
fn test_aarch32_strht_a1_a_combo_6_b0_606000b0() {
    // Encoding: 0x606000B0
    // Test aarch32_STRHT_A1_A field combination: cond=6, U=0, Rn=0, Rt=0, imm4H=0, imm4L=0
    // ISET: A32
    // Fields: U=0, cond=6, Rt=0, imm4H=0, Rn=0, imm4L=0
    let encoding: u32 = 0x606000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=7 (condition VC (overflow clear))
#[test]
fn test_aarch32_strht_a1_a_combo_7_b0_706000b0() {
    // Encoding: 0x706000B0
    // Test aarch32_STRHT_A1_A field combination: cond=7, U=0, Rn=0, Rt=0, imm4H=0, imm4L=0
    // ISET: A32
    // Fields: cond=7, Rn=0, imm4H=0, imm4L=0, U=0, Rt=0
    let encoding: u32 = 0x706000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=8 (condition HI (unsigned higher))
#[test]
fn test_aarch32_strht_a1_a_combo_8_b0_806000b0() {
    // Encoding: 0x806000B0
    // Test aarch32_STRHT_A1_A field combination: cond=8, U=0, Rn=0, Rt=0, imm4H=0, imm4L=0
    // ISET: A32
    // Fields: imm4H=0, imm4L=0, U=0, Rn=0, cond=8, Rt=0
    let encoding: u32 = 0x806000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=9 (condition LS (unsigned lower or same))
#[test]
fn test_aarch32_strht_a1_a_combo_9_b0_906000b0() {
    // Encoding: 0x906000B0
    // Test aarch32_STRHT_A1_A field combination: cond=9, U=0, Rn=0, Rt=0, imm4H=0, imm4L=0
    // ISET: A32
    // Fields: U=0, Rn=0, imm4H=0, imm4L=0, cond=9, Rt=0
    let encoding: u32 = 0x906000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=10 (condition GE (signed >=))
#[test]
fn test_aarch32_strht_a1_a_combo_10_b0_a06000b0() {
    // Encoding: 0xA06000B0
    // Test aarch32_STRHT_A1_A field combination: cond=10, U=0, Rn=0, Rt=0, imm4H=0, imm4L=0
    // ISET: A32
    // Fields: imm4H=0, imm4L=0, cond=10, U=0, Rt=0, Rn=0
    let encoding: u32 = 0xA06000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=11 (condition LT (signed <))
#[test]
fn test_aarch32_strht_a1_a_combo_11_b0_b06000b0() {
    // Encoding: 0xB06000B0
    // Test aarch32_STRHT_A1_A field combination: cond=11, U=0, Rn=0, Rt=0, imm4H=0, imm4L=0
    // ISET: A32
    // Fields: cond=11, Rn=0, U=0, Rt=0, imm4H=0, imm4L=0
    let encoding: u32 = 0xB06000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A1_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=12 (condition GT (signed >))
#[test]
fn test_aarch32_strht_a1_a_combo_12_b0_c06000b0() {
    // Encoding: 0xC06000B0
    // Test aarch32_STRHT_A1_A field combination: cond=12, U=0, Rn=0, Rt=0, imm4H=0, imm4L=0
    // ISET: A32
    // Fields: Rt=0, imm4L=0, Rn=0, imm4H=0, U=0, cond=12
    let encoding: u32 = 0xC06000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A1_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=13 (condition LE (signed <=))
#[test]
fn test_aarch32_strht_a1_a_combo_13_b0_d06000b0() {
    // Encoding: 0xD06000B0
    // Test aarch32_STRHT_A1_A field combination: cond=13, U=0, Rn=0, Rt=0, imm4H=0, imm4L=0
    // ISET: A32
    // Fields: U=0, Rn=0, Rt=0, cond=13, imm4H=0, imm4L=0
    let encoding: u32 = 0xD06000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A1_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=14 (condition AL (always))
#[test]
fn test_aarch32_strht_a1_a_combo_14_b0_e06000b0() {
    // Encoding: 0xE06000B0
    // Test aarch32_STRHT_A1_A field combination: cond=14, U=0, Rn=0, Rt=0, imm4H=0, imm4L=0
    // ISET: A32
    // Fields: Rt=0, imm4H=0, imm4L=0, U=0, cond=14, Rn=0
    let encoding: u32 = 0xE06000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A1_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=15 (condition NV (never, reserved))
#[test]
fn test_aarch32_strht_a1_a_combo_15_b0_f06000b0() {
    // Encoding: 0xF06000B0
    // Test aarch32_STRHT_A1_A field combination: cond=15, U=0, Rn=0, Rt=0, imm4H=0, imm4L=0
    // ISET: A32
    // Fields: Rt=0, imm4H=0, imm4L=0, cond=15, U=0, Rn=0
    let encoding: u32 = 0xF06000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A1_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=0 (minimum value)
#[test]
fn test_aarch32_strht_a1_a_combo_16_b0_006000b0() {
    // Encoding: 0x006000B0
    // Test aarch32_STRHT_A1_A field combination: cond=0, U=0, Rn=0, Rt=0, imm4H=0, imm4L=0
    // ISET: A32
    // Fields: Rn=0, imm4H=0, U=0, imm4L=0, Rt=0, cond=0
    let encoding: u32 = 0x006000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A1_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=1 (maximum value (1))
#[test]
fn test_aarch32_strht_a1_a_combo_17_b0_00e000b0() {
    // Encoding: 0x00E000B0
    // Test aarch32_STRHT_A1_A field combination: cond=0, U=1, Rn=0, Rt=0, imm4H=0, imm4L=0
    // ISET: A32
    // Fields: imm4H=0, U=1, cond=0, imm4L=0, Rn=0, Rt=0
    let encoding: u32 = 0x00E000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A1_A
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_strht_a1_a_combo_18_b0_006000b0() {
    // Encoding: 0x006000B0
    // Test aarch32_STRHT_A1_A field combination: cond=0, U=0, Rn=0, Rt=0, imm4H=0, imm4L=0
    // ISET: A32
    // Fields: U=0, Rt=0, imm4H=0, Rn=0, imm4L=0, cond=0
    let encoding: u32 = 0x006000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A1_A
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_strht_a1_a_combo_19_b0_006100b0() {
    // Encoding: 0x006100B0
    // Test aarch32_STRHT_A1_A field combination: cond=0, U=0, Rn=1, Rt=0, imm4H=0, imm4L=0
    // ISET: A32
    // Fields: Rt=0, imm4H=0, Rn=1, U=0, imm4L=0, cond=0
    let encoding: u32 = 0x006100B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_strht_a1_a_special_cond_0_condition_eq_176_006000b0() {
    // Encoding: 0x006000B0
    // Test aarch32_STRHT_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: cond=0, Rn=0, U=0, imm4L=0, Rt=0, imm4H=0
    let encoding: u32 = 0x006000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_strht_a1_a_special_cond_1_condition_ne_176_106000b0() {
    // Encoding: 0x106000B0
    // Test aarch32_STRHT_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: Rt=0, imm4L=0, cond=1, Rn=0, imm4H=0, U=0
    let encoding: u32 = 0x106000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_strht_a1_a_special_cond_2_condition_cs_hs_176_206000b0() {
    // Encoding: 0x206000B0
    // Test aarch32_STRHT_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: U=0, cond=2, imm4H=0, Rt=0, imm4L=0, Rn=0
    let encoding: u32 = 0x206000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_strht_a1_a_special_cond_3_condition_cc_lo_176_306000b0() {
    // Encoding: 0x306000B0
    // Test aarch32_STRHT_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: Rt=0, imm4H=0, U=0, imm4L=0, Rn=0, cond=3
    let encoding: u32 = 0x306000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_strht_a1_a_special_cond_4_condition_mi_176_406000b0() {
    // Encoding: 0x406000B0
    // Test aarch32_STRHT_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: imm4L=0, Rn=0, cond=4, U=0, imm4H=0, Rt=0
    let encoding: u32 = 0x406000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_strht_a1_a_special_cond_5_condition_pl_176_506000b0() {
    // Encoding: 0x506000B0
    // Test aarch32_STRHT_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: cond=5, imm4H=0, imm4L=0, U=0, Rn=0, Rt=0
    let encoding: u32 = 0x506000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_strht_a1_a_special_cond_6_condition_vs_176_606000b0() {
    // Encoding: 0x606000B0
    // Test aarch32_STRHT_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: imm4H=0, Rn=0, U=0, imm4L=0, Rt=0, cond=6
    let encoding: u32 = 0x606000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_strht_a1_a_special_cond_7_condition_vc_176_706000b0() {
    // Encoding: 0x706000B0
    // Test aarch32_STRHT_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: U=0, Rt=0, cond=7, Rn=0, imm4H=0, imm4L=0
    let encoding: u32 = 0x706000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_strht_a1_a_special_cond_8_condition_hi_176_806000b0() {
    // Encoding: 0x806000B0
    // Test aarch32_STRHT_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: cond=8, Rt=0, Rn=0, imm4H=0, U=0, imm4L=0
    let encoding: u32 = 0x806000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_strht_a1_a_special_cond_9_condition_ls_176_906000b0() {
    // Encoding: 0x906000B0
    // Test aarch32_STRHT_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: imm4L=0, imm4H=0, cond=9, U=0, Rt=0, Rn=0
    let encoding: u32 = 0x906000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_strht_a1_a_special_cond_10_condition_ge_176_a06000b0() {
    // Encoding: 0xA06000B0
    // Test aarch32_STRHT_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: cond=10, U=0, imm4H=0, imm4L=0, Rt=0, Rn=0
    let encoding: u32 = 0xA06000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_strht_a1_a_special_cond_11_condition_lt_176_b06000b0() {
    // Encoding: 0xB06000B0
    // Test aarch32_STRHT_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: imm4H=0, imm4L=0, Rn=0, cond=11, U=0, Rt=0
    let encoding: u32 = 0xB06000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_strht_a1_a_special_cond_12_condition_gt_176_c06000b0() {
    // Encoding: 0xC06000B0
    // Test aarch32_STRHT_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: Rn=0, imm4L=0, cond=12, U=0, Rt=0, imm4H=0
    let encoding: u32 = 0xC06000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_strht_a1_a_special_cond_13_condition_le_176_d06000b0() {
    // Encoding: 0xD06000B0
    // Test aarch32_STRHT_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: Rt=0, imm4H=0, cond=13, imm4L=0, U=0, Rn=0
    let encoding: u32 = 0xD06000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_strht_a1_a_special_cond_14_condition_al_176_e06000b0() {
    // Encoding: 0xE06000B0
    // Test aarch32_STRHT_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: imm4H=0, Rn=0, U=0, Rt=0, cond=14, imm4L=0
    let encoding: u32 = 0xE06000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_strht_a1_a_special_cond_15_condition_nv_176_f06000b0() {
    // Encoding: 0xF06000B0
    // Test aarch32_STRHT_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: Rt=0, U=0, cond=15, Rn=0, imm4H=0, imm4L=0
    let encoding: u32 = 0xF06000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strht_a1_a_invalid_0_b0_006000b0() {
    // Encoding: 0x006000B0
    // Test aarch32_STRHT_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) }
    // ISET: A32
    // Fields: imm4H=0, cond=0, Rt=0, imm4L=0, U=0, Rn=0
    let encoding: u32 = 0x006000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STRHT_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strht_a1_a_invalid_1_b0_006000b0() {
    // Encoding: 0x006000B0
    // Test aarch32_STRHT_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: cond=0, Rt=0, U=0, imm4H=0, imm4L=0, Rn=0
    let encoding: u32 = 0x006000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STRHT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_strht_a2_a_field_cond_0_min_b0_002000b0() {
    // Encoding: 0x002000B0
    // Test aarch32_STRHT_A2_A field cond = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, Rn=0, U=0, cond=0, Rt=0
    let encoding: u32 = 0x002000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_strht_a2_a_field_cond_1_poweroftwo_b0_102000b0() {
    // Encoding: 0x102000B0
    // Test aarch32_STRHT_A2_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, cond=1, Rm=0, U=0, Rn=0
    let encoding: u32 = 0x102000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_strht_a2_a_field_cond_2_poweroftwo_b0_202000b0() {
    // Encoding: 0x202000B0
    // Test aarch32_STRHT_A2_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, cond=2, Rm=0, Rn=0, Rt=0
    let encoding: u32 = 0x202000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_strht_a2_a_field_cond_3_poweroftwo_b0_302000b0() {
    // Encoding: 0x302000B0
    // Test aarch32_STRHT_A2_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, U=0, Rn=0, cond=3, Rt=0
    let encoding: u32 = 0x302000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_strht_a2_a_field_cond_4_poweroftwo_b0_402000b0() {
    // Encoding: 0x402000B0
    // Test aarch32_STRHT_A2_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, U=0, cond=4, Rt=0, Rm=0
    let encoding: u32 = 0x402000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_strht_a2_a_field_cond_5_poweroftwo_b0_502000b0() {
    // Encoding: 0x502000B0
    // Test aarch32_STRHT_A2_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, cond=5, Rn=0, Rt=0, U=0
    let encoding: u32 = 0x502000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_strht_a2_a_field_cond_6_poweroftwo_b0_602000b0() {
    // Encoding: 0x602000B0
    // Test aarch32_STRHT_A2_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, cond=6, Rm=0, Rn=0, U=0
    let encoding: u32 = 0x602000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_strht_a2_a_field_cond_7_poweroftwo_b0_702000b0() {
    // Encoding: 0x702000B0
    // Test aarch32_STRHT_A2_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, Rm=0, Rn=0, cond=7, Rt=0
    let encoding: u32 = 0x702000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_strht_a2_a_field_cond_8_poweroftwo_b0_802000b0() {
    // Encoding: 0x802000B0
    // Test aarch32_STRHT_A2_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, Rn=0, cond=8, Rt=0, Rm=0
    let encoding: u32 = 0x802000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_strht_a2_a_field_cond_9_poweroftwo_b0_902000b0() {
    // Encoding: 0x902000B0
    // Test aarch32_STRHT_A2_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Rn=0, U=0, Rt=0, cond=9
    let encoding: u32 = 0x902000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_strht_a2_a_field_cond_10_poweroftwo_b0_a02000b0() {
    // Encoding: 0xA02000B0
    // Test aarch32_STRHT_A2_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rm=0, cond=10, U=0, Rt=0
    let encoding: u32 = 0xA02000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_strht_a2_a_field_cond_11_poweroftwo_b0_b02000b0() {
    // Encoding: 0xB02000B0
    // Test aarch32_STRHT_A2_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Rt=0, cond=11, U=0, Rn=0
    let encoding: u32 = 0xB02000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_strht_a2_a_field_cond_12_poweroftwo_b0_c02000b0() {
    // Encoding: 0xC02000B0
    // Test aarch32_STRHT_A2_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: U=0, cond=12, Rn=0, Rt=0, Rm=0
    let encoding: u32 = 0xC02000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_strht_a2_a_field_cond_13_poweroftwo_b0_d02000b0() {
    // Encoding: 0xD02000B0
    // Test aarch32_STRHT_A2_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rt=0, Rm=0, cond=13, U=0
    let encoding: u32 = 0xD02000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_strht_a2_a_field_cond_14_poweroftwo_b0_e02000b0() {
    // Encoding: 0xE02000B0
    // Test aarch32_STRHT_A2_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, U=0, cond=14, Rn=0, Rm=0
    let encoding: u32 = 0xE02000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A2_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_strht_a2_a_field_cond_15_max_b0_f02000b0() {
    // Encoding: 0xF02000B0
    // Test aarch32_STRHT_A2_A field cond = 15 (Max)
    // ISET: A32
    // Fields: Rm=0, Rt=0, U=0, Rn=0, cond=15
    let encoding: u32 = 0xF02000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A2_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_strht_a2_a_field_u_0_min_b0_002000b0() {
    // Encoding: 0x002000B0
    // Test aarch32_STRHT_A2_A field U = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, Rn=0, Rt=0, cond=0, U=0
    let encoding: u32 = 0x002000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A2_A
/// ASL: `field U 23 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_strht_a2_a_field_u_1_max_b0_00a000b0() {
    // Encoding: 0x00A000B0
    // Test aarch32_STRHT_A2_A field U = 1 (Max)
    // ISET: A32
    // Fields: cond=0, Rt=0, Rm=0, U=1, Rn=0
    let encoding: u32 = 0x00A000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_strht_a2_a_field_rn_0_min_b0_002000b0() {
    // Encoding: 0x002000B0
    // Test aarch32_STRHT_A2_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, Rt=0, Rm=0, U=0, cond=0
    let encoding: u32 = 0x002000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_strht_a2_a_field_rn_1_poweroftwo_b0_002100b0() {
    // Encoding: 0x002100B0
    // Test aarch32_STRHT_A2_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, cond=0, U=0, Rt=0, Rn=1
    let encoding: u32 = 0x002100B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A2_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_strht_a2_a_field_rt_0_min_b0_002000b0() {
    // Encoding: 0x002000B0
    // Test aarch32_STRHT_A2_A field Rt = 0 (Min)
    // ISET: A32
    // Fields: U=0, Rn=0, Rt=0, Rm=0, cond=0
    let encoding: u32 = 0x002000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A2_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_strht_a2_a_field_rt_1_poweroftwo_b0_002010b0() {
    // Encoding: 0x002010B0
    // Test aarch32_STRHT_A2_A field Rt = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Rt=1, cond=0, Rn=0, U=0
    let encoding: u32 = 0x002010B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_strht_a2_a_field_rm_0_min_b0_002000b0() {
    // Encoding: 0x002000B0
    // Test aarch32_STRHT_A2_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: cond=0, U=0, Rn=0, Rt=0, Rm=0
    let encoding: u32 = 0x002000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_strht_a2_a_field_rm_1_poweroftwo_b0_002000b1() {
    // Encoding: 0x002000B1
    // Test aarch32_STRHT_A2_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=1, Rt=0, cond=0, U=0, Rn=0
    let encoding: u32 = 0x002000B1;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A2_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_strht_a2_a_combo_0_b0_002000b0() {
    // Encoding: 0x002000B0
    // Test aarch32_STRHT_A2_A field combination: cond=0, U=0, Rn=0, Rt=0, Rm=0
    // ISET: A32
    // Fields: Rt=0, Rn=0, Rm=0, cond=0, U=0
    let encoding: u32 = 0x002000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A2_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=1 (condition NE (not equal))
#[test]
fn test_aarch32_strht_a2_a_combo_1_b0_102000b0() {
    // Encoding: 0x102000B0
    // Test aarch32_STRHT_A2_A field combination: cond=1, U=0, Rn=0, Rt=0, Rm=0
    // ISET: A32
    // Fields: Rn=0, Rt=0, Rm=0, cond=1, U=0
    let encoding: u32 = 0x102000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A2_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=2 (condition CS/HS (carry set))
#[test]
fn test_aarch32_strht_a2_a_combo_2_b0_202000b0() {
    // Encoding: 0x202000B0
    // Test aarch32_STRHT_A2_A field combination: cond=2, U=0, Rn=0, Rt=0, Rm=0
    // ISET: A32
    // Fields: Rt=0, Rn=0, Rm=0, cond=2, U=0
    let encoding: u32 = 0x202000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A2_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=3 (condition CC/LO (carry clear))
#[test]
fn test_aarch32_strht_a2_a_combo_3_b0_302000b0() {
    // Encoding: 0x302000B0
    // Test aarch32_STRHT_A2_A field combination: cond=3, U=0, Rn=0, Rt=0, Rm=0
    // ISET: A32
    // Fields: Rt=0, U=0, Rm=0, Rn=0, cond=3
    let encoding: u32 = 0x302000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A2_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=4 (condition MI (minus/negative))
#[test]
fn test_aarch32_strht_a2_a_combo_4_b0_402000b0() {
    // Encoding: 0x402000B0
    // Test aarch32_STRHT_A2_A field combination: cond=4, U=0, Rn=0, Rt=0, Rm=0
    // ISET: A32
    // Fields: cond=4, Rn=0, U=0, Rm=0, Rt=0
    let encoding: u32 = 0x402000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A2_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=5 (condition PL (plus/positive))
#[test]
fn test_aarch32_strht_a2_a_combo_5_b0_502000b0() {
    // Encoding: 0x502000B0
    // Test aarch32_STRHT_A2_A field combination: cond=5, U=0, Rn=0, Rt=0, Rm=0
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=5, Rm=0, U=0
    let encoding: u32 = 0x502000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A2_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=6 (condition VS (overflow set))
#[test]
fn test_aarch32_strht_a2_a_combo_6_b0_602000b0() {
    // Encoding: 0x602000B0
    // Test aarch32_STRHT_A2_A field combination: cond=6, U=0, Rn=0, Rt=0, Rm=0
    // ISET: A32
    // Fields: Rm=0, Rn=0, U=0, cond=6, Rt=0
    let encoding: u32 = 0x602000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A2_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=7 (condition VC (overflow clear))
#[test]
fn test_aarch32_strht_a2_a_combo_7_b0_702000b0() {
    // Encoding: 0x702000B0
    // Test aarch32_STRHT_A2_A field combination: cond=7, U=0, Rn=0, Rt=0, Rm=0
    // ISET: A32
    // Fields: Rm=0, Rn=0, cond=7, U=0, Rt=0
    let encoding: u32 = 0x702000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A2_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=8 (condition HI (unsigned higher))
#[test]
fn test_aarch32_strht_a2_a_combo_8_b0_802000b0() {
    // Encoding: 0x802000B0
    // Test aarch32_STRHT_A2_A field combination: cond=8, U=0, Rn=0, Rt=0, Rm=0
    // ISET: A32
    // Fields: Rn=0, cond=8, U=0, Rt=0, Rm=0
    let encoding: u32 = 0x802000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A2_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=9 (condition LS (unsigned lower or same))
#[test]
fn test_aarch32_strht_a2_a_combo_9_b0_902000b0() {
    // Encoding: 0x902000B0
    // Test aarch32_STRHT_A2_A field combination: cond=9, U=0, Rn=0, Rt=0, Rm=0
    // ISET: A32
    // Fields: U=0, Rt=0, cond=9, Rm=0, Rn=0
    let encoding: u32 = 0x902000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A2_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=10 (condition GE (signed >=))
#[test]
fn test_aarch32_strht_a2_a_combo_10_b0_a02000b0() {
    // Encoding: 0xA02000B0
    // Test aarch32_STRHT_A2_A field combination: cond=10, U=0, Rn=0, Rt=0, Rm=0
    // ISET: A32
    // Fields: Rm=0, Rn=0, cond=10, U=0, Rt=0
    let encoding: u32 = 0xA02000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A2_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=11 (condition LT (signed <))
#[test]
fn test_aarch32_strht_a2_a_combo_11_b0_b02000b0() {
    // Encoding: 0xB02000B0
    // Test aarch32_STRHT_A2_A field combination: cond=11, U=0, Rn=0, Rt=0, Rm=0
    // ISET: A32
    // Fields: U=0, cond=11, Rn=0, Rm=0, Rt=0
    let encoding: u32 = 0xB02000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A2_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=12 (condition GT (signed >))
#[test]
fn test_aarch32_strht_a2_a_combo_12_b0_c02000b0() {
    // Encoding: 0xC02000B0
    // Test aarch32_STRHT_A2_A field combination: cond=12, U=0, Rn=0, Rt=0, Rm=0
    // ISET: A32
    // Fields: Rm=0, cond=12, U=0, Rt=0, Rn=0
    let encoding: u32 = 0xC02000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A2_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=13 (condition LE (signed <=))
#[test]
fn test_aarch32_strht_a2_a_combo_13_b0_d02000b0() {
    // Encoding: 0xD02000B0
    // Test aarch32_STRHT_A2_A field combination: cond=13, U=0, Rn=0, Rt=0, Rm=0
    // ISET: A32
    // Fields: cond=13, U=0, Rt=0, Rm=0, Rn=0
    let encoding: u32 = 0xD02000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A2_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=14 (condition AL (always))
#[test]
fn test_aarch32_strht_a2_a_combo_14_b0_e02000b0() {
    // Encoding: 0xE02000B0
    // Test aarch32_STRHT_A2_A field combination: cond=14, U=0, Rn=0, Rt=0, Rm=0
    // ISET: A32
    // Fields: Rm=0, Rn=0, cond=14, Rt=0, U=0
    let encoding: u32 = 0xE02000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A2_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=15 (condition NV (never, reserved))
#[test]
fn test_aarch32_strht_a2_a_combo_15_b0_f02000b0() {
    // Encoding: 0xF02000B0
    // Test aarch32_STRHT_A2_A field combination: cond=15, U=0, Rn=0, Rt=0, Rm=0
    // ISET: A32
    // Fields: Rm=0, Rt=0, cond=15, U=0, Rn=0
    let encoding: u32 = 0xF02000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A2_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=0 (minimum value)
#[test]
fn test_aarch32_strht_a2_a_combo_16_b0_002000b0() {
    // Encoding: 0x002000B0
    // Test aarch32_STRHT_A2_A field combination: cond=0, U=0, Rn=0, Rt=0, Rm=0
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=0, U=0, Rm=0
    let encoding: u32 = 0x002000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A2_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=1 (maximum value (1))
#[test]
fn test_aarch32_strht_a2_a_combo_17_b0_00a000b0() {
    // Encoding: 0x00A000B0
    // Test aarch32_STRHT_A2_A field combination: cond=0, U=1, Rn=0, Rt=0, Rm=0
    // ISET: A32
    // Fields: cond=0, U=1, Rn=0, Rt=0, Rm=0
    let encoding: u32 = 0x00A000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A2_A
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_strht_a2_a_combo_18_b0_002000b0() {
    // Encoding: 0x002000B0
    // Test aarch32_STRHT_A2_A field combination: cond=0, U=0, Rn=0, Rt=0, Rm=0
    // ISET: A32
    // Fields: cond=0, Rt=0, Rn=0, U=0, Rm=0
    let encoding: u32 = 0x002000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A2_A
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_strht_a2_a_combo_19_b0_002100b0() {
    // Encoding: 0x002100B0
    // Test aarch32_STRHT_A2_A field combination: cond=0, U=0, Rn=1, Rt=0, Rm=0
    // ISET: A32
    // Fields: Rn=1, U=0, cond=0, Rm=0, Rt=0
    let encoding: u32 = 0x002100B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A2_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_strht_a2_a_special_cond_0_condition_eq_176_002000b0() {
    // Encoding: 0x002000B0
    // Test aarch32_STRHT_A2_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: Rm=0, cond=0, U=0, Rt=0, Rn=0
    let encoding: u32 = 0x002000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A2_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_strht_a2_a_special_cond_1_condition_ne_176_102000b0() {
    // Encoding: 0x102000B0
    // Test aarch32_STRHT_A2_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: U=0, Rm=0, cond=1, Rn=0, Rt=0
    let encoding: u32 = 0x102000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A2_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_strht_a2_a_special_cond_2_condition_cs_hs_176_202000b0() {
    // Encoding: 0x202000B0
    // Test aarch32_STRHT_A2_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: Rt=0, cond=2, Rn=0, Rm=0, U=0
    let encoding: u32 = 0x202000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A2_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_strht_a2_a_special_cond_3_condition_cc_lo_176_302000b0() {
    // Encoding: 0x302000B0
    // Test aarch32_STRHT_A2_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: U=0, Rm=0, Rn=0, cond=3, Rt=0
    let encoding: u32 = 0x302000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A2_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_strht_a2_a_special_cond_4_condition_mi_176_402000b0() {
    // Encoding: 0x402000B0
    // Test aarch32_STRHT_A2_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: U=0, Rn=0, Rm=0, cond=4, Rt=0
    let encoding: u32 = 0x402000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A2_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_strht_a2_a_special_cond_5_condition_pl_176_502000b0() {
    // Encoding: 0x502000B0
    // Test aarch32_STRHT_A2_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: Rm=0, cond=5, Rn=0, U=0, Rt=0
    let encoding: u32 = 0x502000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A2_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_strht_a2_a_special_cond_6_condition_vs_176_602000b0() {
    // Encoding: 0x602000B0
    // Test aarch32_STRHT_A2_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: Rn=0, U=0, cond=6, Rt=0, Rm=0
    let encoding: u32 = 0x602000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A2_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_strht_a2_a_special_cond_7_condition_vc_176_702000b0() {
    // Encoding: 0x702000B0
    // Test aarch32_STRHT_A2_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: cond=7, Rn=0, Rm=0, Rt=0, U=0
    let encoding: u32 = 0x702000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A2_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_strht_a2_a_special_cond_8_condition_hi_176_802000b0() {
    // Encoding: 0x802000B0
    // Test aarch32_STRHT_A2_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: U=0, cond=8, Rt=0, Rm=0, Rn=0
    let encoding: u32 = 0x802000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A2_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_strht_a2_a_special_cond_9_condition_ls_176_902000b0() {
    // Encoding: 0x902000B0
    // Test aarch32_STRHT_A2_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: Rt=0, U=0, cond=9, Rn=0, Rm=0
    let encoding: u32 = 0x902000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A2_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_strht_a2_a_special_cond_10_condition_ge_176_a02000b0() {
    // Encoding: 0xA02000B0
    // Test aarch32_STRHT_A2_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: Rm=0, Rn=0, Rt=0, cond=10, U=0
    let encoding: u32 = 0xA02000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A2_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_strht_a2_a_special_cond_11_condition_lt_176_b02000b0() {
    // Encoding: 0xB02000B0
    // Test aarch32_STRHT_A2_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: Rn=0, Rm=0, cond=11, U=0, Rt=0
    let encoding: u32 = 0xB02000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A2_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_strht_a2_a_special_cond_12_condition_gt_176_c02000b0() {
    // Encoding: 0xC02000B0
    // Test aarch32_STRHT_A2_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: U=0, Rt=0, cond=12, Rn=0, Rm=0
    let encoding: u32 = 0xC02000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A2_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_strht_a2_a_special_cond_13_condition_le_176_d02000b0() {
    // Encoding: 0xD02000B0
    // Test aarch32_STRHT_A2_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: Rt=0, Rm=0, U=0, Rn=0, cond=13
    let encoding: u32 = 0xD02000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A2_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_strht_a2_a_special_cond_14_condition_al_176_e02000b0() {
    // Encoding: 0xE02000B0
    // Test aarch32_STRHT_A2_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: Rn=0, Rm=0, U=0, cond=14, Rt=0
    let encoding: u32 = 0xE02000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A2_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_strht_a2_a_special_cond_15_condition_nv_176_f02000b0() {
    // Encoding: 0xF02000B0
    // Test aarch32_STRHT_A2_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: Rm=0, cond=15, U=0, Rt=0, Rn=0
    let encoding: u32 = 0xF02000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STRHT_A2_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strht_a2_a_invalid_0_b0_002000b0() {
    // Encoding: 0x002000B0
    // Test aarch32_STRHT_A2_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }
    // ISET: A32
    // Fields: Rm=0, Rn=0, U=0, Rt=0, cond=0
    let encoding: u32 = 0x002000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STRHT_A2_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strht_a2_a_invalid_1_b0_002000b0() {
    // Encoding: 0x002000B0
    // Test aarch32_STRHT_A2_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: cond=0, U=0, Rt=0, Rn=0, Rm=0
    let encoding: u32 = 0x002000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STRHT_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_strht_t1_a_field_rn_0_min_e00_f8200e00() {
    // Thumb encoding (32): 0xF8200E00
    // Test aarch32_STRHT_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: imm8=0, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8200E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRHT_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_strht_t1_a_field_rn_1_poweroftwo_e00_f8210e00() {
    // Thumb encoding (32): 0xF8210E00
    // Test aarch32_STRHT_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, imm8=0, Rn=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8210E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRHT_T1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_strht_t1_a_field_rt_0_min_e00_f8200e00() {
    // Thumb encoding (32): 0xF8200E00
    // Test aarch32_STRHT_T1_A field Rt = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8200E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRHT_T1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_strht_t1_a_field_rt_1_poweroftwo_e00_f8201e00() {
    // Thumb encoding (32): 0xF8201E00
    // Test aarch32_STRHT_T1_A field Rt = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Rt=1, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8201E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRHT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_strht_t1_a_field_imm8_0_zero_e00_f8200e00() {
    // Thumb encoding (32): 0xF8200E00
    // Test aarch32_STRHT_T1_A field imm8 = 0 (Zero)
    // ISET: T32
    // Fields: Rt=0, imm8=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8200E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRHT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_strht_t1_a_field_imm8_1_poweroftwo_e00_f8200e01() {
    // Thumb encoding (32): 0xF8200E01
    // Test aarch32_STRHT_T1_A field imm8 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm8=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8200E01;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRHT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_strht_t1_a_field_imm8_3_poweroftwominusone_e00_f8200e03() {
    // Thumb encoding (32): 0xF8200E03
    // Test aarch32_STRHT_T1_A field imm8 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rt=0, imm8=3, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8200E03;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRHT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_strht_t1_a_field_imm8_4_poweroftwo_e00_f8200e04() {
    // Thumb encoding (32): 0xF8200E04
    // Test aarch32_STRHT_T1_A field imm8 = 4 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=4, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8200E04;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRHT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_strht_t1_a_field_imm8_7_poweroftwominusone_e00_f8200e07() {
    // Thumb encoding (32): 0xF8200E07
    // Test aarch32_STRHT_T1_A field imm8 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm8=7
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8200E07;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRHT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_strht_t1_a_field_imm8_8_poweroftwo_e00_f8200e08() {
    // Thumb encoding (32): 0xF8200E08
    // Test aarch32_STRHT_T1_A field imm8 = 8 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, imm8=8, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8200E08;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRHT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_strht_t1_a_field_imm8_15_poweroftwominusone_e00_f8200e0f() {
    // Thumb encoding (32): 0xF8200E0F
    // Test aarch32_STRHT_T1_A field imm8 = 15 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm8=15
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8200E0F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRHT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_strht_t1_a_field_imm8_16_poweroftwo_e00_f8200e10() {
    // Thumb encoding (32): 0xF8200E10
    // Test aarch32_STRHT_T1_A field imm8 = 16 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, imm8=16, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8200E10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRHT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_strht_t1_a_field_imm8_31_poweroftwominusone_e00_f8200e1f() {
    // Thumb encoding (32): 0xF8200E1F
    // Test aarch32_STRHT_T1_A field imm8 = 31 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm8=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8200E1F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRHT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_strht_t1_a_field_imm8_32_poweroftwo_e00_f8200e20() {
    // Thumb encoding (32): 0xF8200E20
    // Test aarch32_STRHT_T1_A field imm8 = 32 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, imm8=32, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8200E20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRHT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_strht_t1_a_field_imm8_63_poweroftwominusone_e00_f8200e3f() {
    // Thumb encoding (32): 0xF8200E3F
    // Test aarch32_STRHT_T1_A field imm8 = 63 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm8=63, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8200E3F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRHT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_strht_t1_a_field_imm8_64_poweroftwo_e00_f8200e40() {
    // Thumb encoding (32): 0xF8200E40
    // Test aarch32_STRHT_T1_A field imm8 = 64 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, Rn=0, imm8=64
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8200E40;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRHT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 127, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (127)
#[test]
fn test_aarch32_strht_t1_a_field_imm8_127_poweroftwominusone_e00_f8200e7f() {
    // Thumb encoding (32): 0xF8200E7F
    // Test aarch32_STRHT_T1_A field imm8 = 127 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, imm8=127, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8200E7F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRHT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_strht_t1_a_field_imm8_128_poweroftwo_e00_f8200e80() {
    // Thumb encoding (32): 0xF8200E80
    // Test aarch32_STRHT_T1_A field imm8 = 128 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=0, Rn=0, imm8=128
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8200E80;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRHT_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 255, boundary: Max }
/// maximum immediate (255)
#[test]
fn test_aarch32_strht_t1_a_field_imm8_255_max_e00_f8200eff() {
    // Thumb encoding (32): 0xF8200EFF
    // Test aarch32_STRHT_T1_A field imm8 = 255 (Max)
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm8=255
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8200EFF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRHT_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_strht_t1_a_combo_0_e00_f8200e00() {
    // Thumb encoding (32): 0xF8200E00
    // Test aarch32_STRHT_T1_A field combination: Rn=0, Rt=0, imm8=0
    // ISET: T32
    // Fields: Rt=0, imm8=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8200E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRHT_T1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_strht_t1_a_combo_1_e00_f8210e00() {
    // Thumb encoding (32): 0xF8210E00
    // Test aarch32_STRHT_T1_A field combination: Rn=1, Rt=0, imm8=0
    // ISET: T32
    // Fields: Rn=1, Rt=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8210E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRHT_T1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=0 (register index 0 (first register))
#[test]
fn test_aarch32_strht_t1_a_combo_2_e00_f8200e00() {
    // Thumb encoding (32): 0xF8200E00
    // Test aarch32_STRHT_T1_A field combination: Rn=0, Rt=0, imm8=0
    // ISET: T32
    // Fields: Rt=0, Rn=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8200E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRHT_T1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=1 (register index 1 (second register))
#[test]
fn test_aarch32_strht_t1_a_combo_3_e00_f8201e00() {
    // Thumb encoding (32): 0xF8201E00
    // Test aarch32_STRHT_T1_A field combination: Rn=0, Rt=1, imm8=0
    // ISET: T32
    // Fields: imm8=0, Rn=0, Rt=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8201E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRHT_T1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=0 (immediate value 0)
#[test]
fn test_aarch32_strht_t1_a_combo_4_e00_f8200e00() {
    // Thumb encoding (32): 0xF8200E00
    // Test aarch32_STRHT_T1_A field combination: Rn=0, Rt=0, imm8=0
    // ISET: T32
    // Fields: imm8=0, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8200E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRHT_T1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=1 (immediate value 1)
#[test]
fn test_aarch32_strht_t1_a_combo_5_e00_f8200e01() {
    // Thumb encoding (32): 0xF8200E01
    // Test aarch32_STRHT_T1_A field combination: Rn=0, Rt=0, imm8=1
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm8=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8200E01;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRHT_T1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=3 (2^2 - 1 = 3)
#[test]
fn test_aarch32_strht_t1_a_combo_6_e00_f8200e03() {
    // Thumb encoding (32): 0xF8200E03
    // Test aarch32_STRHT_T1_A field combination: Rn=0, Rt=0, imm8=3
    // ISET: T32
    // Fields: imm8=3, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8200E03;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRHT_T1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=4 (power of 2 (2^2 = 4))
#[test]
fn test_aarch32_strht_t1_a_combo_7_e00_f8200e04() {
    // Thumb encoding (32): 0xF8200E04
    // Test aarch32_STRHT_T1_A field combination: Rn=0, Rt=0, imm8=4
    // ISET: T32
    // Fields: Rn=0, imm8=4, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8200E04;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRHT_T1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=7 (2^3 - 1 = 7)
#[test]
fn test_aarch32_strht_t1_a_combo_8_e00_f8200e07() {
    // Thumb encoding (32): 0xF8200E07
    // Test aarch32_STRHT_T1_A field combination: Rn=0, Rt=0, imm8=7
    // ISET: T32
    // Fields: Rt=0, Rn=0, imm8=7
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8200E07;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRHT_T1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=8 (power of 2 (2^3 = 8))
#[test]
fn test_aarch32_strht_t1_a_combo_9_e00_f8200e08() {
    // Thumb encoding (32): 0xF8200E08
    // Test aarch32_STRHT_T1_A field combination: Rn=0, Rt=0, imm8=8
    // ISET: T32
    // Fields: imm8=8, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8200E08;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRHT_T1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=15 (2^4 - 1 = 15)
#[test]
fn test_aarch32_strht_t1_a_combo_10_e00_f8200e0f() {
    // Thumb encoding (32): 0xF8200E0F
    // Test aarch32_STRHT_T1_A field combination: Rn=0, Rt=0, imm8=15
    // ISET: T32
    // Fields: imm8=15, Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8200E0F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRHT_T1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=16 (power of 2 (2^4 = 16))
#[test]
fn test_aarch32_strht_t1_a_combo_11_e00_f8200e10() {
    // Thumb encoding (32): 0xF8200E10
    // Test aarch32_STRHT_T1_A field combination: Rn=0, Rt=0, imm8=16
    // ISET: T32
    // Fields: Rn=0, imm8=16, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8200E10;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRHT_T1_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=31 (2^5 - 1 = 31)
#[test]
fn test_aarch32_strht_t1_a_combo_12_e00_f8200e1f() {
    // Thumb encoding (32): 0xF8200E1F
    // Test aarch32_STRHT_T1_A field combination: Rn=0, Rt=0, imm8=31
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm8=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8200E1F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRHT_T1_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=32 (power of 2 (2^5 = 32))
#[test]
fn test_aarch32_strht_t1_a_combo_13_e00_f8200e20() {
    // Thumb encoding (32): 0xF8200E20
    // Test aarch32_STRHT_T1_A field combination: Rn=0, Rt=0, imm8=32
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm8=32
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8200E20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRHT_T1_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=63 (2^6 - 1 = 63)
#[test]
fn test_aarch32_strht_t1_a_combo_14_e00_f8200e3f() {
    // Thumb encoding (32): 0xF8200E3F
    // Test aarch32_STRHT_T1_A field combination: Rn=0, Rt=0, imm8=63
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm8=63
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8200E3F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRHT_T1_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=64 (power of 2 (2^6 = 64))
#[test]
fn test_aarch32_strht_t1_a_combo_15_e00_f8200e40() {
    // Thumb encoding (32): 0xF8200E40
    // Test aarch32_STRHT_T1_A field combination: Rn=0, Rt=0, imm8=64
    // ISET: T32
    // Fields: Rt=0, imm8=64, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8200E40;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRHT_T1_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=127 (immediate midpoint (127))
#[test]
fn test_aarch32_strht_t1_a_combo_16_e00_f8200e7f() {
    // Thumb encoding (32): 0xF8200E7F
    // Test aarch32_STRHT_T1_A field combination: Rn=0, Rt=0, imm8=127
    // ISET: T32
    // Fields: Rt=0, Rn=0, imm8=127
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8200E7F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRHT_T1_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=128 (power of 2 (2^7 = 128))
#[test]
fn test_aarch32_strht_t1_a_combo_17_e00_f8200e80() {
    // Thumb encoding (32): 0xF8200E80
    // Test aarch32_STRHT_T1_A field combination: Rn=0, Rt=0, imm8=128
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm8=128
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8200E80;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRHT_T1_A
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=255 (maximum immediate (255))
#[test]
fn test_aarch32_strht_t1_a_combo_18_e00_f8200eff() {
    // Thumb encoding (32): 0xF8200EFF
    // Test aarch32_STRHT_T1_A field combination: Rn=0, Rt=0, imm8=255
    // ISET: T32
    // Fields: Rt=0, imm8=255, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8200EFF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRHT_T1_A
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rt=1 (same register test (reg=1))
#[test]
fn test_aarch32_strht_t1_a_combo_19_e00_f8211e00() {
    // Thumb encoding (32): 0xF8211E00
    // Test aarch32_STRHT_T1_A field combination: Rn=1, Rt=1, imm8=0
    // ISET: T32
    // Fields: Rt=1, imm8=0, Rn=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8211E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STRHT_T1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rn" }), rhs: LitBits([true, true, true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Rn\" }), rhs: LitBits([true, true, true, true]) }" }
/// triggers Undefined
#[test]
fn test_aarch32_strht_t1_a_invalid_0_e00_f8200e00() {
    // Thumb encoding (32): 0xF8200E00
    // Test aarch32_STRHT_T1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rn" }), rhs: LitBits([true, true, true, true]) }
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8200E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_STRHT_T1_A
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch32_strht_t1_a_invalid_1_e00_f8200e00() {
    // Thumb encoding (32): 0xF8200E00
    // Test aarch32_STRHT_T1_A invalid encoding: Unconditional UNDEFINED
    // ISET: T32
    // Fields: Rn=0, imm8=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8200E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for T32 encoding");
}

/// Provenance: aarch32_STRHT_T1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strht_t1_a_invalid_2_e00_f8200e00() {
    // Thumb encoding (32): 0xF8200E00
    // Test aarch32_STRHT_T1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: LitInt(15) }
    // ISET: T32
    // Fields: Rn=0, Rt=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8200E00;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_STRHT_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strht_t1_a_invalid_3_e00_f8200e00() {
    // Thumb encoding (32): 0xF8200E00
    // Test aarch32_STRHT_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: imm8=0, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF8200E00;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_STRHT_A1_A
/// ASL: `UMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple multiply
#[test]
fn test_aarch32_strht_a1_a_umull_oracle_0_9ba27c20() {
    // Test UMULL: simple multiply (oracle)
    // Encoding: 0x9BA27C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3);
    set_w(&mut cpu, 1, 0x2);
    let encoding: u32 = 0x9BA27C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6, "X0 should be 0x0000000000000006");
}

/// Provenance: aarch32_STRHT_A1_A
/// ASL: `UMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max 32-bit * 2
#[test]
fn test_aarch32_strht_a1_a_umull_oracle_1_9ba27c20() {
    // Test UMULL: max 32-bit * 2 (oracle)
    // Encoding: 0x9BA27C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x9BA27C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFE, "X0 should be 0x00000001FFFFFFFE");
}

/// Provenance: aarch32_STRHT_A1_A
/// ASL: `UMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// large positive * large positive
#[test]
fn test_aarch32_strht_a1_a_umull_oracle_2_9ba27c20() {
    // Test UMULL: large positive * large positive (oracle)
    // Encoding: 0x9BA27C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x7FFFFFFF);
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x9BA27C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x3FFFFFFF00000001");
}

/// Provenance: aarch32_STRHT_A1_A
/// ASL: `UMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max unsigned * max unsigned
#[test]
fn test_aarch32_strht_a1_a_umull_oracle_3_9ba27c20() {
    // Test UMULL: max unsigned * max unsigned (oracle)
    // Encoding: 0x9BA27C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x9BA27C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0xFFFFFFFE00000001");
}

/// Provenance: aarch32_STRHT_A1_A
/// ASL: `UMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// medium values
#[test]
fn test_aarch32_strht_a1_a_umull_oracle_4_9ba27c20() {
    // Test UMULL: medium values (oracle)
    // Encoding: 0x9BA27C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0xC8);
    let encoding: u32 = 0x9BA27C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4E20, "X0 should be 0x0000000000004E20");
}

/// Provenance: aarch32_STRHT_A1_A
/// ASL: `UMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// 16-bit values
#[test]
fn test_aarch32_strht_a1_a_umull_oracle_5_9ba27c20() {
    // Test UMULL: 16-bit values (oracle)
    // Encoding: 0x9BA27C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1234);
    set_w(&mut cpu, 2, 0x5678);
    let encoding: u32 = 0x9BA27C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6260060, "X0 should be 0x0000000006260060");
}

/// Provenance: aarch32_STRHT_A1_A
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strht_a1_a_exception_0_006000b0() {
    // Test aarch32_STRHT_A1_A exception: Unpredictable
    // Encoding: 0x006000B0
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x006000B0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_STRHT_A2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple multiply (32)
#[test]
fn test_aarch32_strht_a2_a_mul_oracle_32_0_1b027c20() {
    // Test MUL 32-bit: simple multiply (oracle)
    // Encoding: 0x1B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3);
    set_w(&mut cpu, 1, 0x2);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6, "W0 should be 0x00000006");
}

/// Provenance: aarch32_STRHT_A2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple multiply (64)
#[test]
fn test_aarch32_strht_a2_a_mul_oracle_64_0_9b027c20() {
    // Test MUL 64-bit: simple multiply (oracle)
    // Encoding: 0x9B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x2);
    set_w(&mut cpu, 2, 0x3);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6, "X0 should be 0x0000000000000006");
}

/// Provenance: aarch32_STRHT_A2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// multiply by zero (32)
#[test]
fn test_aarch32_strht_a2_a_mul_oracle_32_1_1b027c20() {
    // Test MUL 32-bit: multiply by zero (oracle)
    // Encoding: 0x1B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x64);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_STRHT_A2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// multiply by zero (64)
#[test]
fn test_aarch32_strht_a2_a_mul_oracle_64_1_9b027c20() {
    // Test MUL 64-bit: multiply by zero (oracle)
    // Encoding: 0x9B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x64);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_STRHT_A2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// multiply by one (32)
#[test]
fn test_aarch32_strht_a2_a_mul_oracle_32_2_1b027c20() {
    // Test MUL 32-bit: multiply by one (oracle)
    // Encoding: 0x1B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_STRHT_A2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// multiply by one (64)
#[test]
fn test_aarch32_strht_a2_a_mul_oracle_64_2_9b027c20() {
    // Test MUL 64-bit: multiply by one (oracle)
    // Encoding: 0x9B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x0000000000000001");
}

/// Provenance: aarch32_STRHT_A2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// 16-bit max * 16-bit max (32)
#[test]
fn test_aarch32_strht_a2_a_mul_oracle_32_3_1b027c20() {
    // Test MUL 32-bit: 16-bit max * 16-bit max (oracle)
    // Encoding: 0x1B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFF);
    set_w(&mut cpu, 1, 0xFFFF);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFE0001, "W0 should be 0xFFFE0001");
}

/// Provenance: aarch32_STRHT_A2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// 16-bit max * 16-bit max (64)
#[test]
fn test_aarch32_strht_a2_a_mul_oracle_64_3_9b027c20() {
    // Test MUL 64-bit: 16-bit max * 16-bit max (oracle)
    // Encoding: 0x9B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFF);
    set_w(&mut cpu, 1, 0xFFFF);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFE0001, "X0 should be 0x00000000FFFE0001");
}

/// Provenance: aarch32_STRHT_A2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift-like multiply (32)
#[test]
fn test_aarch32_strht_a2_a_mul_oracle_32_4_1b027c20() {
    // Test MUL 32-bit: shift-like multiply (oracle)
    // Encoding: 0x1B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x2468ACF0, "W0 should be 0x2468ACF0");
}

/// Provenance: aarch32_STRHT_A2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift-like multiply (64)
#[test]
fn test_aarch32_strht_a2_a_mul_oracle_64_4_9b027c20() {
    // Test MUL 64-bit: shift-like multiply (oracle)
    // Encoding: 0x9B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x2468ACF0, "X0 should be 0x000000002468ACF0");
}

/// Provenance: aarch32_STRHT_A2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// larger values (32)
#[test]
fn test_aarch32_strht_a2_a_mul_oracle_32_5_1b027c20() {
    // Test MUL 32-bit: larger values (oracle)
    // Encoding: 0x1B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xC8);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4E20, "W0 should be 0x00004E20");
}

/// Provenance: aarch32_STRHT_A2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// larger values (64)
#[test]
fn test_aarch32_strht_a2_a_mul_oracle_64_5_9b027c20() {
    // Test MUL 64-bit: larger values (oracle)
    // Encoding: 0x9B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0xC8);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4E20, "X0 should be 0x0000000000004E20");
}

/// Provenance: aarch32_STRHT_A2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// 32-bit overflow (32)
#[test]
fn test_aarch32_strht_a2_a_mul_oracle_32_6_1b027c20() {
    // Test MUL 32-bit: 32-bit overflow (oracle)
    // Encoding: 0x1B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_STRHT_A2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// 32-bit overflow (64)
#[test]
fn test_aarch32_strht_a2_a_mul_oracle_64_6_9b027c20() {
    // Test MUL 64-bit: 32-bit overflow (oracle)
    // Encoding: 0x9B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0xFFFFFFFE00000001");
}

/// Provenance: aarch32_STRHT_A2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// prime numbers (32)
#[test]
fn test_aarch32_strht_a2_a_mul_oracle_32_7_1b027c20() {
    // Test MUL 32-bit: prime numbers (oracle)
    // Encoding: 0x1B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7);
    set_w(&mut cpu, 2, 0xB);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4D, "W0 should be 0x0000004D");
}

/// Provenance: aarch32_STRHT_A2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// prime numbers (64)
#[test]
fn test_aarch32_strht_a2_a_mul_oracle_64_7_9b027c20() {
    // Test MUL 64-bit: prime numbers (oracle)
    // Encoding: 0x9B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7);
    set_w(&mut cpu, 2, 0xB);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4D, "X0 should be 0x000000000000004D");
}

/// Provenance: aarch32_STRHT_A2_A
/// ASL: `MLA R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple values
#[test]
fn test_aarch32_strht_a2_a_a32_mul_0_0020f291() {
    // Test A32 MLA: simple values (oracle)
    // Encoding: 0x0020F291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x32);
    let encoding: u32 = 0x0020F291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1388, "R0 should be 0x00001388");
}

/// Provenance: aarch32_STRHT_A2_A
/// ASL: `MLA R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero values
#[test]
fn test_aarch32_strht_a2_a_a32_mul_1_0020f291() {
    // Test A32 MLA: zero values (oracle)
    // Encoding: 0x0020F291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x0020F291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_STRHT_A2_A
/// ASL: `MLA R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max value
#[test]
fn test_aarch32_strht_a2_a_a32_mul_2_0020f291() {
    // Test A32 MLA: max value (oracle)
    // Encoding: 0x0020F291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x0020F291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "R0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_STRHT_A2_A
/// ASL: `MLA R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set
#[test]
fn test_aarch32_strht_a2_a_a32_mul_3_0020f291() {
    // Test A32 MLA: MSB set (oracle)
    // Encoding: 0x0020F291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    set_w(&mut cpu, 2, 0x80000000);
    let encoding: u32 = 0x0020F291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_STRHT_A2_A
/// ASL: `MLA R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// mixed pattern
#[test]
fn test_aarch32_strht_a2_a_a32_mul_4_0020f291() {
    // Test A32 MLA: mixed pattern (oracle)
    // Encoding: 0x0020F291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x9ABCDEF0);
    let encoding: u32 = 0x0020F291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x242D2080, "R0 should be 0x242D2080");
}

/// Provenance: aarch32_STRHT_A2_A
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strht_a2_a_exception_0_002000b0() {
    // Test aarch32_STRHT_A2_A exception: Unpredictable
    // Encoding: 0x002000B0
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x002000B0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_STRHT_T1_A
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Unpredictable
#[test]
fn test_aarch32_strht_t1_a_exception_0_f8200e00() {
    // Test aarch32_STRHT_T1_A exception: Unpredictable
    // ISET: T32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF8200E00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// aarch32_STMDA_A Tests
// ============================================================================

/// Provenance: aarch32_STMDA_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_stmda_a1_a_field_cond_0_min_0_08000000() {
    // Encoding: 0x08000000
    // Test aarch32_STMDA_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, cond=0, W=0, register_list=0
    let encoding: u32 = 0x08000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDA_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_stmda_a1_a_field_cond_1_poweroftwo_0_18000000() {
    // Encoding: 0x18000000
    // Test aarch32_STMDA_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: register_list=0, cond=1, W=0, Rn=0
    let encoding: u32 = 0x18000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDA_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_stmda_a1_a_field_cond_2_poweroftwo_0_28000000() {
    // Encoding: 0x28000000
    // Test aarch32_STMDA_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, register_list=0, cond=2, Rn=0
    let encoding: u32 = 0x28000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDA_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_stmda_a1_a_field_cond_3_poweroftwo_0_38000000() {
    // Encoding: 0x38000000
    // Test aarch32_STMDA_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, Rn=0, register_list=0, cond=3
    let encoding: u32 = 0x38000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDA_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_stmda_a1_a_field_cond_4_poweroftwo_0_48000000() {
    // Encoding: 0x48000000
    // Test aarch32_STMDA_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=4, W=0, Rn=0, register_list=0
    let encoding: u32 = 0x48000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDA_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_stmda_a1_a_field_cond_5_poweroftwo_0_58000000() {
    // Encoding: 0x58000000
    // Test aarch32_STMDA_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: register_list=0, cond=5, Rn=0, W=0
    let encoding: u32 = 0x58000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDA_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_stmda_a1_a_field_cond_6_poweroftwo_0_68000000() {
    // Encoding: 0x68000000
    // Test aarch32_STMDA_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, register_list=0, cond=6, W=0
    let encoding: u32 = 0x68000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDA_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_stmda_a1_a_field_cond_7_poweroftwo_0_78000000() {
    // Encoding: 0x78000000
    // Test aarch32_STMDA_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, W=0, register_list=0, cond=7
    let encoding: u32 = 0x78000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDA_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_stmda_a1_a_field_cond_8_poweroftwo_0_88000000() {
    // Encoding: 0x88000000
    // Test aarch32_STMDA_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=8, W=0, Rn=0, register_list=0
    let encoding: u32 = 0x88000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDA_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_stmda_a1_a_field_cond_9_poweroftwo_0_98000000() {
    // Encoding: 0x98000000
    // Test aarch32_STMDA_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: register_list=0, W=0, cond=9, Rn=0
    let encoding: u32 = 0x98000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDA_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_stmda_a1_a_field_cond_10_poweroftwo_0_a8000000() {
    // Encoding: 0xA8000000
    // Test aarch32_STMDA_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, register_list=0, W=0, cond=10
    let encoding: u32 = 0xA8000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDA_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_stmda_a1_a_field_cond_11_poweroftwo_0_b8000000() {
    // Encoding: 0xB8000000
    // Test aarch32_STMDA_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, W=0, register_list=0, cond=11
    let encoding: u32 = 0xB8000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDA_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_stmda_a1_a_field_cond_12_poweroftwo_0_c8000000() {
    // Encoding: 0xC8000000
    // Test aarch32_STMDA_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=12, W=0, register_list=0, Rn=0
    let encoding: u32 = 0xC8000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDA_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_stmda_a1_a_field_cond_13_poweroftwo_0_d8000000() {
    // Encoding: 0xD8000000
    // Test aarch32_STMDA_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: register_list=0, cond=13, W=0, Rn=0
    let encoding: u32 = 0xD8000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDA_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_stmda_a1_a_field_cond_14_poweroftwo_0_e8000000() {
    // Encoding: 0xE8000000
    // Test aarch32_STMDA_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=14, Rn=0, W=0, register_list=0
    let encoding: u32 = 0xE8000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDA_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_stmda_a1_a_field_cond_15_max_0_f8000000() {
    // Encoding: 0xF8000000
    // Test aarch32_STMDA_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: cond=15, register_list=0, W=0, Rn=0
    let encoding: u32 = 0xF8000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDA_A1_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_stmda_a1_a_field_w_0_min_0_08000000() {
    // Encoding: 0x08000000
    // Test aarch32_STMDA_A1_A field W = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, cond=0, register_list=0, W=0
    let encoding: u32 = 0x08000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDA_A1_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_stmda_a1_a_field_w_1_max_0_08200000() {
    // Encoding: 0x08200000
    // Test aarch32_STMDA_A1_A field W = 1 (Max)
    // ISET: A32
    // Fields: register_list=0, Rn=0, W=1, cond=0
    let encoding: u32 = 0x08200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDA_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_stmda_a1_a_field_rn_0_min_0_08000000() {
    // Encoding: 0x08000000
    // Test aarch32_STMDA_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: register_list=0, W=0, Rn=0, cond=0
    let encoding: u32 = 0x08000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDA_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_stmda_a1_a_field_rn_1_poweroftwo_0_08010000() {
    // Encoding: 0x08010000
    // Test aarch32_STMDA_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, cond=0, Rn=1, register_list=0
    let encoding: u32 = 0x08010000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDA_A1_A
/// ASL: `field register_list 0 +: 16`
/// Requirement: FieldBoundary { field: "register_list", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_stmda_a1_a_field_register_list_0_min_0_08000000() {
    // Encoding: 0x08000000
    // Test aarch32_STMDA_A1_A field register_list = 0 (Min)
    // ISET: A32
    // Fields: cond=0, W=0, Rn=0, register_list=0
    let encoding: u32 = 0x08000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDA_A1_A
/// ASL: `field register_list 0 +: 16`
/// Requirement: FieldBoundary { field: "register_list", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_stmda_a1_a_field_register_list_1_poweroftwo_0_08000001() {
    // Encoding: 0x08000001
    // Test aarch32_STMDA_A1_A field register_list = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: register_list=1, cond=0, W=0, Rn=0
    let encoding: u32 = 0x08000001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDA_A1_A
/// ASL: `field register_list 0 +: 16`
/// Requirement: FieldBoundary { field: "register_list", value: 32767, boundary: PowerOfTwoMinusOne }
/// midpoint (32767)
#[test]
fn test_aarch32_stmda_a1_a_field_register_list_32767_poweroftwominusone_0_08007fff() {
    // Encoding: 0x08007FFF
    // Test aarch32_STMDA_A1_A field register_list = 32767 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: W=0, Rn=0, cond=0, register_list=32767
    let encoding: u32 = 0x08007FFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDA_A1_A
/// ASL: `field register_list 0 +: 16`
/// Requirement: FieldBoundary { field: "register_list", value: 65535, boundary: Max }
/// maximum value (65535)
#[test]
fn test_aarch32_stmda_a1_a_field_register_list_65535_max_0_0800ffff() {
    // Encoding: 0x0800FFFF
    // Test aarch32_STMDA_A1_A field register_list = 65535 (Max)
    // ISET: A32
    // Fields: Rn=0, W=0, cond=0, register_list=65535
    let encoding: u32 = 0x0800FFFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDA_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_stmda_a1_a_combo_0_0_08000000() {
    // Encoding: 0x08000000
    // Test aarch32_STMDA_A1_A field combination: cond=0, W=0, Rn=0, register_list=0
    // ISET: A32
    // Fields: W=0, Rn=0, register_list=0, cond=0
    let encoding: u32 = 0x08000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDA_A1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=1 (condition NE (not equal))
#[test]
fn test_aarch32_stmda_a1_a_combo_1_0_18000000() {
    // Encoding: 0x18000000
    // Test aarch32_STMDA_A1_A field combination: cond=1, W=0, Rn=0, register_list=0
    // ISET: A32
    // Fields: Rn=0, register_list=0, W=0, cond=1
    let encoding: u32 = 0x18000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDA_A1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=2 (condition CS/HS (carry set))
#[test]
fn test_aarch32_stmda_a1_a_combo_2_0_28000000() {
    // Encoding: 0x28000000
    // Test aarch32_STMDA_A1_A field combination: cond=2, W=0, Rn=0, register_list=0
    // ISET: A32
    // Fields: Rn=0, W=0, cond=2, register_list=0
    let encoding: u32 = 0x28000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDA_A1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=3 (condition CC/LO (carry clear))
#[test]
fn test_aarch32_stmda_a1_a_combo_3_0_38000000() {
    // Encoding: 0x38000000
    // Test aarch32_STMDA_A1_A field combination: cond=3, W=0, Rn=0, register_list=0
    // ISET: A32
    // Fields: Rn=0, register_list=0, W=0, cond=3
    let encoding: u32 = 0x38000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDA_A1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=4 (condition MI (minus/negative))
#[test]
fn test_aarch32_stmda_a1_a_combo_4_0_48000000() {
    // Encoding: 0x48000000
    // Test aarch32_STMDA_A1_A field combination: cond=4, W=0, Rn=0, register_list=0
    // ISET: A32
    // Fields: W=0, Rn=0, cond=4, register_list=0
    let encoding: u32 = 0x48000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDA_A1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=5 (condition PL (plus/positive))
#[test]
fn test_aarch32_stmda_a1_a_combo_5_0_58000000() {
    // Encoding: 0x58000000
    // Test aarch32_STMDA_A1_A field combination: cond=5, W=0, Rn=0, register_list=0
    // ISET: A32
    // Fields: Rn=0, cond=5, W=0, register_list=0
    let encoding: u32 = 0x58000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDA_A1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=6 (condition VS (overflow set))
#[test]
fn test_aarch32_stmda_a1_a_combo_6_0_68000000() {
    // Encoding: 0x68000000
    // Test aarch32_STMDA_A1_A field combination: cond=6, W=0, Rn=0, register_list=0
    // ISET: A32
    // Fields: W=0, register_list=0, cond=6, Rn=0
    let encoding: u32 = 0x68000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDA_A1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=7 (condition VC (overflow clear))
#[test]
fn test_aarch32_stmda_a1_a_combo_7_0_78000000() {
    // Encoding: 0x78000000
    // Test aarch32_STMDA_A1_A field combination: cond=7, W=0, Rn=0, register_list=0
    // ISET: A32
    // Fields: Rn=0, cond=7, register_list=0, W=0
    let encoding: u32 = 0x78000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDA_A1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=8 (condition HI (unsigned higher))
#[test]
fn test_aarch32_stmda_a1_a_combo_8_0_88000000() {
    // Encoding: 0x88000000
    // Test aarch32_STMDA_A1_A field combination: cond=8, W=0, Rn=0, register_list=0
    // ISET: A32
    // Fields: register_list=0, cond=8, Rn=0, W=0
    let encoding: u32 = 0x88000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDA_A1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=9 (condition LS (unsigned lower or same))
#[test]
fn test_aarch32_stmda_a1_a_combo_9_0_98000000() {
    // Encoding: 0x98000000
    // Test aarch32_STMDA_A1_A field combination: cond=9, W=0, Rn=0, register_list=0
    // ISET: A32
    // Fields: register_list=0, W=0, Rn=0, cond=9
    let encoding: u32 = 0x98000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDA_A1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=10 (condition GE (signed >=))
#[test]
fn test_aarch32_stmda_a1_a_combo_10_0_a8000000() {
    // Encoding: 0xA8000000
    // Test aarch32_STMDA_A1_A field combination: cond=10, W=0, Rn=0, register_list=0
    // ISET: A32
    // Fields: cond=10, register_list=0, W=0, Rn=0
    let encoding: u32 = 0xA8000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDA_A1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=11 (condition LT (signed <))
#[test]
fn test_aarch32_stmda_a1_a_combo_11_0_b8000000() {
    // Encoding: 0xB8000000
    // Test aarch32_STMDA_A1_A field combination: cond=11, W=0, Rn=0, register_list=0
    // ISET: A32
    // Fields: register_list=0, cond=11, W=0, Rn=0
    let encoding: u32 = 0xB8000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDA_A1_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=12 (condition GT (signed >))
#[test]
fn test_aarch32_stmda_a1_a_combo_12_0_c8000000() {
    // Encoding: 0xC8000000
    // Test aarch32_STMDA_A1_A field combination: cond=12, W=0, Rn=0, register_list=0
    // ISET: A32
    // Fields: W=0, register_list=0, cond=12, Rn=0
    let encoding: u32 = 0xC8000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDA_A1_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=13 (condition LE (signed <=))
#[test]
fn test_aarch32_stmda_a1_a_combo_13_0_d8000000() {
    // Encoding: 0xD8000000
    // Test aarch32_STMDA_A1_A field combination: cond=13, W=0, Rn=0, register_list=0
    // ISET: A32
    // Fields: cond=13, register_list=0, Rn=0, W=0
    let encoding: u32 = 0xD8000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDA_A1_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=14 (condition AL (always))
#[test]
fn test_aarch32_stmda_a1_a_combo_14_0_e8000000() {
    // Encoding: 0xE8000000
    // Test aarch32_STMDA_A1_A field combination: cond=14, W=0, Rn=0, register_list=0
    // ISET: A32
    // Fields: Rn=0, cond=14, W=0, register_list=0
    let encoding: u32 = 0xE8000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDA_A1_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=15 (condition NV (never, reserved))
#[test]
fn test_aarch32_stmda_a1_a_combo_15_0_f8000000() {
    // Encoding: 0xF8000000
    // Test aarch32_STMDA_A1_A field combination: cond=15, W=0, Rn=0, register_list=0
    // ISET: A32
    // Fields: cond=15, W=0, Rn=0, register_list=0
    let encoding: u32 = 0xF8000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDA_A1_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// W=0 (minimum value)
#[test]
fn test_aarch32_stmda_a1_a_combo_16_0_08000000() {
    // Encoding: 0x08000000
    // Test aarch32_STMDA_A1_A field combination: cond=0, W=0, Rn=0, register_list=0
    // ISET: A32
    // Fields: Rn=0, cond=0, W=0, register_list=0
    let encoding: u32 = 0x08000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDA_A1_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// W=1 (maximum value (1))
#[test]
fn test_aarch32_stmda_a1_a_combo_17_0_08200000() {
    // Encoding: 0x08200000
    // Test aarch32_STMDA_A1_A field combination: cond=0, W=1, Rn=0, register_list=0
    // ISET: A32
    // Fields: W=1, Rn=0, register_list=0, cond=0
    let encoding: u32 = 0x08200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDA_A1_A
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_stmda_a1_a_combo_18_0_08000000() {
    // Encoding: 0x08000000
    // Test aarch32_STMDA_A1_A field combination: cond=0, W=0, Rn=0, register_list=0
    // ISET: A32
    // Fields: W=0, cond=0, Rn=0, register_list=0
    let encoding: u32 = 0x08000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDA_A1_A
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_stmda_a1_a_combo_19_0_08010000() {
    // Encoding: 0x08010000
    // Test aarch32_STMDA_A1_A field combination: cond=0, W=0, Rn=1, register_list=0
    // ISET: A32
    // Fields: cond=0, W=0, register_list=0, Rn=1
    let encoding: u32 = 0x08010000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDA_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_stmda_a1_a_special_cond_0_condition_eq_0_08000000() {
    // Encoding: 0x08000000
    // Test aarch32_STMDA_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: Rn=0, W=0, cond=0, register_list=0
    let encoding: u32 = 0x08000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDA_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_stmda_a1_a_special_cond_1_condition_ne_0_18000000() {
    // Encoding: 0x18000000
    // Test aarch32_STMDA_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: Rn=0, cond=1, W=0, register_list=0
    let encoding: u32 = 0x18000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDA_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_stmda_a1_a_special_cond_2_condition_cs_hs_0_28000000() {
    // Encoding: 0x28000000
    // Test aarch32_STMDA_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: W=0, cond=2, Rn=0, register_list=0
    let encoding: u32 = 0x28000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDA_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_stmda_a1_a_special_cond_3_condition_cc_lo_0_38000000() {
    // Encoding: 0x38000000
    // Test aarch32_STMDA_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: register_list=0, cond=3, W=0, Rn=0
    let encoding: u32 = 0x38000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDA_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_stmda_a1_a_special_cond_4_condition_mi_0_48000000() {
    // Encoding: 0x48000000
    // Test aarch32_STMDA_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: W=0, Rn=0, cond=4, register_list=0
    let encoding: u32 = 0x48000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDA_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_stmda_a1_a_special_cond_5_condition_pl_0_58000000() {
    // Encoding: 0x58000000
    // Test aarch32_STMDA_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: cond=5, W=0, Rn=0, register_list=0
    let encoding: u32 = 0x58000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDA_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_stmda_a1_a_special_cond_6_condition_vs_0_68000000() {
    // Encoding: 0x68000000
    // Test aarch32_STMDA_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: cond=6, Rn=0, register_list=0, W=0
    let encoding: u32 = 0x68000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDA_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_stmda_a1_a_special_cond_7_condition_vc_0_78000000() {
    // Encoding: 0x78000000
    // Test aarch32_STMDA_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: W=0, Rn=0, register_list=0, cond=7
    let encoding: u32 = 0x78000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDA_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_stmda_a1_a_special_cond_8_condition_hi_0_88000000() {
    // Encoding: 0x88000000
    // Test aarch32_STMDA_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: cond=8, W=0, Rn=0, register_list=0
    let encoding: u32 = 0x88000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDA_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_stmda_a1_a_special_cond_9_condition_ls_0_98000000() {
    // Encoding: 0x98000000
    // Test aarch32_STMDA_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: register_list=0, W=0, Rn=0, cond=9
    let encoding: u32 = 0x98000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDA_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_stmda_a1_a_special_cond_10_condition_ge_0_a8000000() {
    // Encoding: 0xA8000000
    // Test aarch32_STMDA_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: W=0, Rn=0, register_list=0, cond=10
    let encoding: u32 = 0xA8000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDA_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_stmda_a1_a_special_cond_11_condition_lt_0_b8000000() {
    // Encoding: 0xB8000000
    // Test aarch32_STMDA_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: W=0, Rn=0, register_list=0, cond=11
    let encoding: u32 = 0xB8000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDA_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_stmda_a1_a_special_cond_12_condition_gt_0_c8000000() {
    // Encoding: 0xC8000000
    // Test aarch32_STMDA_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: W=0, cond=12, Rn=0, register_list=0
    let encoding: u32 = 0xC8000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDA_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_stmda_a1_a_special_cond_13_condition_le_0_d8000000() {
    // Encoding: 0xD8000000
    // Test aarch32_STMDA_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: cond=13, Rn=0, register_list=0, W=0
    let encoding: u32 = 0xD8000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDA_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_stmda_a1_a_special_cond_14_condition_al_0_e8000000() {
    // Encoding: 0xE8000000
    // Test aarch32_STMDA_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: W=0, cond=14, Rn=0, register_list=0
    let encoding: u32 = 0xE8000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDA_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_stmda_a1_a_special_cond_15_condition_nv_0_f8000000() {
    // Encoding: 0xF8000000
    // Test aarch32_STMDA_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: cond=15, Rn=0, register_list=0, W=0
    let encoding: u32 = 0xF8000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDA_A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Binary { op: Lt, lhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "BitCount" }, args: [Var(QualifiedIdentifier { qualifier: Any, name: "registers" })] }, rhs: LitInt(1) } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Binary { op: Lt, lhs: Call { name: QualifiedIdentifier { qualifier: Any, name: \"BitCount\" }, args: [Var(QualifiedIdentifier { qualifier: Any, name: \"registers\" })] }, rhs: LitInt(1) } } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_stmda_a1_a_invalid_0_0_08000000() {
    // Encoding: 0x08000000
    // Test aarch32_STMDA_A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Binary { op: Lt, lhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "BitCount" }, args: [Var(QualifiedIdentifier { qualifier: Any, name: "registers" })] }, rhs: LitInt(1) } } }
    // ISET: A32
    // Fields: Rn=0, cond=0, register_list=0, W=0
    let encoding: u32 = 0x08000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STMDA_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_stmda_a1_a_invalid_1_0_08000000() {
    // Encoding: 0x08000000
    // Test aarch32_STMDA_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: cond=0, register_list=0, Rn=0, W=0
    let encoding: u32 = 0x08000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STMDA_A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_stmda_a1_a_store_0_08010000() {
    // Test aarch32_STMDA_A1_A memory store: 8 bytes
    // Encoding: 0x08010000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0x08010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_STMDA_A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_stmda_a1_a_store_1_08010000() {
    // Test aarch32_STMDA_A1_A memory store: 8 bytes
    // Encoding: 0x08010000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x08010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_STMDA_A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_stmda_a1_a_store_2_08010000() {
    // Test aarch32_STMDA_A1_A memory store: 8 bytes
    // Encoding: 0x08010000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0x08010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// aarch32_STL_A Tests
// ============================================================================

/// Provenance: aarch32_STL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_stl_a1_a_field_cond_0_min_90_01800090() {
    // Encoding: 0x01800090
    // Test aarch32_STL_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: Rt=0, cond=0, Rn=0
    let encoding: u32 = 0x01800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_stl_a1_a_field_cond_1_poweroftwo_90_11800090() {
    // Encoding: 0x11800090
    // Test aarch32_STL_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=1
    let encoding: u32 = 0x11800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_stl_a1_a_field_cond_2_poweroftwo_90_21800090() {
    // Encoding: 0x21800090
    // Test aarch32_STL_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=2
    let encoding: u32 = 0x21800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_stl_a1_a_field_cond_3_poweroftwo_90_31800090() {
    // Encoding: 0x31800090
    // Test aarch32_STL_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=3
    let encoding: u32 = 0x31800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_stl_a1_a_field_cond_4_poweroftwo_90_41800090() {
    // Encoding: 0x41800090
    // Test aarch32_STL_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, Rn=0, cond=4
    let encoding: u32 = 0x41800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_stl_a1_a_field_cond_5_poweroftwo_90_51800090() {
    // Encoding: 0x51800090
    // Test aarch32_STL_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, Rn=0, cond=5
    let encoding: u32 = 0x51800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_stl_a1_a_field_cond_6_poweroftwo_90_61800090() {
    // Encoding: 0x61800090
    // Test aarch32_STL_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=6, Rt=0
    let encoding: u32 = 0x61800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_stl_a1_a_field_cond_7_poweroftwo_90_71800090() {
    // Encoding: 0x71800090
    // Test aarch32_STL_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=7, Rt=0
    let encoding: u32 = 0x71800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_stl_a1_a_field_cond_8_poweroftwo_90_81800090() {
    // Encoding: 0x81800090
    // Test aarch32_STL_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=8, Rt=0
    let encoding: u32 = 0x81800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_stl_a1_a_field_cond_9_poweroftwo_90_91800090() {
    // Encoding: 0x91800090
    // Test aarch32_STL_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=9
    let encoding: u32 = 0x91800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_stl_a1_a_field_cond_10_poweroftwo_90_a1800090() {
    // Encoding: 0xA1800090
    // Test aarch32_STL_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=10, Rt=0
    let encoding: u32 = 0xA1800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_stl_a1_a_field_cond_11_poweroftwo_90_b1800090() {
    // Encoding: 0xB1800090
    // Test aarch32_STL_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=11, Rn=0, Rt=0
    let encoding: u32 = 0xB1800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_stl_a1_a_field_cond_12_poweroftwo_90_c1800090() {
    // Encoding: 0xC1800090
    // Test aarch32_STL_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=12
    let encoding: u32 = 0xC1800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_stl_a1_a_field_cond_13_poweroftwo_90_d1800090() {
    // Encoding: 0xD1800090
    // Test aarch32_STL_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=13
    let encoding: u32 = 0xD1800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_stl_a1_a_field_cond_14_poweroftwo_90_e1800090() {
    // Encoding: 0xE1800090
    // Test aarch32_STL_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=14, Rt=0, Rn=0
    let encoding: u32 = 0xE1800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_stl_a1_a_field_cond_15_max_90_f1800090() {
    // Encoding: 0xF1800090
    // Test aarch32_STL_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: Rt=0, cond=15, Rn=0
    let encoding: u32 = 0xF1800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STL_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_stl_a1_a_field_rn_0_min_90_01800090() {
    // Encoding: 0x01800090
    // Test aarch32_STL_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=0
    let encoding: u32 = 0x01800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STL_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_stl_a1_a_field_rn_1_poweroftwo_90_01810090() {
    // Encoding: 0x01810090
    // Test aarch32_STL_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Rn=1, Rt=0
    let encoding: u32 = 0x01810090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STL_A1_A
/// ASL: `field Rt 0 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_stl_a1_a_field_rt_0_min_90_01800090() {
    // Encoding: 0x01800090
    // Test aarch32_STL_A1_A field Rt = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=0
    let encoding: u32 = 0x01800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STL_A1_A
/// ASL: `field Rt 0 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_stl_a1_a_field_rt_1_poweroftwo_90_01800091() {
    // Encoding: 0x01800091
    // Test aarch32_STL_A1_A field Rt = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rt=1, cond=0
    let encoding: u32 = 0x01800091;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STL_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_stl_a1_a_combo_0_90_01800090() {
    // Encoding: 0x01800090
    // Test aarch32_STL_A1_A field combination: cond=0, Rn=0, Rt=0
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=0
    let encoding: u32 = 0x01800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STL_A1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=1 (condition NE (not equal))
#[test]
fn test_aarch32_stl_a1_a_combo_1_90_11800090() {
    // Encoding: 0x11800090
    // Test aarch32_STL_A1_A field combination: cond=1, Rn=0, Rt=0
    // ISET: A32
    // Fields: Rt=0, cond=1, Rn=0
    let encoding: u32 = 0x11800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STL_A1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=2 (condition CS/HS (carry set))
#[test]
fn test_aarch32_stl_a1_a_combo_2_90_21800090() {
    // Encoding: 0x21800090
    // Test aarch32_STL_A1_A field combination: cond=2, Rn=0, Rt=0
    // ISET: A32
    // Fields: Rn=0, cond=2, Rt=0
    let encoding: u32 = 0x21800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STL_A1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=3 (condition CC/LO (carry clear))
#[test]
fn test_aarch32_stl_a1_a_combo_3_90_31800090() {
    // Encoding: 0x31800090
    // Test aarch32_STL_A1_A field combination: cond=3, Rn=0, Rt=0
    // ISET: A32
    // Fields: Rn=0, cond=3, Rt=0
    let encoding: u32 = 0x31800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STL_A1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=4 (condition MI (minus/negative))
#[test]
fn test_aarch32_stl_a1_a_combo_4_90_41800090() {
    // Encoding: 0x41800090
    // Test aarch32_STL_A1_A field combination: cond=4, Rn=0, Rt=0
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=4
    let encoding: u32 = 0x41800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STL_A1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=5 (condition PL (plus/positive))
#[test]
fn test_aarch32_stl_a1_a_combo_5_90_51800090() {
    // Encoding: 0x51800090
    // Test aarch32_STL_A1_A field combination: cond=5, Rn=0, Rt=0
    // ISET: A32
    // Fields: cond=5, Rn=0, Rt=0
    let encoding: u32 = 0x51800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STL_A1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=6 (condition VS (overflow set))
#[test]
fn test_aarch32_stl_a1_a_combo_6_90_61800090() {
    // Encoding: 0x61800090
    // Test aarch32_STL_A1_A field combination: cond=6, Rn=0, Rt=0
    // ISET: A32
    // Fields: Rt=0, Rn=0, cond=6
    let encoding: u32 = 0x61800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STL_A1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=7 (condition VC (overflow clear))
#[test]
fn test_aarch32_stl_a1_a_combo_7_90_71800090() {
    // Encoding: 0x71800090
    // Test aarch32_STL_A1_A field combination: cond=7, Rn=0, Rt=0
    // ISET: A32
    // Fields: Rt=0, cond=7, Rn=0
    let encoding: u32 = 0x71800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STL_A1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=8 (condition HI (unsigned higher))
#[test]
fn test_aarch32_stl_a1_a_combo_8_90_81800090() {
    // Encoding: 0x81800090
    // Test aarch32_STL_A1_A field combination: cond=8, Rn=0, Rt=0
    // ISET: A32
    // Fields: Rt=0, cond=8, Rn=0
    let encoding: u32 = 0x81800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STL_A1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=9 (condition LS (unsigned lower or same))
#[test]
fn test_aarch32_stl_a1_a_combo_9_90_91800090() {
    // Encoding: 0x91800090
    // Test aarch32_STL_A1_A field combination: cond=9, Rn=0, Rt=0
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=9
    let encoding: u32 = 0x91800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STL_A1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=10 (condition GE (signed >=))
#[test]
fn test_aarch32_stl_a1_a_combo_10_90_a1800090() {
    // Encoding: 0xA1800090
    // Test aarch32_STL_A1_A field combination: cond=10, Rn=0, Rt=0
    // ISET: A32
    // Fields: cond=10, Rn=0, Rt=0
    let encoding: u32 = 0xA1800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STL_A1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=11 (condition LT (signed <))
#[test]
fn test_aarch32_stl_a1_a_combo_11_90_b1800090() {
    // Encoding: 0xB1800090
    // Test aarch32_STL_A1_A field combination: cond=11, Rn=0, Rt=0
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=11
    let encoding: u32 = 0xB1800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STL_A1_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=12 (condition GT (signed >))
#[test]
fn test_aarch32_stl_a1_a_combo_12_90_c1800090() {
    // Encoding: 0xC1800090
    // Test aarch32_STL_A1_A field combination: cond=12, Rn=0, Rt=0
    // ISET: A32
    // Fields: cond=12, Rt=0, Rn=0
    let encoding: u32 = 0xC1800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STL_A1_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=13 (condition LE (signed <=))
#[test]
fn test_aarch32_stl_a1_a_combo_13_90_d1800090() {
    // Encoding: 0xD1800090
    // Test aarch32_STL_A1_A field combination: cond=13, Rn=0, Rt=0
    // ISET: A32
    // Fields: Rn=0, cond=13, Rt=0
    let encoding: u32 = 0xD1800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STL_A1_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=14 (condition AL (always))
#[test]
fn test_aarch32_stl_a1_a_combo_14_90_e1800090() {
    // Encoding: 0xE1800090
    // Test aarch32_STL_A1_A field combination: cond=14, Rn=0, Rt=0
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=14
    let encoding: u32 = 0xE1800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STL_A1_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=15 (condition NV (never, reserved))
#[test]
fn test_aarch32_stl_a1_a_combo_15_90_f1800090() {
    // Encoding: 0xF1800090
    // Test aarch32_STL_A1_A field combination: cond=15, Rn=0, Rt=0
    // ISET: A32
    // Fields: cond=15, Rt=0, Rn=0
    let encoding: u32 = 0xF1800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STL_A1_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_stl_a1_a_combo_16_90_01800090() {
    // Encoding: 0x01800090
    // Test aarch32_STL_A1_A field combination: cond=0, Rn=0, Rt=0
    // ISET: A32
    // Fields: cond=0, Rn=0, Rt=0
    let encoding: u32 = 0x01800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STL_A1_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_stl_a1_a_combo_17_90_01810090() {
    // Encoding: 0x01810090
    // Test aarch32_STL_A1_A field combination: cond=0, Rn=1, Rt=0
    // ISET: A32
    // Fields: cond=0, Rt=0, Rn=1
    let encoding: u32 = 0x01810090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STL_A1_A
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=0 (register index 0 (first register))
#[test]
fn test_aarch32_stl_a1_a_combo_18_90_01800090() {
    // Encoding: 0x01800090
    // Test aarch32_STL_A1_A field combination: cond=0, Rn=0, Rt=0
    // ISET: A32
    // Fields: cond=0, Rn=0, Rt=0
    let encoding: u32 = 0x01800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STL_A1_A
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=1 (register index 1 (second register))
#[test]
fn test_aarch32_stl_a1_a_combo_19_90_01800091() {
    // Encoding: 0x01800091
    // Test aarch32_STL_A1_A field combination: cond=0, Rn=0, Rt=1
    // ISET: A32
    // Fields: Rn=0, Rt=1, cond=0
    let encoding: u32 = 0x01800091;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STL_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_stl_a1_a_special_cond_0_condition_eq_144_01800090() {
    // Encoding: 0x01800090
    // Test aarch32_STL_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: Rt=0, Rn=0, cond=0
    let encoding: u32 = 0x01800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STL_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_stl_a1_a_special_cond_1_condition_ne_144_11800090() {
    // Encoding: 0x11800090
    // Test aarch32_STL_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: cond=1, Rn=0, Rt=0
    let encoding: u32 = 0x11800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STL_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_stl_a1_a_special_cond_2_condition_cs_hs_144_21800090() {
    // Encoding: 0x21800090
    // Test aarch32_STL_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: Rn=0, cond=2, Rt=0
    let encoding: u32 = 0x21800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STL_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_stl_a1_a_special_cond_3_condition_cc_lo_144_31800090() {
    // Encoding: 0x31800090
    // Test aarch32_STL_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: cond=3, Rn=0, Rt=0
    let encoding: u32 = 0x31800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STL_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_stl_a1_a_special_cond_4_condition_mi_144_41800090() {
    // Encoding: 0x41800090
    // Test aarch32_STL_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: cond=4, Rn=0, Rt=0
    let encoding: u32 = 0x41800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STL_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_stl_a1_a_special_cond_5_condition_pl_144_51800090() {
    // Encoding: 0x51800090
    // Test aarch32_STL_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: Rt=0, Rn=0, cond=5
    let encoding: u32 = 0x51800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STL_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_stl_a1_a_special_cond_6_condition_vs_144_61800090() {
    // Encoding: 0x61800090
    // Test aarch32_STL_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: Rt=0, Rn=0, cond=6
    let encoding: u32 = 0x61800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STL_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_stl_a1_a_special_cond_7_condition_vc_144_71800090() {
    // Encoding: 0x71800090
    // Test aarch32_STL_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: Rn=0, cond=7, Rt=0
    let encoding: u32 = 0x71800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STL_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_stl_a1_a_special_cond_8_condition_hi_144_81800090() {
    // Encoding: 0x81800090
    // Test aarch32_STL_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: Rn=0, cond=8, Rt=0
    let encoding: u32 = 0x81800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STL_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_stl_a1_a_special_cond_9_condition_ls_144_91800090() {
    // Encoding: 0x91800090
    // Test aarch32_STL_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: Rt=0, Rn=0, cond=9
    let encoding: u32 = 0x91800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STL_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_stl_a1_a_special_cond_10_condition_ge_144_a1800090() {
    // Encoding: 0xA1800090
    // Test aarch32_STL_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=10
    let encoding: u32 = 0xA1800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STL_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_stl_a1_a_special_cond_11_condition_lt_144_b1800090() {
    // Encoding: 0xB1800090
    // Test aarch32_STL_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: cond=11, Rn=0, Rt=0
    let encoding: u32 = 0xB1800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STL_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_stl_a1_a_special_cond_12_condition_gt_144_c1800090() {
    // Encoding: 0xC1800090
    // Test aarch32_STL_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: cond=12, Rt=0, Rn=0
    let encoding: u32 = 0xC1800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STL_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_stl_a1_a_special_cond_13_condition_le_144_d1800090() {
    // Encoding: 0xD1800090
    // Test aarch32_STL_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: cond=13, Rn=0, Rt=0
    let encoding: u32 = 0xD1800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STL_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_stl_a1_a_special_cond_14_condition_al_144_e1800090() {
    // Encoding: 0xE1800090
    // Test aarch32_STL_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: cond=14, Rn=0, Rt=0
    let encoding: u32 = 0xE1800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STL_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_stl_a1_a_special_cond_15_condition_nv_144_f1800090() {
    // Encoding: 0xF1800090
    // Test aarch32_STL_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: cond=15, Rt=0, Rn=0
    let encoding: u32 = 0xF1800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STL_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_stl_a1_a_invalid_0_90_01800090() {
    // Encoding: 0x01800090
    // Test aarch32_STL_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }
    // ISET: A32
    // Fields: Rt=0, cond=0, Rn=0
    let encoding: u32 = 0x01800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STL_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_stl_a1_a_invalid_1_90_01800090() {
    // Encoding: 0x01800090
    // Test aarch32_STL_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Rn=0, cond=0, Rt=0
    let encoding: u32 = 0x01800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STL_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_stl_t1_a_field_rn_0_min_a0_e8c000a0() {
    // Thumb encoding (32): 0xE8C000A0
    // Test aarch32_STL_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C000A0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STL_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_stl_t1_a_field_rn_1_poweroftwo_a0_e8c100a0() {
    // Thumb encoding (32): 0xE8C100A0
    // Test aarch32_STL_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=1, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C100A0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STL_T1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_stl_t1_a_field_rt_0_min_a0_e8c000a0() {
    // Thumb encoding (32): 0xE8C000A0
    // Test aarch32_STL_T1_A field Rt = 0 (Min)
    // ISET: T32
    // Fields: Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C000A0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STL_T1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_stl_t1_a_field_rt_1_poweroftwo_a0_e8c010a0() {
    // Thumb encoding (32): 0xE8C010A0
    // Test aarch32_STL_T1_A field Rt = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt=1, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C010A0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STL_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_stl_t1_a_combo_0_a0_e8c000a0() {
    // Thumb encoding (32): 0xE8C000A0
    // Test aarch32_STL_T1_A field combination: Rn=0, Rt=0
    // ISET: T32
    // Fields: Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C000A0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STL_T1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_stl_t1_a_combo_1_a0_e8c100a0() {
    // Thumb encoding (32): 0xE8C100A0
    // Test aarch32_STL_T1_A field combination: Rn=1, Rt=0
    // ISET: T32
    // Fields: Rn=1, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C100A0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STL_T1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=0 (register index 0 (first register))
#[test]
fn test_aarch32_stl_t1_a_combo_2_a0_e8c000a0() {
    // Thumb encoding (32): 0xE8C000A0
    // Test aarch32_STL_T1_A field combination: Rn=0, Rt=0
    // ISET: T32
    // Fields: Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C000A0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STL_T1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=1 (register index 1 (second register))
#[test]
fn test_aarch32_stl_t1_a_combo_3_a0_e8c010a0() {
    // Thumb encoding (32): 0xE8C010A0
    // Test aarch32_STL_T1_A field combination: Rn=0, Rt=1
    // ISET: T32
    // Fields: Rn=0, Rt=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C010A0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STL_T1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rt=1 (same register test (reg=1))
#[test]
fn test_aarch32_stl_t1_a_combo_4_a0_e8c110a0() {
    // Thumb encoding (32): 0xE8C110A0
    // Test aarch32_STL_T1_A field combination: Rn=1, Rt=1
    // ISET: T32
    // Fields: Rt=1, Rn=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C110A0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STL_T1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rt=31 (same register test (reg=31))
#[test]
fn test_aarch32_stl_t1_a_combo_5_a0_e8cff0a0() {
    // Thumb encoding (32): 0xE8CFF0A0
    // Test aarch32_STL_T1_A field combination: Rn=31, Rt=31
    // ISET: T32
    // Fields: Rn=31, Rt=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8CFF0A0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STL_T1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_stl_t1_a_invalid_0_a0_e8c000a0() {
    // Thumb encoding (32): 0xE8C000A0
    // Test aarch32_STL_T1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }
    // ISET: T32
    // Fields: Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C000A0;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_STL_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_stl_t1_a_invalid_1_a0_e8c000a0() {
    // Thumb encoding (32): 0xE8C000A0
    // Test aarch32_STL_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C000A0;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_STL_A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_stl_a1_a_store_0_01810090() {
    // Test aarch32_STL_A1_A memory store: 8 bytes
    // Encoding: 0x01810090
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x01810090;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_STL_T1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_stl_t1_a_store_0_e8c100a0() {
    // Test aarch32_STL_T1_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0xE8C100A0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// aarch32_STLEXD_A Tests
// ============================================================================

/// Provenance: aarch32_STLEXD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_stlexd_a1_a_field_cond_0_min_290_01a00290() {
    // Encoding: 0x01A00290
    // Test aarch32_STLEXD_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rt=0, Rn=0, Rd=0
    let encoding: u32 = 0x01A00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_stlexd_a1_a_field_cond_1_poweroftwo_290_11a00290() {
    // Encoding: 0x11A00290
    // Test aarch32_STLEXD_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=1, Rt=0, Rn=0, Rd=0
    let encoding: u32 = 0x11A00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_stlexd_a1_a_field_cond_2_poweroftwo_290_21a00290() {
    // Encoding: 0x21A00290
    // Test aarch32_STLEXD_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=2, Rn=0, Rd=0, Rt=0
    let encoding: u32 = 0x21A00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_stlexd_a1_a_field_cond_3_poweroftwo_290_31a00290() {
    // Encoding: 0x31A00290
    // Test aarch32_STLEXD_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rt=0, cond=3, Rn=0
    let encoding: u32 = 0x31A00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_stlexd_a1_a_field_cond_4_poweroftwo_290_41a00290() {
    // Encoding: 0x41A00290
    // Test aarch32_STLEXD_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rd=0, Rt=0, cond=4
    let encoding: u32 = 0x41A00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_stlexd_a1_a_field_cond_5_poweroftwo_290_51a00290() {
    // Encoding: 0x51A00290
    // Test aarch32_STLEXD_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=5, Rd=0, Rt=0
    let encoding: u32 = 0x51A00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_stlexd_a1_a_field_cond_6_poweroftwo_290_61a00290() {
    // Encoding: 0x61A00290
    // Test aarch32_STLEXD_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, cond=6, Rn=0, Rd=0
    let encoding: u32 = 0x61A00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_stlexd_a1_a_field_cond_7_poweroftwo_290_71a00290() {
    // Encoding: 0x71A00290
    // Test aarch32_STLEXD_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=7, Rd=0, Rn=0, Rt=0
    let encoding: u32 = 0x71A00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_stlexd_a1_a_field_cond_8_poweroftwo_290_81a00290() {
    // Encoding: 0x81A00290
    // Test aarch32_STLEXD_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=8, Rn=0, Rt=0, Rd=0
    let encoding: u32 = 0x81A00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_stlexd_a1_a_field_cond_9_poweroftwo_290_91a00290() {
    // Encoding: 0x91A00290
    // Test aarch32_STLEXD_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=9, Rn=0, Rt=0, Rd=0
    let encoding: u32 = 0x91A00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_stlexd_a1_a_field_cond_10_poweroftwo_290_a1a00290() {
    // Encoding: 0xA1A00290
    // Test aarch32_STLEXD_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=10, Rd=0, Rt=0, Rn=0
    let encoding: u32 = 0xA1A00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_stlexd_a1_a_field_cond_11_poweroftwo_290_b1a00290() {
    // Encoding: 0xB1A00290
    // Test aarch32_STLEXD_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=11, Rd=0, Rt=0
    let encoding: u32 = 0xB1A00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_stlexd_a1_a_field_cond_12_poweroftwo_290_c1a00290() {
    // Encoding: 0xC1A00290
    // Test aarch32_STLEXD_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, Rd=0, cond=12, Rn=0
    let encoding: u32 = 0xC1A00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_stlexd_a1_a_field_cond_13_poweroftwo_290_d1a00290() {
    // Encoding: 0xD1A00290
    // Test aarch32_STLEXD_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, Rd=0, cond=13, Rn=0
    let encoding: u32 = 0xD1A00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_stlexd_a1_a_field_cond_14_poweroftwo_290_e1a00290() {
    // Encoding: 0xE1A00290
    // Test aarch32_STLEXD_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=14, Rd=0
    let encoding: u32 = 0xE1A00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_stlexd_a1_a_field_cond_15_max_290_f1a00290() {
    // Encoding: 0xF1A00290
    // Test aarch32_STLEXD_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: Rt=0, Rd=0, cond=15, Rn=0
    let encoding: u32 = 0xF1A00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXD_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_stlexd_a1_a_field_rn_0_min_290_01a00290() {
    // Encoding: 0x01A00290
    // Test aarch32_STLEXD_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: Rd=0, Rt=0, cond=0, Rn=0
    let encoding: u32 = 0x01A00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXD_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_stlexd_a1_a_field_rn_1_poweroftwo_290_01a10290() {
    // Encoding: 0x01A10290
    // Test aarch32_STLEXD_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rt=0, cond=0, Rd=0, Rn=1
    let encoding: u32 = 0x01A10290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXD_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_stlexd_a1_a_field_rd_0_min_290_01a00290() {
    // Encoding: 0x01A00290
    // Test aarch32_STLEXD_A1_A field Rd = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rd=0, Rn=0, Rt=0
    let encoding: u32 = 0x01A00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXD_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_stlexd_a1_a_field_rd_1_poweroftwo_290_01a01290() {
    // Encoding: 0x01A01290
    // Test aarch32_STLEXD_A1_A field Rd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=1, cond=0, Rn=0, Rt=0
    let encoding: u32 = 0x01A01290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXD_A1_A
/// ASL: `field Rt 0 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_stlexd_a1_a_field_rt_0_min_290_01a00290() {
    // Encoding: 0x01A00290
    // Test aarch32_STLEXD_A1_A field Rt = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rd=0, Rt=0, Rn=0
    let encoding: u32 = 0x01A00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXD_A1_A
/// ASL: `field Rt 0 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_stlexd_a1_a_field_rt_1_poweroftwo_290_01a00291() {
    // Encoding: 0x01A00291
    // Test aarch32_STLEXD_A1_A field Rt = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=0, Rt=1, Rd=0
    let encoding: u32 = 0x01A00291;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXD_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_stlexd_a1_a_combo_0_290_01a00290() {
    // Encoding: 0x01A00290
    // Test aarch32_STLEXD_A1_A field combination: cond=0, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rn=0, Rd=0, cond=0, Rt=0
    let encoding: u32 = 0x01A00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXD_A1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=1 (condition NE (not equal))
#[test]
fn test_aarch32_stlexd_a1_a_combo_1_290_11a00290() {
    // Encoding: 0x11A00290
    // Test aarch32_STLEXD_A1_A field combination: cond=1, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rd=0, Rn=0, Rt=0, cond=1
    let encoding: u32 = 0x11A00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXD_A1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=2 (condition CS/HS (carry set))
#[test]
fn test_aarch32_stlexd_a1_a_combo_2_290_21a00290() {
    // Encoding: 0x21A00290
    // Test aarch32_STLEXD_A1_A field combination: cond=2, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rn=0, Rd=0, cond=2, Rt=0
    let encoding: u32 = 0x21A00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXD_A1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=3 (condition CC/LO (carry clear))
#[test]
fn test_aarch32_stlexd_a1_a_combo_3_290_31a00290() {
    // Encoding: 0x31A00290
    // Test aarch32_STLEXD_A1_A field combination: cond=3, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rd=0, Rn=0, cond=3, Rt=0
    let encoding: u32 = 0x31A00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXD_A1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=4 (condition MI (minus/negative))
#[test]
fn test_aarch32_stlexd_a1_a_combo_4_290_41a00290() {
    // Encoding: 0x41A00290
    // Test aarch32_STLEXD_A1_A field combination: cond=4, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rd=0, cond=4, Rt=0, Rn=0
    let encoding: u32 = 0x41A00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXD_A1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=5 (condition PL (plus/positive))
#[test]
fn test_aarch32_stlexd_a1_a_combo_5_290_51a00290() {
    // Encoding: 0x51A00290
    // Test aarch32_STLEXD_A1_A field combination: cond=5, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rt=0, Rd=0, cond=5, Rn=0
    let encoding: u32 = 0x51A00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXD_A1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=6 (condition VS (overflow set))
#[test]
fn test_aarch32_stlexd_a1_a_combo_6_290_61a00290() {
    // Encoding: 0x61A00290
    // Test aarch32_STLEXD_A1_A field combination: cond=6, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rd=0, Rn=0, cond=6, Rt=0
    let encoding: u32 = 0x61A00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXD_A1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=7 (condition VC (overflow clear))
#[test]
fn test_aarch32_stlexd_a1_a_combo_7_290_71a00290() {
    // Encoding: 0x71A00290
    // Test aarch32_STLEXD_A1_A field combination: cond=7, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rd=0, Rn=0, cond=7, Rt=0
    let encoding: u32 = 0x71A00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXD_A1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=8 (condition HI (unsigned higher))
#[test]
fn test_aarch32_stlexd_a1_a_combo_8_290_81a00290() {
    // Encoding: 0x81A00290
    // Test aarch32_STLEXD_A1_A field combination: cond=8, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rd=0, Rt=0, Rn=0, cond=8
    let encoding: u32 = 0x81A00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXD_A1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=9 (condition LS (unsigned lower or same))
#[test]
fn test_aarch32_stlexd_a1_a_combo_9_290_91a00290() {
    // Encoding: 0x91A00290
    // Test aarch32_STLEXD_A1_A field combination: cond=9, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rn=0, cond=9, Rd=0, Rt=0
    let encoding: u32 = 0x91A00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXD_A1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=10 (condition GE (signed >=))
#[test]
fn test_aarch32_stlexd_a1_a_combo_10_290_a1a00290() {
    // Encoding: 0xA1A00290
    // Test aarch32_STLEXD_A1_A field combination: cond=10, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: cond=10, Rn=0, Rt=0, Rd=0
    let encoding: u32 = 0xA1A00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXD_A1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=11 (condition LT (signed <))
#[test]
fn test_aarch32_stlexd_a1_a_combo_11_290_b1a00290() {
    // Encoding: 0xB1A00290
    // Test aarch32_STLEXD_A1_A field combination: cond=11, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: cond=11, Rn=0, Rd=0, Rt=0
    let encoding: u32 = 0xB1A00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXD_A1_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=12 (condition GT (signed >))
#[test]
fn test_aarch32_stlexd_a1_a_combo_12_290_c1a00290() {
    // Encoding: 0xC1A00290
    // Test aarch32_STLEXD_A1_A field combination: cond=12, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rn=0, Rd=0, Rt=0, cond=12
    let encoding: u32 = 0xC1A00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXD_A1_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=13 (condition LE (signed <=))
#[test]
fn test_aarch32_stlexd_a1_a_combo_13_290_d1a00290() {
    // Encoding: 0xD1A00290
    // Test aarch32_STLEXD_A1_A field combination: cond=13, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rt=0, Rn=0, cond=13, Rd=0
    let encoding: u32 = 0xD1A00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXD_A1_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=14 (condition AL (always))
#[test]
fn test_aarch32_stlexd_a1_a_combo_14_290_e1a00290() {
    // Encoding: 0xE1A00290
    // Test aarch32_STLEXD_A1_A field combination: cond=14, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=14, Rd=0
    let encoding: u32 = 0xE1A00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXD_A1_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=15 (condition NV (never, reserved))
#[test]
fn test_aarch32_stlexd_a1_a_combo_15_290_f1a00290() {
    // Encoding: 0xF1A00290
    // Test aarch32_STLEXD_A1_A field combination: cond=15, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rn=0, Rd=0, cond=15, Rt=0
    let encoding: u32 = 0xF1A00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXD_A1_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_stlexd_a1_a_combo_16_290_01a00290() {
    // Encoding: 0x01A00290
    // Test aarch32_STLEXD_A1_A field combination: cond=0, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rd=0, cond=0, Rn=0, Rt=0
    let encoding: u32 = 0x01A00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXD_A1_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_stlexd_a1_a_combo_17_290_01a10290() {
    // Encoding: 0x01A10290
    // Test aarch32_STLEXD_A1_A field combination: cond=0, Rn=1, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rn=1, cond=0, Rt=0, Rd=0
    let encoding: u32 = 0x01A10290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXD_A1_A
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch32_stlexd_a1_a_combo_18_290_01a00290() {
    // Encoding: 0x01A00290
    // Test aarch32_STLEXD_A1_A field combination: cond=0, Rn=0, Rd=0, Rt=0
    // ISET: A32
    // Fields: Rt=0, Rn=0, Rd=0, cond=0
    let encoding: u32 = 0x01A00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXD_A1_A
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch32_stlexd_a1_a_combo_19_290_01a01290() {
    // Encoding: 0x01A01290
    // Test aarch32_STLEXD_A1_A field combination: cond=0, Rn=0, Rd=1, Rt=0
    // ISET: A32
    // Fields: Rn=0, cond=0, Rt=0, Rd=1
    let encoding: u32 = 0x01A01290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXD_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_stlexd_a1_a_special_cond_0_condition_eq_656_01a00290() {
    // Encoding: 0x01A00290
    // Test aarch32_STLEXD_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: Rn=0, Rt=0, cond=0, Rd=0
    let encoding: u32 = 0x01A00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXD_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_stlexd_a1_a_special_cond_1_condition_ne_656_11a00290() {
    // Encoding: 0x11A00290
    // Test aarch32_STLEXD_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: Rt=0, cond=1, Rd=0, Rn=0
    let encoding: u32 = 0x11A00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXD_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_stlexd_a1_a_special_cond_2_condition_cs_hs_656_21a00290() {
    // Encoding: 0x21A00290
    // Test aarch32_STLEXD_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: Rd=0, cond=2, Rn=0, Rt=0
    let encoding: u32 = 0x21A00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXD_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_stlexd_a1_a_special_cond_3_condition_cc_lo_656_31a00290() {
    // Encoding: 0x31A00290
    // Test aarch32_STLEXD_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: Rd=0, Rt=0, cond=3, Rn=0
    let encoding: u32 = 0x31A00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXD_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_stlexd_a1_a_special_cond_4_condition_mi_656_41a00290() {
    // Encoding: 0x41A00290
    // Test aarch32_STLEXD_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: Rt=0, Rn=0, cond=4, Rd=0
    let encoding: u32 = 0x41A00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXD_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_stlexd_a1_a_special_cond_5_condition_pl_656_51a00290() {
    // Encoding: 0x51A00290
    // Test aarch32_STLEXD_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: cond=5, Rd=0, Rt=0, Rn=0
    let encoding: u32 = 0x51A00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXD_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_stlexd_a1_a_special_cond_6_condition_vs_656_61a00290() {
    // Encoding: 0x61A00290
    // Test aarch32_STLEXD_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: Rd=0, Rn=0, cond=6, Rt=0
    let encoding: u32 = 0x61A00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXD_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_stlexd_a1_a_special_cond_7_condition_vc_656_71a00290() {
    // Encoding: 0x71A00290
    // Test aarch32_STLEXD_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: cond=7, Rt=0, Rd=0, Rn=0
    let encoding: u32 = 0x71A00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXD_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_stlexd_a1_a_special_cond_8_condition_hi_656_81a00290() {
    // Encoding: 0x81A00290
    // Test aarch32_STLEXD_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: Rd=0, Rn=0, cond=8, Rt=0
    let encoding: u32 = 0x81A00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXD_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_stlexd_a1_a_special_cond_9_condition_ls_656_91a00290() {
    // Encoding: 0x91A00290
    // Test aarch32_STLEXD_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: Rn=0, Rt=0, Rd=0, cond=9
    let encoding: u32 = 0x91A00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXD_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_stlexd_a1_a_special_cond_10_condition_ge_656_a1a00290() {
    // Encoding: 0xA1A00290
    // Test aarch32_STLEXD_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: Rd=0, cond=10, Rt=0, Rn=0
    let encoding: u32 = 0xA1A00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXD_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_stlexd_a1_a_special_cond_11_condition_lt_656_b1a00290() {
    // Encoding: 0xB1A00290
    // Test aarch32_STLEXD_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: cond=11, Rn=0, Rt=0, Rd=0
    let encoding: u32 = 0xB1A00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXD_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_stlexd_a1_a_special_cond_12_condition_gt_656_c1a00290() {
    // Encoding: 0xC1A00290
    // Test aarch32_STLEXD_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: cond=12, Rd=0, Rn=0, Rt=0
    let encoding: u32 = 0xC1A00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXD_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_stlexd_a1_a_special_cond_13_condition_le_656_d1a00290() {
    // Encoding: 0xD1A00290
    // Test aarch32_STLEXD_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: cond=13, Rt=0, Rn=0, Rd=0
    let encoding: u32 = 0xD1A00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXD_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_stlexd_a1_a_special_cond_14_condition_al_656_e1a00290() {
    // Encoding: 0xE1A00290
    // Test aarch32_STLEXD_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: cond=14, Rd=0, Rn=0, Rt=0
    let encoding: u32 = 0xE1A00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXD_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_stlexd_a1_a_special_cond_15_condition_nv_656_f1a00290() {
    // Encoding: 0xF1A00290
    // Test aarch32_STLEXD_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: cond=15, Rd=0, Rn=0, Rt=0
    let encoding: u32 = 0xF1A00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STLEXD_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Rt" }), indices: [Single(LitInt(0))] } } }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t2" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"Rt\" }), indices: [Single(LitInt(0))] } } }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t2\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_stlexd_a1_a_invalid_0_290_01a00290() {
    // Encoding: 0x01A00290
    // Test aarch32_STLEXD_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "Rt" }), indices: [Single(LitInt(0))] } } }, rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t2" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }
    // ISET: A32
    // Fields: Rd=0, Rt=0, cond=0, Rn=0
    let encoding: u32 = 0x01A00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STLEXD_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_stlexd_a1_a_invalid_1_290_01a00290() {
    // Encoding: 0x01A00290
    // Test aarch32_STLEXD_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: cond=0, Rn=0, Rd=0, Rt=0
    let encoding: u32 = 0x01A00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STLEXD_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }) } }, rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t2" }) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }) } }, rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t2\" }) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_stlexd_a1_a_invalid_2_290_01a00290() {
    // Encoding: 0x01A00290
    // Test aarch32_STLEXD_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }) } }, rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t2" }) }
    // ISET: A32
    // Fields: cond=0, Rn=0, Rd=0, Rt=0
    let encoding: u32 = 0x01A00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STLEXD_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_stlexd_a1_a_invalid_3_290_01a00290() {
    // Encoding: 0x01A00290
    // Test aarch32_STLEXD_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Rn=0, cond=0, Rt=0, Rd=0
    let encoding: u32 = 0x01A00290;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STLEXD_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_stlexd_t1_a_field_rn_0_min_f0_e8c000f0() {
    // Thumb encoding (32): 0xE8C000F0
    // Test aarch32_STLEXD_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rt=0, Rd=0, Rt2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C000F0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLEXD_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_stlexd_t1_a_field_rn_1_poweroftwo_f0_e8c100f0() {
    // Thumb encoding (32): 0xE8C100F0
    // Test aarch32_STLEXD_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rt2=0, Rd=0, Rt=0, Rn=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C100F0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLEXD_T1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_stlexd_t1_a_field_rt_0_min_f0_e8c000f0() {
    // Thumb encoding (32): 0xE8C000F0
    // Test aarch32_STLEXD_T1_A field Rt = 0 (Min)
    // ISET: T32
    // Fields: Rd=0, Rn=0, Rt=0, Rt2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C000F0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLEXD_T1_A
/// ASL: `field Rt 12 +: 4`
/// Requirement: FieldBoundary { field: "Rt", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_stlexd_t1_a_field_rt_1_poweroftwo_f0_e8c010f0() {
    // Thumb encoding (32): 0xE8C010F0
    // Test aarch32_STLEXD_T1_A field Rt = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Rt2=0, Rt=1, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C010F0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLEXD_T1_A
/// ASL: `field Rt2 8 +: 4`
/// Requirement: FieldBoundary { field: "Rt2", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_stlexd_t1_a_field_rt2_0_min_f0_e8c000f0() {
    // Thumb encoding (32): 0xE8C000F0
    // Test aarch32_STLEXD_T1_A field Rt2 = 0 (Min)
    // ISET: T32
    // Fields: Rt=0, Rn=0, Rd=0, Rt2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C000F0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLEXD_T1_A
/// ASL: `field Rt2 8 +: 4`
/// Requirement: FieldBoundary { field: "Rt2", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_stlexd_t1_a_field_rt2_1_poweroftwo_f0_e8c001f0() {
    // Thumb encoding (32): 0xE8C001F0
    // Test aarch32_STLEXD_T1_A field Rt2 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rd=0, Rn=0, Rt=0, Rt2=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C001F0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLEXD_T1_A
/// ASL: `field Rd 0 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_stlexd_t1_a_field_rd_0_min_f0_e8c000f0() {
    // Thumb encoding (32): 0xE8C000F0
    // Test aarch32_STLEXD_T1_A field Rd = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rt=0, Rt2=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C000F0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLEXD_T1_A
/// ASL: `field Rd 0 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_stlexd_t1_a_field_rd_1_poweroftwo_f0_e8c000f1() {
    // Thumb encoding (32): 0xE8C000F1
    // Test aarch32_STLEXD_T1_A field Rd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Rt=0, Rt2=0, Rd=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C000F1;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLEXD_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_stlexd_t1_a_combo_0_f0_e8c000f0() {
    // Thumb encoding (32): 0xE8C000F0
    // Test aarch32_STLEXD_T1_A field combination: Rn=0, Rt=0, Rt2=0, Rd=0
    // ISET: T32
    // Fields: Rt2=0, Rn=0, Rt=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C000F0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLEXD_T1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_stlexd_t1_a_combo_1_f0_e8c100f0() {
    // Thumb encoding (32): 0xE8C100F0
    // Test aarch32_STLEXD_T1_A field combination: Rn=1, Rt=0, Rt2=0, Rd=0
    // ISET: T32
    // Fields: Rt2=0, Rt=0, Rd=0, Rn=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C100F0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLEXD_T1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=0 (register index 0 (first register))
#[test]
fn test_aarch32_stlexd_t1_a_combo_2_f0_e8c000f0() {
    // Thumb encoding (32): 0xE8C000F0
    // Test aarch32_STLEXD_T1_A field combination: Rn=0, Rt=0, Rt2=0, Rd=0
    // ISET: T32
    // Fields: Rt2=0, Rt=0, Rn=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C000F0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLEXD_T1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=1 (register index 1 (second register))
#[test]
fn test_aarch32_stlexd_t1_a_combo_3_f0_e8c010f0() {
    // Thumb encoding (32): 0xE8C010F0
    // Test aarch32_STLEXD_T1_A field combination: Rn=0, Rt=1, Rt2=0, Rd=0
    // ISET: T32
    // Fields: Rn=0, Rt2=0, Rd=0, Rt=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C010F0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLEXD_T1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt2=0 (register index 0 (first register))
#[test]
fn test_aarch32_stlexd_t1_a_combo_4_f0_e8c000f0() {
    // Thumb encoding (32): 0xE8C000F0
    // Test aarch32_STLEXD_T1_A field combination: Rn=0, Rt=0, Rt2=0, Rd=0
    // ISET: T32
    // Fields: Rd=0, Rt2=0, Rn=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C000F0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLEXD_T1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt2=1 (register index 1 (second register))
#[test]
fn test_aarch32_stlexd_t1_a_combo_5_f0_e8c001f0() {
    // Thumb encoding (32): 0xE8C001F0
    // Test aarch32_STLEXD_T1_A field combination: Rn=0, Rt=0, Rt2=1, Rd=0
    // ISET: T32
    // Fields: Rt=0, Rd=0, Rn=0, Rt2=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C001F0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLEXD_T1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch32_stlexd_t1_a_combo_6_f0_e8c000f0() {
    // Thumb encoding (32): 0xE8C000F0
    // Test aarch32_STLEXD_T1_A field combination: Rn=0, Rt=0, Rt2=0, Rd=0
    // ISET: T32
    // Fields: Rn=0, Rd=0, Rt=0, Rt2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C000F0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLEXD_T1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch32_stlexd_t1_a_combo_7_f0_e8c000f1() {
    // Thumb encoding (32): 0xE8C000F1
    // Test aarch32_STLEXD_T1_A field combination: Rn=0, Rt=0, Rt2=0, Rd=1
    // ISET: T32
    // Fields: Rt2=0, Rt=0, Rd=1, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C000F1;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLEXD_T1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rt=1 (same register test (reg=1))
#[test]
fn test_aarch32_stlexd_t1_a_combo_8_f0_e8c110f0() {
    // Thumb encoding (32): 0xE8C110F0
    // Test aarch32_STLEXD_T1_A field combination: Rn=1, Rt=1, Rt2=0, Rd=0
    // ISET: T32
    // Fields: Rn=1, Rt2=0, Rd=0, Rt=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C110F0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLEXD_T1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rt=31 (same register test (reg=31))
#[test]
fn test_aarch32_stlexd_t1_a_combo_9_f0_e8cff0f0() {
    // Thumb encoding (32): 0xE8CFF0F0
    // Test aarch32_STLEXD_T1_A field combination: Rn=31, Rt=31, Rt2=0, Rd=0
    // ISET: T32
    // Fields: Rn=31, Rt=31, Rd=0, Rt2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8CFF0F0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLEXD_T1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rt2=1 (same register test (reg=1))
#[test]
fn test_aarch32_stlexd_t1_a_combo_10_f0_e8c101f0() {
    // Thumb encoding (32): 0xE8C101F0
    // Test aarch32_STLEXD_T1_A field combination: Rn=1, Rt=0, Rt2=1, Rd=0
    // ISET: T32
    // Fields: Rt=0, Rn=1, Rt2=1, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C101F0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLEXD_T1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rt2=31 (same register test (reg=31))
#[test]
fn test_aarch32_stlexd_t1_a_combo_11_f0_e8cf0ff0() {
    // Thumb encoding (32): 0xE8CF0FF0
    // Test aarch32_STLEXD_T1_A field combination: Rn=31, Rt=0, Rt2=31, Rd=0
    // ISET: T32
    // Fields: Rd=0, Rn=31, Rt2=31, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8CF0FF0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLEXD_T1_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch32_stlexd_t1_a_combo_12_f0_e8c100f1() {
    // Thumb encoding (32): 0xE8C100F1
    // Test aarch32_STLEXD_T1_A field combination: Rn=1, Rt=0, Rt2=0, Rd=1
    // ISET: T32
    // Fields: Rt2=0, Rn=1, Rt=0, Rd=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C100F1;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLEXD_T1_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch32_stlexd_t1_a_combo_13_f0_e8cf00ff() {
    // Thumb encoding (32): 0xE8CF00FF
    // Test aarch32_STLEXD_T1_A field combination: Rn=31, Rt=0, Rt2=0, Rd=31
    // ISET: T32
    // Fields: Rt=0, Rn=31, Rt2=0, Rd=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8CF00FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLEXD_T1_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=1 (same register test (reg=1)), Rt2=1 (same register test (reg=1))
#[test]
fn test_aarch32_stlexd_t1_a_combo_14_f0_e8c011f0() {
    // Thumb encoding (32): 0xE8C011F0
    // Test aarch32_STLEXD_T1_A field combination: Rn=0, Rt=1, Rt2=1, Rd=0
    // ISET: T32
    // Fields: Rn=0, Rt2=1, Rd=0, Rt=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C011F0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLEXD_T1_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=31 (same register test (reg=31)), Rt2=31 (same register test (reg=31))
#[test]
fn test_aarch32_stlexd_t1_a_combo_15_f0_e8c0fff0() {
    // Thumb encoding (32): 0xE8C0FFF0
    // Test aarch32_STLEXD_T1_A field combination: Rn=0, Rt=31, Rt2=31, Rd=0
    // ISET: T32
    // Fields: Rt2=31, Rn=0, Rt=31, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C0FFF0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLEXD_T1_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch32_stlexd_t1_a_combo_16_f0_e8c010f1() {
    // Thumb encoding (32): 0xE8C010F1
    // Test aarch32_STLEXD_T1_A field combination: Rn=0, Rt=1, Rt2=0, Rd=1
    // ISET: T32
    // Fields: Rn=0, Rt=1, Rd=1, Rt2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C010F1;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLEXD_T1_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch32_stlexd_t1_a_combo_17_f0_e8c0f0ff() {
    // Thumb encoding (32): 0xE8C0F0FF
    // Test aarch32_STLEXD_T1_A field combination: Rn=0, Rt=31, Rt2=0, Rd=31
    // ISET: T32
    // Fields: Rn=0, Rt=31, Rt2=0, Rd=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C0F0FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLEXD_T1_A
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt2=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch32_stlexd_t1_a_combo_18_f0_e8c001f1() {
    // Thumb encoding (32): 0xE8C001F1
    // Test aarch32_STLEXD_T1_A field combination: Rn=0, Rt=0, Rt2=1, Rd=1
    // ISET: T32
    // Fields: Rn=0, Rt2=1, Rt=0, Rd=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C001F1;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLEXD_T1_A
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rt2=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch32_stlexd_t1_a_combo_19_f0_e8c00fff() {
    // Thumb encoding (32): 0xE8C00FFF
    // Test aarch32_STLEXD_T1_A field combination: Rn=0, Rt=0, Rt2=31, Rd=31
    // ISET: T32
    // Fields: Rt=0, Rn=0, Rt2=31, Rd=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C00FFF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STLEXD_T1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t2" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t2\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_stlexd_t1_a_invalid_0_f0_e8c000f0() {
    // Thumb encoding (32): 0xE8C000F0
    // Test aarch32_STLEXD_T1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t2" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }
    // ISET: T32
    // Fields: Rn=0, Rd=0, Rt=0, Rt2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C000F0;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_STLEXD_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_stlexd_t1_a_invalid_1_f0_e8c000f0() {
    // Thumb encoding (32): 0xE8C000F0
    // Test aarch32_STLEXD_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rn=0, Rt=0, Rt2=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C000F0;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_STLEXD_T1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }) } }, rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t2" }) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }) } }, rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"t2\" }) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_stlexd_t1_a_invalid_2_f0_e8c000f0() {
    // Thumb encoding (32): 0xE8C000F0
    // Test aarch32_STLEXD_T1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }) } }, rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "t" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }) } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "t2" }) }
    // ISET: T32
    // Fields: Rt2=0, Rn=0, Rd=0, Rt=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C000F0;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_STLEXD_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_stlexd_t1_a_invalid_3_f0_e8c000f0() {
    // Thumb encoding (32): 0xE8C000F0
    // Test aarch32_STLEXD_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rd=0, Rt2=0, Rt=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8C000F0;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_STLEXD_A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_stlexd_a1_a_store_0_01a10290() {
    // Test aarch32_STLEXD_A1_A memory store: 8 bytes
    // Encoding: 0x01A10290
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x01A10290;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_STLEXD_T1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_stlexd_t1_a_store_0_e8c100f0() {
    // Test aarch32_STLEXD_T1_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xE8C100F0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// aarch32_STM_A Tests
// ============================================================================

/// Provenance: aarch32_STM_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_stm_a1_a_field_cond_0_min_0_08800000() {
    // Encoding: 0x08800000
    // Test aarch32_STM_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: W=0, Rn=0, cond=0, register_list=0
    let encoding: u32 = 0x08800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_stm_a1_a_field_cond_1_poweroftwo_0_18800000() {
    // Encoding: 0x18800000
    // Test aarch32_STM_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, register_list=0, Rn=0, cond=1
    let encoding: u32 = 0x18800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_stm_a1_a_field_cond_2_poweroftwo_0_28800000() {
    // Encoding: 0x28800000
    // Test aarch32_STM_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: register_list=0, W=0, Rn=0, cond=2
    let encoding: u32 = 0x28800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_stm_a1_a_field_cond_3_poweroftwo_0_38800000() {
    // Encoding: 0x38800000
    // Test aarch32_STM_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: register_list=0, W=0, cond=3, Rn=0
    let encoding: u32 = 0x38800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_stm_a1_a_field_cond_4_poweroftwo_0_48800000() {
    // Encoding: 0x48800000
    // Test aarch32_STM_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=4, register_list=0, W=0
    let encoding: u32 = 0x48800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_stm_a1_a_field_cond_5_poweroftwo_0_58800000() {
    // Encoding: 0x58800000
    // Test aarch32_STM_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, register_list=0, W=0, cond=5
    let encoding: u32 = 0x58800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_stm_a1_a_field_cond_6_poweroftwo_0_68800000() {
    // Encoding: 0x68800000
    // Test aarch32_STM_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, register_list=0, Rn=0, cond=6
    let encoding: u32 = 0x68800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_stm_a1_a_field_cond_7_poweroftwo_0_78800000() {
    // Encoding: 0x78800000
    // Test aarch32_STM_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, Rn=0, cond=7, register_list=0
    let encoding: u32 = 0x78800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_stm_a1_a_field_cond_8_poweroftwo_0_88800000() {
    // Encoding: 0x88800000
    // Test aarch32_STM_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=8, W=0, register_list=0
    let encoding: u32 = 0x88800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_stm_a1_a_field_cond_9_poweroftwo_0_98800000() {
    // Encoding: 0x98800000
    // Test aarch32_STM_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=9, Rn=0, register_list=0, W=0
    let encoding: u32 = 0x98800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_stm_a1_a_field_cond_10_poweroftwo_0_a8800000() {
    // Encoding: 0xA8800000
    // Test aarch32_STM_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=10, W=0, Rn=0, register_list=0
    let encoding: u32 = 0xA8800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_stm_a1_a_field_cond_11_poweroftwo_0_b8800000() {
    // Encoding: 0xB8800000
    // Test aarch32_STM_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, Rn=0, register_list=0, cond=11
    let encoding: u32 = 0xB8800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_stm_a1_a_field_cond_12_poweroftwo_0_c8800000() {
    // Encoding: 0xC8800000
    // Test aarch32_STM_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=12, Rn=0, register_list=0, W=0
    let encoding: u32 = 0xC8800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_stm_a1_a_field_cond_13_poweroftwo_0_d8800000() {
    // Encoding: 0xD8800000
    // Test aarch32_STM_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=13, register_list=0, W=0, Rn=0
    let encoding: u32 = 0xD8800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_stm_a1_a_field_cond_14_poweroftwo_0_e8800000() {
    // Encoding: 0xE8800000
    // Test aarch32_STM_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, register_list=0, Rn=0, cond=14
    let encoding: u32 = 0xE8800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_stm_a1_a_field_cond_15_max_0_f8800000() {
    // Encoding: 0xF8800000
    // Test aarch32_STM_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: W=0, register_list=0, cond=15, Rn=0
    let encoding: u32 = 0xF8800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_A1_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_stm_a1_a_field_w_0_min_0_08800000() {
    // Encoding: 0x08800000
    // Test aarch32_STM_A1_A field W = 0 (Min)
    // ISET: A32
    // Fields: register_list=0, W=0, cond=0, Rn=0
    let encoding: u32 = 0x08800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_A1_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_stm_a1_a_field_w_1_max_0_08a00000() {
    // Encoding: 0x08A00000
    // Test aarch32_STM_A1_A field W = 1 (Max)
    // ISET: A32
    // Fields: W=1, Rn=0, cond=0, register_list=0
    let encoding: u32 = 0x08A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_stm_a1_a_field_rn_0_min_0_08800000() {
    // Encoding: 0x08800000
    // Test aarch32_STM_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: W=0, Rn=0, cond=0, register_list=0
    let encoding: u32 = 0x08800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_stm_a1_a_field_rn_1_poweroftwo_0_08810000() {
    // Encoding: 0x08810000
    // Test aarch32_STM_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, Rn=1, cond=0, register_list=0
    let encoding: u32 = 0x08810000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_A1_A
/// ASL: `field register_list 0 +: 16`
/// Requirement: FieldBoundary { field: "register_list", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_stm_a1_a_field_register_list_0_min_0_08800000() {
    // Encoding: 0x08800000
    // Test aarch32_STM_A1_A field register_list = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rn=0, register_list=0, W=0
    let encoding: u32 = 0x08800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_A1_A
/// ASL: `field register_list 0 +: 16`
/// Requirement: FieldBoundary { field: "register_list", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_stm_a1_a_field_register_list_1_poweroftwo_0_08800001() {
    // Encoding: 0x08800001
    // Test aarch32_STM_A1_A field register_list = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, W=0, register_list=1, Rn=0
    let encoding: u32 = 0x08800001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_A1_A
/// ASL: `field register_list 0 +: 16`
/// Requirement: FieldBoundary { field: "register_list", value: 32767, boundary: PowerOfTwoMinusOne }
/// midpoint (32767)
#[test]
fn test_aarch32_stm_a1_a_field_register_list_32767_poweroftwominusone_0_08807fff() {
    // Encoding: 0x08807FFF
    // Test aarch32_STM_A1_A field register_list = 32767 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rn=0, W=0, register_list=32767, cond=0
    let encoding: u32 = 0x08807FFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_A1_A
/// ASL: `field register_list 0 +: 16`
/// Requirement: FieldBoundary { field: "register_list", value: 65535, boundary: Max }
/// maximum value (65535)
#[test]
fn test_aarch32_stm_a1_a_field_register_list_65535_max_0_0880ffff() {
    // Encoding: 0x0880FFFF
    // Test aarch32_STM_A1_A field register_list = 65535 (Max)
    // ISET: A32
    // Fields: register_list=65535, cond=0, Rn=0, W=0
    let encoding: u32 = 0x0880FFFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_stm_a1_a_combo_0_0_08800000() {
    // Encoding: 0x08800000
    // Test aarch32_STM_A1_A field combination: cond=0, W=0, Rn=0, register_list=0
    // ISET: A32
    // Fields: cond=0, W=0, Rn=0, register_list=0
    let encoding: u32 = 0x08800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_A1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=1 (condition NE (not equal))
#[test]
fn test_aarch32_stm_a1_a_combo_1_0_18800000() {
    // Encoding: 0x18800000
    // Test aarch32_STM_A1_A field combination: cond=1, W=0, Rn=0, register_list=0
    // ISET: A32
    // Fields: W=0, register_list=0, cond=1, Rn=0
    let encoding: u32 = 0x18800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_A1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=2 (condition CS/HS (carry set))
#[test]
fn test_aarch32_stm_a1_a_combo_2_0_28800000() {
    // Encoding: 0x28800000
    // Test aarch32_STM_A1_A field combination: cond=2, W=0, Rn=0, register_list=0
    // ISET: A32
    // Fields: Rn=0, W=0, cond=2, register_list=0
    let encoding: u32 = 0x28800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_A1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=3 (condition CC/LO (carry clear))
#[test]
fn test_aarch32_stm_a1_a_combo_3_0_38800000() {
    // Encoding: 0x38800000
    // Test aarch32_STM_A1_A field combination: cond=3, W=0, Rn=0, register_list=0
    // ISET: A32
    // Fields: register_list=0, W=0, cond=3, Rn=0
    let encoding: u32 = 0x38800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_A1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=4 (condition MI (minus/negative))
#[test]
fn test_aarch32_stm_a1_a_combo_4_0_48800000() {
    // Encoding: 0x48800000
    // Test aarch32_STM_A1_A field combination: cond=4, W=0, Rn=0, register_list=0
    // ISET: A32
    // Fields: W=0, register_list=0, Rn=0, cond=4
    let encoding: u32 = 0x48800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_A1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=5 (condition PL (plus/positive))
#[test]
fn test_aarch32_stm_a1_a_combo_5_0_58800000() {
    // Encoding: 0x58800000
    // Test aarch32_STM_A1_A field combination: cond=5, W=0, Rn=0, register_list=0
    // ISET: A32
    // Fields: register_list=0, W=0, Rn=0, cond=5
    let encoding: u32 = 0x58800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_A1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=6 (condition VS (overflow set))
#[test]
fn test_aarch32_stm_a1_a_combo_6_0_68800000() {
    // Encoding: 0x68800000
    // Test aarch32_STM_A1_A field combination: cond=6, W=0, Rn=0, register_list=0
    // ISET: A32
    // Fields: W=0, Rn=0, cond=6, register_list=0
    let encoding: u32 = 0x68800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_A1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=7 (condition VC (overflow clear))
#[test]
fn test_aarch32_stm_a1_a_combo_7_0_78800000() {
    // Encoding: 0x78800000
    // Test aarch32_STM_A1_A field combination: cond=7, W=0, Rn=0, register_list=0
    // ISET: A32
    // Fields: cond=7, register_list=0, Rn=0, W=0
    let encoding: u32 = 0x78800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_A1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=8 (condition HI (unsigned higher))
#[test]
fn test_aarch32_stm_a1_a_combo_8_0_88800000() {
    // Encoding: 0x88800000
    // Test aarch32_STM_A1_A field combination: cond=8, W=0, Rn=0, register_list=0
    // ISET: A32
    // Fields: Rn=0, cond=8, register_list=0, W=0
    let encoding: u32 = 0x88800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_A1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=9 (condition LS (unsigned lower or same))
#[test]
fn test_aarch32_stm_a1_a_combo_9_0_98800000() {
    // Encoding: 0x98800000
    // Test aarch32_STM_A1_A field combination: cond=9, W=0, Rn=0, register_list=0
    // ISET: A32
    // Fields: cond=9, register_list=0, Rn=0, W=0
    let encoding: u32 = 0x98800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_A1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=10 (condition GE (signed >=))
#[test]
fn test_aarch32_stm_a1_a_combo_10_0_a8800000() {
    // Encoding: 0xA8800000
    // Test aarch32_STM_A1_A field combination: cond=10, W=0, Rn=0, register_list=0
    // ISET: A32
    // Fields: Rn=0, cond=10, W=0, register_list=0
    let encoding: u32 = 0xA8800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_A1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=11 (condition LT (signed <))
#[test]
fn test_aarch32_stm_a1_a_combo_11_0_b8800000() {
    // Encoding: 0xB8800000
    // Test aarch32_STM_A1_A field combination: cond=11, W=0, Rn=0, register_list=0
    // ISET: A32
    // Fields: W=0, register_list=0, cond=11, Rn=0
    let encoding: u32 = 0xB8800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_A1_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=12 (condition GT (signed >))
#[test]
fn test_aarch32_stm_a1_a_combo_12_0_c8800000() {
    // Encoding: 0xC8800000
    // Test aarch32_STM_A1_A field combination: cond=12, W=0, Rn=0, register_list=0
    // ISET: A32
    // Fields: W=0, register_list=0, cond=12, Rn=0
    let encoding: u32 = 0xC8800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_A1_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=13 (condition LE (signed <=))
#[test]
fn test_aarch32_stm_a1_a_combo_13_0_d8800000() {
    // Encoding: 0xD8800000
    // Test aarch32_STM_A1_A field combination: cond=13, W=0, Rn=0, register_list=0
    // ISET: A32
    // Fields: W=0, Rn=0, register_list=0, cond=13
    let encoding: u32 = 0xD8800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_A1_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=14 (condition AL (always))
#[test]
fn test_aarch32_stm_a1_a_combo_14_0_e8800000() {
    // Encoding: 0xE8800000
    // Test aarch32_STM_A1_A field combination: cond=14, W=0, Rn=0, register_list=0
    // ISET: A32
    // Fields: Rn=0, cond=14, W=0, register_list=0
    let encoding: u32 = 0xE8800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_A1_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=15 (condition NV (never, reserved))
#[test]
fn test_aarch32_stm_a1_a_combo_15_0_f8800000() {
    // Encoding: 0xF8800000
    // Test aarch32_STM_A1_A field combination: cond=15, W=0, Rn=0, register_list=0
    // ISET: A32
    // Fields: register_list=0, cond=15, W=0, Rn=0
    let encoding: u32 = 0xF8800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_A1_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// W=0 (minimum value)
#[test]
fn test_aarch32_stm_a1_a_combo_16_0_08800000() {
    // Encoding: 0x08800000
    // Test aarch32_STM_A1_A field combination: cond=0, W=0, Rn=0, register_list=0
    // ISET: A32
    // Fields: cond=0, W=0, Rn=0, register_list=0
    let encoding: u32 = 0x08800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_A1_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// W=1 (maximum value (1))
#[test]
fn test_aarch32_stm_a1_a_combo_17_0_08a00000() {
    // Encoding: 0x08A00000
    // Test aarch32_STM_A1_A field combination: cond=0, W=1, Rn=0, register_list=0
    // ISET: A32
    // Fields: register_list=0, W=1, Rn=0, cond=0
    let encoding: u32 = 0x08A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_A1_A
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_stm_a1_a_combo_18_0_08800000() {
    // Encoding: 0x08800000
    // Test aarch32_STM_A1_A field combination: cond=0, W=0, Rn=0, register_list=0
    // ISET: A32
    // Fields: register_list=0, cond=0, Rn=0, W=0
    let encoding: u32 = 0x08800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_A1_A
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_stm_a1_a_combo_19_0_08810000() {
    // Encoding: 0x08810000
    // Test aarch32_STM_A1_A field combination: cond=0, W=0, Rn=1, register_list=0
    // ISET: A32
    // Fields: cond=0, W=0, register_list=0, Rn=1
    let encoding: u32 = 0x08810000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_stm_a1_a_special_cond_0_condition_eq_0_08800000() {
    // Encoding: 0x08800000
    // Test aarch32_STM_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: W=0, Rn=0, cond=0, register_list=0
    let encoding: u32 = 0x08800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_stm_a1_a_special_cond_1_condition_ne_0_18800000() {
    // Encoding: 0x18800000
    // Test aarch32_STM_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: cond=1, Rn=0, W=0, register_list=0
    let encoding: u32 = 0x18800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_stm_a1_a_special_cond_2_condition_cs_hs_0_28800000() {
    // Encoding: 0x28800000
    // Test aarch32_STM_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: cond=2, Rn=0, register_list=0, W=0
    let encoding: u32 = 0x28800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_stm_a1_a_special_cond_3_condition_cc_lo_0_38800000() {
    // Encoding: 0x38800000
    // Test aarch32_STM_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: W=0, register_list=0, cond=3, Rn=0
    let encoding: u32 = 0x38800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_stm_a1_a_special_cond_4_condition_mi_0_48800000() {
    // Encoding: 0x48800000
    // Test aarch32_STM_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: cond=4, W=0, Rn=0, register_list=0
    let encoding: u32 = 0x48800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_stm_a1_a_special_cond_5_condition_pl_0_58800000() {
    // Encoding: 0x58800000
    // Test aarch32_STM_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: cond=5, W=0, Rn=0, register_list=0
    let encoding: u32 = 0x58800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_stm_a1_a_special_cond_6_condition_vs_0_68800000() {
    // Encoding: 0x68800000
    // Test aarch32_STM_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: Rn=0, cond=6, W=0, register_list=0
    let encoding: u32 = 0x68800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_stm_a1_a_special_cond_7_condition_vc_0_78800000() {
    // Encoding: 0x78800000
    // Test aarch32_STM_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: Rn=0, register_list=0, W=0, cond=7
    let encoding: u32 = 0x78800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_stm_a1_a_special_cond_8_condition_hi_0_88800000() {
    // Encoding: 0x88800000
    // Test aarch32_STM_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: register_list=0, cond=8, W=0, Rn=0
    let encoding: u32 = 0x88800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_stm_a1_a_special_cond_9_condition_ls_0_98800000() {
    // Encoding: 0x98800000
    // Test aarch32_STM_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: cond=9, Rn=0, register_list=0, W=0
    let encoding: u32 = 0x98800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_stm_a1_a_special_cond_10_condition_ge_0_a8800000() {
    // Encoding: 0xA8800000
    // Test aarch32_STM_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: Rn=0, W=0, cond=10, register_list=0
    let encoding: u32 = 0xA8800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_stm_a1_a_special_cond_11_condition_lt_0_b8800000() {
    // Encoding: 0xB8800000
    // Test aarch32_STM_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: register_list=0, cond=11, W=0, Rn=0
    let encoding: u32 = 0xB8800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_stm_a1_a_special_cond_12_condition_gt_0_c8800000() {
    // Encoding: 0xC8800000
    // Test aarch32_STM_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: W=0, cond=12, register_list=0, Rn=0
    let encoding: u32 = 0xC8800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_stm_a1_a_special_cond_13_condition_le_0_d8800000() {
    // Encoding: 0xD8800000
    // Test aarch32_STM_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: Rn=0, W=0, register_list=0, cond=13
    let encoding: u32 = 0xD8800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_stm_a1_a_special_cond_14_condition_al_0_e8800000() {
    // Encoding: 0xE8800000
    // Test aarch32_STM_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: Rn=0, W=0, register_list=0, cond=14
    let encoding: u32 = 0xE8800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_stm_a1_a_special_cond_15_condition_nv_0_f8800000() {
    // Encoding: 0xF8800000
    // Test aarch32_STM_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: W=0, cond=15, Rn=0, register_list=0
    let encoding: u32 = 0xF8800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STM_A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Binary { op: Lt, lhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "BitCount" }, args: [Var(QualifiedIdentifier { qualifier: Any, name: "registers" })] }, rhs: LitInt(1) } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Binary { op: Lt, lhs: Call { name: QualifiedIdentifier { qualifier: Any, name: \"BitCount\" }, args: [Var(QualifiedIdentifier { qualifier: Any, name: \"registers\" })] }, rhs: LitInt(1) } } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_stm_a1_a_invalid_0_0_08800000() {
    // Encoding: 0x08800000
    // Test aarch32_STM_A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Binary { op: Lt, lhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "BitCount" }, args: [Var(QualifiedIdentifier { qualifier: Any, name: "registers" })] }, rhs: LitInt(1) } } }
    // ISET: A32
    // Fields: Rn=0, cond=0, register_list=0, W=0
    let encoding: u32 = 0x08800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STM_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_stm_a1_a_invalid_1_0_08800000() {
    // Encoding: 0x08800000
    // Test aarch32_STM_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: W=0, register_list=0, Rn=0, cond=0
    let encoding: u32 = 0x08800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STM_T1_A
/// ASL: `field Rn 24 +: 3`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_stm_t1_a_field_rn_0_min_0_c0000000() {
    // Thumb encoding (32): 0xC0000000
    // Test aarch32_STM_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, register_list=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xC0000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STM_T1_A
/// ASL: `field Rn 24 +: 3`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_stm_t1_a_field_rn_1_poweroftwo_0_c1000000() {
    // Thumb encoding (32): 0xC1000000
    // Test aarch32_STM_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: register_list=0, Rn=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xC1000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STM_T1_A
/// ASL: `field register_list 16 +: 8`
/// Requirement: FieldBoundary { field: "register_list", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_stm_t1_a_field_register_list_0_min_0_c0000000() {
    // Thumb encoding (32): 0xC0000000
    // Test aarch32_STM_T1_A field register_list = 0 (Min)
    // ISET: T32
    // Fields: register_list=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xC0000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STM_T1_A
/// ASL: `field register_list 16 +: 8`
/// Requirement: FieldBoundary { field: "register_list", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_stm_t1_a_field_register_list_1_poweroftwo_0_c0010000() {
    // Thumb encoding (32): 0xC0010000
    // Test aarch32_STM_T1_A field register_list = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: register_list=1, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xC0010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STM_T1_A
/// ASL: `field register_list 16 +: 8`
/// Requirement: FieldBoundary { field: "register_list", value: 127, boundary: PowerOfTwoMinusOne }
/// midpoint (127)
#[test]
fn test_aarch32_stm_t1_a_field_register_list_127_poweroftwominusone_0_c07f0000() {
    // Thumb encoding (32): 0xC07F0000
    // Test aarch32_STM_T1_A field register_list = 127 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: register_list=127, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xC07F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STM_T1_A
/// ASL: `field register_list 16 +: 8`
/// Requirement: FieldBoundary { field: "register_list", value: 255, boundary: Max }
/// maximum value (255)
#[test]
fn test_aarch32_stm_t1_a_field_register_list_255_max_0_c0ff0000() {
    // Thumb encoding (32): 0xC0FF0000
    // Test aarch32_STM_T1_A field register_list = 255 (Max)
    // ISET: T32
    // Fields: Rn=0, register_list=255
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xC0FF0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STM_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_stm_t1_a_combo_0_0_c0000000() {
    // Thumb encoding (32): 0xC0000000
    // Test aarch32_STM_T1_A field combination: Rn=0, register_list=0
    // ISET: T32
    // Fields: Rn=0, register_list=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xC0000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STM_T1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_stm_t1_a_combo_1_0_c1000000() {
    // Thumb encoding (32): 0xC1000000
    // Test aarch32_STM_T1_A field combination: Rn=1, register_list=0
    // ISET: T32
    // Fields: Rn=1, register_list=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xC1000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STM_T1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// register_list=0 (minimum value)
#[test]
fn test_aarch32_stm_t1_a_combo_2_0_c0000000() {
    // Thumb encoding (32): 0xC0000000
    // Test aarch32_STM_T1_A field combination: Rn=0, register_list=0
    // ISET: T32
    // Fields: Rn=0, register_list=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xC0000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STM_T1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// register_list=1 (value 1)
#[test]
fn test_aarch32_stm_t1_a_combo_3_0_c0010000() {
    // Thumb encoding (32): 0xC0010000
    // Test aarch32_STM_T1_A field combination: Rn=0, register_list=1
    // ISET: T32
    // Fields: Rn=0, register_list=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xC0010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STM_T1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// register_list=127 (midpoint (127))
#[test]
fn test_aarch32_stm_t1_a_combo_4_0_c07f0000() {
    // Thumb encoding (32): 0xC07F0000
    // Test aarch32_STM_T1_A field combination: Rn=0, register_list=127
    // ISET: T32
    // Fields: Rn=0, register_list=127
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xC07F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STM_T1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// register_list=255 (maximum value (255))
#[test]
fn test_aarch32_stm_t1_a_combo_5_0_c0ff0000() {
    // Thumb encoding (32): 0xC0FF0000
    // Test aarch32_STM_T1_A field combination: Rn=0, register_list=255
    // ISET: T32
    // Fields: Rn=0, register_list=255
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xC0FF0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STM_T1_A
/// ASL: `Binary { op: Lt, lhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "BitCount" }, args: [Var(QualifiedIdentifier { qualifier: Any, name: "registers" })] }, rhs: LitInt(1) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Lt, lhs: Call { name: QualifiedIdentifier { qualifier: Any, name: \"BitCount\" }, args: [Var(QualifiedIdentifier { qualifier: Any, name: \"registers\" })] }, rhs: LitInt(1) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_stm_t1_a_invalid_0_0_c0000000() {
    // Thumb encoding (32): 0xC0000000
    // Test aarch32_STM_T1_A invalid encoding: Binary { op: Lt, lhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "BitCount" }, args: [Var(QualifiedIdentifier { qualifier: Any, name: "registers" })] }, rhs: LitInt(1) }
    // ISET: T32
    // Fields: Rn=0, register_list=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xC0000000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_STM_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_stm_t1_a_invalid_1_0_c0000000() {
    // Thumb encoding (32): 0xC0000000
    // Test aarch32_STM_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rn=0, register_list=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xC0000000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_STM_T2_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_stm_t2_a_field_w_0_min_0_e8800000() {
    // Thumb encoding (32): 0xE8800000
    // Test aarch32_STM_T2_A field W = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, W=0, M=0, register_list=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STM_T2_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_stm_t2_a_field_w_1_max_0_e8a00000() {
    // Thumb encoding (32): 0xE8A00000
    // Test aarch32_STM_T2_A field W = 1 (Max)
    // ISET: T32
    // Fields: register_list=0, Rn=0, M=0, P=0, W=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STM_T2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_stm_t2_a_field_rn_0_min_0_e8800000() {
    // Thumb encoding (32): 0xE8800000
    // Test aarch32_STM_T2_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: P=0, W=0, M=0, register_list=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STM_T2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_stm_t2_a_field_rn_1_poweroftwo_0_e8810000() {
    // Thumb encoding (32): 0xE8810000
    // Test aarch32_STM_T2_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=1, P=0, M=0, W=0, register_list=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STM_T2_A
/// ASL: `field P 15 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_stm_t2_a_field_p_0_min_0_e8800000() {
    // Thumb encoding (32): 0xE8800000
    // Test aarch32_STM_T2_A field P = 0 (Min)
    // ISET: T32
    // Fields: P=0, W=0, Rn=0, M=0, register_list=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STM_T2_A
/// ASL: `field P 15 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_stm_t2_a_field_p_1_max_0_e8808000() {
    // Thumb encoding (32): 0xE8808000
    // Test aarch32_STM_T2_A field P = 1 (Max)
    // ISET: T32
    // Fields: W=0, Rn=0, register_list=0, P=1, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8808000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STM_T2_A
/// ASL: `field M 14 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_stm_t2_a_field_m_0_min_0_e8800000() {
    // Thumb encoding (32): 0xE8800000
    // Test aarch32_STM_T2_A field M = 0 (Min)
    // ISET: T32
    // Fields: M=0, register_list=0, Rn=0, W=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STM_T2_A
/// ASL: `field M 14 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_stm_t2_a_field_m_1_max_0_e8804000() {
    // Thumb encoding (32): 0xE8804000
    // Test aarch32_STM_T2_A field M = 1 (Max)
    // ISET: T32
    // Fields: P=0, M=1, Rn=0, register_list=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8804000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STM_T2_A
/// ASL: `field register_list 0 +: 14`
/// Requirement: FieldBoundary { field: "register_list", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_stm_t2_a_field_register_list_0_min_0_e8800000() {
    // Thumb encoding (32): 0xE8800000
    // Test aarch32_STM_T2_A field register_list = 0 (Min)
    // ISET: T32
    // Fields: register_list=0, P=0, W=0, M=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STM_T2_A
/// ASL: `field register_list 0 +: 14`
/// Requirement: FieldBoundary { field: "register_list", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_stm_t2_a_field_register_list_1_poweroftwo_0_e8800001() {
    // Thumb encoding (32): 0xE8800001
    // Test aarch32_STM_T2_A field register_list = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: M=0, register_list=1, Rn=0, P=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8800001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STM_T2_A
/// ASL: `field register_list 0 +: 14`
/// Requirement: FieldBoundary { field: "register_list", value: 8191, boundary: PowerOfTwoMinusOne }
/// midpoint (8191)
#[test]
fn test_aarch32_stm_t2_a_field_register_list_8191_poweroftwominusone_0_e8801fff() {
    // Thumb encoding (32): 0xE8801FFF
    // Test aarch32_STM_T2_A field register_list = 8191 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: M=0, W=0, register_list=8191, P=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8801FFF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STM_T2_A
/// ASL: `field register_list 0 +: 14`
/// Requirement: FieldBoundary { field: "register_list", value: 16383, boundary: Max }
/// maximum value (16383)
#[test]
fn test_aarch32_stm_t2_a_field_register_list_16383_max_0_e8803fff() {
    // Thumb encoding (32): 0xE8803FFF
    // Test aarch32_STM_T2_A field register_list = 16383 (Max)
    // ISET: T32
    // Fields: P=0, M=0, W=0, register_list=16383, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8803FFF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STM_T2_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// W=0 (minimum value)
#[test]
fn test_aarch32_stm_t2_a_combo_0_0_e8800000() {
    // Thumb encoding (32): 0xE8800000
    // Test aarch32_STM_T2_A field combination: W=0, Rn=0, P=0, M=0, register_list=0
    // ISET: T32
    // Fields: register_list=0, P=0, W=0, M=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STM_T2_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// W=1 (maximum value (1))
#[test]
fn test_aarch32_stm_t2_a_combo_1_0_e8a00000() {
    // Thumb encoding (32): 0xE8A00000
    // Test aarch32_STM_T2_A field combination: W=1, Rn=0, P=0, M=0, register_list=0
    // ISET: T32
    // Fields: P=0, W=1, Rn=0, register_list=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STM_T2_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_stm_t2_a_combo_2_0_e8800000() {
    // Thumb encoding (32): 0xE8800000
    // Test aarch32_STM_T2_A field combination: W=0, Rn=0, P=0, M=0, register_list=0
    // ISET: T32
    // Fields: M=0, W=0, P=0, register_list=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STM_T2_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_stm_t2_a_combo_3_0_e8810000() {
    // Thumb encoding (32): 0xE8810000
    // Test aarch32_STM_T2_A field combination: W=0, Rn=1, P=0, M=0, register_list=0
    // ISET: T32
    // Fields: Rn=1, M=0, register_list=0, W=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STM_T2_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// P=0 (minimum value)
#[test]
fn test_aarch32_stm_t2_a_combo_4_0_e8800000() {
    // Thumb encoding (32): 0xE8800000
    // Test aarch32_STM_T2_A field combination: W=0, Rn=0, P=0, M=0, register_list=0
    // ISET: T32
    // Fields: P=0, M=0, W=0, Rn=0, register_list=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STM_T2_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// P=1 (maximum value (1))
#[test]
fn test_aarch32_stm_t2_a_combo_5_0_e8808000() {
    // Thumb encoding (32): 0xE8808000
    // Test aarch32_STM_T2_A field combination: W=0, Rn=0, P=1, M=0, register_list=0
    // ISET: T32
    // Fields: Rn=0, M=0, W=0, P=1, register_list=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8808000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STM_T2_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// M=0 (minimum value)
#[test]
fn test_aarch32_stm_t2_a_combo_6_0_e8800000() {
    // Thumb encoding (32): 0xE8800000
    // Test aarch32_STM_T2_A field combination: W=0, Rn=0, P=0, M=0, register_list=0
    // ISET: T32
    // Fields: P=0, M=0, register_list=0, W=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STM_T2_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// M=1 (maximum value (1))
#[test]
fn test_aarch32_stm_t2_a_combo_7_0_e8804000() {
    // Thumb encoding (32): 0xE8804000
    // Test aarch32_STM_T2_A field combination: W=0, Rn=0, P=0, M=1, register_list=0
    // ISET: T32
    // Fields: W=0, Rn=0, P=0, M=1, register_list=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8804000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STM_T2_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// register_list=0 (minimum value)
#[test]
fn test_aarch32_stm_t2_a_combo_8_0_e8800000() {
    // Thumb encoding (32): 0xE8800000
    // Test aarch32_STM_T2_A field combination: W=0, Rn=0, P=0, M=0, register_list=0
    // ISET: T32
    // Fields: P=0, M=0, Rn=0, register_list=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STM_T2_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// register_list=1 (value 1)
#[test]
fn test_aarch32_stm_t2_a_combo_9_0_e8800001() {
    // Thumb encoding (32): 0xE8800001
    // Test aarch32_STM_T2_A field combination: W=0, Rn=0, P=0, M=0, register_list=1
    // ISET: T32
    // Fields: W=0, Rn=0, P=0, M=0, register_list=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8800001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STM_T2_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// register_list=8191 (midpoint (8191))
#[test]
fn test_aarch32_stm_t2_a_combo_10_0_e8801fff() {
    // Thumb encoding (32): 0xE8801FFF
    // Test aarch32_STM_T2_A field combination: W=0, Rn=0, P=0, M=0, register_list=8191
    // ISET: T32
    // Fields: W=0, Rn=0, P=0, register_list=8191, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8801FFF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STM_T2_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// register_list=16383 (maximum value (16383))
#[test]
fn test_aarch32_stm_t2_a_combo_11_0_e8803fff() {
    // Thumb encoding (32): 0xE8803FFF
    // Test aarch32_STM_T2_A field combination: W=0, Rn=0, P=0, M=0, register_list=16383
    // ISET: T32
    // Fields: W=0, P=0, M=0, register_list=16383, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8803FFF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STM_T2_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Binary { op: Lt, lhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "BitCount" }, args: [Var(QualifiedIdentifier { qualifier: Any, name: "registers" })] }, rhs: LitInt(2) } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Binary { op: Lt, lhs: Call { name: QualifiedIdentifier { qualifier: Any, name: \"BitCount\" }, args: [Var(QualifiedIdentifier { qualifier: Any, name: \"registers\" })] }, rhs: LitInt(2) } } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_stm_t2_a_invalid_0_0_e8800000() {
    // Thumb encoding (32): 0xE8800000
    // Test aarch32_STM_T2_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Binary { op: Lt, lhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "BitCount" }, args: [Var(QualifiedIdentifier { qualifier: Any, name: "registers" })] }, rhs: LitInt(2) } } }
    // ISET: T32
    // Fields: Rn=0, M=0, register_list=0, P=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8800000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_STM_T2_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_stm_t2_a_invalid_1_0_e8800000() {
    // Thumb encoding (32): 0xE8800000
    // Test aarch32_STM_T2_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rn=0, M=0, register_list=0, P=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8800000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_STM_T2_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "registers" }), indices: [Single(Var(QualifiedIdentifier { qualifier: Any, name: "n" }))] } }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"wback\" }), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"registers\" }), indices: [Single(Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }))] } }, rhs: LitBits([true]) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_stm_t2_a_invalid_2_0_e8800000() {
    // Thumb encoding (32): 0xE8800000
    // Test aarch32_STM_T2_A invalid encoding: Binary { op: Eq, lhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "registers" }), indices: [Single(Var(QualifiedIdentifier { qualifier: Any, name: "n" }))] } }, rhs: LitBits([true]) }
    // ISET: T32
    // Fields: W=0, P=0, Rn=0, M=0, register_list=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8800000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_STM_T2_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_stm_t2_a_invalid_3_0_e8800000() {
    // Thumb encoding (32): 0xE8800000
    // Test aarch32_STM_T2_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rn=0, M=0, register_list=0, W=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8800000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_STM_T2_A
/// ASL: `Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "registers" }), indices: [Single(LitInt(13))] }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"registers\" }), indices: [Single(LitInt(13))] }, rhs: LitBits([true]) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_stm_t2_a_invalid_4_0_e8800000() {
    // Thumb encoding (32): 0xE8800000
    // Test aarch32_STM_T2_A invalid encoding: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "registers" }), indices: [Single(LitInt(13))] }, rhs: LitBits([true]) }
    // ISET: T32
    // Fields: register_list=0, P=0, W=0, M=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8800000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_STM_T2_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_stm_t2_a_invalid_5_0_e8800000() {
    // Thumb encoding (32): 0xE8800000
    // Test aarch32_STM_T2_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: P=0, W=0, M=0, Rn=0, register_list=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8800000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_STM_T2_A
/// ASL: `Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "registers" }), indices: [Single(LitInt(15))] }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"registers\" }), indices: [Single(LitInt(15))] }, rhs: LitBits([true]) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_stm_t2_a_invalid_6_0_e8800000() {
    // Thumb encoding (32): 0xE8800000
    // Test aarch32_STM_T2_A invalid encoding: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "registers" }), indices: [Single(LitInt(15))] }, rhs: LitBits([true]) }
    // ISET: T32
    // Fields: W=0, M=0, Rn=0, P=0, register_list=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8800000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_STM_T2_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_stm_t2_a_invalid_7_0_e8800000() {
    // Thumb encoding (32): 0xE8800000
    // Test aarch32_STM_T2_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: P=0, M=0, Rn=0, W=0, register_list=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE8800000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_STM_A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_stm_a1_a_store_0_08810000() {
    // Test aarch32_STM_A1_A memory store: 8 bytes
    // Encoding: 0x08810000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0x08810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_STM_A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_stm_a1_a_store_1_08810000() {
    // Test aarch32_STM_A1_A memory store: 8 bytes
    // Encoding: 0x08810000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x08810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_STM_A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_stm_a1_a_store_2_08810000() {
    // Test aarch32_STM_A1_A memory store: 8 bytes
    // Encoding: 0x08810000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0x08810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_STM_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 0 (32)
#[test]
fn test_aarch32_stm_t1_a_lslv_oracle_32_0_c0020020() {
    // Test LSLV 32-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x12345678, "W0 should be 0x12345678");
}

/// Provenance: aarch32_STM_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 0 (64)
#[test]
fn test_aarch32_stm_t1_a_lslv_oracle_64_0_c0020020() {
    // Test LSLV 64-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x12345678, "X0 should be 0x0000000012345678");
}

/// Provenance: aarch32_STM_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4 (32)
#[test]
fn test_aarch32_stm_t1_a_lslv_oracle_32_1_c0020020() {
    // Test LSLV 32-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x4);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x23456780, "W0 should be 0x23456780");
}

/// Provenance: aarch32_STM_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 4 (64)
#[test]
fn test_aarch32_stm_t1_a_lslv_oracle_64_1_c0020020() {
    // Test LSLV 64-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x4);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x23456780, "X0 should be 0x0000000123456780");
}

/// Provenance: aarch32_STM_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 8 (32)
#[test]
fn test_aarch32_stm_t1_a_lslv_oracle_32_2_c0020020() {
    // Test LSLV 32-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x8);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x34567800, "W0 should be 0x34567800");
}

/// Provenance: aarch32_STM_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 8 (64)
#[test]
fn test_aarch32_stm_t1_a_lslv_oracle_64_2_c0020020() {
    // Test LSLV 64-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x8);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x34567800, "X0 should be 0x0000001234567800");
}

/// Provenance: aarch32_STM_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1 (32)
#[test]
fn test_aarch32_stm_t1_a_lslv_oracle_32_3_c0020020() {
    // Test LSLV 32-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_STM_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// MSB set, shift 1 (64)
#[test]
fn test_aarch32_stm_t1_a_lslv_oracle_64_3_c0020020() {
    // Test LSLV 64-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_STM_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// LSB set, max shift (32)
#[test]
fn test_aarch32_stm_t1_a_lslv_oracle_32_4_c0020020() {
    // Test LSLV 32-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x3F);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "W0 should be 0x80000000");
}

/// Provenance: aarch32_STM_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// LSB set, max shift (64)
#[test]
fn test_aarch32_stm_t1_a_lslv_oracle_64_4_c0020020() {
    // Test LSLV 64-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3F);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x8000000000000000");
}

/// Provenance: aarch32_STM_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// all ones, shift 32 (32)
#[test]
fn test_aarch32_stm_t1_a_lslv_oracle_32_5_c0020020() {
    // Test LSLV 32-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x20);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "W0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_STM_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// all ones, shift 32 (64)
#[test]
fn test_aarch32_stm_t1_a_lslv_oracle_64_5_c0020020() {
    // Test LSLV 64-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x20);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0xFFFFFFFF00000000");
}

/// Provenance: aarch32_STM_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// no shift
#[test]
fn test_aarch32_stm_t1_a_t16_oracle_0_c1000000() {
    // Test T16 LSLS: no shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_STM_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4
#[test]
fn test_aarch32_stm_t1_a_t16_oracle_1_c1000000() {
    // Test T16 LSLS: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    set_w(&mut cpu, 2, 0x4);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF0, "R0 should be 0x00000FF0");
}

/// Provenance: aarch32_STM_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1
#[test]
fn test_aarch32_stm_t1_a_t16_oracle_2_c1000000() {
    // Test T16 LSLS: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_STM_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift to MSB
#[test]
fn test_aarch32_stm_t1_a_t16_oracle_3_c1000000() {
    // Test T16 LSLS: shift to MSB (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1F);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "R0 should be 0x80000000");
}

/// Provenance: aarch32_STM_T1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_stm_t1_a_store_0_c1000000() {
    // Test aarch32_STM_T1_A memory store: 8 bytes
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_STM_T1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_stm_t1_a_store_1_c1000000() {
    // Test aarch32_STM_T1_A memory store: 8 bytes
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_STM_T1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_stm_t1_a_store_2_c1000000() {
    // Test aarch32_STM_T1_A memory store: 8 bytes
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_STM_T2_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_stm_t2_a_store_0_e8810000() {
    // Test aarch32_STM_T2_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xE8810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_STM_T2_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_stm_t2_a_store_1_e8810000() {
    // Test aarch32_STM_T2_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 0, 0xCAFEBABE);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xE8810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_STM_T2_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_stm_t2_a_store_2_e8810000() {
    // Test aarch32_STM_T2_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0xE8810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// aarch32_STMDB_A Tests
// ============================================================================

/// Provenance: aarch32_STMDB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_stmdb_a1_a_field_cond_0_min_0_09000000() {
    // Encoding: 0x09000000
    // Test aarch32_STMDB_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: W=0, register_list=0, Rn=0, cond=0
    let encoding: u32 = 0x09000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_stmdb_a1_a_field_cond_1_poweroftwo_0_19000000() {
    // Encoding: 0x19000000
    // Test aarch32_STMDB_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, register_list=0, cond=1, W=0
    let encoding: u32 = 0x19000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_stmdb_a1_a_field_cond_2_poweroftwo_0_29000000() {
    // Encoding: 0x29000000
    // Test aarch32_STMDB_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, Rn=0, cond=2, register_list=0
    let encoding: u32 = 0x29000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_stmdb_a1_a_field_cond_3_poweroftwo_0_39000000() {
    // Encoding: 0x39000000
    // Test aarch32_STMDB_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, Rn=0, register_list=0, cond=3
    let encoding: u32 = 0x39000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_stmdb_a1_a_field_cond_4_poweroftwo_0_49000000() {
    // Encoding: 0x49000000
    // Test aarch32_STMDB_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: register_list=0, W=0, Rn=0, cond=4
    let encoding: u32 = 0x49000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_stmdb_a1_a_field_cond_5_poweroftwo_0_59000000() {
    // Encoding: 0x59000000
    // Test aarch32_STMDB_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: register_list=0, cond=5, W=0, Rn=0
    let encoding: u32 = 0x59000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_stmdb_a1_a_field_cond_6_poweroftwo_0_69000000() {
    // Encoding: 0x69000000
    // Test aarch32_STMDB_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, cond=6, Rn=0, register_list=0
    let encoding: u32 = 0x69000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_stmdb_a1_a_field_cond_7_poweroftwo_0_79000000() {
    // Encoding: 0x79000000
    // Test aarch32_STMDB_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, W=0, cond=7, register_list=0
    let encoding: u32 = 0x79000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_stmdb_a1_a_field_cond_8_poweroftwo_0_89000000() {
    // Encoding: 0x89000000
    // Test aarch32_STMDB_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, W=0, register_list=0, cond=8
    let encoding: u32 = 0x89000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_stmdb_a1_a_field_cond_9_poweroftwo_0_99000000() {
    // Encoding: 0x99000000
    // Test aarch32_STMDB_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=9, register_list=0, Rn=0, W=0
    let encoding: u32 = 0x99000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_stmdb_a1_a_field_cond_10_poweroftwo_0_a9000000() {
    // Encoding: 0xA9000000
    // Test aarch32_STMDB_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: register_list=0, cond=10, W=0, Rn=0
    let encoding: u32 = 0xA9000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_stmdb_a1_a_field_cond_11_poweroftwo_0_b9000000() {
    // Encoding: 0xB9000000
    // Test aarch32_STMDB_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=11, W=0, register_list=0, Rn=0
    let encoding: u32 = 0xB9000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_stmdb_a1_a_field_cond_12_poweroftwo_0_c9000000() {
    // Encoding: 0xC9000000
    // Test aarch32_STMDB_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: W=0, cond=12, Rn=0, register_list=0
    let encoding: u32 = 0xC9000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_stmdb_a1_a_field_cond_13_poweroftwo_0_d9000000() {
    // Encoding: 0xD9000000
    // Test aarch32_STMDB_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: register_list=0, Rn=0, W=0, cond=13
    let encoding: u32 = 0xD9000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_stmdb_a1_a_field_cond_14_poweroftwo_0_e9000000() {
    // Encoding: 0xE9000000
    // Test aarch32_STMDB_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=14, W=0, register_list=0, Rn=0
    let encoding: u32 = 0xE9000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_stmdb_a1_a_field_cond_15_max_0_f9000000() {
    // Encoding: 0xF9000000
    // Test aarch32_STMDB_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: register_list=0, W=0, Rn=0, cond=15
    let encoding: u32 = 0xF9000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDB_A1_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_stmdb_a1_a_field_w_0_min_0_09000000() {
    // Encoding: 0x09000000
    // Test aarch32_STMDB_A1_A field W = 0 (Min)
    // ISET: A32
    // Fields: register_list=0, W=0, Rn=0, cond=0
    let encoding: u32 = 0x09000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDB_A1_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_stmdb_a1_a_field_w_1_max_0_09200000() {
    // Encoding: 0x09200000
    // Test aarch32_STMDB_A1_A field W = 1 (Max)
    // ISET: A32
    // Fields: cond=0, W=1, Rn=0, register_list=0
    let encoding: u32 = 0x09200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDB_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_stmdb_a1_a_field_rn_0_min_0_09000000() {
    // Encoding: 0x09000000
    // Test aarch32_STMDB_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: cond=0, W=0, Rn=0, register_list=0
    let encoding: u32 = 0x09000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDB_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_stmdb_a1_a_field_rn_1_poweroftwo_0_09010000() {
    // Encoding: 0x09010000
    // Test aarch32_STMDB_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=1, cond=0, register_list=0, W=0
    let encoding: u32 = 0x09010000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDB_A1_A
/// ASL: `field register_list 0 +: 16`
/// Requirement: FieldBoundary { field: "register_list", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_stmdb_a1_a_field_register_list_0_min_0_09000000() {
    // Encoding: 0x09000000
    // Test aarch32_STMDB_A1_A field register_list = 0 (Min)
    // ISET: A32
    // Fields: register_list=0, cond=0, Rn=0, W=0
    let encoding: u32 = 0x09000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDB_A1_A
/// ASL: `field register_list 0 +: 16`
/// Requirement: FieldBoundary { field: "register_list", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_stmdb_a1_a_field_register_list_1_poweroftwo_0_09000001() {
    // Encoding: 0x09000001
    // Test aarch32_STMDB_A1_A field register_list = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=0, W=0, register_list=1
    let encoding: u32 = 0x09000001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDB_A1_A
/// ASL: `field register_list 0 +: 16`
/// Requirement: FieldBoundary { field: "register_list", value: 32767, boundary: PowerOfTwoMinusOne }
/// midpoint (32767)
#[test]
fn test_aarch32_stmdb_a1_a_field_register_list_32767_poweroftwominusone_0_09007fff() {
    // Encoding: 0x09007FFF
    // Test aarch32_STMDB_A1_A field register_list = 32767 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: register_list=32767, cond=0, Rn=0, W=0
    let encoding: u32 = 0x09007FFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDB_A1_A
/// ASL: `field register_list 0 +: 16`
/// Requirement: FieldBoundary { field: "register_list", value: 65535, boundary: Max }
/// maximum value (65535)
#[test]
fn test_aarch32_stmdb_a1_a_field_register_list_65535_max_0_0900ffff() {
    // Encoding: 0x0900FFFF
    // Test aarch32_STMDB_A1_A field register_list = 65535 (Max)
    // ISET: A32
    // Fields: Rn=0, cond=0, register_list=65535, W=0
    let encoding: u32 = 0x0900FFFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDB_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_stmdb_a1_a_combo_0_0_09000000() {
    // Encoding: 0x09000000
    // Test aarch32_STMDB_A1_A field combination: cond=0, W=0, Rn=0, register_list=0
    // ISET: A32
    // Fields: cond=0, W=0, Rn=0, register_list=0
    let encoding: u32 = 0x09000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDB_A1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=1 (condition NE (not equal))
#[test]
fn test_aarch32_stmdb_a1_a_combo_1_0_19000000() {
    // Encoding: 0x19000000
    // Test aarch32_STMDB_A1_A field combination: cond=1, W=0, Rn=0, register_list=0
    // ISET: A32
    // Fields: Rn=0, cond=1, register_list=0, W=0
    let encoding: u32 = 0x19000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDB_A1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=2 (condition CS/HS (carry set))
#[test]
fn test_aarch32_stmdb_a1_a_combo_2_0_29000000() {
    // Encoding: 0x29000000
    // Test aarch32_STMDB_A1_A field combination: cond=2, W=0, Rn=0, register_list=0
    // ISET: A32
    // Fields: cond=2, W=0, register_list=0, Rn=0
    let encoding: u32 = 0x29000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDB_A1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=3 (condition CC/LO (carry clear))
#[test]
fn test_aarch32_stmdb_a1_a_combo_3_0_39000000() {
    // Encoding: 0x39000000
    // Test aarch32_STMDB_A1_A field combination: cond=3, W=0, Rn=0, register_list=0
    // ISET: A32
    // Fields: Rn=0, W=0, register_list=0, cond=3
    let encoding: u32 = 0x39000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDB_A1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=4 (condition MI (minus/negative))
#[test]
fn test_aarch32_stmdb_a1_a_combo_4_0_49000000() {
    // Encoding: 0x49000000
    // Test aarch32_STMDB_A1_A field combination: cond=4, W=0, Rn=0, register_list=0
    // ISET: A32
    // Fields: register_list=0, Rn=0, cond=4, W=0
    let encoding: u32 = 0x49000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDB_A1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=5 (condition PL (plus/positive))
#[test]
fn test_aarch32_stmdb_a1_a_combo_5_0_59000000() {
    // Encoding: 0x59000000
    // Test aarch32_STMDB_A1_A field combination: cond=5, W=0, Rn=0, register_list=0
    // ISET: A32
    // Fields: cond=5, W=0, Rn=0, register_list=0
    let encoding: u32 = 0x59000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDB_A1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=6 (condition VS (overflow set))
#[test]
fn test_aarch32_stmdb_a1_a_combo_6_0_69000000() {
    // Encoding: 0x69000000
    // Test aarch32_STMDB_A1_A field combination: cond=6, W=0, Rn=0, register_list=0
    // ISET: A32
    // Fields: register_list=0, W=0, Rn=0, cond=6
    let encoding: u32 = 0x69000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDB_A1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=7 (condition VC (overflow clear))
#[test]
fn test_aarch32_stmdb_a1_a_combo_7_0_79000000() {
    // Encoding: 0x79000000
    // Test aarch32_STMDB_A1_A field combination: cond=7, W=0, Rn=0, register_list=0
    // ISET: A32
    // Fields: W=0, register_list=0, cond=7, Rn=0
    let encoding: u32 = 0x79000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDB_A1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=8 (condition HI (unsigned higher))
#[test]
fn test_aarch32_stmdb_a1_a_combo_8_0_89000000() {
    // Encoding: 0x89000000
    // Test aarch32_STMDB_A1_A field combination: cond=8, W=0, Rn=0, register_list=0
    // ISET: A32
    // Fields: register_list=0, cond=8, W=0, Rn=0
    let encoding: u32 = 0x89000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDB_A1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=9 (condition LS (unsigned lower or same))
#[test]
fn test_aarch32_stmdb_a1_a_combo_9_0_99000000() {
    // Encoding: 0x99000000
    // Test aarch32_STMDB_A1_A field combination: cond=9, W=0, Rn=0, register_list=0
    // ISET: A32
    // Fields: W=0, register_list=0, Rn=0, cond=9
    let encoding: u32 = 0x99000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDB_A1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=10 (condition GE (signed >=))
#[test]
fn test_aarch32_stmdb_a1_a_combo_10_0_a9000000() {
    // Encoding: 0xA9000000
    // Test aarch32_STMDB_A1_A field combination: cond=10, W=0, Rn=0, register_list=0
    // ISET: A32
    // Fields: cond=10, register_list=0, Rn=0, W=0
    let encoding: u32 = 0xA9000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDB_A1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=11 (condition LT (signed <))
#[test]
fn test_aarch32_stmdb_a1_a_combo_11_0_b9000000() {
    // Encoding: 0xB9000000
    // Test aarch32_STMDB_A1_A field combination: cond=11, W=0, Rn=0, register_list=0
    // ISET: A32
    // Fields: Rn=0, cond=11, W=0, register_list=0
    let encoding: u32 = 0xB9000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDB_A1_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=12 (condition GT (signed >))
#[test]
fn test_aarch32_stmdb_a1_a_combo_12_0_c9000000() {
    // Encoding: 0xC9000000
    // Test aarch32_STMDB_A1_A field combination: cond=12, W=0, Rn=0, register_list=0
    // ISET: A32
    // Fields: register_list=0, W=0, cond=12, Rn=0
    let encoding: u32 = 0xC9000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDB_A1_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=13 (condition LE (signed <=))
#[test]
fn test_aarch32_stmdb_a1_a_combo_13_0_d9000000() {
    // Encoding: 0xD9000000
    // Test aarch32_STMDB_A1_A field combination: cond=13, W=0, Rn=0, register_list=0
    // ISET: A32
    // Fields: Rn=0, W=0, register_list=0, cond=13
    let encoding: u32 = 0xD9000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDB_A1_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=14 (condition AL (always))
#[test]
fn test_aarch32_stmdb_a1_a_combo_14_0_e9000000() {
    // Encoding: 0xE9000000
    // Test aarch32_STMDB_A1_A field combination: cond=14, W=0, Rn=0, register_list=0
    // ISET: A32
    // Fields: W=0, cond=14, Rn=0, register_list=0
    let encoding: u32 = 0xE9000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDB_A1_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=15 (condition NV (never, reserved))
#[test]
fn test_aarch32_stmdb_a1_a_combo_15_0_f9000000() {
    // Encoding: 0xF9000000
    // Test aarch32_STMDB_A1_A field combination: cond=15, W=0, Rn=0, register_list=0
    // ISET: A32
    // Fields: cond=15, W=0, Rn=0, register_list=0
    let encoding: u32 = 0xF9000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDB_A1_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// W=0 (minimum value)
#[test]
fn test_aarch32_stmdb_a1_a_combo_16_0_09000000() {
    // Encoding: 0x09000000
    // Test aarch32_STMDB_A1_A field combination: cond=0, W=0, Rn=0, register_list=0
    // ISET: A32
    // Fields: Rn=0, W=0, cond=0, register_list=0
    let encoding: u32 = 0x09000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDB_A1_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// W=1 (maximum value (1))
#[test]
fn test_aarch32_stmdb_a1_a_combo_17_0_09200000() {
    // Encoding: 0x09200000
    // Test aarch32_STMDB_A1_A field combination: cond=0, W=1, Rn=0, register_list=0
    // ISET: A32
    // Fields: Rn=0, cond=0, W=1, register_list=0
    let encoding: u32 = 0x09200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDB_A1_A
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_stmdb_a1_a_combo_18_0_09000000() {
    // Encoding: 0x09000000
    // Test aarch32_STMDB_A1_A field combination: cond=0, W=0, Rn=0, register_list=0
    // ISET: A32
    // Fields: cond=0, W=0, register_list=0, Rn=0
    let encoding: u32 = 0x09000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDB_A1_A
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_stmdb_a1_a_combo_19_0_09010000() {
    // Encoding: 0x09010000
    // Test aarch32_STMDB_A1_A field combination: cond=0, W=0, Rn=1, register_list=0
    // ISET: A32
    // Fields: register_list=0, Rn=1, cond=0, W=0
    let encoding: u32 = 0x09010000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDB_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_stmdb_a1_a_special_cond_0_condition_eq_0_09000000() {
    // Encoding: 0x09000000
    // Test aarch32_STMDB_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: Rn=0, register_list=0, cond=0, W=0
    let encoding: u32 = 0x09000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDB_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_stmdb_a1_a_special_cond_1_condition_ne_0_19000000() {
    // Encoding: 0x19000000
    // Test aarch32_STMDB_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: Rn=0, cond=1, W=0, register_list=0
    let encoding: u32 = 0x19000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDB_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_stmdb_a1_a_special_cond_2_condition_cs_hs_0_29000000() {
    // Encoding: 0x29000000
    // Test aarch32_STMDB_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: W=0, register_list=0, cond=2, Rn=0
    let encoding: u32 = 0x29000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDB_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_stmdb_a1_a_special_cond_3_condition_cc_lo_0_39000000() {
    // Encoding: 0x39000000
    // Test aarch32_STMDB_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: Rn=0, W=0, register_list=0, cond=3
    let encoding: u32 = 0x39000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDB_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_stmdb_a1_a_special_cond_4_condition_mi_0_49000000() {
    // Encoding: 0x49000000
    // Test aarch32_STMDB_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: register_list=0, W=0, cond=4, Rn=0
    let encoding: u32 = 0x49000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDB_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_stmdb_a1_a_special_cond_5_condition_pl_0_59000000() {
    // Encoding: 0x59000000
    // Test aarch32_STMDB_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: Rn=0, cond=5, W=0, register_list=0
    let encoding: u32 = 0x59000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDB_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_stmdb_a1_a_special_cond_6_condition_vs_0_69000000() {
    // Encoding: 0x69000000
    // Test aarch32_STMDB_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: cond=6, Rn=0, register_list=0, W=0
    let encoding: u32 = 0x69000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDB_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_stmdb_a1_a_special_cond_7_condition_vc_0_79000000() {
    // Encoding: 0x79000000
    // Test aarch32_STMDB_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: register_list=0, Rn=0, W=0, cond=7
    let encoding: u32 = 0x79000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDB_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_stmdb_a1_a_special_cond_8_condition_hi_0_89000000() {
    // Encoding: 0x89000000
    // Test aarch32_STMDB_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: Rn=0, register_list=0, cond=8, W=0
    let encoding: u32 = 0x89000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDB_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_stmdb_a1_a_special_cond_9_condition_ls_0_99000000() {
    // Encoding: 0x99000000
    // Test aarch32_STMDB_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: register_list=0, cond=9, Rn=0, W=0
    let encoding: u32 = 0x99000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDB_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_stmdb_a1_a_special_cond_10_condition_ge_0_a9000000() {
    // Encoding: 0xA9000000
    // Test aarch32_STMDB_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: cond=10, Rn=0, register_list=0, W=0
    let encoding: u32 = 0xA9000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDB_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_stmdb_a1_a_special_cond_11_condition_lt_0_b9000000() {
    // Encoding: 0xB9000000
    // Test aarch32_STMDB_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: W=0, cond=11, Rn=0, register_list=0
    let encoding: u32 = 0xB9000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDB_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_stmdb_a1_a_special_cond_12_condition_gt_0_c9000000() {
    // Encoding: 0xC9000000
    // Test aarch32_STMDB_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: W=0, Rn=0, register_list=0, cond=12
    let encoding: u32 = 0xC9000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDB_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_stmdb_a1_a_special_cond_13_condition_le_0_d9000000() {
    // Encoding: 0xD9000000
    // Test aarch32_STMDB_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: W=0, register_list=0, cond=13, Rn=0
    let encoding: u32 = 0xD9000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDB_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_stmdb_a1_a_special_cond_14_condition_al_0_e9000000() {
    // Encoding: 0xE9000000
    // Test aarch32_STMDB_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: cond=14, Rn=0, register_list=0, W=0
    let encoding: u32 = 0xE9000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDB_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_stmdb_a1_a_special_cond_15_condition_nv_0_f9000000() {
    // Encoding: 0xF9000000
    // Test aarch32_STMDB_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: cond=15, Rn=0, register_list=0, W=0
    let encoding: u32 = 0xF9000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_STMDB_A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Binary { op: Lt, lhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "BitCount" }, args: [Var(QualifiedIdentifier { qualifier: Any, name: "registers" })] }, rhs: LitInt(1) } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Binary { op: Lt, lhs: Call { name: QualifiedIdentifier { qualifier: Any, name: \"BitCount\" }, args: [Var(QualifiedIdentifier { qualifier: Any, name: \"registers\" })] }, rhs: LitInt(1) } } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_stmdb_a1_a_invalid_0_0_09000000() {
    // Encoding: 0x09000000
    // Test aarch32_STMDB_A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Binary { op: Lt, lhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "BitCount" }, args: [Var(QualifiedIdentifier { qualifier: Any, name: "registers" })] }, rhs: LitInt(1) } } }
    // ISET: A32
    // Fields: register_list=0, Rn=0, cond=0, W=0
    let encoding: u32 = 0x09000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STMDB_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_stmdb_a1_a_invalid_1_0_09000000() {
    // Encoding: 0x09000000
    // Test aarch32_STMDB_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: W=0, cond=0, register_list=0, Rn=0
    let encoding: u32 = 0x09000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_STMDB_T1_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_stmdb_t1_a_field_w_0_min_0_e9000000() {
    // Thumb encoding (32): 0xE9000000
    // Test aarch32_STMDB_T1_A field W = 0 (Min)
    // ISET: T32
    // Fields: W=0, P=0, M=0, register_list=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE9000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STMDB_T1_A
/// ASL: `field W 21 +: 1`
/// Requirement: FieldBoundary { field: "W", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_stmdb_t1_a_field_w_1_max_0_e9200000() {
    // Thumb encoding (32): 0xE9200000
    // Test aarch32_STMDB_T1_A field W = 1 (Max)
    // ISET: T32
    // Fields: register_list=0, W=1, P=0, Rn=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE9200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STMDB_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_stmdb_t1_a_field_rn_0_min_0_e9000000() {
    // Thumb encoding (32): 0xE9000000
    // Test aarch32_STMDB_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: W=0, Rn=0, P=0, M=0, register_list=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE9000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STMDB_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_stmdb_t1_a_field_rn_1_poweroftwo_0_e9010000() {
    // Thumb encoding (32): 0xE9010000
    // Test aarch32_STMDB_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: M=0, W=0, register_list=0, Rn=1, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE9010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STMDB_T1_A
/// ASL: `field P 15 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_stmdb_t1_a_field_p_0_min_0_e9000000() {
    // Thumb encoding (32): 0xE9000000
    // Test aarch32_STMDB_T1_A field P = 0 (Min)
    // ISET: T32
    // Fields: register_list=0, Rn=0, W=0, P=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE9000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STMDB_T1_A
/// ASL: `field P 15 +: 1`
/// Requirement: FieldBoundary { field: "P", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_stmdb_t1_a_field_p_1_max_0_e9008000() {
    // Thumb encoding (32): 0xE9008000
    // Test aarch32_STMDB_T1_A field P = 1 (Max)
    // ISET: T32
    // Fields: P=1, Rn=0, W=0, register_list=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE9008000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STMDB_T1_A
/// ASL: `field M 14 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_stmdb_t1_a_field_m_0_min_0_e9000000() {
    // Thumb encoding (32): 0xE9000000
    // Test aarch32_STMDB_T1_A field M = 0 (Min)
    // ISET: T32
    // Fields: register_list=0, W=0, P=0, Rn=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE9000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STMDB_T1_A
/// ASL: `field M 14 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_stmdb_t1_a_field_m_1_max_0_e9004000() {
    // Thumb encoding (32): 0xE9004000
    // Test aarch32_STMDB_T1_A field M = 1 (Max)
    // ISET: T32
    // Fields: M=1, P=0, W=0, register_list=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE9004000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STMDB_T1_A
/// ASL: `field register_list 0 +: 14`
/// Requirement: FieldBoundary { field: "register_list", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_stmdb_t1_a_field_register_list_0_min_0_e9000000() {
    // Thumb encoding (32): 0xE9000000
    // Test aarch32_STMDB_T1_A field register_list = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, M=0, W=0, register_list=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE9000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STMDB_T1_A
/// ASL: `field register_list 0 +: 14`
/// Requirement: FieldBoundary { field: "register_list", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_stmdb_t1_a_field_register_list_1_poweroftwo_0_e9000001() {
    // Thumb encoding (32): 0xE9000001
    // Test aarch32_STMDB_T1_A field register_list = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: register_list=1, P=0, W=0, M=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE9000001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STMDB_T1_A
/// ASL: `field register_list 0 +: 14`
/// Requirement: FieldBoundary { field: "register_list", value: 8191, boundary: PowerOfTwoMinusOne }
/// midpoint (8191)
#[test]
fn test_aarch32_stmdb_t1_a_field_register_list_8191_poweroftwominusone_0_e9001fff() {
    // Thumb encoding (32): 0xE9001FFF
    // Test aarch32_STMDB_T1_A field register_list = 8191 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: W=0, register_list=8191, P=0, Rn=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE9001FFF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STMDB_T1_A
/// ASL: `field register_list 0 +: 14`
/// Requirement: FieldBoundary { field: "register_list", value: 16383, boundary: Max }
/// maximum value (16383)
#[test]
fn test_aarch32_stmdb_t1_a_field_register_list_16383_max_0_e9003fff() {
    // Thumb encoding (32): 0xE9003FFF
    // Test aarch32_STMDB_T1_A field register_list = 16383 (Max)
    // ISET: T32
    // Fields: P=0, W=0, register_list=16383, M=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE9003FFF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STMDB_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// W=0 (minimum value)
#[test]
fn test_aarch32_stmdb_t1_a_combo_0_0_e9000000() {
    // Thumb encoding (32): 0xE9000000
    // Test aarch32_STMDB_T1_A field combination: W=0, Rn=0, P=0, M=0, register_list=0
    // ISET: T32
    // Fields: register_list=0, W=0, P=0, Rn=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE9000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STMDB_T1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// W=1 (maximum value (1))
#[test]
fn test_aarch32_stmdb_t1_a_combo_1_0_e9200000() {
    // Thumb encoding (32): 0xE9200000
    // Test aarch32_STMDB_T1_A field combination: W=1, Rn=0, P=0, M=0, register_list=0
    // ISET: T32
    // Fields: register_list=0, P=0, Rn=0, M=0, W=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE9200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STMDB_T1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_stmdb_t1_a_combo_2_0_e9000000() {
    // Thumb encoding (32): 0xE9000000
    // Test aarch32_STMDB_T1_A field combination: W=0, Rn=0, P=0, M=0, register_list=0
    // ISET: T32
    // Fields: register_list=0, M=0, W=0, Rn=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE9000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STMDB_T1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_stmdb_t1_a_combo_3_0_e9010000() {
    // Thumb encoding (32): 0xE9010000
    // Test aarch32_STMDB_T1_A field combination: W=0, Rn=1, P=0, M=0, register_list=0
    // ISET: T32
    // Fields: register_list=0, W=0, Rn=1, P=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE9010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STMDB_T1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// P=0 (minimum value)
#[test]
fn test_aarch32_stmdb_t1_a_combo_4_0_e9000000() {
    // Thumb encoding (32): 0xE9000000
    // Test aarch32_STMDB_T1_A field combination: W=0, Rn=0, P=0, M=0, register_list=0
    // ISET: T32
    // Fields: P=0, W=0, Rn=0, M=0, register_list=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE9000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STMDB_T1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// P=1 (maximum value (1))
#[test]
fn test_aarch32_stmdb_t1_a_combo_5_0_e9008000() {
    // Thumb encoding (32): 0xE9008000
    // Test aarch32_STMDB_T1_A field combination: W=0, Rn=0, P=1, M=0, register_list=0
    // ISET: T32
    // Fields: Rn=0, W=0, P=1, M=0, register_list=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE9008000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STMDB_T1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// M=0 (minimum value)
#[test]
fn test_aarch32_stmdb_t1_a_combo_6_0_e9000000() {
    // Thumb encoding (32): 0xE9000000
    // Test aarch32_STMDB_T1_A field combination: W=0, Rn=0, P=0, M=0, register_list=0
    // ISET: T32
    // Fields: P=0, M=0, register_list=0, Rn=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE9000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STMDB_T1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// M=1 (maximum value (1))
#[test]
fn test_aarch32_stmdb_t1_a_combo_7_0_e9004000() {
    // Thumb encoding (32): 0xE9004000
    // Test aarch32_STMDB_T1_A field combination: W=0, Rn=0, P=0, M=1, register_list=0
    // ISET: T32
    // Fields: Rn=0, register_list=0, M=1, W=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE9004000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STMDB_T1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// register_list=0 (minimum value)
#[test]
fn test_aarch32_stmdb_t1_a_combo_8_0_e9000000() {
    // Thumb encoding (32): 0xE9000000
    // Test aarch32_STMDB_T1_A field combination: W=0, Rn=0, P=0, M=0, register_list=0
    // ISET: T32
    // Fields: P=0, Rn=0, W=0, M=0, register_list=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE9000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STMDB_T1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// register_list=1 (value 1)
#[test]
fn test_aarch32_stmdb_t1_a_combo_9_0_e9000001() {
    // Thumb encoding (32): 0xE9000001
    // Test aarch32_STMDB_T1_A field combination: W=0, Rn=0, P=0, M=0, register_list=1
    // ISET: T32
    // Fields: register_list=1, W=0, Rn=0, P=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE9000001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STMDB_T1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// register_list=8191 (midpoint (8191))
#[test]
fn test_aarch32_stmdb_t1_a_combo_10_0_e9001fff() {
    // Thumb encoding (32): 0xE9001FFF
    // Test aarch32_STMDB_T1_A field combination: W=0, Rn=0, P=0, M=0, register_list=8191
    // ISET: T32
    // Fields: P=0, W=0, Rn=0, M=0, register_list=8191
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE9001FFF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STMDB_T1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// register_list=16383 (maximum value (16383))
#[test]
fn test_aarch32_stmdb_t1_a_combo_11_0_e9003fff() {
    // Thumb encoding (32): 0xE9003FFF
    // Test aarch32_STMDB_T1_A field combination: W=0, Rn=0, P=0, M=0, register_list=16383
    // ISET: T32
    // Fields: P=0, M=0, Rn=0, register_list=16383, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE9003FFF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_STMDB_T1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Binary { op: Lt, lhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "BitCount" }, args: [Var(QualifiedIdentifier { qualifier: Any, name: "registers" })] }, rhs: LitInt(2) } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Binary { op: Lt, lhs: Call { name: QualifiedIdentifier { qualifier: Any, name: \"BitCount\" }, args: [Var(QualifiedIdentifier { qualifier: Any, name: \"registers\" })] }, rhs: LitInt(2) } } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_stmdb_t1_a_invalid_0_0_e9000000() {
    // Thumb encoding (32): 0xE9000000
    // Test aarch32_STMDB_T1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Binary { op: Lt, lhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "BitCount" }, args: [Var(QualifiedIdentifier { qualifier: Any, name: "registers" })] }, rhs: LitInt(2) } } }
    // ISET: T32
    // Fields: W=0, P=0, M=0, register_list=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE9000000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_STMDB_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_stmdb_t1_a_invalid_1_0_e9000000() {
    // Thumb encoding (32): 0xE9000000
    // Test aarch32_STMDB_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: P=0, W=0, Rn=0, M=0, register_list=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE9000000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_STMDB_T1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "registers" }), indices: [Single(Var(QualifiedIdentifier { qualifier: Any, name: "n" }))] } }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"wback\" }), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"registers\" }), indices: [Single(Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }))] } }, rhs: LitBits([true]) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_stmdb_t1_a_invalid_2_0_e9000000() {
    // Thumb encoding (32): 0xE9000000
    // Test aarch32_STMDB_T1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: And, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "wback" }), rhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "registers" }), indices: [Single(Var(QualifiedIdentifier { qualifier: Any, name: "n" }))] } }, rhs: LitBits([true]) }
    // ISET: T32
    // Fields: Rn=0, W=0, M=0, register_list=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE9000000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_STMDB_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_stmdb_t1_a_invalid_3_0_e9000000() {
    // Thumb encoding (32): 0xE9000000
    // Test aarch32_STMDB_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: M=0, Rn=0, W=0, register_list=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE9000000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_STMDB_T1_A
/// ASL: `Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "registers" }), indices: [Single(LitInt(13))] }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"registers\" }), indices: [Single(LitInt(13))] }, rhs: LitBits([true]) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_stmdb_t1_a_invalid_4_0_e9000000() {
    // Thumb encoding (32): 0xE9000000
    // Test aarch32_STMDB_T1_A invalid encoding: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "registers" }), indices: [Single(LitInt(13))] }, rhs: LitBits([true]) }
    // ISET: T32
    // Fields: W=0, Rn=0, P=0, M=0, register_list=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE9000000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_STMDB_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_stmdb_t1_a_invalid_5_0_e9000000() {
    // Thumb encoding (32): 0xE9000000
    // Test aarch32_STMDB_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: P=0, M=0, W=0, Rn=0, register_list=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE9000000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_STMDB_T1_A
/// ASL: `Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "registers" }), indices: [Single(LitInt(15))] }, rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: \"registers\" }), indices: [Single(LitInt(15))] }, rhs: LitBits([true]) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_stmdb_t1_a_invalid_6_0_e9000000() {
    // Thumb encoding (32): 0xE9000000
    // Test aarch32_STMDB_T1_A invalid encoding: Binary { op: Eq, lhs: Index { base: Var(QualifiedIdentifier { qualifier: Any, name: "registers" }), indices: [Single(LitInt(15))] }, rhs: LitBits([true]) }
    // ISET: T32
    // Fields: Rn=0, M=0, register_list=0, W=0, P=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE9000000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_STMDB_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_stmdb_t1_a_invalid_7_0_e9000000() {
    // Thumb encoding (32): 0xE9000000
    // Test aarch32_STMDB_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rn=0, P=0, M=0, register_list=0, W=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xE9000000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_STMDB_A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_stmdb_a1_a_store_0_09010000() {
    // Test aarch32_STMDB_A1_A memory store: 8 bytes
    // Encoding: 0x09010000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0x09010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_STMDB_A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_stmdb_a1_a_store_1_09010000() {
    // Test aarch32_STMDB_A1_A memory store: 8 bytes
    // Encoding: 0x09010000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0x09010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_STMDB_A1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_stmdb_a1_a_store_2_09010000() {
    // Test aarch32_STMDB_A1_A memory store: 8 bytes
    // Encoding: 0x09010000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0x09010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_STMDB_T1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_stmdb_t1_a_store_0_e9010000() {
    // Test aarch32_STMDB_T1_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0xE9010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_STMDB_T1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_stmdb_t1_a_store_1_e9010000() {
    // Test aarch32_STMDB_T1_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0xE9010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_STMDB_T1_A
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_aarch32_stmdb_t1_a_store_2_e9010000() {
    // Test aarch32_STMDB_T1_A memory store: 8 bytes
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 0, 0xCAFEBABE);
    let encoding: u32 = 0xE9010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

