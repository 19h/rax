//! A32 data_processing add_sub tests.
//!
//! Auto-generated from ARM ASL specifications.
//! DO NOT EDIT MANUALLY.

#![allow(unused_imports)]
#![allow(dead_code)]

use crate::generated::test_helpers_32::*;

// ============================================================================
// aarch32_ADC_i_A Tests
// ============================================================================

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_adc_i_a1_a_field_cond_0_min_0_02a00000() {
    // Encoding: 0x02A00000
    // Test aarch32_ADC_i_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, imm12=0, cond=0, Rd=0, S=0
    let encoding: u32 = 0x02A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_adc_i_a1_a_field_cond_1_poweroftwo_0_12a00000() {
    // Encoding: 0x12A00000
    // Test aarch32_ADC_i_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=1, Rd=0, S=0, Rn=0, imm12=0
    let encoding: u32 = 0x12A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_adc_i_a1_a_field_cond_2_poweroftwo_0_22a00000() {
    // Encoding: 0x22A00000
    // Test aarch32_ADC_i_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, S=0, cond=2, imm12=0, Rd=0
    let encoding: u32 = 0x22A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_adc_i_a1_a_field_cond_3_poweroftwo_0_32a00000() {
    // Encoding: 0x32A00000
    // Test aarch32_ADC_i_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=0, cond=3, Rn=0, Rd=0, S=0
    let encoding: u32 = 0x32A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_adc_i_a1_a_field_cond_4_poweroftwo_0_42a00000() {
    // Encoding: 0x42A00000
    // Test aarch32_ADC_i_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, S=0, Rd=0, cond=4, imm12=0
    let encoding: u32 = 0x42A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_adc_i_a1_a_field_cond_5_poweroftwo_0_52a00000() {
    // Encoding: 0x52A00000
    // Test aarch32_ADC_i_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, S=0, imm12=0, cond=5, Rd=0
    let encoding: u32 = 0x52A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_adc_i_a1_a_field_cond_6_poweroftwo_0_62a00000() {
    // Encoding: 0x62A00000
    // Test aarch32_ADC_i_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=6, imm12=0, Rd=0, Rn=0, S=0
    let encoding: u32 = 0x62A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_adc_i_a1_a_field_cond_7_poweroftwo_0_72a00000() {
    // Encoding: 0x72A00000
    // Test aarch32_ADC_i_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=0, cond=7, Rn=0, S=0, Rd=0
    let encoding: u32 = 0x72A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_adc_i_a1_a_field_cond_8_poweroftwo_0_82a00000() {
    // Encoding: 0x82A00000
    // Test aarch32_ADC_i_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rd=0, cond=8, S=0, imm12=0
    let encoding: u32 = 0x82A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_adc_i_a1_a_field_cond_9_poweroftwo_0_92a00000() {
    // Encoding: 0x92A00000
    // Test aarch32_ADC_i_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=9, S=0, imm12=0, Rn=0, Rd=0
    let encoding: u32 = 0x92A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_adc_i_a1_a_field_cond_10_poweroftwo_0_a2a00000() {
    // Encoding: 0xA2A00000
    // Test aarch32_ADC_i_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, Rn=0, Rd=0, cond=10, imm12=0
    let encoding: u32 = 0xA2A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_adc_i_a1_a_field_cond_11_poweroftwo_0_b2a00000() {
    // Encoding: 0xB2A00000
    // Test aarch32_ADC_i_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rn=0, cond=11, imm12=0, S=0
    let encoding: u32 = 0xB2A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_adc_i_a1_a_field_cond_12_poweroftwo_0_c2a00000() {
    // Encoding: 0xC2A00000
    // Test aarch32_ADC_i_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rn=0, S=0, imm12=0, cond=12
    let encoding: u32 = 0xC2A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_adc_i_a1_a_field_cond_13_poweroftwo_0_d2a00000() {
    // Encoding: 0xD2A00000
    // Test aarch32_ADC_i_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, imm12=0, S=0, Rn=0, cond=13
    let encoding: u32 = 0xD2A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_adc_i_a1_a_field_cond_14_poweroftwo_0_e2a00000() {
    // Encoding: 0xE2A00000
    // Test aarch32_ADC_i_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=0, S=0, Rn=0, cond=14, Rd=0
    let encoding: u32 = 0xE2A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_adc_i_a1_a_field_cond_15_max_0_f2a00000() {
    // Encoding: 0xF2A00000
    // Test aarch32_ADC_i_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: Rn=0, Rd=0, S=0, imm12=0, cond=15
    let encoding: u32 = 0xF2A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_adc_i_a1_a_field_s_0_min_0_02a00000() {
    // Encoding: 0x02A00000
    // Test aarch32_ADC_i_A1_A field S = 0 (Min)
    // ISET: A32
    // Fields: S=0, Rn=0, Rd=0, cond=0, imm12=0
    let encoding: u32 = 0x02A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_adc_i_a1_a_field_s_1_max_0_02b00000() {
    // Encoding: 0x02B00000
    // Test aarch32_ADC_i_A1_A field S = 1 (Max)
    // ISET: A32
    // Fields: Rd=0, S=1, imm12=0, cond=0, Rn=0
    let encoding: u32 = 0x02B00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_adc_i_a1_a_field_rn_0_min_0_02a00000() {
    // Encoding: 0x02A00000
    // Test aarch32_ADC_i_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: imm12=0, cond=0, S=0, Rn=0, Rd=0
    let encoding: u32 = 0x02A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_adc_i_a1_a_field_rn_1_poweroftwo_0_02a10000() {
    // Encoding: 0x02A10000
    // Test aarch32_ADC_i_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=1, Rd=0, imm12=0, cond=0, S=0
    let encoding: u32 = 0x02A10000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_adc_i_a1_a_field_rd_0_min_0_02a00000() {
    // Encoding: 0x02A00000
    // Test aarch32_ADC_i_A1_A field Rd = 0 (Min)
    // ISET: A32
    // Fields: imm12=0, Rn=0, Rd=0, cond=0, S=0
    let encoding: u32 = 0x02A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_adc_i_a1_a_field_rd_1_poweroftwo_0_02a01000() {
    // Encoding: 0x02A01000
    // Test aarch32_ADC_i_A1_A field Rd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, imm12=0, Rd=1, S=0, Rn=0
    let encoding: u32 = 0x02A01000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_adc_i_a1_a_field_imm12_0_zero_0_02a00000() {
    // Encoding: 0x02A00000
    // Test aarch32_ADC_i_A1_A field imm12 = 0 (Zero)
    // ISET: A32
    // Fields: Rn=0, S=0, Rd=0, imm12=0, cond=0
    let encoding: u32 = 0x02A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_adc_i_a1_a_field_imm12_1_poweroftwo_0_02a00001() {
    // Encoding: 0x02A00001
    // Test aarch32_ADC_i_A1_A field imm12 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=1, S=0, Rn=0, Rd=0, cond=0
    let encoding: u32 = 0x02A00001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_adc_i_a1_a_field_imm12_3_poweroftwominusone_0_02a00003() {
    // Encoding: 0x02A00003
    // Test aarch32_ADC_i_A1_A field imm12 = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm12=3, S=0, cond=0, Rd=0, Rn=0
    let encoding: u32 = 0x02A00003;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_adc_i_a1_a_field_imm12_4_poweroftwo_0_02a00004() {
    // Encoding: 0x02A00004
    // Test aarch32_ADC_i_A1_A field imm12 = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Rd=0, imm12=4, S=0, Rn=0
    let encoding: u32 = 0x02A00004;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_adc_i_a1_a_field_imm12_7_poweroftwominusone_0_02a00007() {
    // Encoding: 0x02A00007
    // Test aarch32_ADC_i_A1_A field imm12 = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: S=0, cond=0, Rd=0, Rn=0, imm12=7
    let encoding: u32 = 0x02A00007;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_adc_i_a1_a_field_imm12_8_poweroftwo_0_02a00008() {
    // Encoding: 0x02A00008
    // Test aarch32_ADC_i_A1_A field imm12 = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, imm12=8, Rn=0, S=0, cond=0
    let encoding: u32 = 0x02A00008;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_adc_i_a1_a_field_imm12_15_poweroftwominusone_0_02a0000f() {
    // Encoding: 0x02A0000F
    // Test aarch32_ADC_i_A1_A field imm12 = 15 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm12=15, S=0, cond=0, Rn=0, Rd=0
    let encoding: u32 = 0x02A0000F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_adc_i_a1_a_field_imm12_16_poweroftwo_0_02a00010() {
    // Encoding: 0x02A00010
    // Test aarch32_ADC_i_A1_A field imm12 = 16 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, S=0, imm12=16, Rn=0, Rd=0
    let encoding: u32 = 0x02A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_adc_i_a1_a_field_imm12_31_poweroftwominusone_0_02a0001f() {
    // Encoding: 0x02A0001F
    // Test aarch32_ADC_i_A1_A field imm12 = 31 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rd=0, cond=0, S=0, imm12=31, Rn=0
    let encoding: u32 = 0x02A0001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_adc_i_a1_a_field_imm12_32_poweroftwo_0_02a00020() {
    // Encoding: 0x02A00020
    // Test aarch32_ADC_i_A1_A field imm12 = 32 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rn=0, imm12=32, cond=0, S=0
    let encoding: u32 = 0x02A00020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_adc_i_a1_a_field_imm12_63_poweroftwominusone_0_02a0003f() {
    // Encoding: 0x02A0003F
    // Test aarch32_ADC_i_A1_A field imm12 = 63 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: S=0, Rn=0, cond=0, Rd=0, imm12=63
    let encoding: u32 = 0x02A0003F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_adc_i_a1_a_field_imm12_64_poweroftwo_0_02a00040() {
    // Encoding: 0x02A00040
    // Test aarch32_ADC_i_A1_A field imm12 = 64 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=64, cond=0, Rn=0, Rd=0, S=0
    let encoding: u32 = 0x02A00040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 127, boundary: PowerOfTwoMinusOne }
/// 2^7 - 1 = 127
#[test]
fn test_aarch32_adc_i_a1_a_field_imm12_127_poweroftwominusone_0_02a0007f() {
    // Encoding: 0x02A0007F
    // Test aarch32_ADC_i_A1_A field imm12 = 127 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: S=0, Rd=0, Rn=0, cond=0, imm12=127
    let encoding: u32 = 0x02A0007F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_adc_i_a1_a_field_imm12_128_poweroftwo_0_02a00080() {
    // Encoding: 0x02A00080
    // Test aarch32_ADC_i_A1_A field imm12 = 128 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rd=0, cond=0, imm12=128, S=0
    let encoding: u32 = 0x02A00080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 255, boundary: PowerOfTwoMinusOne }
/// 2^8 - 1 = 255
#[test]
fn test_aarch32_adc_i_a1_a_field_imm12_255_poweroftwominusone_0_02a000ff() {
    // Encoding: 0x02A000FF
    // Test aarch32_ADC_i_A1_A field imm12 = 255 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: S=0, Rn=0, Rd=0, cond=0, imm12=255
    let encoding: u32 = 0x02A000FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 256, boundary: PowerOfTwo }
/// power of 2 (2^8 = 256)
#[test]
fn test_aarch32_adc_i_a1_a_field_imm12_256_poweroftwo_0_02a00100() {
    // Encoding: 0x02A00100
    // Test aarch32_ADC_i_A1_A field imm12 = 256 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, cond=0, imm12=256, Rd=0, Rn=0
    let encoding: u32 = 0x02A00100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 511, boundary: PowerOfTwoMinusOne }
/// 2^9 - 1 = 511
#[test]
fn test_aarch32_adc_i_a1_a_field_imm12_511_poweroftwominusone_0_02a001ff() {
    // Encoding: 0x02A001FF
    // Test aarch32_ADC_i_A1_A field imm12 = 511 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rd=0, Rn=0, cond=0, S=0, imm12=511
    let encoding: u32 = 0x02A001FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 512, boundary: PowerOfTwo }
/// power of 2 (2^9 = 512)
#[test]
fn test_aarch32_adc_i_a1_a_field_imm12_512_poweroftwo_0_02a00200() {
    // Encoding: 0x02A00200
    // Test aarch32_ADC_i_A1_A field imm12 = 512 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, imm12=512, S=0, cond=0, Rd=0
    let encoding: u32 = 0x02A00200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1023, boundary: PowerOfTwoMinusOne }
/// 2^10 - 1 = 1023
#[test]
fn test_aarch32_adc_i_a1_a_field_imm12_1023_poweroftwominusone_0_02a003ff() {
    // Encoding: 0x02A003FF
    // Test aarch32_ADC_i_A1_A field imm12 = 1023 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rd=0, S=0, Rn=0, imm12=1023, cond=0
    let encoding: u32 = 0x02A003FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1024, boundary: PowerOfTwo }
/// power of 2 (2^10 = 1024)
#[test]
fn test_aarch32_adc_i_a1_a_field_imm12_1024_poweroftwo_0_02a00400() {
    // Encoding: 0x02A00400
    // Test aarch32_ADC_i_A1_A field imm12 = 1024 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=1024, Rd=0, S=0, cond=0, Rn=0
    let encoding: u32 = 0x02A00400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2047, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (2047)
#[test]
fn test_aarch32_adc_i_a1_a_field_imm12_2047_poweroftwominusone_0_02a007ff() {
    // Encoding: 0x02A007FF
    // Test aarch32_ADC_i_A1_A field imm12 = 2047 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm12=2047, Rn=0, cond=0, S=0, Rd=0
    let encoding: u32 = 0x02A007FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2048, boundary: PowerOfTwo }
/// power of 2 (2^11 = 2048)
#[test]
fn test_aarch32_adc_i_a1_a_field_imm12_2048_poweroftwo_0_02a00800() {
    // Encoding: 0x02A00800
    // Test aarch32_ADC_i_A1_A field imm12 = 2048 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, Rn=0, Rd=0, imm12=2048, cond=0
    let encoding: u32 = 0x02A00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4095, boundary: Max }
/// maximum immediate (4095)
#[test]
fn test_aarch32_adc_i_a1_a_field_imm12_4095_max_0_02a00fff() {
    // Encoding: 0x02A00FFF
    // Test aarch32_ADC_i_A1_A field imm12 = 4095 (Max)
    // ISET: A32
    // Fields: imm12=4095, cond=0, Rn=0, Rd=0, S=0
    let encoding: u32 = 0x02A00FFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_adc_i_a1_a_combo_0_0_02a00000() {
    // Encoding: 0x02A00000
    // Test aarch32_ADC_i_A1_A field combination: cond=0, S=0, Rn=0, Rd=0, imm12=0
    // ISET: A32
    // Fields: Rn=0, Rd=0, cond=0, S=0, imm12=0
    let encoding: u32 = 0x02A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_adc_i_a1_a_special_cond_0_condition_eq_0_02a00000() {
    // Encoding: 0x02A00000
    // Test aarch32_ADC_i_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: S=0, Rn=0, Rd=0, cond=0, imm12=0
    let encoding: u32 = 0x02A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_adc_i_a1_a_special_cond_1_condition_ne_0_12a00000() {
    // Encoding: 0x12A00000
    // Test aarch32_ADC_i_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: Rn=0, imm12=0, S=0, Rd=0, cond=1
    let encoding: u32 = 0x12A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_adc_i_a1_a_special_cond_2_condition_cs_hs_0_22a00000() {
    // Encoding: 0x22A00000
    // Test aarch32_ADC_i_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: imm12=0, Rn=0, cond=2, S=0, Rd=0
    let encoding: u32 = 0x22A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_adc_i_a1_a_special_cond_3_condition_cc_lo_0_32a00000() {
    // Encoding: 0x32A00000
    // Test aarch32_ADC_i_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: S=0, cond=3, Rn=0, Rd=0, imm12=0
    let encoding: u32 = 0x32A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_adc_i_a1_a_special_cond_4_condition_mi_0_42a00000() {
    // Encoding: 0x42A00000
    // Test aarch32_ADC_i_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: S=0, Rn=0, cond=4, Rd=0, imm12=0
    let encoding: u32 = 0x42A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_adc_i_a1_a_special_cond_5_condition_pl_0_52a00000() {
    // Encoding: 0x52A00000
    // Test aarch32_ADC_i_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: cond=5, Rd=0, Rn=0, S=0, imm12=0
    let encoding: u32 = 0x52A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_adc_i_a1_a_special_cond_6_condition_vs_0_62a00000() {
    // Encoding: 0x62A00000
    // Test aarch32_ADC_i_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: cond=6, imm12=0, Rn=0, S=0, Rd=0
    let encoding: u32 = 0x62A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_adc_i_a1_a_special_cond_7_condition_vc_0_72a00000() {
    // Encoding: 0x72A00000
    // Test aarch32_ADC_i_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: S=0, Rn=0, Rd=0, imm12=0, cond=7
    let encoding: u32 = 0x72A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_adc_i_a1_a_special_cond_8_condition_hi_0_82a00000() {
    // Encoding: 0x82A00000
    // Test aarch32_ADC_i_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: Rd=0, cond=8, imm12=0, S=0, Rn=0
    let encoding: u32 = 0x82A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_adc_i_a1_a_special_cond_9_condition_ls_0_92a00000() {
    // Encoding: 0x92A00000
    // Test aarch32_ADC_i_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: Rn=0, Rd=0, S=0, imm12=0, cond=9
    let encoding: u32 = 0x92A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_adc_i_a1_a_special_cond_10_condition_ge_0_a2a00000() {
    // Encoding: 0xA2A00000
    // Test aarch32_ADC_i_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: cond=10, imm12=0, Rn=0, Rd=0, S=0
    let encoding: u32 = 0xA2A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_adc_i_a1_a_special_cond_11_condition_lt_0_b2a00000() {
    // Encoding: 0xB2A00000
    // Test aarch32_ADC_i_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: S=0, Rn=0, Rd=0, imm12=0, cond=11
    let encoding: u32 = 0xB2A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_adc_i_a1_a_special_cond_12_condition_gt_0_c2a00000() {
    // Encoding: 0xC2A00000
    // Test aarch32_ADC_i_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: S=0, cond=12, imm12=0, Rd=0, Rn=0
    let encoding: u32 = 0xC2A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_adc_i_a1_a_special_cond_13_condition_le_0_d2a00000() {
    // Encoding: 0xD2A00000
    // Test aarch32_ADC_i_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: imm12=0, cond=13, Rn=0, S=0, Rd=0
    let encoding: u32 = 0xD2A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_adc_i_a1_a_special_cond_14_condition_al_0_e2a00000() {
    // Encoding: 0xE2A00000
    // Test aarch32_ADC_i_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: imm12=0, S=0, Rn=0, Rd=0, cond=14
    let encoding: u32 = 0xE2A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_adc_i_a1_a_special_cond_15_condition_nv_0_f2a00000() {
    // Encoding: 0xF2A00000
    // Test aarch32_ADC_i_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: imm12=0, Rd=0, cond=15, Rn=0, S=0
    let encoding: u32 = 0xF2A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `field S = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "S", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_adc_i_a1_a_special_s_0_size_variant_0_0_02a00000() {
    // Encoding: 0x02A00000
    // Test aarch32_ADC_i_A1_A special value S = 0 (Size variant 0)
    // ISET: A32
    // Fields: S=0, imm12=0, Rd=0, Rn=0, cond=0
    let encoding: u32 = 0x02A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `field S = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "S", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_adc_i_a1_a_special_s_1_size_variant_1_0_02b00000() {
    // Encoding: 0x02B00000
    // Test aarch32_ADC_i_A1_A special value S = 1 (Size variant 1)
    // ISET: A32
    // Fields: imm12=0, Rd=0, cond=0, Rn=0, S=1
    let encoding: u32 = 0x02B00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `field i 26 +: 1`
/// Requirement: FieldBoundary { field: "i", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_adc_i_t1_a_field_i_0_min_0_f1400000() {
    // Thumb encoding (32): 0xF1400000
    // Test aarch32_ADC_i_T1_A field i = 0 (Min)
    // ISET: T32
    // Fields: imm3=0, imm8=0, i=0, Rn=0, Rd=0, S=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `field i 26 +: 1`
/// Requirement: FieldBoundary { field: "i", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_adc_i_t1_a_field_i_1_max_0_f5400000() {
    // Thumb encoding (32): 0xF5400000
    // Test aarch32_ADC_i_T1_A field i = 1 (Max)
    // ISET: T32
    // Fields: imm8=0, Rd=0, imm3=0, Rn=0, S=0, i=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF5400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_adc_i_t1_a_field_s_0_min_0_f1400000() {
    // Thumb encoding (32): 0xF1400000
    // Test aarch32_ADC_i_T1_A field S = 0 (Min)
    // ISET: T32
    // Fields: S=0, imm3=0, Rd=0, imm8=0, i=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_adc_i_t1_a_field_s_1_max_0_f1500000() {
    // Thumb encoding (32): 0xF1500000
    // Test aarch32_ADC_i_T1_A field S = 1 (Max)
    // ISET: T32
    // Fields: i=0, Rd=0, S=1, Rn=0, imm8=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1500000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_adc_i_t1_a_field_rn_0_min_0_f1400000() {
    // Thumb encoding (32): 0xF1400000
    // Test aarch32_ADC_i_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rd=0, imm3=0, i=0, imm8=0, S=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_adc_i_t1_a_field_rn_1_poweroftwo_0_f1410000() {
    // Thumb encoding (32): 0xF1410000
    // Test aarch32_ADC_i_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: S=0, imm3=0, Rd=0, imm8=0, Rn=1, i=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1410000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_adc_i_t1_a_field_imm3_0_zero_0_f1400000() {
    // Thumb encoding (32): 0xF1400000
    // Test aarch32_ADC_i_T1_A field imm3 = 0 (Zero)
    // ISET: T32
    // Fields: imm8=0, Rn=0, S=0, i=0, imm3=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_adc_i_t1_a_field_imm3_1_poweroftwo_0_f1401000() {
    // Thumb encoding (32): 0xF1401000
    // Test aarch32_ADC_i_T1_A field imm3 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: i=0, imm3=1, Rn=0, S=0, imm8=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1401000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 3, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (3)
#[test]
fn test_aarch32_adc_i_t1_a_field_imm3_3_poweroftwominusone_0_f1403000() {
    // Thumb encoding (32): 0xF1403000
    // Test aarch32_ADC_i_T1_A field imm3 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: S=0, Rd=0, Rn=0, imm3=3, imm8=0, i=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1403000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 7, boundary: Max }
/// maximum immediate (7)
#[test]
fn test_aarch32_adc_i_t1_a_field_imm3_7_max_0_f1407000() {
    // Thumb encoding (32): 0xF1407000
    // Test aarch32_ADC_i_T1_A field imm3 = 7 (Max)
    // ISET: T32
    // Fields: imm8=0, Rn=0, i=0, S=0, imm3=7, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1407000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_adc_i_t1_a_field_rd_0_min_0_f1400000() {
    // Thumb encoding (32): 0xF1400000
    // Test aarch32_ADC_i_T1_A field Rd = 0 (Min)
    // ISET: T32
    // Fields: S=0, i=0, Rn=0, imm3=0, Rd=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_adc_i_t1_a_field_rd_1_poweroftwo_0_f1400100() {
    // Thumb encoding (32): 0xF1400100
    // Test aarch32_ADC_i_T1_A field Rd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, S=0, i=0, imm8=0, imm3=0, Rd=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1400100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_adc_i_t1_a_field_imm8_0_zero_0_f1400000() {
    // Thumb encoding (32): 0xF1400000
    // Test aarch32_ADC_i_T1_A field imm8 = 0 (Zero)
    // ISET: T32
    // Fields: Rd=0, i=0, Rn=0, imm3=0, S=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_adc_i_t1_a_field_imm8_1_poweroftwo_0_f1400001() {
    // Thumb encoding (32): 0xF1400001
    // Test aarch32_ADC_i_T1_A field imm8 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: i=0, imm3=0, S=0, Rn=0, Rd=0, imm8=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1400001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_adc_i_t1_a_field_imm8_3_poweroftwominusone_0_f1400003() {
    // Thumb encoding (32): 0xF1400003
    // Test aarch32_ADC_i_T1_A field imm8 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: i=0, Rn=0, S=0, Rd=0, imm3=0, imm8=3
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1400003;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_adc_i_t1_a_field_imm8_4_poweroftwo_0_f1400004() {
    // Thumb encoding (32): 0xF1400004
    // Test aarch32_ADC_i_T1_A field imm8 = 4 (PowerOfTwo)
    // ISET: T32
    // Fields: S=0, i=0, Rd=0, imm8=4, Rn=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1400004;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_adc_i_t1_a_field_imm8_7_poweroftwominusone_0_f1400007() {
    // Thumb encoding (32): 0xF1400007
    // Test aarch32_ADC_i_T1_A field imm8 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm3=0, Rd=0, i=0, S=0, Rn=0, imm8=7
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1400007;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_adc_i_t1_a_field_imm8_8_poweroftwo_0_f1400008() {
    // Thumb encoding (32): 0xF1400008
    // Test aarch32_ADC_i_T1_A field imm8 = 8 (PowerOfTwo)
    // ISET: T32
    // Fields: S=0, Rn=0, i=0, imm3=0, Rd=0, imm8=8
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1400008;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_adc_i_t1_a_field_imm8_15_poweroftwominusone_0_f140000f() {
    // Thumb encoding (32): 0xF140000F
    // Test aarch32_ADC_i_T1_A field imm8 = 15 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: i=0, imm8=15, Rn=0, S=0, imm3=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF140000F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_adc_i_t1_a_field_imm8_16_poweroftwo_0_f1400010() {
    // Thumb encoding (32): 0xF1400010
    // Test aarch32_ADC_i_T1_A field imm8 = 16 (PowerOfTwo)
    // ISET: T32
    // Fields: S=0, Rn=0, imm3=0, i=0, Rd=0, imm8=16
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1400010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_adc_i_t1_a_field_imm8_31_poweroftwominusone_0_f140001f() {
    // Thumb encoding (32): 0xF140001F
    // Test aarch32_ADC_i_T1_A field imm8 = 31 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm3=0, Rd=0, imm8=31, S=0, i=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF140001F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_adc_i_t1_a_field_imm8_32_poweroftwo_0_f1400020() {
    // Thumb encoding (32): 0xF1400020
    // Test aarch32_ADC_i_T1_A field imm8 = 32 (PowerOfTwo)
    // ISET: T32
    // Fields: S=0, i=0, Rd=0, Rn=0, imm3=0, imm8=32
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1400020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_adc_i_t1_a_field_imm8_63_poweroftwominusone_0_f140003f() {
    // Thumb encoding (32): 0xF140003F
    // Test aarch32_ADC_i_T1_A field imm8 = 63 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm8=63, Rn=0, i=0, S=0, imm3=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF140003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_adc_i_t1_a_field_imm8_64_poweroftwo_0_f1400040() {
    // Thumb encoding (32): 0xF1400040
    // Test aarch32_ADC_i_T1_A field imm8 = 64 (PowerOfTwo)
    // ISET: T32
    // Fields: i=0, S=0, Rn=0, imm8=64, imm3=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1400040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 127, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (127)
#[test]
fn test_aarch32_adc_i_t1_a_field_imm8_127_poweroftwominusone_0_f140007f() {
    // Thumb encoding (32): 0xF140007F
    // Test aarch32_ADC_i_T1_A field imm8 = 127 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, i=0, imm3=0, S=0, Rd=0, imm8=127
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF140007F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_adc_i_t1_a_field_imm8_128_poweroftwo_0_f1400080() {
    // Thumb encoding (32): 0xF1400080
    // Test aarch32_ADC_i_T1_A field imm8 = 128 (PowerOfTwo)
    // ISET: T32
    // Fields: S=0, imm3=0, i=0, Rn=0, Rd=0, imm8=128
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1400080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 255, boundary: Max }
/// maximum immediate (255)
#[test]
fn test_aarch32_adc_i_t1_a_field_imm8_255_max_0_f14000ff() {
    // Thumb encoding (32): 0xF14000FF
    // Test aarch32_ADC_i_T1_A field imm8 = 255 (Max)
    // ISET: T32
    // Fields: i=0, imm8=255, Rn=0, imm3=0, Rd=0, S=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF14000FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// i=0 (minimum value)
#[test]
fn test_aarch32_adc_i_t1_a_combo_0_0_f1400000() {
    // Thumb encoding (32): 0xF1400000
    // Test aarch32_ADC_i_T1_A field combination: i=0, S=0, Rn=0, imm3=0, Rd=0, imm8=0
    // ISET: T32
    // Fields: Rd=0, imm8=0, i=0, S=0, Rn=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `field S = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "S", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_adc_i_t1_a_special_s_0_size_variant_0_0_f1400000() {
    // Thumb encoding (32): 0xF1400000
    // Test aarch32_ADC_i_T1_A special value S = 0 (Size variant 0)
    // ISET: T32
    // Fields: i=0, S=0, imm3=0, Rd=0, imm8=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `field S = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "S", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_adc_i_t1_a_special_s_1_size_variant_1_0_f1500000() {
    // Thumb encoding (32): 0xF1500000
    // Test aarch32_ADC_i_T1_A special value S = 1 (Size variant 1)
    // ISET: T32
    // Fields: i=0, imm8=0, Rd=0, imm3=0, Rn=0, S=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1500000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_adc_i_t1_a_invalid_0_0_f1400000() {
    // Thumb encoding (32): 0xF1400000
    // Test aarch32_ADC_i_T1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }
    // ISET: T32
    // Fields: imm8=0, S=0, Rn=0, imm3=0, i=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1400000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_adc_i_t1_a_invalid_1_0_f1400000() {
    // Thumb encoding (32): 0xF1400000
    // Test aarch32_ADC_i_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: imm8=0, S=0, imm3=0, i=0, Rn=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1400000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `ADD X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_adc_i_a1_a_add_oracle_32_0_02a02820() {
    // Test ADD 32-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0x02A02820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x02A02820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x86E, "W0 should be 0x86E");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `ADD X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_adc_i_a1_a_add_oracle_64_0_82a02820() {
    // Test ADD 64-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0x82A02820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x82A02820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x86E, "X0 should be 0x000000000000086E");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `ADD X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero operands (32)
#[test]
fn test_aarch32_adc_i_a1_a_add_oracle_32_1_02a00020() {
    // Test ADD 32-bit: zero operands (with oracle verification)
    // Encoding: 0x02A00020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x02A00020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x800, "W0 should be 0x800");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `ADD X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero operands (64)
#[test]
fn test_aarch32_adc_i_a1_a_add_oracle_64_1_82a00020() {
    // Test ADD 64-bit: zero operands (with oracle verification)
    // Encoding: 0x82A00020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x82A00020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x800, "X0 should be 0x0000000000000800");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small values (32)
#[test]
fn test_aarch32_adc_i_a1_a_add_oracle_32_2_02a00420() {
    // Test ADD 32-bit: small values (with oracle verification)
    // Encoding: 0x02A00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x02A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x802, "W0 should be 0x802");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// small values (64)
#[test]
fn test_aarch32_adc_i_a1_a_add_oracle_64_2_82a00420() {
    // Test ADD 64-bit: small values (with oracle verification)
    // Encoding: 0x82A00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x82A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x802, "X0 should be 0x0000000000000802");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `ADD X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_adc_i_a1_a_add_oracle_32_3_02bffc20() {
    // Test ADD 32-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0x02BFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x02BFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF, "W0 should be 0xFFF");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `ADD X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_adc_i_a1_a_add_oracle_64_3_82bffc20() {
    // Test ADD 64-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0x82BFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x82BFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF, "X0 should be 0x0000000000000FFF");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `ADD X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_adc_i_a1_a_add_oracle_32_4_02fffc20() {
    // Test ADD 32-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0x02FFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x02FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF000, "W0 should be 0xFFF000");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `ADD X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_adc_i_a1_a_add_oracle_64_4_82fffc20() {
    // Test ADD 64-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0x82FFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x82FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF000, "X0 should be 0x0000000000FFF000");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max u64 operand (32)
#[test]
fn test_aarch32_adc_i_a1_a_add_oracle_32_5_02a00420() {
    // Test ADD 32-bit: max u64 operand (with oracle verification)
    // Encoding: 0x02A00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x02A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x800, "W0 should be 0x800");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max u64 operand (64)
#[test]
fn test_aarch32_adc_i_a1_a_add_oracle_64_5_82a00420() {
    // Test ADD 64-bit: max u64 operand (with oracle verification)
    // Encoding: 0x82A00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x82A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x800, "X0 should be 0x0000000000000800");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_adc_i_a1_a_add_oracle_32_6_02a00420() {
    // Test ADD 32-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0x02A00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x02A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x801, "W0 should be 0x801");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_adc_i_a1_a_add_oracle_64_6_82a00420() {
    // Test ADD 64-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0x82A00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x82A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x801, "X0 should be 0x0000000000000801");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_adc_i_a1_a_add_oracle_32_7_02a00420() {
    // Test ADD 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0x02A00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x02A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x800, "W0 should be 0x800");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_adc_i_a1_a_add_oracle_64_7_82a00420() {
    // Test ADD 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0x82A00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x82A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x800, "X0 should be 0x8000000000000800");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_adc_i_a1_a_add_oracle_32_8_02a00420() {
    // Test ADD 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0x02A00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x02A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000800, "W0 should be 0x80000800");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_adc_i_a1_a_add_oracle_64_8_82a00420() {
    // Test ADD 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0x82A00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x82A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x80000800,
        "X0 should be 0x0000000080000800"
    );
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_adc_i_a1_a_add_oracle_32_9_02a00420() {
    // Test ADD 32-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0x02A00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x02A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x800, "W0 should be 0x800");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_adc_i_a1_a_add_oracle_64_9_82a00420() {
    // Test ADD 64-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0x82A00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x82A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x800, "X0 should be 0x0000000000000800");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_adc_i_a1_a_add_oracle_32_10_02a00420() {
    // Test ADD 32-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0x02A00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x02A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x800, "W0 should be 0x800");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_adc_i_a1_a_add_oracle_64_10_82a00420() {
    // Test ADD 64-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0x82A00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x82A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x800, "X0 should be 0x0000000100000800");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `ADD SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (32)
#[test]
fn test_aarch32_adc_i_a1_a_add_oracle_32_rd31_sp_02a0283f() {
    // Test ADD 32-bit with Rd=31 (SP)
    // Encoding: 0x02A0283F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x02A0283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    // TODO: assertion - TestAssertion { check: Sp, expected: U64(2158), message: "SP should be 0x86E" }
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `ADD SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (64)
#[test]
fn test_aarch32_adc_i_a1_a_add_oracle_64_rd31_sp_82a0283f() {
    // Test ADD 64-bit with Rd=31 (SP)
    // Encoding: 0x82A0283F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x82A0283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    // TODO: assertion - TestAssertion { check: Sp, expected: U64(2158), message: "SP should be 0x86E" }
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `ADDS X0, X1, #10`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_adc_i_a1_a_adds_oracle_32_0_22a02820() {
    // Test ADDS 32-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0x22A02820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x22A02820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x86E, "W0 should be 0x86E");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `ADDS X0, X1, #10`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_adc_i_a1_a_adds_oracle_64_0_a2a02820() {
    // Test ADDS 64-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0xA2A02820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xA2A02820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x86E, "X0 should be 0x000000000000086E");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `ADDS X0, X1, #0`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero operands (32)
#[test]
fn test_aarch32_adc_i_a1_a_adds_oracle_32_1_22a00020() {
    // Test ADDS 32-bit: zero operands (with oracle verification)
    // Encoding: 0x22A00020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x22A00020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x800, "W0 should be 0x800");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `ADDS X0, X1, #0`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero operands (64)
#[test]
fn test_aarch32_adc_i_a1_a_adds_oracle_64_1_a2a00020() {
    // Test ADDS 64-bit: zero operands (with oracle verification)
    // Encoding: 0xA2A00020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xA2A00020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x800, "X0 should be 0x0000000000000800");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// small values (32)
#[test]
fn test_aarch32_adc_i_a1_a_adds_oracle_32_2_22a00420() {
    // Test ADDS 32-bit: small values (with oracle verification)
    // Encoding: 0x22A00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x22A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x802, "W0 should be 0x802");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// small values (64)
#[test]
fn test_aarch32_adc_i_a1_a_adds_oracle_64_2_a2a00420() {
    // Test ADDS 64-bit: small values (with oracle verification)
    // Encoding: 0xA2A00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xA2A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x802, "X0 should be 0x0000000000000802");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `ADDS X0, X1, #4095`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_adc_i_a1_a_adds_oracle_32_3_22bffc20() {
    // Test ADDS 32-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0x22BFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x22BFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF, "W0 should be 0xFFF");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `ADDS X0, X1, #4095`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_adc_i_a1_a_adds_oracle_64_3_a2bffc20() {
    // Test ADDS 64-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0xA2BFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xA2BFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF, "X0 should be 0x0000000000000FFF");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `ADDS X0, X1, #4095, LSL #12`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_adc_i_a1_a_adds_oracle_32_4_22fffc20() {
    // Test ADDS 32-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0x22FFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x22FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF000, "W0 should be 0xFFF000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `ADDS X0, X1, #4095, LSL #12`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_adc_i_a1_a_adds_oracle_64_4_a2fffc20() {
    // Test ADDS 64-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0xA2FFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xA2FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF000, "X0 should be 0x0000000000FFF000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max u64 operand (32)
#[test]
fn test_aarch32_adc_i_a1_a_adds_oracle_32_5_22a00420() {
    // Test ADDS 32-bit: max u64 operand (with oracle verification)
    // Encoding: 0x22A00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x22A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x800, "W0 should be 0x800");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max u64 operand (64)
#[test]
fn test_aarch32_adc_i_a1_a_adds_oracle_64_5_a2a00420() {
    // Test ADDS 64-bit: max u64 operand (with oracle verification)
    // Encoding: 0xA2A00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xA2A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x800, "X0 should be 0x0000000000000800");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_adc_i_a1_a_adds_oracle_32_6_22a00420() {
    // Test ADDS 32-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0x22A00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x22A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x801, "W0 should be 0x801");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_adc_i_a1_a_adds_oracle_64_6_a2a00420() {
    // Test ADDS 64-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0xA2A00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xA2A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x801, "X0 should be 0x0000000000000801");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_adc_i_a1_a_adds_oracle_32_7_22a00420() {
    // Test ADDS 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0x22A00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x22A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x800, "W0 should be 0x800");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_adc_i_a1_a_adds_oracle_64_7_a2a00420() {
    // Test ADDS 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0xA2A00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xA2A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x800, "X0 should be 0x8000000000000800");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, true, "V flag should be true");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_adc_i_a1_a_adds_oracle_32_8_22a00420() {
    // Test ADDS 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0x22A00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x22A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000800, "W0 should be 0x80000800");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, true, "V flag should be true");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_adc_i_a1_a_adds_oracle_64_8_a2a00420() {
    // Test ADDS 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0xA2A00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xA2A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x80000800,
        "X0 should be 0x0000000080000800"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_adc_i_a1_a_adds_oracle_32_9_22a00420() {
    // Test ADDS 32-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0x22A00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x22A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x800, "W0 should be 0x800");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_adc_i_a1_a_adds_oracle_64_9_a2a00420() {
    // Test ADDS 64-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0xA2A00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xA2A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x800, "X0 should be 0x0000000000000800");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_adc_i_a1_a_adds_oracle_32_10_22a00420() {
    // Test ADDS 32-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0x22A00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x22A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x800, "W0 should be 0x800");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_adc_i_a1_a_adds_oracle_64_10_a2a00420() {
    // Test ADDS 64-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0xA2A00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xA2A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x800, "X0 should be 0x0000000100000800");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `ADDS ZR, X1, #10`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "result discarded, flags set" }
/// ZR destination (32)
#[test]
fn test_aarch32_adc_i_a1_a_adds_oracle_32_rd31_zr_22a0283f() {
    // Test ADDS 32-bit with Rd=31 (ZR)
    // Encoding: 0x22A0283F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x22A0283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `ADDS ZR, X1, #10`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "result discarded, flags set" }
/// ZR destination (64)
#[test]
fn test_aarch32_adc_i_a1_a_adds_oracle_64_rd31_zr_a2a0283f() {
    // Test ADDS 64-bit with Rd=31 (ZR)
    // Encoding: 0xA2A0283F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xA2A0283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `SUB X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_adc_i_a1_a_sub_oracle_32_0_42a02820() {
    // Test SUB 32-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0x42A02820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x42A02820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFF85A, "W0 should be 0xFFFFF85A");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `SUB X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_adc_i_a1_a_sub_oracle_64_0_c2a02820() {
    // Test SUB 64-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0xC2A02820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xC2A02820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF85A,
        "X0 should be 0xFFFFFFFFFFFFF85A"
    );
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `SUB X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero operands (32)
#[test]
fn test_aarch32_adc_i_a1_a_sub_oracle_32_1_42a00020() {
    // Test SUB 32-bit: zero operands (with oracle verification)
    // Encoding: 0x42A00020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x42A00020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFF800, "W0 should be 0xFFFFF800");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `SUB X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero operands (64)
#[test]
fn test_aarch32_adc_i_a1_a_sub_oracle_64_1_c2a00020() {
    // Test SUB 64-bit: zero operands (with oracle verification)
    // Encoding: 0xC2A00020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xC2A00020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF800,
        "X0 should be 0xFFFFFFFFFFFFF800"
    );
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small values (32)
#[test]
fn test_aarch32_adc_i_a1_a_sub_oracle_32_2_42a00420() {
    // Test SUB 32-bit: small values (with oracle verification)
    // Encoding: 0x42A00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x42A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFF800, "W0 should be 0xFFFFF800");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// small values (64)
#[test]
fn test_aarch32_adc_i_a1_a_sub_oracle_64_2_c2a00420() {
    // Test SUB 64-bit: small values (with oracle verification)
    // Encoding: 0xC2A00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xC2A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF800,
        "X0 should be 0xFFFFFFFFFFFFF800"
    );
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `SUB X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_adc_i_a1_a_sub_oracle_32_3_42bffc20() {
    // Test SUB 32-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0x42BFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x42BFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFF001, "W0 should be 0xFFFFF001");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `SUB X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_adc_i_a1_a_sub_oracle_64_3_c2bffc20() {
    // Test SUB 64-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0xC2BFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xC2BFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `SUB X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_adc_i_a1_a_sub_oracle_32_4_42fffc20() {
    // Test SUB 32-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0x42FFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x42FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF001000, "W0 should be 0xFF001000");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `SUB X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_adc_i_a1_a_sub_oracle_64_4_c2fffc20() {
    // Test SUB 64-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0xC2FFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xC2FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max u64 operand (32)
#[test]
fn test_aarch32_adc_i_a1_a_sub_oracle_32_5_42a00420() {
    // Test SUB 32-bit: max u64 operand (with oracle verification)
    // Encoding: 0x42A00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x42A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFF7FE, "W0 should be 0xFFFFF7FE");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max u64 operand (64)
#[test]
fn test_aarch32_adc_i_a1_a_sub_oracle_64_5_c2a00420() {
    // Test SUB 64-bit: max u64 operand (with oracle verification)
    // Encoding: 0xC2A00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xC2A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF7FE,
        "X0 should be 0xFFFFFFFFFFFFF7FE"
    );
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_adc_i_a1_a_sub_oracle_32_6_42a00420() {
    // Test SUB 32-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0x42A00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x42A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFF7FF, "W0 should be 0xFFFFF7FF");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_adc_i_a1_a_sub_oracle_64_6_c2a00420() {
    // Test SUB 64-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0xC2A00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xC2A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF7FF,
        "X0 should be 0xFFFFFFFFFFFFF7FF"
    );
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_adc_i_a1_a_sub_oracle_32_7_42a00420() {
    // Test SUB 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0x42A00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x42A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFF7FE, "W0 should be 0xFFFFF7FE");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_adc_i_a1_a_sub_oracle_64_7_c2a00420() {
    // Test SUB 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0xC2A00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xC2A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF7FE,
        "X0 should be 0x7FFFFFFFFFFFF7FE"
    );
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_adc_i_a1_a_sub_oracle_32_8_42a00420() {
    // Test SUB 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0x42A00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x42A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FFFF7FE, "W0 should be 0x7FFFF7FE");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_adc_i_a1_a_sub_oracle_64_8_c2a00420() {
    // Test SUB 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0xC2A00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xC2A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x7FFFF7FE,
        "X0 should be 0x000000007FFFF7FE"
    );
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_adc_i_a1_a_sub_oracle_32_9_42a00420() {
    // Test SUB 32-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0x42A00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x42A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFF7FE, "W0 should be 0xFFFFF7FE");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_adc_i_a1_a_sub_oracle_64_9_c2a00420() {
    // Test SUB 64-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0xC2A00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xC2A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF7FE,
        "X0 should be 0xFFFFFFFFFFFFF7FE"
    );
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_adc_i_a1_a_sub_oracle_32_10_42a00420() {
    // Test SUB 32-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0x42A00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x42A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFF7FE, "W0 should be 0xFFFFF7FE");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_adc_i_a1_a_sub_oracle_64_10_c2a00420() {
    // Test SUB 64-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0xC2A00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xC2A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF7FE,
        "X0 should be 0x00000000FFFFF7FE"
    );
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `SUB SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (32)
#[test]
fn test_aarch32_adc_i_a1_a_sub_oracle_32_rd31_sp_42a0283f() {
    // Test SUB 32-bit with Rd=31 (SP)
    // Encoding: 0x42A0283F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x42A0283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    // TODO: assertion - TestAssertion { check: Sp, expected: U64(4294965338), message: "SP should be 0xFFFFF85A" }
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `SUB SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (64)
#[test]
fn test_aarch32_adc_i_a1_a_sub_oracle_64_rd31_sp_c2a0283f() {
    // Test SUB 64-bit with Rd=31 (SP)
    // Encoding: 0xC2A0283F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xC2A0283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    // TODO: assertion - TestAssertion { check: Sp, expected: U64(18446744073709549658), message: "SP should be 0xFFFFFFFFFFFFF85A" }
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `SUBS X0, X1, #10`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_adc_i_a1_a_subs_oracle_32_0_62a02820() {
    // Test SUBS 32-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0x62A02820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x62A02820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFF85A, "W0 should be 0xFFFFF85A");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `SUBS X0, X1, #10`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_adc_i_a1_a_subs_oracle_64_0_e2a02820() {
    // Test SUBS 64-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0xE2A02820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xE2A02820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF85A,
        "X0 should be 0xFFFFFFFFFFFFF85A"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `SUBS X0, X1, #0`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero operands (32)
#[test]
fn test_aarch32_adc_i_a1_a_subs_oracle_32_1_62a00020() {
    // Test SUBS 32-bit: zero operands (with oracle verification)
    // Encoding: 0x62A00020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x62A00020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFF800, "W0 should be 0xFFFFF800");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `SUBS X0, X1, #0`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero operands (64)
#[test]
fn test_aarch32_adc_i_a1_a_subs_oracle_64_1_e2a00020() {
    // Test SUBS 64-bit: zero operands (with oracle verification)
    // Encoding: 0xE2A00020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xE2A00020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF800,
        "X0 should be 0xFFFFFFFFFFFFF800"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// small values (32)
#[test]
fn test_aarch32_adc_i_a1_a_subs_oracle_32_2_62a00420() {
    // Test SUBS 32-bit: small values (with oracle verification)
    // Encoding: 0x62A00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x62A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFF800, "W0 should be 0xFFFFF800");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// small values (64)
#[test]
fn test_aarch32_adc_i_a1_a_subs_oracle_64_2_e2a00420() {
    // Test SUBS 64-bit: small values (with oracle verification)
    // Encoding: 0xE2A00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xE2A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF800,
        "X0 should be 0xFFFFFFFFFFFFF800"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `SUBS X0, X1, #4095`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_adc_i_a1_a_subs_oracle_32_3_62bffc20() {
    // Test SUBS 32-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0x62BFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x62BFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFF001, "W0 should be 0xFFFFF001");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `SUBS X0, X1, #4095`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_adc_i_a1_a_subs_oracle_64_3_e2bffc20() {
    // Test SUBS 64-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0xE2BFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xE2BFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `SUBS X0, X1, #4095, LSL #12`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_adc_i_a1_a_subs_oracle_32_4_62fffc20() {
    // Test SUBS 32-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0x62FFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x62FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF001000, "W0 should be 0xFF001000");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `SUBS X0, X1, #4095, LSL #12`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_adc_i_a1_a_subs_oracle_64_4_e2fffc20() {
    // Test SUBS 64-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0xE2FFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xE2FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max u64 operand (32)
#[test]
fn test_aarch32_adc_i_a1_a_subs_oracle_32_5_62a00420() {
    // Test SUBS 32-bit: max u64 operand (with oracle verification)
    // Encoding: 0x62A00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x62A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFF7FE, "W0 should be 0xFFFFF7FE");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max u64 operand (64)
#[test]
fn test_aarch32_adc_i_a1_a_subs_oracle_64_5_e2a00420() {
    // Test SUBS 64-bit: max u64 operand (with oracle verification)
    // Encoding: 0xE2A00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xE2A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF7FE,
        "X0 should be 0xFFFFFFFFFFFFF7FE"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_adc_i_a1_a_subs_oracle_32_6_62a00420() {
    // Test SUBS 32-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0x62A00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x62A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFF7FF, "W0 should be 0xFFFFF7FF");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_adc_i_a1_a_subs_oracle_64_6_e2a00420() {
    // Test SUBS 64-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0xE2A00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xE2A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF7FF,
        "X0 should be 0xFFFFFFFFFFFFF7FF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_adc_i_a1_a_subs_oracle_32_7_62a00420() {
    // Test SUBS 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0x62A00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x62A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFF7FE, "W0 should be 0xFFFFF7FE");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_adc_i_a1_a_subs_oracle_64_7_e2a00420() {
    // Test SUBS 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0xE2A00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xE2A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF7FE,
        "X0 should be 0x7FFFFFFFFFFFF7FE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_adc_i_a1_a_subs_oracle_32_8_62a00420() {
    // Test SUBS 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0x62A00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x62A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FFFF7FE, "W0 should be 0x7FFFF7FE");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_adc_i_a1_a_subs_oracle_64_8_e2a00420() {
    // Test SUBS 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0xE2A00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xE2A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x7FFFF7FE,
        "X0 should be 0x000000007FFFF7FE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_adc_i_a1_a_subs_oracle_32_9_62a00420() {
    // Test SUBS 32-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0x62A00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x62A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFF7FE, "W0 should be 0xFFFFF7FE");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_adc_i_a1_a_subs_oracle_64_9_e2a00420() {
    // Test SUBS 64-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0xE2A00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xE2A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF7FE,
        "X0 should be 0xFFFFFFFFFFFFF7FE"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_adc_i_a1_a_subs_oracle_32_10_62a00420() {
    // Test SUBS 32-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0x62A00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x62A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFF7FE, "W0 should be 0xFFFFF7FE");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_adc_i_a1_a_subs_oracle_64_10_e2a00420() {
    // Test SUBS 64-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0xE2A00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xE2A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF7FE,
        "X0 should be 0x00000000FFFFF7FE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `SUBS ZR, X1, #10`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "result discarded, flags set" }
/// ZR destination (32)
#[test]
fn test_aarch32_adc_i_a1_a_subs_oracle_32_rd31_zr_62a0283f() {
    // Test SUBS 32-bit with Rd=31 (ZR)
    // Encoding: 0x62A0283F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x62A0283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `SUBS ZR, X1, #10`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "result discarded, flags set" }
/// ZR destination (64)
#[test]
fn test_aarch32_adc_i_a1_a_subs_oracle_64_rd31_zr_e2a0283f() {
    // Test SUBS 64-bit with Rd=31 (ZR)
    // Encoding: 0xE2A0283F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xE2A0283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `ADD R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x00000000)
#[test]
fn test_aarch32_adc_i_a1_a_a32_add_sub_imm_0_0_0281000a() {
    // Test A32 ADD: small immediate (oracle)
    // Encoding: 0x0281000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x0281000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA, "R0 should be 0x0000000A");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `ADD R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x00000064)
#[test]
fn test_aarch32_adc_i_a1_a_a32_add_sub_imm_0_64_0281000a() {
    // Test A32 ADD: small immediate (oracle)
    // Encoding: 0x0281000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x0281000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6E, "R0 should be 0x0000006E");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `ADD R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_adc_i_a1_a_a32_add_sub_imm_0_7fffffff_0281000a() {
    // Test A32 ADD: small immediate (oracle)
    // Encoding: 0x0281000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x0281000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000009, "R0 should be 0x80000009");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `ADD R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x80000000)
#[test]
fn test_aarch32_adc_i_a1_a_a32_add_sub_imm_0_80000000_0281000a() {
    // Test A32 ADD: small immediate (oracle)
    // Encoding: 0x0281000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0x0281000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x8000000A, "R0 should be 0x8000000A");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `ADD R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_adc_i_a1_a_a32_add_sub_imm_0_ffffffff_0281000a() {
    // Test A32 ADD: small immediate (oracle)
    // Encoding: 0x0281000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x0281000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x9, "R0 should be 0x00000009");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `ADD R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x00000000)
#[test]
fn test_aarch32_adc_i_a1_a_a32_add_sub_imm_1_0_028100ff() {
    // Test A32 ADD: max imm8 (oracle)
    // Encoding: 0x028100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x028100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `ADD R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x00000064)
#[test]
fn test_aarch32_adc_i_a1_a_a32_add_sub_imm_1_64_028100ff() {
    // Test A32 ADD: max imm8 (oracle)
    // Encoding: 0x028100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x028100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x163, "R0 should be 0x00000163");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `ADD R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_adc_i_a1_a_a32_add_sub_imm_1_7fffffff_028100ff() {
    // Test A32 ADD: max imm8 (oracle)
    // Encoding: 0x028100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x028100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x800000FE, "R0 should be 0x800000FE");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `ADD R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x80000000)
#[test]
fn test_aarch32_adc_i_a1_a_a32_add_sub_imm_1_80000000_028100ff() {
    // Test A32 ADD: max imm8 (oracle)
    // Encoding: 0x028100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0x028100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x800000FF, "R0 should be 0x800000FF");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `ADD R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_adc_i_a1_a_a32_add_sub_imm_1_ffffffff_028100ff() {
    // Test A32 ADD: max imm8 (oracle)
    // Encoding: 0x028100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x028100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFE, "R0 should be 0x000000FE");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `ADD R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x00000000)
#[test]
fn test_aarch32_adc_i_a1_a_a32_add_sub_imm_2_0_02810180() {
    // Test A32 ADD: rotated by 2 (oracle)
    // Encoding: 0x02810180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x02810180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x20, "R0 should be 0x00000020");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `ADD R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x00000064)
#[test]
fn test_aarch32_adc_i_a1_a_a32_add_sub_imm_2_64_02810180() {
    // Test A32 ADD: rotated by 2 (oracle)
    // Encoding: 0x02810180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x02810180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x84, "R0 should be 0x00000084");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `ADD R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_adc_i_a1_a_a32_add_sub_imm_2_7fffffff_02810180() {
    // Test A32 ADD: rotated by 2 (oracle)
    // Encoding: 0x02810180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x02810180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x8000001F, "R0 should be 0x8000001F");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `ADD R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x80000000)
#[test]
fn test_aarch32_adc_i_a1_a_a32_add_sub_imm_2_80000000_02810180() {
    // Test A32 ADD: rotated by 2 (oracle)
    // Encoding: 0x02810180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0x02810180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000020, "R0 should be 0x80000020");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `ADD R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_adc_i_a1_a_a32_add_sub_imm_2_ffffffff_02810180() {
    // Test A32 ADD: rotated by 2 (oracle)
    // Encoding: 0x02810180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x02810180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1F, "R0 should be 0x0000001F");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `ADD R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x00000000)
#[test]
fn test_aarch32_adc_i_a1_a_a32_add_sub_imm_3_0_0281040f() {
    // Test A32 ADD: rotated by 8 (oracle)
    // Encoding: 0x0281040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x0281040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xF000000, "R0 should be 0x0F000000");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `ADD R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x00000064)
#[test]
fn test_aarch32_adc_i_a1_a_a32_add_sub_imm_3_64_0281040f() {
    // Test A32 ADD: rotated by 8 (oracle)
    // Encoding: 0x0281040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x0281040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xF000064, "R0 should be 0x0F000064");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `ADD R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_adc_i_a1_a_a32_add_sub_imm_3_7fffffff_0281040f() {
    // Test A32 ADD: rotated by 8 (oracle)
    // Encoding: 0x0281040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x0281040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x8EFFFFFF, "R0 should be 0x8EFFFFFF");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `ADD R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x80000000)
#[test]
fn test_aarch32_adc_i_a1_a_a32_add_sub_imm_3_80000000_0281040f() {
    // Test A32 ADD: rotated by 8 (oracle)
    // Encoding: 0x0281040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0x0281040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x8F000000, "R0 should be 0x8F000000");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `ADD R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_adc_i_a1_a_a32_add_sub_imm_3_ffffffff_0281040f() {
    // Test A32 ADD: rotated by 8 (oracle)
    // Encoding: 0x0281040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x0281040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xEFFFFFF, "R0 should be 0x0EFFFFFF");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `ADD R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x00000000)
#[test]
fn test_aarch32_adc_i_a1_a_a32_add_sub_imm_4_0_02810000() {
    // Test A32 ADD: zero immediate (oracle)
    // Encoding: 0x02810000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x02810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `ADD R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x00000064)
#[test]
fn test_aarch32_adc_i_a1_a_a32_add_sub_imm_4_64_02810000() {
    // Test A32 ADD: zero immediate (oracle)
    // Encoding: 0x02810000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x02810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x64, "R0 should be 0x00000064");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `ADD R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_adc_i_a1_a_a32_add_sub_imm_4_7fffffff_02810000() {
    // Test A32 ADD: zero immediate (oracle)
    // Encoding: 0x02810000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x02810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FFFFFFF, "R0 should be 0x7FFFFFFF");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `ADD R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x80000000)
#[test]
fn test_aarch32_adc_i_a1_a_a32_add_sub_imm_4_80000000_02810000() {
    // Test A32 ADD: zero immediate (oracle)
    // Encoding: 0x02810000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0x02810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "R0 should be 0x80000000");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `ADD R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_adc_i_a1_a_a32_add_sub_imm_4_ffffffff_02810000() {
    // Test A32 ADD: zero immediate (oracle)
    // Encoding: 0x02810000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x02810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "R0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_aarch32_adc_i_a1_a_flags_zeroresult_0_02b10000() {
    // Test aarch32_ADC_i_A1_A flag computation: ZeroResult
    // Encoding: 0x02B10000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x02B10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_aarch32_adc_i_a1_a_flags_zeroresult_1_02b10000() {
    // Test aarch32_ADC_i_A1_A flag computation: ZeroResult
    // Encoding: 0x02B10000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x02B10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_aarch32_adc_i_a1_a_flags_negativeresult_2_02b10000() {
    // Test aarch32_ADC_i_A1_A flag computation: NegativeResult
    // Encoding: 0x02B10000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x02B10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_aarch32_adc_i_a1_a_flags_unsignedoverflow_3_02b10000() {
    // Test aarch32_ADC_i_A1_A flag computation: UnsignedOverflow
    // Encoding: 0x02B10000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x02B10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_aarch32_adc_i_a1_a_flags_unsignedoverflow_4_02b10000() {
    // Test aarch32_ADC_i_A1_A flag computation: UnsignedOverflow
    // Encoding: 0x02B10000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x02B10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_aarch32_adc_i_a1_a_flags_signedoverflow_5_02b10000() {
    // Test aarch32_ADC_i_A1_A flag computation: SignedOverflow
    // Encoding: 0x02B10000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x02B10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_aarch32_adc_i_a1_a_flags_signedoverflow_6_02b10000() {
    // Test aarch32_ADC_i_A1_A flag computation: SignedOverflow
    // Encoding: 0x02B10000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x02B10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_ADC_i_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_aarch32_adc_i_a1_a_flags_positiveresult_7_02b10000() {
    // Test aarch32_ADC_i_A1_A flag computation: PositiveResult
    // Encoding: 0x02B10000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x32);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x02B10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `ADD X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_adc_i_t1_a_add_oracle_32_0_f1402820() {
    // Test ADD 32-bit: simple addition/subtraction (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF1402820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFF6064,
        "X0 should be 0xFFFFFFFFFFFF6064"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `ADD X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_adc_i_t1_a_add_oracle_64_0_f1402820() {
    // Test ADD 64-bit: simple addition/subtraction (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF1402820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFF6064,
        "X0 should be 0xFFFFFFFFFFFF6064"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `ADD X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero operands (32)
#[test]
fn test_aarch32_adc_i_t1_a_add_oracle_32_1_f1400020() {
    // Test ADD 32-bit: zero operands (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1400020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `ADD X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero operands (64)
#[test]
fn test_aarch32_adc_i_t1_a_add_oracle_64_1_f1400020() {
    // Test ADD 64-bit: zero operands (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1400020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small values (32)
#[test]
fn test_aarch32_adc_i_t1_a_add_oracle_32_2_f1400420() {
    // Test ADD 32-bit: small values (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF1400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// small values (64)
#[test]
fn test_aarch32_adc_i_t1_a_add_oracle_64_2_f1400420() {
    // Test ADD 64-bit: small values (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF1400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `ADD X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_adc_i_t1_a_add_oracle_32_3_f17ffc20() {
    // Test ADD 32-bit: max imm12 unshifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF17FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `ADD X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_adc_i_t1_a_add_oracle_64_3_f17ffc20() {
    // Test ADD 64-bit: max imm12 unshifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF17FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `ADD X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_adc_i_t1_a_add_oracle_32_4_f17ffc20() {
    // Test ADD 32-bit: max imm12 shifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF17FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `ADD X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_adc_i_t1_a_add_oracle_64_4_f17ffc20() {
    // Test ADD 64-bit: max imm12 shifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF17FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max u64 operand (32)
#[test]
fn test_aarch32_adc_i_t1_a_add_oracle_32_5_f1400420() {
    // Test ADD 32-bit: max u64 operand (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFEFFF,
        "X0 should be 0x00000000FFFFEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max u64 operand (64)
#[test]
fn test_aarch32_adc_i_t1_a_add_oracle_64_5_f1400420() {
    // Test ADD 64-bit: max u64 operand (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFEFFF,
        "X0 should be 0xFFFFFFFFFFFFEFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_adc_i_t1_a_add_oracle_32_6_f1400420() {
    // Test ADD 32-bit: zero result (for sub 1-1) (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF000,
        "X0 should be 0xFFFFFFFFFFFFF000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_adc_i_t1_a_add_oracle_64_6_f1400420() {
    // Test ADD 64-bit: zero result (for sub 1-1) (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF000,
        "X0 should be 0xFFFFFFFFFFFFF000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_adc_i_t1_a_add_oracle_32_7_f1400420() {
    // Test ADD 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFEFFF,
        "X0 should be 0x00000000FFFFEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_adc_i_t1_a_add_oracle_64_7_f1400420() {
    // Test ADD 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFEFFF,
        "X0 should be 0x7FFFFFFFFFFFEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_adc_i_t1_a_add_oracle_32_8_f1400420() {
    // Test ADD 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF1400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x7FFFEFFF,
        "X0 should be 0x000000007FFFEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_adc_i_t1_a_add_oracle_64_8_f1400420() {
    // Test ADD 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF1400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x7FFFEFFF,
        "X0 should be 0x000000007FFFEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_adc_i_t1_a_add_oracle_32_9_f1400420() {
    // Test ADD 32-bit: unsigned overflow 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFEFFF,
        "X0 should be 0x00000000FFFFEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_adc_i_t1_a_add_oracle_64_9_f1400420() {
    // Test ADD 64-bit: unsigned overflow 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFEFFF,
        "X0 should be 0xFFFFFFFFFFFFEFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_adc_i_t1_a_add_oracle_32_10_f1400420() {
    // Test ADD 32-bit: unsigned overflow 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFEFFF,
        "X0 should be 0x00000000FFFFEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_adc_i_t1_a_add_oracle_64_10_f1400420() {
    // Test ADD 64-bit: unsigned overflow 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFEFFF,
        "X0 should be 0x00000000FFFFEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `ADD SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (32)
#[test]
fn test_aarch32_adc_i_t1_a_add_oracle_32_rd31_sp_f140283f() {
    // Test ADD 32-bit with Rd=31 (SP)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF140283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `ADD SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (64)
#[test]
fn test_aarch32_adc_i_t1_a_add_oracle_64_rd31_sp_f140283f() {
    // Test ADD 64-bit with Rd=31 (SP)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF140283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `ADDS X0, X1, #10`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_adc_i_t1_a_adds_oracle_32_0_f1402820() {
    // Test ADDS 32-bit: simple addition/subtraction (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF1402820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFF6064,
        "X0 should be 0xFFFFFFFFFFFF6064"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `ADDS X0, X1, #10`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_adc_i_t1_a_adds_oracle_64_0_f1402820() {
    // Test ADDS 64-bit: simple addition/subtraction (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF1402820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFF6064,
        "X0 should be 0xFFFFFFFFFFFF6064"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `ADDS X0, X1, #0`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero operands (32)
#[test]
fn test_aarch32_adc_i_t1_a_adds_oracle_32_1_f1400020() {
    // Test ADDS 32-bit: zero operands (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1400020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `ADDS X0, X1, #0`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero operands (64)
#[test]
fn test_aarch32_adc_i_t1_a_adds_oracle_64_1_f1400020() {
    // Test ADDS 64-bit: zero operands (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1400020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// small values (32)
#[test]
fn test_aarch32_adc_i_t1_a_adds_oracle_32_2_f1400420() {
    // Test ADDS 32-bit: small values (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF1400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// small values (64)
#[test]
fn test_aarch32_adc_i_t1_a_adds_oracle_64_2_f1400420() {
    // Test ADDS 64-bit: small values (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF1400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `ADDS X0, X1, #4095`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_adc_i_t1_a_adds_oracle_32_3_f17ffc20() {
    // Test ADDS 32-bit: max imm12 unshifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF17FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `ADDS X0, X1, #4095`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_adc_i_t1_a_adds_oracle_64_3_f17ffc20() {
    // Test ADDS 64-bit: max imm12 unshifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF17FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `ADDS X0, X1, #4095, LSL #12`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_adc_i_t1_a_adds_oracle_32_4_f17ffc20() {
    // Test ADDS 32-bit: max imm12 shifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF17FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `ADDS X0, X1, #4095, LSL #12`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_adc_i_t1_a_adds_oracle_64_4_f17ffc20() {
    // Test ADDS 64-bit: max imm12 shifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF17FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max u64 operand (32)
#[test]
fn test_aarch32_adc_i_t1_a_adds_oracle_32_5_f1400420() {
    // Test ADDS 32-bit: max u64 operand (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFEFFF,
        "X0 should be 0x00000000FFFFEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max u64 operand (64)
#[test]
fn test_aarch32_adc_i_t1_a_adds_oracle_64_5_f1400420() {
    // Test ADDS 64-bit: max u64 operand (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFEFFF,
        "X0 should be 0xFFFFFFFFFFFFEFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_adc_i_t1_a_adds_oracle_32_6_f1400420() {
    // Test ADDS 32-bit: zero result (for sub 1-1) (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF000,
        "X0 should be 0xFFFFFFFFFFFFF000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_adc_i_t1_a_adds_oracle_64_6_f1400420() {
    // Test ADDS 64-bit: zero result (for sub 1-1) (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF000,
        "X0 should be 0xFFFFFFFFFFFFF000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_adc_i_t1_a_adds_oracle_32_7_f1400420() {
    // Test ADDS 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFEFFF,
        "X0 should be 0x00000000FFFFEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_adc_i_t1_a_adds_oracle_64_7_f1400420() {
    // Test ADDS 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFEFFF,
        "X0 should be 0x7FFFFFFFFFFFEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_adc_i_t1_a_adds_oracle_32_8_f1400420() {
    // Test ADDS 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF1400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x7FFFEFFF,
        "X0 should be 0x000000007FFFEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_adc_i_t1_a_adds_oracle_64_8_f1400420() {
    // Test ADDS 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF1400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x7FFFEFFF,
        "X0 should be 0x000000007FFFEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_adc_i_t1_a_adds_oracle_32_9_f1400420() {
    // Test ADDS 32-bit: unsigned overflow 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFEFFF,
        "X0 should be 0x00000000FFFFEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_adc_i_t1_a_adds_oracle_64_9_f1400420() {
    // Test ADDS 64-bit: unsigned overflow 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFEFFF,
        "X0 should be 0xFFFFFFFFFFFFEFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_adc_i_t1_a_adds_oracle_32_10_f1400420() {
    // Test ADDS 32-bit: unsigned overflow 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFEFFF,
        "X0 should be 0x00000000FFFFEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_adc_i_t1_a_adds_oracle_64_10_f1400420() {
    // Test ADDS 64-bit: unsigned overflow 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFEFFF,
        "X0 should be 0x00000000FFFFEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `ADDS ZR, X1, #10`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "result discarded, flags set" }
/// ZR destination (32)
#[test]
fn test_aarch32_adc_i_t1_a_adds_oracle_32_rd31_zr_f140283f() {
    // Test ADDS 32-bit with Rd=31 (ZR)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF140283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `ADDS ZR, X1, #10`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "result discarded, flags set" }
/// ZR destination (64)
#[test]
fn test_aarch32_adc_i_t1_a_adds_oracle_64_rd31_zr_f140283f() {
    // Test ADDS 64-bit with Rd=31 (ZR)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF140283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `SUB X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_adc_i_t1_a_sub_oracle_32_0_f1402820() {
    // Test SUB 32-bit: simple addition/subtraction (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF1402820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFF6064,
        "X0 should be 0xFFFFFFFFFFFF6064"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `SUB X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_adc_i_t1_a_sub_oracle_64_0_f1402820() {
    // Test SUB 64-bit: simple addition/subtraction (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF1402820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFF6064,
        "X0 should be 0xFFFFFFFFFFFF6064"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `SUB X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero operands (32)
#[test]
fn test_aarch32_adc_i_t1_a_sub_oracle_32_1_f1400020() {
    // Test SUB 32-bit: zero operands (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1400020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `SUB X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero operands (64)
#[test]
fn test_aarch32_adc_i_t1_a_sub_oracle_64_1_f1400020() {
    // Test SUB 64-bit: zero operands (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1400020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small values (32)
#[test]
fn test_aarch32_adc_i_t1_a_sub_oracle_32_2_f1400420() {
    // Test SUB 32-bit: small values (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF1400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// small values (64)
#[test]
fn test_aarch32_adc_i_t1_a_sub_oracle_64_2_f1400420() {
    // Test SUB 64-bit: small values (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF1400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `SUB X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_adc_i_t1_a_sub_oracle_32_3_f17ffc20() {
    // Test SUB 32-bit: max imm12 unshifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF17FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `SUB X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_adc_i_t1_a_sub_oracle_64_3_f17ffc20() {
    // Test SUB 64-bit: max imm12 unshifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF17FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `SUB X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_adc_i_t1_a_sub_oracle_32_4_f17ffc20() {
    // Test SUB 32-bit: max imm12 shifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF17FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `SUB X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_adc_i_t1_a_sub_oracle_64_4_f17ffc20() {
    // Test SUB 64-bit: max imm12 shifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF17FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max u64 operand (32)
#[test]
fn test_aarch32_adc_i_t1_a_sub_oracle_32_5_f1400420() {
    // Test SUB 32-bit: max u64 operand (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFEFFF,
        "X0 should be 0x00000000FFFFEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max u64 operand (64)
#[test]
fn test_aarch32_adc_i_t1_a_sub_oracle_64_5_f1400420() {
    // Test SUB 64-bit: max u64 operand (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFEFFF,
        "X0 should be 0xFFFFFFFFFFFFEFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_adc_i_t1_a_sub_oracle_32_6_f1400420() {
    // Test SUB 32-bit: zero result (for sub 1-1) (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF000,
        "X0 should be 0xFFFFFFFFFFFFF000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_adc_i_t1_a_sub_oracle_64_6_f1400420() {
    // Test SUB 64-bit: zero result (for sub 1-1) (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF000,
        "X0 should be 0xFFFFFFFFFFFFF000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_adc_i_t1_a_sub_oracle_32_7_f1400420() {
    // Test SUB 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFEFFF,
        "X0 should be 0x00000000FFFFEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_adc_i_t1_a_sub_oracle_64_7_f1400420() {
    // Test SUB 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFEFFF,
        "X0 should be 0x7FFFFFFFFFFFEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_adc_i_t1_a_sub_oracle_32_8_f1400420() {
    // Test SUB 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF1400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x7FFFEFFF,
        "X0 should be 0x000000007FFFEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_adc_i_t1_a_sub_oracle_64_8_f1400420() {
    // Test SUB 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF1400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x7FFFEFFF,
        "X0 should be 0x000000007FFFEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_adc_i_t1_a_sub_oracle_32_9_f1400420() {
    // Test SUB 32-bit: unsigned overflow 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFEFFF,
        "X0 should be 0x00000000FFFFEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_adc_i_t1_a_sub_oracle_64_9_f1400420() {
    // Test SUB 64-bit: unsigned overflow 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFEFFF,
        "X0 should be 0xFFFFFFFFFFFFEFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_adc_i_t1_a_sub_oracle_32_10_f1400420() {
    // Test SUB 32-bit: unsigned overflow 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFEFFF,
        "X0 should be 0x00000000FFFFEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_adc_i_t1_a_sub_oracle_64_10_f1400420() {
    // Test SUB 64-bit: unsigned overflow 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFEFFF,
        "X0 should be 0x00000000FFFFEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `SUB SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (32)
#[test]
fn test_aarch32_adc_i_t1_a_sub_oracle_32_rd31_sp_f140283f() {
    // Test SUB 32-bit with Rd=31 (SP)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF140283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `SUB SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (64)
#[test]
fn test_aarch32_adc_i_t1_a_sub_oracle_64_rd31_sp_f140283f() {
    // Test SUB 64-bit with Rd=31 (SP)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF140283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `SUBS X0, X1, #10`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_adc_i_t1_a_subs_oracle_32_0_f1402820() {
    // Test SUBS 32-bit: simple addition/subtraction (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF1402820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFF6064,
        "X0 should be 0xFFFFFFFFFFFF6064"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `SUBS X0, X1, #10`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_adc_i_t1_a_subs_oracle_64_0_f1402820() {
    // Test SUBS 64-bit: simple addition/subtraction (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF1402820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFF6064,
        "X0 should be 0xFFFFFFFFFFFF6064"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `SUBS X0, X1, #0`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero operands (32)
#[test]
fn test_aarch32_adc_i_t1_a_subs_oracle_32_1_f1400020() {
    // Test SUBS 32-bit: zero operands (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1400020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `SUBS X0, X1, #0`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero operands (64)
#[test]
fn test_aarch32_adc_i_t1_a_subs_oracle_64_1_f1400020() {
    // Test SUBS 64-bit: zero operands (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1400020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// small values (32)
#[test]
fn test_aarch32_adc_i_t1_a_subs_oracle_32_2_f1400420() {
    // Test SUBS 32-bit: small values (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF1400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// small values (64)
#[test]
fn test_aarch32_adc_i_t1_a_subs_oracle_64_2_f1400420() {
    // Test SUBS 64-bit: small values (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF1400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `SUBS X0, X1, #4095`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_adc_i_t1_a_subs_oracle_32_3_f17ffc20() {
    // Test SUBS 32-bit: max imm12 unshifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF17FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `SUBS X0, X1, #4095`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_adc_i_t1_a_subs_oracle_64_3_f17ffc20() {
    // Test SUBS 64-bit: max imm12 unshifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF17FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `SUBS X0, X1, #4095, LSL #12`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_adc_i_t1_a_subs_oracle_32_4_f17ffc20() {
    // Test SUBS 32-bit: max imm12 shifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF17FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `SUBS X0, X1, #4095, LSL #12`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_adc_i_t1_a_subs_oracle_64_4_f17ffc20() {
    // Test SUBS 64-bit: max imm12 shifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF17FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max u64 operand (32)
#[test]
fn test_aarch32_adc_i_t1_a_subs_oracle_32_5_f1400420() {
    // Test SUBS 32-bit: max u64 operand (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFEFFF,
        "X0 should be 0x00000000FFFFEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max u64 operand (64)
#[test]
fn test_aarch32_adc_i_t1_a_subs_oracle_64_5_f1400420() {
    // Test SUBS 64-bit: max u64 operand (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFEFFF,
        "X0 should be 0xFFFFFFFFFFFFEFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_adc_i_t1_a_subs_oracle_32_6_f1400420() {
    // Test SUBS 32-bit: zero result (for sub 1-1) (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF000,
        "X0 should be 0xFFFFFFFFFFFFF000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_adc_i_t1_a_subs_oracle_64_6_f1400420() {
    // Test SUBS 64-bit: zero result (for sub 1-1) (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF000,
        "X0 should be 0xFFFFFFFFFFFFF000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_adc_i_t1_a_subs_oracle_32_7_f1400420() {
    // Test SUBS 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFEFFF,
        "X0 should be 0x00000000FFFFEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_adc_i_t1_a_subs_oracle_64_7_f1400420() {
    // Test SUBS 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFEFFF,
        "X0 should be 0x7FFFFFFFFFFFEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_adc_i_t1_a_subs_oracle_32_8_f1400420() {
    // Test SUBS 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF1400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x7FFFEFFF,
        "X0 should be 0x000000007FFFEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_adc_i_t1_a_subs_oracle_64_8_f1400420() {
    // Test SUBS 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF1400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x7FFFEFFF,
        "X0 should be 0x000000007FFFEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_adc_i_t1_a_subs_oracle_32_9_f1400420() {
    // Test SUBS 32-bit: unsigned overflow 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFEFFF,
        "X0 should be 0x00000000FFFFEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_adc_i_t1_a_subs_oracle_64_9_f1400420() {
    // Test SUBS 64-bit: unsigned overflow 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFEFFF,
        "X0 should be 0xFFFFFFFFFFFFEFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_adc_i_t1_a_subs_oracle_32_10_f1400420() {
    // Test SUBS 32-bit: unsigned overflow 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFEFFF,
        "X0 should be 0x00000000FFFFEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_adc_i_t1_a_subs_oracle_64_10_f1400420() {
    // Test SUBS 64-bit: unsigned overflow 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFEFFF,
        "X0 should be 0x00000000FFFFEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `SUBS ZR, X1, #10`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "result discarded, flags set" }
/// ZR destination (32)
#[test]
fn test_aarch32_adc_i_t1_a_subs_oracle_32_rd31_zr_f140283f() {
    // Test SUBS 32-bit with Rd=31 (ZR)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF140283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `SUBS ZR, X1, #10`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "result discarded, flags set" }
/// ZR destination (64)
#[test]
fn test_aarch32_adc_i_t1_a_subs_oracle_64_rd31_zr_f140283f() {
    // Test SUBS 64-bit with Rd=31 (ZR)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF140283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `ADD.W R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple values
#[test]
fn test_aarch32_adc_i_t1_a_t32_oracle_0_f1410000() {
    // Test T32 ADD: simple values (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x32);
    let encoding: u32 = 0xF1410000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x96, "R0 should be 0x00000096");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `ADD.W R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero values
#[test]
fn test_aarch32_adc_i_t1_a_t32_oracle_1_f1410000() {
    // Test T32 ADD: zero values (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xF1410000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `ADD.W R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max value
#[test]
fn test_aarch32_adc_i_t1_a_t32_oracle_2_f1410000() {
    // Test T32 ADD: max value (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1410000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `ADD.W R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// mixed pattern
#[test]
fn test_aarch32_adc_i_t1_a_t32_oracle_3_f1410000() {
    // Test T32 ADD: mixed pattern (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0xABCDEF01);
    let encoding: u32 = 0xF1410000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xBE024579, "R0 should be 0xBE024579");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_aarch32_adc_i_t1_a_flags_zeroresult_0_f1510000() {
    // Test aarch32_ADC_i_T1_A flag computation: ZeroResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1510000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_aarch32_adc_i_t1_a_flags_zeroresult_1_f1510000() {
    // Test aarch32_ADC_i_T1_A flag computation: ZeroResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0xF1510000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_aarch32_adc_i_t1_a_flags_negativeresult_2_f1510000() {
    // Test aarch32_ADC_i_T1_A flag computation: NegativeResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xF1510000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_aarch32_adc_i_t1_a_flags_unsignedoverflow_3_f1510000() {
    // Test aarch32_ADC_i_T1_A flag computation: UnsignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1510000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_aarch32_adc_i_t1_a_flags_unsignedoverflow_4_f1510000() {
    // Test aarch32_ADC_i_T1_A flag computation: UnsignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1510000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_aarch32_adc_i_t1_a_flags_signedoverflow_5_f1510000() {
    // Test aarch32_ADC_i_T1_A flag computation: SignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1510000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_aarch32_adc_i_t1_a_flags_signedoverflow_6_f1510000() {
    // Test aarch32_ADC_i_T1_A flag computation: SignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1510000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_ADC_i_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_aarch32_adc_i_t1_a_flags_positiveresult_7_f1510000() {
    // Test aarch32_ADC_i_T1_A flag computation: PositiveResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x32);
    let encoding: u32 = 0xF1510000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

// ============================================================================
// aarch32_RSC_i_A Tests
// ============================================================================

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_rsc_i_a1_a_field_cond_0_min_0_02e00000() {
    // Encoding: 0x02E00000
    // Test aarch32_RSC_i_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: S=0, Rn=0, Rd=0, imm12=0, cond=0
    let encoding: u32 = 0x02E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_rsc_i_a1_a_field_cond_1_poweroftwo_0_12e00000() {
    // Encoding: 0x12E00000
    // Test aarch32_RSC_i_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, S=0, Rd=0, cond=1, imm12=0
    let encoding: u32 = 0x12E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_rsc_i_a1_a_field_cond_2_poweroftwo_0_22e00000() {
    // Encoding: 0x22E00000
    // Test aarch32_RSC_i_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, Rd=0, imm12=0, Rn=0, cond=2
    let encoding: u32 = 0x22E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_rsc_i_a1_a_field_cond_3_poweroftwo_0_32e00000() {
    // Encoding: 0x32E00000
    // Test aarch32_RSC_i_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=3, Rd=0, S=0, imm12=0, Rn=0
    let encoding: u32 = 0x32E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_rsc_i_a1_a_field_cond_4_poweroftwo_0_42e00000() {
    // Encoding: 0x42E00000
    // Test aarch32_RSC_i_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=4, Rn=0, Rd=0, imm12=0, S=0
    let encoding: u32 = 0x42E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_rsc_i_a1_a_field_cond_5_poweroftwo_0_52e00000() {
    // Encoding: 0x52E00000
    // Test aarch32_RSC_i_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, S=0, cond=5, Rd=0, imm12=0
    let encoding: u32 = 0x52E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_rsc_i_a1_a_field_cond_6_poweroftwo_0_62e00000() {
    // Encoding: 0x62E00000
    // Test aarch32_RSC_i_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, S=0, Rn=0, imm12=0, cond=6
    let encoding: u32 = 0x62E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_rsc_i_a1_a_field_cond_7_poweroftwo_0_72e00000() {
    // Encoding: 0x72E00000
    // Test aarch32_RSC_i_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=7, S=0, Rd=0, imm12=0
    let encoding: u32 = 0x72E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_rsc_i_a1_a_field_cond_8_poweroftwo_0_82e00000() {
    // Encoding: 0x82E00000
    // Test aarch32_RSC_i_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rn=0, cond=8, imm12=0, S=0
    let encoding: u32 = 0x82E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_rsc_i_a1_a_field_cond_9_poweroftwo_0_92e00000() {
    // Encoding: 0x92E00000
    // Test aarch32_RSC_i_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=9, Rd=0, S=0, Rn=0, imm12=0
    let encoding: u32 = 0x92E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_rsc_i_a1_a_field_cond_10_poweroftwo_0_a2e00000() {
    // Encoding: 0xA2E00000
    // Test aarch32_RSC_i_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=0, cond=10, S=0, Rd=0, Rn=0
    let encoding: u32 = 0xA2E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_rsc_i_a1_a_field_cond_11_poweroftwo_0_b2e00000() {
    // Encoding: 0xB2E00000
    // Test aarch32_RSC_i_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, imm12=0, S=0, Rn=0, cond=11
    let encoding: u32 = 0xB2E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_rsc_i_a1_a_field_cond_12_poweroftwo_0_c2e00000() {
    // Encoding: 0xC2E00000
    // Test aarch32_RSC_i_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=0, cond=12, Rd=0, S=0, Rn=0
    let encoding: u32 = 0xC2E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_rsc_i_a1_a_field_cond_13_poweroftwo_0_d2e00000() {
    // Encoding: 0xD2E00000
    // Test aarch32_RSC_i_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, cond=13, Rn=0, S=0, imm12=0
    let encoding: u32 = 0xD2E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_rsc_i_a1_a_field_cond_14_poweroftwo_0_e2e00000() {
    // Encoding: 0xE2E00000
    // Test aarch32_RSC_i_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=14, imm12=0, Rd=0, Rn=0, S=0
    let encoding: u32 = 0xE2E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_rsc_i_a1_a_field_cond_15_max_0_f2e00000() {
    // Encoding: 0xF2E00000
    // Test aarch32_RSC_i_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: cond=15, S=0, Rn=0, Rd=0, imm12=0
    let encoding: u32 = 0xF2E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_rsc_i_a1_a_field_s_0_min_0_02e00000() {
    // Encoding: 0x02E00000
    // Test aarch32_RSC_i_A1_A field S = 0 (Min)
    // ISET: A32
    // Fields: cond=0, S=0, Rd=0, Rn=0, imm12=0
    let encoding: u32 = 0x02E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_rsc_i_a1_a_field_s_1_max_0_02f00000() {
    // Encoding: 0x02F00000
    // Test aarch32_RSC_i_A1_A field S = 1 (Max)
    // ISET: A32
    // Fields: Rn=0, cond=0, S=1, Rd=0, imm12=0
    let encoding: u32 = 0x02F00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_rsc_i_a1_a_field_rn_0_min_0_02e00000() {
    // Encoding: 0x02E00000
    // Test aarch32_RSC_i_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: imm12=0, cond=0, Rn=0, S=0, Rd=0
    let encoding: u32 = 0x02E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_rsc_i_a1_a_field_rn_1_poweroftwo_0_02e10000() {
    // Encoding: 0x02E10000
    // Test aarch32_RSC_i_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Rn=1, Rd=0, S=0, imm12=0
    let encoding: u32 = 0x02E10000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_rsc_i_a1_a_field_rd_0_min_0_02e00000() {
    // Encoding: 0x02E00000
    // Test aarch32_RSC_i_A1_A field Rd = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rn=0, Rd=0, imm12=0, S=0
    let encoding: u32 = 0x02E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_rsc_i_a1_a_field_rd_1_poweroftwo_0_02e01000() {
    // Encoding: 0x02E01000
    // Test aarch32_RSC_i_A1_A field Rd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=0, cond=0, Rd=1, Rn=0, S=0
    let encoding: u32 = 0x02E01000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_rsc_i_a1_a_field_imm12_0_zero_0_02e00000() {
    // Encoding: 0x02E00000
    // Test aarch32_RSC_i_A1_A field imm12 = 0 (Zero)
    // ISET: A32
    // Fields: S=0, Rd=0, cond=0, Rn=0, imm12=0
    let encoding: u32 = 0x02E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_rsc_i_a1_a_field_imm12_1_poweroftwo_0_02e00001() {
    // Encoding: 0x02E00001
    // Test aarch32_RSC_i_A1_A field imm12 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, Rn=0, imm12=1, cond=0, Rd=0
    let encoding: u32 = 0x02E00001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_rsc_i_a1_a_field_imm12_3_poweroftwominusone_0_02e00003() {
    // Encoding: 0x02E00003
    // Test aarch32_RSC_i_A1_A field imm12 = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, imm12=3, Rn=0, S=0, Rd=0
    let encoding: u32 = 0x02E00003;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_rsc_i_a1_a_field_imm12_4_poweroftwo_0_02e00004() {
    // Encoding: 0x02E00004
    // Test aarch32_RSC_i_A1_A field imm12 = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=4, Rd=0, Rn=0, S=0, cond=0
    let encoding: u32 = 0x02E00004;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_rsc_i_a1_a_field_imm12_7_poweroftwominusone_0_02e00007() {
    // Encoding: 0x02E00007
    // Test aarch32_RSC_i_A1_A field imm12 = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rd=0, S=0, imm12=7, Rn=0, cond=0
    let encoding: u32 = 0x02E00007;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_rsc_i_a1_a_field_imm12_8_poweroftwo_0_02e00008() {
    // Encoding: 0x02E00008
    // Test aarch32_RSC_i_A1_A field imm12 = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=8, cond=0, Rn=0, Rd=0, S=0
    let encoding: u32 = 0x02E00008;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_rsc_i_a1_a_field_imm12_15_poweroftwominusone_0_02e0000f() {
    // Encoding: 0x02E0000F
    // Test aarch32_RSC_i_A1_A field imm12 = 15 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rn=0, Rd=0, imm12=15, cond=0, S=0
    let encoding: u32 = 0x02E0000F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_rsc_i_a1_a_field_imm12_16_poweroftwo_0_02e00010() {
    // Encoding: 0x02E00010
    // Test aarch32_RSC_i_A1_A field imm12 = 16 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=16, S=0, cond=0, Rn=0, Rd=0
    let encoding: u32 = 0x02E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_rsc_i_a1_a_field_imm12_31_poweroftwominusone_0_02e0001f() {
    // Encoding: 0x02E0001F
    // Test aarch32_RSC_i_A1_A field imm12 = 31 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, S=0, Rd=0, Rn=0, imm12=31
    let encoding: u32 = 0x02E0001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_rsc_i_a1_a_field_imm12_32_poweroftwo_0_02e00020() {
    // Encoding: 0x02E00020
    // Test aarch32_RSC_i_A1_A field imm12 = 32 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, imm12=32, Rn=0, S=0, Rd=0
    let encoding: u32 = 0x02E00020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_rsc_i_a1_a_field_imm12_63_poweroftwominusone_0_02e0003f() {
    // Encoding: 0x02E0003F
    // Test aarch32_RSC_i_A1_A field imm12 = 63 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, Rn=0, S=0, Rd=0, imm12=63
    let encoding: u32 = 0x02E0003F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_rsc_i_a1_a_field_imm12_64_poweroftwo_0_02e00040() {
    // Encoding: 0x02E00040
    // Test aarch32_RSC_i_A1_A field imm12 = 64 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, S=0, Rn=0, Rd=0, imm12=64
    let encoding: u32 = 0x02E00040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 127, boundary: PowerOfTwoMinusOne }
/// 2^7 - 1 = 127
#[test]
fn test_aarch32_rsc_i_a1_a_field_imm12_127_poweroftwominusone_0_02e0007f() {
    // Encoding: 0x02E0007F
    // Test aarch32_RSC_i_A1_A field imm12 = 127 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm12=127, cond=0, S=0, Rd=0, Rn=0
    let encoding: u32 = 0x02E0007F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_rsc_i_a1_a_field_imm12_128_poweroftwo_0_02e00080() {
    // Encoding: 0x02E00080
    // Test aarch32_RSC_i_A1_A field imm12 = 128 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Rn=0, imm12=128, S=0, Rd=0
    let encoding: u32 = 0x02E00080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 255, boundary: PowerOfTwoMinusOne }
/// 2^8 - 1 = 255
#[test]
fn test_aarch32_rsc_i_a1_a_field_imm12_255_poweroftwominusone_0_02e000ff() {
    // Encoding: 0x02E000FF
    // Test aarch32_RSC_i_A1_A field imm12 = 255 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, S=0, Rn=0, imm12=255, Rd=0
    let encoding: u32 = 0x02E000FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 256, boundary: PowerOfTwo }
/// power of 2 (2^8 = 256)
#[test]
fn test_aarch32_rsc_i_a1_a_field_imm12_256_poweroftwo_0_02e00100() {
    // Encoding: 0x02E00100
    // Test aarch32_RSC_i_A1_A field imm12 = 256 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, Rn=0, Rd=0, imm12=256, cond=0
    let encoding: u32 = 0x02E00100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 511, boundary: PowerOfTwoMinusOne }
/// 2^9 - 1 = 511
#[test]
fn test_aarch32_rsc_i_a1_a_field_imm12_511_poweroftwominusone_0_02e001ff() {
    // Encoding: 0x02E001FF
    // Test aarch32_RSC_i_A1_A field imm12 = 511 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm12=511, cond=0, Rn=0, Rd=0, S=0
    let encoding: u32 = 0x02E001FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 512, boundary: PowerOfTwo }
/// power of 2 (2^9 = 512)
#[test]
fn test_aarch32_rsc_i_a1_a_field_imm12_512_poweroftwo_0_02e00200() {
    // Encoding: 0x02E00200
    // Test aarch32_RSC_i_A1_A field imm12 = 512 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Rn=0, Rd=0, S=0, imm12=512
    let encoding: u32 = 0x02E00200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1023, boundary: PowerOfTwoMinusOne }
/// 2^10 - 1 = 1023
#[test]
fn test_aarch32_rsc_i_a1_a_field_imm12_1023_poweroftwominusone_0_02e003ff() {
    // Encoding: 0x02E003FF
    // Test aarch32_RSC_i_A1_A field imm12 = 1023 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, Rn=0, Rd=0, S=0, imm12=1023
    let encoding: u32 = 0x02E003FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1024, boundary: PowerOfTwo }
/// power of 2 (2^10 = 1024)
#[test]
fn test_aarch32_rsc_i_a1_a_field_imm12_1024_poweroftwo_0_02e00400() {
    // Encoding: 0x02E00400
    // Test aarch32_RSC_i_A1_A field imm12 = 1024 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=1024, cond=0, Rn=0, S=0, Rd=0
    let encoding: u32 = 0x02E00400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2047, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (2047)
#[test]
fn test_aarch32_rsc_i_a1_a_field_imm12_2047_poweroftwominusone_0_02e007ff() {
    // Encoding: 0x02E007FF
    // Test aarch32_RSC_i_A1_A field imm12 = 2047 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, S=0, imm12=2047, Rd=0, Rn=0
    let encoding: u32 = 0x02E007FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2048, boundary: PowerOfTwo }
/// power of 2 (2^11 = 2048)
#[test]
fn test_aarch32_rsc_i_a1_a_field_imm12_2048_poweroftwo_0_02e00800() {
    // Encoding: 0x02E00800
    // Test aarch32_RSC_i_A1_A field imm12 = 2048 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rn=0, S=0, imm12=2048, cond=0
    let encoding: u32 = 0x02E00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4095, boundary: Max }
/// maximum immediate (4095)
#[test]
fn test_aarch32_rsc_i_a1_a_field_imm12_4095_max_0_02e00fff() {
    // Encoding: 0x02E00FFF
    // Test aarch32_RSC_i_A1_A field imm12 = 4095 (Max)
    // ISET: A32
    // Fields: Rn=0, imm12=4095, Rd=0, S=0, cond=0
    let encoding: u32 = 0x02E00FFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_rsc_i_a1_a_combo_0_0_02e00000() {
    // Encoding: 0x02E00000
    // Test aarch32_RSC_i_A1_A field combination: cond=0, S=0, Rn=0, Rd=0, imm12=0
    // ISET: A32
    // Fields: Rn=0, S=0, cond=0, Rd=0, imm12=0
    let encoding: u32 = 0x02E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_rsc_i_a1_a_special_cond_0_condition_eq_0_02e00000() {
    // Encoding: 0x02E00000
    // Test aarch32_RSC_i_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: Rn=0, cond=0, imm12=0, Rd=0, S=0
    let encoding: u32 = 0x02E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_rsc_i_a1_a_special_cond_1_condition_ne_0_12e00000() {
    // Encoding: 0x12E00000
    // Test aarch32_RSC_i_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: cond=1, Rn=0, imm12=0, Rd=0, S=0
    let encoding: u32 = 0x12E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_rsc_i_a1_a_special_cond_2_condition_cs_hs_0_22e00000() {
    // Encoding: 0x22E00000
    // Test aarch32_RSC_i_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: S=0, cond=2, Rn=0, imm12=0, Rd=0
    let encoding: u32 = 0x22E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_rsc_i_a1_a_special_cond_3_condition_cc_lo_0_32e00000() {
    // Encoding: 0x32E00000
    // Test aarch32_RSC_i_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: S=0, cond=3, Rn=0, Rd=0, imm12=0
    let encoding: u32 = 0x32E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_rsc_i_a1_a_special_cond_4_condition_mi_0_42e00000() {
    // Encoding: 0x42E00000
    // Test aarch32_RSC_i_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: Rd=0, cond=4, Rn=0, imm12=0, S=0
    let encoding: u32 = 0x42E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_rsc_i_a1_a_special_cond_5_condition_pl_0_52e00000() {
    // Encoding: 0x52E00000
    // Test aarch32_RSC_i_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: Rn=0, S=0, Rd=0, cond=5, imm12=0
    let encoding: u32 = 0x52E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_rsc_i_a1_a_special_cond_6_condition_vs_0_62e00000() {
    // Encoding: 0x62E00000
    // Test aarch32_RSC_i_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: Rd=0, imm12=0, Rn=0, cond=6, S=0
    let encoding: u32 = 0x62E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_rsc_i_a1_a_special_cond_7_condition_vc_0_72e00000() {
    // Encoding: 0x72E00000
    // Test aarch32_RSC_i_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: Rn=0, Rd=0, S=0, imm12=0, cond=7
    let encoding: u32 = 0x72E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_rsc_i_a1_a_special_cond_8_condition_hi_0_82e00000() {
    // Encoding: 0x82E00000
    // Test aarch32_RSC_i_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: Rn=0, S=0, imm12=0, cond=8, Rd=0
    let encoding: u32 = 0x82E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_rsc_i_a1_a_special_cond_9_condition_ls_0_92e00000() {
    // Encoding: 0x92E00000
    // Test aarch32_RSC_i_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: cond=9, S=0, Rn=0, Rd=0, imm12=0
    let encoding: u32 = 0x92E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_rsc_i_a1_a_special_cond_10_condition_ge_0_a2e00000() {
    // Encoding: 0xA2E00000
    // Test aarch32_RSC_i_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: Rd=0, cond=10, Rn=0, S=0, imm12=0
    let encoding: u32 = 0xA2E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_rsc_i_a1_a_special_cond_11_condition_lt_0_b2e00000() {
    // Encoding: 0xB2E00000
    // Test aarch32_RSC_i_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: Rd=0, Rn=0, S=0, cond=11, imm12=0
    let encoding: u32 = 0xB2E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_rsc_i_a1_a_special_cond_12_condition_gt_0_c2e00000() {
    // Encoding: 0xC2E00000
    // Test aarch32_RSC_i_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: Rn=0, imm12=0, Rd=0, cond=12, S=0
    let encoding: u32 = 0xC2E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_rsc_i_a1_a_special_cond_13_condition_le_0_d2e00000() {
    // Encoding: 0xD2E00000
    // Test aarch32_RSC_i_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: Rn=0, S=0, Rd=0, imm12=0, cond=13
    let encoding: u32 = 0xD2E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_rsc_i_a1_a_special_cond_14_condition_al_0_e2e00000() {
    // Encoding: 0xE2E00000
    // Test aarch32_RSC_i_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: Rd=0, imm12=0, S=0, cond=14, Rn=0
    let encoding: u32 = 0xE2E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_rsc_i_a1_a_special_cond_15_condition_nv_0_f2e00000() {
    // Encoding: 0xF2E00000
    // Test aarch32_RSC_i_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: Rd=0, imm12=0, cond=15, S=0, Rn=0
    let encoding: u32 = 0xF2E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `field S = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "S", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_rsc_i_a1_a_special_s_0_size_variant_0_0_02e00000() {
    // Encoding: 0x02E00000
    // Test aarch32_RSC_i_A1_A special value S = 0 (Size variant 0)
    // ISET: A32
    // Fields: imm12=0, S=0, Rd=0, cond=0, Rn=0
    let encoding: u32 = 0x02E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `field S = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "S", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_rsc_i_a1_a_special_s_1_size_variant_1_0_02f00000() {
    // Encoding: 0x02F00000
    // Test aarch32_RSC_i_A1_A special value S = 1 (Size variant 1)
    // ISET: A32
    // Fields: Rn=0, Rd=0, imm12=0, cond=0, S=1
    let encoding: u32 = 0x02F00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `ADD X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_rsc_i_a1_a_add_oracle_32_0_02e02820() {
    // Test ADD 32-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0x02E02820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x02E02820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80A064, "W0 should be 0x80A064");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `ADD X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_rsc_i_a1_a_add_oracle_64_0_82e02820() {
    // Test ADD 64-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0x82E02820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x82E02820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80A064, "X0 should be 0x000000000080A064");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `ADD X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero operands (32)
#[test]
fn test_aarch32_rsc_i_a1_a_add_oracle_32_1_02e00020() {
    // Test ADD 32-bit: zero operands (with oracle verification)
    // Encoding: 0x02E00020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x02E00020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x800000, "W0 should be 0x800000");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `ADD X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero operands (64)
#[test]
fn test_aarch32_rsc_i_a1_a_add_oracle_64_1_82e00020() {
    // Test ADD 64-bit: zero operands (with oracle verification)
    // Encoding: 0x82E00020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x82E00020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x800000, "X0 should be 0x0000000000800000");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small values (32)
#[test]
fn test_aarch32_rsc_i_a1_a_add_oracle_32_2_02e00420() {
    // Test ADD 32-bit: small values (with oracle verification)
    // Encoding: 0x02E00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x02E00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x801001, "W0 should be 0x801001");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// small values (64)
#[test]
fn test_aarch32_rsc_i_a1_a_add_oracle_64_2_82e00420() {
    // Test ADD 64-bit: small values (with oracle verification)
    // Encoding: 0x82E00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x82E00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x801001, "X0 should be 0x0000000000801001");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `ADD X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_rsc_i_a1_a_add_oracle_32_3_02fffc20() {
    // Test ADD 32-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0x02FFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x02FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF000, "W0 should be 0xFFF000");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `ADD X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_rsc_i_a1_a_add_oracle_64_3_82fffc20() {
    // Test ADD 64-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0x82FFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x82FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF000, "X0 should be 0x0000000000FFF000");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `ADD X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_rsc_i_a1_a_add_oracle_32_4_02fffc20() {
    // Test ADD 32-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0x02FFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x02FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF000, "W0 should be 0xFFF000");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `ADD X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_rsc_i_a1_a_add_oracle_64_4_82fffc20() {
    // Test ADD 64-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0x82FFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x82FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF000, "X0 should be 0x0000000000FFF000");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max u64 operand (32)
#[test]
fn test_aarch32_rsc_i_a1_a_add_oracle_32_5_02e00420() {
    // Test ADD 32-bit: max u64 operand (with oracle verification)
    // Encoding: 0x02E00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x02E00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x800FFF, "W0 should be 0x800FFF");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max u64 operand (64)
#[test]
fn test_aarch32_rsc_i_a1_a_add_oracle_64_5_82e00420() {
    // Test ADD 64-bit: max u64 operand (with oracle verification)
    // Encoding: 0x82E00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x82E00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x800FFF, "X0 should be 0x0000000000800FFF");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_rsc_i_a1_a_add_oracle_32_6_02e00420() {
    // Test ADD 32-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0x02E00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x02E00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x801000, "W0 should be 0x801000");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_rsc_i_a1_a_add_oracle_64_6_82e00420() {
    // Test ADD 64-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0x82E00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x82E00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x801000, "X0 should be 0x0000000000801000");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_rsc_i_a1_a_add_oracle_32_7_02e00420() {
    // Test ADD 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0x02E00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x02E00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x800FFF, "W0 should be 0x800FFF");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_rsc_i_a1_a_add_oracle_64_7_82e00420() {
    // Test ADD 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0x82E00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x82E00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x800FFF, "X0 should be 0x8000000000800FFF");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_rsc_i_a1_a_add_oracle_32_8_02e00420() {
    // Test ADD 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0x02E00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x02E00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80800FFF, "W0 should be 0x80800FFF");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_rsc_i_a1_a_add_oracle_64_8_82e00420() {
    // Test ADD 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0x82E00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x82E00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x80800FFF,
        "X0 should be 0x0000000080800FFF"
    );
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_rsc_i_a1_a_add_oracle_32_9_02e00420() {
    // Test ADD 32-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0x02E00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x02E00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x800FFF, "W0 should be 0x800FFF");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_rsc_i_a1_a_add_oracle_64_9_82e00420() {
    // Test ADD 64-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0x82E00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x82E00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x800FFF, "X0 should be 0x0000000000800FFF");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_rsc_i_a1_a_add_oracle_32_10_02e00420() {
    // Test ADD 32-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0x02E00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x02E00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x800FFF, "W0 should be 0x800FFF");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_rsc_i_a1_a_add_oracle_64_10_82e00420() {
    // Test ADD 64-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0x82E00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x82E00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x800FFF, "X0 should be 0x0000000100800FFF");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `ADD SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (32)
#[test]
fn test_aarch32_rsc_i_a1_a_add_oracle_32_rd31_sp_02e0283f() {
    // Test ADD 32-bit with Rd=31 (SP)
    // Encoding: 0x02E0283F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x02E0283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    // TODO: assertion - TestAssertion { check: Sp, expected: U64(8429668), message: "SP should be 0x80A064" }
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `ADD SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (64)
#[test]
fn test_aarch32_rsc_i_a1_a_add_oracle_64_rd31_sp_82e0283f() {
    // Test ADD 64-bit with Rd=31 (SP)
    // Encoding: 0x82E0283F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x82E0283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    // TODO: assertion - TestAssertion { check: Sp, expected: U64(8429668), message: "SP should be 0x80A064" }
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `ADDS X0, X1, #10`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_rsc_i_a1_a_adds_oracle_32_0_22e02820() {
    // Test ADDS 32-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0x22E02820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x22E02820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80A064, "W0 should be 0x80A064");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `ADDS X0, X1, #10`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_rsc_i_a1_a_adds_oracle_64_0_a2e02820() {
    // Test ADDS 64-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0xA2E02820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xA2E02820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80A064, "X0 should be 0x000000000080A064");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `ADDS X0, X1, #0`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero operands (32)
#[test]
fn test_aarch32_rsc_i_a1_a_adds_oracle_32_1_22e00020() {
    // Test ADDS 32-bit: zero operands (with oracle verification)
    // Encoding: 0x22E00020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x22E00020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x800000, "W0 should be 0x800000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `ADDS X0, X1, #0`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero operands (64)
#[test]
fn test_aarch32_rsc_i_a1_a_adds_oracle_64_1_a2e00020() {
    // Test ADDS 64-bit: zero operands (with oracle verification)
    // Encoding: 0xA2E00020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xA2E00020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x800000, "X0 should be 0x0000000000800000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// small values (32)
#[test]
fn test_aarch32_rsc_i_a1_a_adds_oracle_32_2_22e00420() {
    // Test ADDS 32-bit: small values (with oracle verification)
    // Encoding: 0x22E00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x22E00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x801001, "W0 should be 0x801001");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// small values (64)
#[test]
fn test_aarch32_rsc_i_a1_a_adds_oracle_64_2_a2e00420() {
    // Test ADDS 64-bit: small values (with oracle verification)
    // Encoding: 0xA2E00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xA2E00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x801001, "X0 should be 0x0000000000801001");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `ADDS X0, X1, #4095`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_rsc_i_a1_a_adds_oracle_32_3_22fffc20() {
    // Test ADDS 32-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0x22FFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x22FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF000, "W0 should be 0xFFF000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `ADDS X0, X1, #4095`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_rsc_i_a1_a_adds_oracle_64_3_a2fffc20() {
    // Test ADDS 64-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0xA2FFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xA2FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF000, "X0 should be 0x0000000000FFF000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `ADDS X0, X1, #4095, LSL #12`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_rsc_i_a1_a_adds_oracle_32_4_22fffc20() {
    // Test ADDS 32-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0x22FFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x22FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF000, "W0 should be 0xFFF000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `ADDS X0, X1, #4095, LSL #12`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_rsc_i_a1_a_adds_oracle_64_4_a2fffc20() {
    // Test ADDS 64-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0xA2FFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xA2FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF000, "X0 should be 0x0000000000FFF000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max u64 operand (32)
#[test]
fn test_aarch32_rsc_i_a1_a_adds_oracle_32_5_22e00420() {
    // Test ADDS 32-bit: max u64 operand (with oracle verification)
    // Encoding: 0x22E00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x22E00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x800FFF, "W0 should be 0x800FFF");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max u64 operand (64)
#[test]
fn test_aarch32_rsc_i_a1_a_adds_oracle_64_5_a2e00420() {
    // Test ADDS 64-bit: max u64 operand (with oracle verification)
    // Encoding: 0xA2E00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xA2E00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x800FFF, "X0 should be 0x0000000000800FFF");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_rsc_i_a1_a_adds_oracle_32_6_22e00420() {
    // Test ADDS 32-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0x22E00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x22E00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x801000, "W0 should be 0x801000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_rsc_i_a1_a_adds_oracle_64_6_a2e00420() {
    // Test ADDS 64-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0xA2E00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xA2E00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x801000, "X0 should be 0x0000000000801000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_rsc_i_a1_a_adds_oracle_32_7_22e00420() {
    // Test ADDS 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0x22E00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x22E00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x800FFF, "W0 should be 0x800FFF");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_rsc_i_a1_a_adds_oracle_64_7_a2e00420() {
    // Test ADDS 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0xA2E00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xA2E00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x800FFF, "X0 should be 0x8000000000800FFF");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, true, "V flag should be true");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_rsc_i_a1_a_adds_oracle_32_8_22e00420() {
    // Test ADDS 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0x22E00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x22E00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80800FFF, "W0 should be 0x80800FFF");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, true, "V flag should be true");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_rsc_i_a1_a_adds_oracle_64_8_a2e00420() {
    // Test ADDS 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0xA2E00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xA2E00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x80800FFF,
        "X0 should be 0x0000000080800FFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_rsc_i_a1_a_adds_oracle_32_9_22e00420() {
    // Test ADDS 32-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0x22E00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x22E00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x800FFF, "W0 should be 0x800FFF");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_rsc_i_a1_a_adds_oracle_64_9_a2e00420() {
    // Test ADDS 64-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0xA2E00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xA2E00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x800FFF, "X0 should be 0x0000000000800FFF");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_rsc_i_a1_a_adds_oracle_32_10_22e00420() {
    // Test ADDS 32-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0x22E00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x22E00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x800FFF, "W0 should be 0x800FFF");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_rsc_i_a1_a_adds_oracle_64_10_a2e00420() {
    // Test ADDS 64-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0xA2E00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xA2E00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x800FFF, "X0 should be 0x0000000100800FFF");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `ADDS ZR, X1, #10`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "result discarded, flags set" }
/// ZR destination (32)
#[test]
fn test_aarch32_rsc_i_a1_a_adds_oracle_32_rd31_zr_22e0283f() {
    // Test ADDS 32-bit with Rd=31 (ZR)
    // Encoding: 0x22E0283F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x22E0283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `ADDS ZR, X1, #10`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "result discarded, flags set" }
/// ZR destination (64)
#[test]
fn test_aarch32_rsc_i_a1_a_adds_oracle_64_rd31_zr_a2e0283f() {
    // Test ADDS 64-bit with Rd=31 (ZR)
    // Encoding: 0xA2E0283F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xA2E0283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `SUB X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_rsc_i_a1_a_sub_oracle_32_0_42e02820() {
    // Test SUB 32-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0x42E02820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x42E02820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF7F6064, "W0 should be 0xFF7F6064");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `SUB X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_rsc_i_a1_a_sub_oracle_64_0_c2e02820() {
    // Test SUB 64-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0xC2E02820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xC2E02820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF7F6064,
        "X0 should be 0xFFFFFFFFFF7F6064"
    );
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `SUB X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero operands (32)
#[test]
fn test_aarch32_rsc_i_a1_a_sub_oracle_32_1_42e00020() {
    // Test SUB 32-bit: zero operands (with oracle verification)
    // Encoding: 0x42E00020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x42E00020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF800000, "W0 should be 0xFF800000");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `SUB X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero operands (64)
#[test]
fn test_aarch32_rsc_i_a1_a_sub_oracle_64_1_c2e00020() {
    // Test SUB 64-bit: zero operands (with oracle verification)
    // Encoding: 0xC2E00020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xC2E00020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF800000,
        "X0 should be 0xFFFFFFFFFF800000"
    );
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small values (32)
#[test]
fn test_aarch32_rsc_i_a1_a_sub_oracle_32_2_42e00420() {
    // Test SUB 32-bit: small values (with oracle verification)
    // Encoding: 0x42E00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x42E00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF7FF001, "W0 should be 0xFF7FF001");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// small values (64)
#[test]
fn test_aarch32_rsc_i_a1_a_sub_oracle_64_2_c2e00420() {
    // Test SUB 64-bit: small values (with oracle verification)
    // Encoding: 0xC2E00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xC2E00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF7FF001,
        "X0 should be 0xFFFFFFFFFF7FF001"
    );
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `SUB X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_rsc_i_a1_a_sub_oracle_32_3_42fffc20() {
    // Test SUB 32-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0x42FFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x42FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF001000, "W0 should be 0xFF001000");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `SUB X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_rsc_i_a1_a_sub_oracle_64_3_c2fffc20() {
    // Test SUB 64-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0xC2FFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xC2FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `SUB X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_rsc_i_a1_a_sub_oracle_32_4_42fffc20() {
    // Test SUB 32-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0x42FFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x42FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF001000, "W0 should be 0xFF001000");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `SUB X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_rsc_i_a1_a_sub_oracle_64_4_c2fffc20() {
    // Test SUB 64-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0xC2FFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xC2FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max u64 operand (32)
#[test]
fn test_aarch32_rsc_i_a1_a_sub_oracle_32_5_42e00420() {
    // Test SUB 32-bit: max u64 operand (with oracle verification)
    // Encoding: 0x42E00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x42E00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF7FEFFF, "W0 should be 0xFF7FEFFF");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max u64 operand (64)
#[test]
fn test_aarch32_rsc_i_a1_a_sub_oracle_64_5_c2e00420() {
    // Test SUB 64-bit: max u64 operand (with oracle verification)
    // Encoding: 0xC2E00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xC2E00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF7FEFFF,
        "X0 should be 0xFFFFFFFFFF7FEFFF"
    );
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_rsc_i_a1_a_sub_oracle_32_6_42e00420() {
    // Test SUB 32-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0x42E00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x42E00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF7FF000, "W0 should be 0xFF7FF000");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_rsc_i_a1_a_sub_oracle_64_6_c2e00420() {
    // Test SUB 64-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0xC2E00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xC2E00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF7FF000,
        "X0 should be 0xFFFFFFFFFF7FF000"
    );
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_rsc_i_a1_a_sub_oracle_32_7_42e00420() {
    // Test SUB 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0x42E00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x42E00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF7FEFFF, "W0 should be 0xFF7FEFFF");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_rsc_i_a1_a_sub_oracle_64_7_c2e00420() {
    // Test SUB 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0xC2E00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xC2E00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF7FEFFF,
        "X0 should be 0x7FFFFFFFFF7FEFFF"
    );
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_rsc_i_a1_a_sub_oracle_32_8_42e00420() {
    // Test SUB 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0x42E00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x42E00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7F7FEFFF, "W0 should be 0x7F7FEFFF");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_rsc_i_a1_a_sub_oracle_64_8_c2e00420() {
    // Test SUB 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0xC2E00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xC2E00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x7F7FEFFF,
        "X0 should be 0x000000007F7FEFFF"
    );
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_rsc_i_a1_a_sub_oracle_32_9_42e00420() {
    // Test SUB 32-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0x42E00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x42E00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF7FEFFF, "W0 should be 0xFF7FEFFF");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_rsc_i_a1_a_sub_oracle_64_9_c2e00420() {
    // Test SUB 64-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0xC2E00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xC2E00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF7FEFFF,
        "X0 should be 0xFFFFFFFFFF7FEFFF"
    );
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_rsc_i_a1_a_sub_oracle_32_10_42e00420() {
    // Test SUB 32-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0x42E00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x42E00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF7FEFFF, "W0 should be 0xFF7FEFFF");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_rsc_i_a1_a_sub_oracle_64_10_c2e00420() {
    // Test SUB 64-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0xC2E00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xC2E00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF7FEFFF,
        "X0 should be 0x00000000FF7FEFFF"
    );
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `SUB SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (32)
#[test]
fn test_aarch32_rsc_i_a1_a_sub_oracle_32_rd31_sp_42e0283f() {
    // Test SUB 32-bit with Rd=31 (SP)
    // Encoding: 0x42E0283F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x42E0283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    // TODO: assertion - TestAssertion { check: Sp, expected: U64(4286537828), message: "SP should be 0xFF7F6064" }
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `SUB SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (64)
#[test]
fn test_aarch32_rsc_i_a1_a_sub_oracle_64_rd31_sp_c2e0283f() {
    // Test SUB 64-bit with Rd=31 (SP)
    // Encoding: 0xC2E0283F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xC2E0283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    // TODO: assertion - TestAssertion { check: Sp, expected: U64(18446744073701122148), message: "SP should be 0xFFFFFFFFFF7F6064" }
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `SUBS X0, X1, #10`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_rsc_i_a1_a_subs_oracle_32_0_62e02820() {
    // Test SUBS 32-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0x62E02820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x62E02820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF7F6064, "W0 should be 0xFF7F6064");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `SUBS X0, X1, #10`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_rsc_i_a1_a_subs_oracle_64_0_e2e02820() {
    // Test SUBS 64-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0xE2E02820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xE2E02820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF7F6064,
        "X0 should be 0xFFFFFFFFFF7F6064"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `SUBS X0, X1, #0`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero operands (32)
#[test]
fn test_aarch32_rsc_i_a1_a_subs_oracle_32_1_62e00020() {
    // Test SUBS 32-bit: zero operands (with oracle verification)
    // Encoding: 0x62E00020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x62E00020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF800000, "W0 should be 0xFF800000");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `SUBS X0, X1, #0`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero operands (64)
#[test]
fn test_aarch32_rsc_i_a1_a_subs_oracle_64_1_e2e00020() {
    // Test SUBS 64-bit: zero operands (with oracle verification)
    // Encoding: 0xE2E00020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xE2E00020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF800000,
        "X0 should be 0xFFFFFFFFFF800000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// small values (32)
#[test]
fn test_aarch32_rsc_i_a1_a_subs_oracle_32_2_62e00420() {
    // Test SUBS 32-bit: small values (with oracle verification)
    // Encoding: 0x62E00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x62E00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF7FF001, "W0 should be 0xFF7FF001");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// small values (64)
#[test]
fn test_aarch32_rsc_i_a1_a_subs_oracle_64_2_e2e00420() {
    // Test SUBS 64-bit: small values (with oracle verification)
    // Encoding: 0xE2E00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xE2E00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF7FF001,
        "X0 should be 0xFFFFFFFFFF7FF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `SUBS X0, X1, #4095`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_rsc_i_a1_a_subs_oracle_32_3_62fffc20() {
    // Test SUBS 32-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0x62FFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x62FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF001000, "W0 should be 0xFF001000");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `SUBS X0, X1, #4095`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_rsc_i_a1_a_subs_oracle_64_3_e2fffc20() {
    // Test SUBS 64-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0xE2FFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xE2FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `SUBS X0, X1, #4095, LSL #12`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_rsc_i_a1_a_subs_oracle_32_4_62fffc20() {
    // Test SUBS 32-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0x62FFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x62FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF001000, "W0 should be 0xFF001000");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `SUBS X0, X1, #4095, LSL #12`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_rsc_i_a1_a_subs_oracle_64_4_e2fffc20() {
    // Test SUBS 64-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0xE2FFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xE2FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max u64 operand (32)
#[test]
fn test_aarch32_rsc_i_a1_a_subs_oracle_32_5_62e00420() {
    // Test SUBS 32-bit: max u64 operand (with oracle verification)
    // Encoding: 0x62E00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x62E00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF7FEFFF, "W0 should be 0xFF7FEFFF");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max u64 operand (64)
#[test]
fn test_aarch32_rsc_i_a1_a_subs_oracle_64_5_e2e00420() {
    // Test SUBS 64-bit: max u64 operand (with oracle verification)
    // Encoding: 0xE2E00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xE2E00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF7FEFFF,
        "X0 should be 0xFFFFFFFFFF7FEFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_rsc_i_a1_a_subs_oracle_32_6_62e00420() {
    // Test SUBS 32-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0x62E00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x62E00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF7FF000, "W0 should be 0xFF7FF000");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_rsc_i_a1_a_subs_oracle_64_6_e2e00420() {
    // Test SUBS 64-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0xE2E00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xE2E00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF7FF000,
        "X0 should be 0xFFFFFFFFFF7FF000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_rsc_i_a1_a_subs_oracle_32_7_62e00420() {
    // Test SUBS 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0x62E00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x62E00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF7FEFFF, "W0 should be 0xFF7FEFFF");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_rsc_i_a1_a_subs_oracle_64_7_e2e00420() {
    // Test SUBS 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0xE2E00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xE2E00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF7FEFFF,
        "X0 should be 0x7FFFFFFFFF7FEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_rsc_i_a1_a_subs_oracle_32_8_62e00420() {
    // Test SUBS 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0x62E00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x62E00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7F7FEFFF, "W0 should be 0x7F7FEFFF");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_rsc_i_a1_a_subs_oracle_64_8_e2e00420() {
    // Test SUBS 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0xE2E00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xE2E00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x7F7FEFFF,
        "X0 should be 0x000000007F7FEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_rsc_i_a1_a_subs_oracle_32_9_62e00420() {
    // Test SUBS 32-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0x62E00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x62E00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF7FEFFF, "W0 should be 0xFF7FEFFF");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_rsc_i_a1_a_subs_oracle_64_9_e2e00420() {
    // Test SUBS 64-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0xE2E00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xE2E00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF7FEFFF,
        "X0 should be 0xFFFFFFFFFF7FEFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_rsc_i_a1_a_subs_oracle_32_10_62e00420() {
    // Test SUBS 32-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0x62E00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x62E00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF7FEFFF, "W0 should be 0xFF7FEFFF");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_rsc_i_a1_a_subs_oracle_64_10_e2e00420() {
    // Test SUBS 64-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0xE2E00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xE2E00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF7FEFFF,
        "X0 should be 0x00000000FF7FEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `SUBS ZR, X1, #10`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "result discarded, flags set" }
/// ZR destination (32)
#[test]
fn test_aarch32_rsc_i_a1_a_subs_oracle_32_rd31_zr_62e0283f() {
    // Test SUBS 32-bit with Rd=31 (ZR)
    // Encoding: 0x62E0283F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x62E0283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `SUBS ZR, X1, #10`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "result discarded, flags set" }
/// ZR destination (64)
#[test]
fn test_aarch32_rsc_i_a1_a_subs_oracle_64_rd31_zr_e2e0283f() {
    // Test SUBS 64-bit with Rd=31 (ZR)
    // Encoding: 0xE2E0283F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xE2E0283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `SUB R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x00000000)
#[test]
fn test_aarch32_rsc_i_a1_a_a32_add_sub_imm_0_0_0241000a() {
    // Test A32 SUB: small immediate (oracle)
    // Encoding: 0x0241000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x0241000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFF6, "R0 should be 0xFFFFFFF6");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `SUB R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x00000064)
#[test]
fn test_aarch32_rsc_i_a1_a_a32_add_sub_imm_0_64_0241000a() {
    // Test A32 SUB: small immediate (oracle)
    // Encoding: 0x0241000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x0241000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x5A, "R0 should be 0x0000005A");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `SUB R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_rsc_i_a1_a_a32_add_sub_imm_0_7fffffff_0241000a() {
    // Test A32 SUB: small immediate (oracle)
    // Encoding: 0x0241000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x0241000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FFFFFF5, "R0 should be 0x7FFFFFF5");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `SUB R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x80000000)
#[test]
fn test_aarch32_rsc_i_a1_a_a32_add_sub_imm_0_80000000_0241000a() {
    // Test A32 SUB: small immediate (oracle)
    // Encoding: 0x0241000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0x0241000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FFFFFF6, "R0 should be 0x7FFFFFF6");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `SUB R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_rsc_i_a1_a_a32_add_sub_imm_0_ffffffff_0241000a() {
    // Test A32 SUB: small immediate (oracle)
    // Encoding: 0x0241000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x0241000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFF5, "R0 should be 0xFFFFFFF5");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `SUB R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x00000000)
#[test]
fn test_aarch32_rsc_i_a1_a_a32_add_sub_imm_1_0_024100ff() {
    // Test A32 SUB: max imm8 (oracle)
    // Encoding: 0x024100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x024100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFF01, "R0 should be 0xFFFFFF01");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `SUB R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x00000064)
#[test]
fn test_aarch32_rsc_i_a1_a_a32_add_sub_imm_1_64_024100ff() {
    // Test A32 SUB: max imm8 (oracle)
    // Encoding: 0x024100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x024100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFF65, "R0 should be 0xFFFFFF65");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `SUB R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_rsc_i_a1_a_a32_add_sub_imm_1_7fffffff_024100ff() {
    // Test A32 SUB: max imm8 (oracle)
    // Encoding: 0x024100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x024100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FFFFF00, "R0 should be 0x7FFFFF00");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `SUB R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x80000000)
#[test]
fn test_aarch32_rsc_i_a1_a_a32_add_sub_imm_1_80000000_024100ff() {
    // Test A32 SUB: max imm8 (oracle)
    // Encoding: 0x024100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0x024100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FFFFF01, "R0 should be 0x7FFFFF01");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `SUB R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_rsc_i_a1_a_a32_add_sub_imm_1_ffffffff_024100ff() {
    // Test A32 SUB: max imm8 (oracle)
    // Encoding: 0x024100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x024100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFF00, "R0 should be 0xFFFFFF00");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `SUB R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x00000000)
#[test]
fn test_aarch32_rsc_i_a1_a_a32_add_sub_imm_2_0_02410180() {
    // Test A32 SUB: rotated by 2 (oracle)
    // Encoding: 0x02410180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x02410180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFE0, "R0 should be 0xFFFFFFE0");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `SUB R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x00000064)
#[test]
fn test_aarch32_rsc_i_a1_a_a32_add_sub_imm_2_64_02410180() {
    // Test A32 SUB: rotated by 2 (oracle)
    // Encoding: 0x02410180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x02410180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x44, "R0 should be 0x00000044");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `SUB R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_rsc_i_a1_a_a32_add_sub_imm_2_7fffffff_02410180() {
    // Test A32 SUB: rotated by 2 (oracle)
    // Encoding: 0x02410180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x02410180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FFFFFDF, "R0 should be 0x7FFFFFDF");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `SUB R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x80000000)
#[test]
fn test_aarch32_rsc_i_a1_a_a32_add_sub_imm_2_80000000_02410180() {
    // Test A32 SUB: rotated by 2 (oracle)
    // Encoding: 0x02410180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0x02410180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FFFFFE0, "R0 should be 0x7FFFFFE0");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `SUB R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_rsc_i_a1_a_a32_add_sub_imm_2_ffffffff_02410180() {
    // Test A32 SUB: rotated by 2 (oracle)
    // Encoding: 0x02410180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x02410180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFDF, "R0 should be 0xFFFFFFDF");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `SUB R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x00000000)
#[test]
fn test_aarch32_rsc_i_a1_a_a32_add_sub_imm_3_0_0241040f() {
    // Test A32 SUB: rotated by 8 (oracle)
    // Encoding: 0x0241040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x0241040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xF1000000, "R0 should be 0xF1000000");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `SUB R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x00000064)
#[test]
fn test_aarch32_rsc_i_a1_a_a32_add_sub_imm_3_64_0241040f() {
    // Test A32 SUB: rotated by 8 (oracle)
    // Encoding: 0x0241040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x0241040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xF1000064, "R0 should be 0xF1000064");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `SUB R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_rsc_i_a1_a_a32_add_sub_imm_3_7fffffff_0241040f() {
    // Test A32 SUB: rotated by 8 (oracle)
    // Encoding: 0x0241040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x0241040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x70FFFFFF, "R0 should be 0x70FFFFFF");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `SUB R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x80000000)
#[test]
fn test_aarch32_rsc_i_a1_a_a32_add_sub_imm_3_80000000_0241040f() {
    // Test A32 SUB: rotated by 8 (oracle)
    // Encoding: 0x0241040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0x0241040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x71000000, "R0 should be 0x71000000");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `SUB R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_rsc_i_a1_a_a32_add_sub_imm_3_ffffffff_0241040f() {
    // Test A32 SUB: rotated by 8 (oracle)
    // Encoding: 0x0241040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x0241040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xF0FFFFFF, "R0 should be 0xF0FFFFFF");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `SUB R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x00000000)
#[test]
fn test_aarch32_rsc_i_a1_a_a32_add_sub_imm_4_0_02410000() {
    // Test A32 SUB: zero immediate (oracle)
    // Encoding: 0x02410000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x02410000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `SUB R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x00000064)
#[test]
fn test_aarch32_rsc_i_a1_a_a32_add_sub_imm_4_64_02410000() {
    // Test A32 SUB: zero immediate (oracle)
    // Encoding: 0x02410000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x02410000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x64, "R0 should be 0x00000064");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `SUB R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_rsc_i_a1_a_a32_add_sub_imm_4_7fffffff_02410000() {
    // Test A32 SUB: zero immediate (oracle)
    // Encoding: 0x02410000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x02410000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FFFFFFF, "R0 should be 0x7FFFFFFF");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `SUB R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x80000000)
#[test]
fn test_aarch32_rsc_i_a1_a_a32_add_sub_imm_4_80000000_02410000() {
    // Test A32 SUB: zero immediate (oracle)
    // Encoding: 0x02410000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0x02410000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "R0 should be 0x80000000");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `SUB R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_rsc_i_a1_a_a32_add_sub_imm_4_ffffffff_02410000() {
    // Test A32 SUB: zero immediate (oracle)
    // Encoding: 0x02410000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x02410000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "R0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_aarch32_rsc_i_a1_a_flags_zeroresult_0_02f10000() {
    // Test aarch32_RSC_i_A1_A flag computation: ZeroResult
    // Encoding: 0x02F10000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x02F10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_aarch32_rsc_i_a1_a_flags_zeroresult_1_02f10000() {
    // Test aarch32_RSC_i_A1_A flag computation: ZeroResult
    // Encoding: 0x02F10000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x02F10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_aarch32_rsc_i_a1_a_flags_negativeresult_2_02f10000() {
    // Test aarch32_RSC_i_A1_A flag computation: NegativeResult
    // Encoding: 0x02F10000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x02F10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_aarch32_rsc_i_a1_a_flags_unsignedoverflow_3_02f10000() {
    // Test aarch32_RSC_i_A1_A flag computation: UnsignedOverflow
    // Encoding: 0x02F10000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x02F10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_aarch32_rsc_i_a1_a_flags_unsignedoverflow_4_02f10000() {
    // Test aarch32_RSC_i_A1_A flag computation: UnsignedOverflow
    // Encoding: 0x02F10000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x02F10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_aarch32_rsc_i_a1_a_flags_signedoverflow_5_02f10000() {
    // Test aarch32_RSC_i_A1_A flag computation: SignedOverflow
    // Encoding: 0x02F10000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x02F10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_aarch32_rsc_i_a1_a_flags_signedoverflow_6_02f10000() {
    // Test aarch32_RSC_i_A1_A flag computation: SignedOverflow
    // Encoding: 0x02F10000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x02F10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_RSC_i_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_aarch32_rsc_i_a1_a_flags_positiveresult_7_02f10000() {
    // Test aarch32_RSC_i_A1_A flag computation: PositiveResult
    // Encoding: 0x02F10000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x32);
    let encoding: u32 = 0x02F10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

// ============================================================================
// aarch32_SBC_rr_A Tests
// ============================================================================

/// Provenance: aarch32_SBC_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_sbc_rr_a1_a_field_cond_0_min_10_00c00010() {
    // Encoding: 0x00C00010
    // Test aarch32_SBC_rr_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: S=0, Rm=0, Rn=0, cond=0, Rs=0, Rd=0, type1=0
    let encoding: u32 = 0x00C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_sbc_rr_a1_a_field_cond_1_poweroftwo_10_10c00010() {
    // Encoding: 0x10C00010
    // Test aarch32_SBC_rr_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=1, type1=0, S=0, Rs=0, Rd=0, Rm=0
    let encoding: u32 = 0x10C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_sbc_rr_a1_a_field_cond_2_poweroftwo_10_20c00010() {
    // Encoding: 0x20C00010
    // Test aarch32_SBC_rr_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Rs=0, Rn=0, type1=0, Rm=0, S=0, cond=2, Rd=0
    let encoding: u32 = 0x20C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_sbc_rr_a1_a_field_cond_3_poweroftwo_10_30c00010() {
    // Encoding: 0x30C00010
    // Test aarch32_SBC_rr_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rs=0, cond=3, Rm=0, Rd=0, S=0, type1=0
    let encoding: u32 = 0x30C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_sbc_rr_a1_a_field_cond_4_poweroftwo_10_40c00010() {
    // Encoding: 0x40C00010
    // Test aarch32_SBC_rr_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Rd=0, Rs=0, Rn=0, cond=4, type1=0, S=0
    let encoding: u32 = 0x40C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_sbc_rr_a1_a_field_cond_5_poweroftwo_10_50c00010() {
    // Encoding: 0x50C00010
    // Test aarch32_SBC_rr_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: type1=0, Rd=0, cond=5, Rs=0, Rn=0, Rm=0, S=0
    let encoding: u32 = 0x50C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_sbc_rr_a1_a_field_cond_6_poweroftwo_10_60c00010() {
    // Encoding: 0x60C00010
    // Test aarch32_SBC_rr_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: type1=0, Rn=0, Rs=0, Rm=0, Rd=0, cond=6, S=0
    let encoding: u32 = 0x60C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_sbc_rr_a1_a_field_cond_7_poweroftwo_10_70c00010() {
    // Encoding: 0x70C00010
    // Test aarch32_SBC_rr_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=7, Rd=0, S=0, type1=0, Rm=0, Rn=0, Rs=0
    let encoding: u32 = 0x70C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_sbc_rr_a1_a_field_cond_8_poweroftwo_10_80c00010() {
    // Encoding: 0x80C00010
    // Test aarch32_SBC_rr_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Rn=0, cond=8, S=0, Rd=0, Rs=0, type1=0
    let encoding: u32 = 0x80C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_sbc_rr_a1_a_field_cond_9_poweroftwo_10_90c00010() {
    // Encoding: 0x90C00010
    // Test aarch32_SBC_rr_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, cond=9, Rd=0, type1=0, Rn=0, Rs=0, S=0
    let encoding: u32 = 0x90C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_sbc_rr_a1_a_field_cond_10_poweroftwo_10_a0c00010() {
    // Encoding: 0xA0C00010
    // Test aarch32_SBC_rr_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: type1=0, Rm=0, Rs=0, S=0, Rn=0, Rd=0, cond=10
    let encoding: u32 = 0xA0C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_sbc_rr_a1_a_field_cond_11_poweroftwo_10_b0c00010() {
    // Encoding: 0xB0C00010
    // Test aarch32_SBC_rr_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=11, type1=0, Rm=0, S=0, Rn=0, Rs=0, Rd=0
    let encoding: u32 = 0xB0C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_sbc_rr_a1_a_field_cond_12_poweroftwo_10_c0c00010() {
    // Encoding: 0xC0C00010
    // Test aarch32_SBC_rr_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Rn=0, Rd=0, S=0, cond=12, Rs=0, type1=0
    let encoding: u32 = 0xC0C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_sbc_rr_a1_a_field_cond_13_poweroftwo_10_d0c00010() {
    // Encoding: 0xD0C00010
    // Test aarch32_SBC_rr_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, Rd=0, cond=13, type1=0, Rm=0, Rn=0, Rs=0
    let encoding: u32 = 0xD0C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_sbc_rr_a1_a_field_cond_14_poweroftwo_10_e0c00010() {
    // Encoding: 0xE0C00010
    // Test aarch32_SBC_rr_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: type1=0, S=0, Rn=0, Rd=0, cond=14, Rs=0, Rm=0
    let encoding: u32 = 0xE0C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_sbc_rr_a1_a_field_cond_15_max_10_f0c00010() {
    // Encoding: 0xF0C00010
    // Test aarch32_SBC_rr_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: S=0, Rd=0, Rs=0, type1=0, Rm=0, cond=15, Rn=0
    let encoding: u32 = 0xF0C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_rr_A1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_sbc_rr_a1_a_field_s_0_min_10_00c00010() {
    // Encoding: 0x00C00010
    // Test aarch32_SBC_rr_A1_A field S = 0 (Min)
    // ISET: A32
    // Fields: Rs=0, Rn=0, cond=0, type1=0, Rd=0, Rm=0, S=0
    let encoding: u32 = 0x00C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_rr_A1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_sbc_rr_a1_a_field_s_1_max_10_00d00010() {
    // Encoding: 0x00D00010
    // Test aarch32_SBC_rr_A1_A field S = 1 (Max)
    // ISET: A32
    // Fields: Rm=0, cond=0, S=1, Rd=0, Rn=0, Rs=0, type1=0
    let encoding: u32 = 0x00D00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_rr_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_sbc_rr_a1_a_field_rn_0_min_10_00c00010() {
    // Encoding: 0x00C00010
    // Test aarch32_SBC_rr_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rs=0, Rm=0, Rn=0, type1=0, S=0, Rd=0
    let encoding: u32 = 0x00C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_rr_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_sbc_rr_a1_a_field_rn_1_poweroftwo_10_00c10010() {
    // Encoding: 0x00C10010
    // Test aarch32_SBC_rr_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Rn=1, cond=0, S=0, type1=0, Rd=0, Rs=0
    let encoding: u32 = 0x00C10010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_rr_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_sbc_rr_a1_a_field_rd_0_min_10_00c00010() {
    // Encoding: 0x00C00010
    // Test aarch32_SBC_rr_A1_A field Rd = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, S=0, Rn=0, cond=0, Rd=0, type1=0, Rs=0
    let encoding: u32 = 0x00C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_rr_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_sbc_rr_a1_a_field_rd_1_poweroftwo_10_00c01010() {
    // Encoding: 0x00C01010
    // Test aarch32_SBC_rr_A1_A field Rd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: type1=0, S=0, Rm=0, Rn=0, Rd=1, cond=0, Rs=0
    let encoding: u32 = 0x00C01010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_rr_A1_A
/// ASL: `field Rs 8 +: 4`
/// Requirement: FieldBoundary { field: "Rs", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_sbc_rr_a1_a_field_rs_0_min_10_00c00010() {
    // Encoding: 0x00C00010
    // Test aarch32_SBC_rr_A1_A field Rs = 0 (Min)
    // ISET: A32
    // Fields: type1=0, cond=0, Rm=0, Rs=0, Rd=0, Rn=0, S=0
    let encoding: u32 = 0x00C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_rr_A1_A
/// ASL: `field Rs 8 +: 4`
/// Requirement: FieldBoundary { field: "Rs", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_sbc_rr_a1_a_field_rs_1_poweroftwo_10_00c00110() {
    // Encoding: 0x00C00110
    // Test aarch32_SBC_rr_A1_A field Rs = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, Rm=0, Rd=0, Rn=0, Rs=1, type1=0, cond=0
    let encoding: u32 = 0x00C00110;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_rr_A1_A
/// ASL: `field type1 5 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_sbc_rr_a1_a_field_type1_0_min_10_00c00010() {
    // Encoding: 0x00C00010
    // Test aarch32_SBC_rr_A1_A field type1 = 0 (Min)
    // ISET: A32
    // Fields: type1=0, Rm=0, cond=0, Rd=0, Rn=0, S=0, Rs=0
    let encoding: u32 = 0x00C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_rr_A1_A
/// ASL: `field type1 5 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_sbc_rr_a1_a_field_type1_1_poweroftwo_10_00c00030() {
    // Encoding: 0x00C00030
    // Test aarch32_SBC_rr_A1_A field type1 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rs=0, Rm=0, type1=1, Rd=0, S=0, cond=0, Rn=0
    let encoding: u32 = 0x00C00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_rr_A1_A
/// ASL: `field type1 5 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_aarch32_sbc_rr_a1_a_field_type1_3_max_10_00c00070() {
    // Encoding: 0x00C00070
    // Test aarch32_SBC_rr_A1_A field type1 = 3 (Max)
    // ISET: A32
    // Fields: S=0, Rs=0, Rd=0, Rm=0, type1=3, cond=0, Rn=0
    let encoding: u32 = 0x00C00070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_rr_A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_sbc_rr_a1_a_field_rm_0_min_10_00c00010() {
    // Encoding: 0x00C00010
    // Test aarch32_SBC_rr_A1_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: Rd=0, Rm=0, Rs=0, type1=0, S=0, Rn=0, cond=0
    let encoding: u32 = 0x00C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_rr_A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_sbc_rr_a1_a_field_rm_1_poweroftwo_10_00c00011() {
    // Encoding: 0x00C00011
    // Test aarch32_SBC_rr_A1_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rm=1, Rd=0, S=0, cond=0, Rs=0, type1=0
    let encoding: u32 = 0x00C00011;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_rr_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_sbc_rr_a1_a_combo_0_10_00c00010() {
    // Encoding: 0x00C00010
    // Test aarch32_SBC_rr_A1_A field combination: cond=0, S=0, Rn=0, Rd=0, Rs=0, type1=0, Rm=0
    // ISET: A32
    // Fields: Rs=0, type1=0, Rm=0, cond=0, S=0, Rn=0, Rd=0
    let encoding: u32 = 0x00C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_rr_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_sbc_rr_a1_a_special_cond_0_condition_eq_16_00c00010() {
    // Encoding: 0x00C00010
    // Test aarch32_SBC_rr_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: cond=0, Rd=0, S=0, Rs=0, Rn=0, type1=0, Rm=0
    let encoding: u32 = 0x00C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_rr_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_sbc_rr_a1_a_special_cond_1_condition_ne_16_10c00010() {
    // Encoding: 0x10C00010
    // Test aarch32_SBC_rr_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: cond=1, Rn=0, Rs=0, S=0, type1=0, Rd=0, Rm=0
    let encoding: u32 = 0x10C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_rr_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_sbc_rr_a1_a_special_cond_2_condition_cs_hs_16_20c00010() {
    // Encoding: 0x20C00010
    // Test aarch32_SBC_rr_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: Rm=0, S=0, Rn=0, Rs=0, cond=2, Rd=0, type1=0
    let encoding: u32 = 0x20C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_rr_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_sbc_rr_a1_a_special_cond_3_condition_cc_lo_16_30c00010() {
    // Encoding: 0x30C00010
    // Test aarch32_SBC_rr_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: Rm=0, Rd=0, S=0, type1=0, Rn=0, Rs=0, cond=3
    let encoding: u32 = 0x30C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_rr_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_sbc_rr_a1_a_special_cond_4_condition_mi_16_40c00010() {
    // Encoding: 0x40C00010
    // Test aarch32_SBC_rr_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: type1=0, Rm=0, Rs=0, cond=4, S=0, Rd=0, Rn=0
    let encoding: u32 = 0x40C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_rr_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_sbc_rr_a1_a_special_cond_5_condition_pl_16_50c00010() {
    // Encoding: 0x50C00010
    // Test aarch32_SBC_rr_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: Rn=0, type1=0, Rd=0, S=0, cond=5, Rm=0, Rs=0
    let encoding: u32 = 0x50C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_rr_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_sbc_rr_a1_a_special_cond_6_condition_vs_16_60c00010() {
    // Encoding: 0x60C00010
    // Test aarch32_SBC_rr_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: S=0, Rs=0, Rd=0, Rm=0, Rn=0, cond=6, type1=0
    let encoding: u32 = 0x60C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_rr_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_sbc_rr_a1_a_special_cond_7_condition_vc_16_70c00010() {
    // Encoding: 0x70C00010
    // Test aarch32_SBC_rr_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: Rs=0, cond=7, type1=0, Rd=0, Rn=0, Rm=0, S=0
    let encoding: u32 = 0x70C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_rr_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_sbc_rr_a1_a_special_cond_8_condition_hi_16_80c00010() {
    // Encoding: 0x80C00010
    // Test aarch32_SBC_rr_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: cond=8, Rn=0, type1=0, Rm=0, Rs=0, S=0, Rd=0
    let encoding: u32 = 0x80C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_rr_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_sbc_rr_a1_a_special_cond_9_condition_ls_16_90c00010() {
    // Encoding: 0x90C00010
    // Test aarch32_SBC_rr_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: Rm=0, Rn=0, Rd=0, S=0, Rs=0, type1=0, cond=9
    let encoding: u32 = 0x90C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_rr_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_sbc_rr_a1_a_special_cond_10_condition_ge_16_a0c00010() {
    // Encoding: 0xA0C00010
    // Test aarch32_SBC_rr_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: Rm=0, S=0, Rn=0, type1=0, Rs=0, cond=10, Rd=0
    let encoding: u32 = 0xA0C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_rr_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_sbc_rr_a1_a_special_cond_11_condition_lt_16_b0c00010() {
    // Encoding: 0xB0C00010
    // Test aarch32_SBC_rr_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: Rs=0, Rm=0, Rn=0, type1=0, Rd=0, S=0, cond=11
    let encoding: u32 = 0xB0C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_rr_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_sbc_rr_a1_a_special_cond_12_condition_gt_16_c0c00010() {
    // Encoding: 0xC0C00010
    // Test aarch32_SBC_rr_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: Rd=0, Rn=0, cond=12, Rm=0, Rs=0, type1=0, S=0
    let encoding: u32 = 0xC0C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_rr_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_sbc_rr_a1_a_special_cond_13_condition_le_16_d0c00010() {
    // Encoding: 0xD0C00010
    // Test aarch32_SBC_rr_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: type1=0, Rn=0, Rm=0, S=0, cond=13, Rd=0, Rs=0
    let encoding: u32 = 0xD0C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_rr_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_sbc_rr_a1_a_special_cond_14_condition_al_16_e0c00010() {
    // Encoding: 0xE0C00010
    // Test aarch32_SBC_rr_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: cond=14, type1=0, Rm=0, Rs=0, Rn=0, S=0, Rd=0
    let encoding: u32 = 0xE0C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_rr_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_sbc_rr_a1_a_special_cond_15_condition_nv_16_f0c00010() {
    // Encoding: 0xF0C00010
    // Test aarch32_SBC_rr_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: Rm=0, Rd=0, Rn=0, S=0, Rs=0, cond=15, type1=0
    let encoding: u32 = 0xF0C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_rr_A1_A
/// ASL: `field S = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "S", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_sbc_rr_a1_a_special_s_0_size_variant_0_16_00c00010() {
    // Encoding: 0x00C00010
    // Test aarch32_SBC_rr_A1_A special value S = 0 (Size variant 0)
    // ISET: A32
    // Fields: cond=0, S=0, Rn=0, Rd=0, Rs=0, Rm=0, type1=0
    let encoding: u32 = 0x00C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_rr_A1_A
/// ASL: `field S = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "S", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_sbc_rr_a1_a_special_s_1_size_variant_1_16_00d00010() {
    // Encoding: 0x00D00010
    // Test aarch32_SBC_rr_A1_A special value S = 1 (Size variant 1)
    // ISET: A32
    // Fields: cond=0, Rd=0, Rs=0, type1=0, Rm=0, S=1, Rn=0
    let encoding: u32 = 0x00D00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_rr_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "s" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"s\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_sbc_rr_a1_a_invalid_0_10_00c00010() {
    // Encoding: 0x00C00010
    // Test aarch32_SBC_rr_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "s" }) } }, rhs: LitInt(15) }
    // ISET: A32
    // Fields: type1=0, Rd=0, S=0, cond=0, Rs=0, Rn=0, Rm=0
    let encoding: u32 = 0x00C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_SBC_rr_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_sbc_rr_a1_a_invalid_1_10_00c00010() {
    // Encoding: 0x00C00010
    // Test aarch32_SBC_rr_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: S=0, Rs=0, Rm=0, type1=0, Rd=0, cond=0, Rn=0
    let encoding: u32 = 0x00C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_SBC_rr_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_aarch32_sbc_rr_a1_a_flags_zeroresult_0_00d10012() {
    // Test aarch32_SBC_rr_A1_A flag computation: ZeroResult
    // Encoding: 0x00D10012
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x00D10012;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SBC_rr_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_aarch32_sbc_rr_a1_a_flags_zeroresult_1_00d10012() {
    // Test aarch32_SBC_rr_A1_A flag computation: ZeroResult
    // Encoding: 0x00D10012
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x00D10012;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SBC_rr_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_aarch32_sbc_rr_a1_a_flags_negativeresult_2_00d10012() {
    // Test aarch32_SBC_rr_A1_A flag computation: NegativeResult
    // Encoding: 0x00D10012
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x00D10012;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SBC_rr_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_aarch32_sbc_rr_a1_a_flags_unsignedoverflow_3_00d10012() {
    // Test aarch32_SBC_rr_A1_A flag computation: UnsignedOverflow
    // Encoding: 0x00D10012
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x00D10012;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SBC_rr_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_aarch32_sbc_rr_a1_a_flags_unsignedoverflow_4_00d10012() {
    // Test aarch32_SBC_rr_A1_A flag computation: UnsignedOverflow
    // Encoding: 0x00D10012
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x00D10012;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SBC_rr_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_aarch32_sbc_rr_a1_a_flags_signedoverflow_5_00d10012() {
    // Test aarch32_SBC_rr_A1_A flag computation: SignedOverflow
    // Encoding: 0x00D10012
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x00D10012;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_SBC_rr_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_aarch32_sbc_rr_a1_a_flags_signedoverflow_6_00d10012() {
    // Test aarch32_SBC_rr_A1_A flag computation: SignedOverflow
    // Encoding: 0x00D10012
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x00D10012;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_SBC_rr_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_aarch32_sbc_rr_a1_a_flags_positiveresult_7_00d10012() {
    // Test aarch32_SBC_rr_A1_A flag computation: PositiveResult
    // Encoding: 0x00D10012
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x32);
    let encoding: u32 = 0x00D10012;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

// ============================================================================
// aarch32_ADD_rr_A Tests
// ============================================================================

/// Provenance: aarch32_ADD_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_add_rr_a1_a_field_cond_0_min_10_00800010() {
    // Encoding: 0x00800010
    // Test aarch32_ADD_rr_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rs=0, Rm=0, Rd=0, Rn=0, type1=0, S=0
    let encoding: u32 = 0x00800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_add_rr_a1_a_field_cond_1_poweroftwo_10_10800010() {
    // Encoding: 0x10800010
    // Test aarch32_ADD_rr_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, cond=1, Rd=0, Rn=0, S=0, type1=0, Rs=0
    let encoding: u32 = 0x10800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_add_rr_a1_a_field_cond_2_poweroftwo_10_20800010() {
    // Encoding: 0x20800010
    // Test aarch32_ADD_rr_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: type1=0, Rn=0, S=0, cond=2, Rm=0, Rs=0, Rd=0
    let encoding: u32 = 0x20800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_add_rr_a1_a_field_cond_3_poweroftwo_10_30800010() {
    // Encoding: 0x30800010
    // Test aarch32_ADD_rr_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, Rs=0, type1=0, Rn=0, Rd=0, Rm=0, cond=3
    let encoding: u32 = 0x30800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_add_rr_a1_a_field_cond_4_poweroftwo_10_40800010() {
    // Encoding: 0x40800010
    // Test aarch32_ADD_rr_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: type1=0, Rs=0, Rm=0, S=0, cond=4, Rn=0, Rd=0
    let encoding: u32 = 0x40800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_add_rr_a1_a_field_cond_5_poweroftwo_10_50800010() {
    // Encoding: 0x50800010
    // Test aarch32_ADD_rr_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, S=0, Rd=0, Rs=0, Rn=0, type1=0, cond=5
    let encoding: u32 = 0x50800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_add_rr_a1_a_field_cond_6_poweroftwo_10_60800010() {
    // Encoding: 0x60800010
    // Test aarch32_ADD_rr_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=6, S=0, Rn=0, type1=0, Rm=0, Rd=0, Rs=0
    let encoding: u32 = 0x60800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_add_rr_a1_a_field_cond_7_poweroftwo_10_70800010() {
    // Encoding: 0x70800010
    // Test aarch32_ADD_rr_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=7, Rs=0, S=0, type1=0, Rd=0, Rm=0
    let encoding: u32 = 0x70800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_add_rr_a1_a_field_cond_8_poweroftwo_10_80800010() {
    // Encoding: 0x80800010
    // Test aarch32_ADD_rr_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, Rn=0, Rs=0, type1=0, Rm=0, cond=8, Rd=0
    let encoding: u32 = 0x80800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_add_rr_a1_a_field_cond_9_poweroftwo_10_90800010() {
    // Encoding: 0x90800010
    // Test aarch32_ADD_rr_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: Rs=0, S=0, Rn=0, cond=9, type1=0, Rd=0, Rm=0
    let encoding: u32 = 0x90800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_add_rr_a1_a_field_cond_10_poweroftwo_10_a0800010() {
    // Encoding: 0xA0800010
    // Test aarch32_ADD_rr_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Rn=0, type1=0, Rd=0, S=0, Rs=0, cond=10
    let encoding: u32 = 0xA0800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_add_rr_a1_a_field_cond_11_poweroftwo_10_b0800010() {
    // Encoding: 0xB0800010
    // Test aarch32_ADD_rr_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=11, Rs=0, Rm=0, S=0, Rd=0, type1=0
    let encoding: u32 = 0xB0800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_add_rr_a1_a_field_cond_12_poweroftwo_10_c0800010() {
    // Encoding: 0xC0800010
    // Test aarch32_ADD_rr_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=12, Rm=0, Rd=0, S=0, Rn=0, Rs=0, type1=0
    let encoding: u32 = 0xC0800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_add_rr_a1_a_field_cond_13_poweroftwo_10_d0800010() {
    // Encoding: 0xD0800010
    // Test aarch32_ADD_rr_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rn=0, cond=13, S=0, Rs=0, Rm=0, type1=0
    let encoding: u32 = 0xD0800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_add_rr_a1_a_field_cond_14_poweroftwo_10_e0800010() {
    // Encoding: 0xE0800010
    // Test aarch32_ADD_rr_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, Rm=0, cond=14, type1=0, Rd=0, Rs=0, Rn=0
    let encoding: u32 = 0xE0800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_add_rr_a1_a_field_cond_15_max_10_f0800010() {
    // Encoding: 0xF0800010
    // Test aarch32_ADD_rr_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: Rs=0, Rm=0, type1=0, cond=15, Rn=0, S=0, Rd=0
    let encoding: u32 = 0xF0800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_rr_A1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_add_rr_a1_a_field_s_0_min_10_00800010() {
    // Encoding: 0x00800010
    // Test aarch32_ADD_rr_A1_A field S = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, Rd=0, cond=0, type1=0, Rm=0, Rs=0, S=0
    let encoding: u32 = 0x00800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_rr_A1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_add_rr_a1_a_field_s_1_max_10_00900010() {
    // Encoding: 0x00900010
    // Test aarch32_ADD_rr_A1_A field S = 1 (Max)
    // ISET: A32
    // Fields: cond=0, type1=0, Rm=0, S=1, Rd=0, Rn=0, Rs=0
    let encoding: u32 = 0x00900010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_rr_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_add_rr_a1_a_field_rn_0_min_10_00800010() {
    // Encoding: 0x00800010
    // Test aarch32_ADD_rr_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: Rs=0, Rn=0, Rd=0, type1=0, cond=0, S=0, Rm=0
    let encoding: u32 = 0x00800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_rr_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_add_rr_a1_a_field_rn_1_poweroftwo_10_00810010() {
    // Encoding: 0x00810010
    // Test aarch32_ADD_rr_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=1, S=0, Rd=0, cond=0, Rs=0, type1=0, Rm=0
    let encoding: u32 = 0x00810010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_rr_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_add_rr_a1_a_field_rd_0_min_10_00800010() {
    // Encoding: 0x00800010
    // Test aarch32_ADD_rr_A1_A field Rd = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, cond=0, Rd=0, Rs=0, type1=0, Rn=0, S=0
    let encoding: u32 = 0x00800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_rr_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_add_rr_a1_a_field_rd_1_poweroftwo_10_00801010() {
    // Encoding: 0x00801010
    // Test aarch32_ADD_rr_A1_A field Rd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, cond=0, type1=0, Rm=0, Rn=0, Rs=0, Rd=1
    let encoding: u32 = 0x00801010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_rr_A1_A
/// ASL: `field Rs 8 +: 4`
/// Requirement: FieldBoundary { field: "Rs", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_add_rr_a1_a_field_rs_0_min_10_00800010() {
    // Encoding: 0x00800010
    // Test aarch32_ADD_rr_A1_A field Rs = 0 (Min)
    // ISET: A32
    // Fields: S=0, Rs=0, cond=0, Rd=0, Rn=0, type1=0, Rm=0
    let encoding: u32 = 0x00800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_rr_A1_A
/// ASL: `field Rs 8 +: 4`
/// Requirement: FieldBoundary { field: "Rs", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_add_rr_a1_a_field_rs_1_poweroftwo_10_00800110() {
    // Encoding: 0x00800110
    // Test aarch32_ADD_rr_A1_A field Rs = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rs=1, Rm=0, Rn=0, cond=0, S=0, type1=0
    let encoding: u32 = 0x00800110;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_rr_A1_A
/// ASL: `field type1 5 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_add_rr_a1_a_field_type1_0_min_10_00800010() {
    // Encoding: 0x00800010
    // Test aarch32_ADD_rr_A1_A field type1 = 0 (Min)
    // ISET: A32
    // Fields: Rd=0, S=0, Rn=0, Rs=0, cond=0, type1=0, Rm=0
    let encoding: u32 = 0x00800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_rr_A1_A
/// ASL: `field type1 5 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_add_rr_a1_a_field_type1_1_poweroftwo_10_00800030() {
    // Encoding: 0x00800030
    // Test aarch32_ADD_rr_A1_A field type1 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, S=0, Rn=0, Rs=0, type1=1, Rd=0, Rm=0
    let encoding: u32 = 0x00800030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_rr_A1_A
/// ASL: `field type1 5 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_aarch32_add_rr_a1_a_field_type1_3_max_10_00800070() {
    // Encoding: 0x00800070
    // Test aarch32_ADD_rr_A1_A field type1 = 3 (Max)
    // ISET: A32
    // Fields: Rs=0, S=0, type1=3, Rn=0, Rm=0, Rd=0, cond=0
    let encoding: u32 = 0x00800070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_rr_A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_add_rr_a1_a_field_rm_0_min_10_00800010() {
    // Encoding: 0x00800010
    // Test aarch32_ADD_rr_A1_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: Rd=0, Rs=0, S=0, type1=0, Rn=0, Rm=0, cond=0
    let encoding: u32 = 0x00800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_rr_A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_add_rr_a1_a_field_rm_1_poweroftwo_10_00800011() {
    // Encoding: 0x00800011
    // Test aarch32_ADD_rr_A1_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rs=0, type1=0, Rm=1, Rd=0, cond=0, S=0, Rn=0
    let encoding: u32 = 0x00800011;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_rr_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_add_rr_a1_a_combo_0_10_00800010() {
    // Encoding: 0x00800010
    // Test aarch32_ADD_rr_A1_A field combination: cond=0, S=0, Rn=0, Rd=0, Rs=0, type1=0, Rm=0
    // ISET: A32
    // Fields: type1=0, Rn=0, Rm=0, Rd=0, cond=0, S=0, Rs=0
    let encoding: u32 = 0x00800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_rr_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_add_rr_a1_a_special_cond_0_condition_eq_16_00800010() {
    // Encoding: 0x00800010
    // Test aarch32_ADD_rr_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: S=0, Rn=0, cond=0, Rs=0, Rd=0, type1=0, Rm=0
    let encoding: u32 = 0x00800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_rr_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_add_rr_a1_a_special_cond_1_condition_ne_16_10800010() {
    // Encoding: 0x10800010
    // Test aarch32_ADD_rr_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: Rs=0, Rm=0, S=0, cond=1, type1=0, Rn=0, Rd=0
    let encoding: u32 = 0x10800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_rr_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_add_rr_a1_a_special_cond_2_condition_cs_hs_16_20800010() {
    // Encoding: 0x20800010
    // Test aarch32_ADD_rr_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: Rd=0, Rn=0, Rm=0, cond=2, Rs=0, S=0, type1=0
    let encoding: u32 = 0x20800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_rr_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_add_rr_a1_a_special_cond_3_condition_cc_lo_16_30800010() {
    // Encoding: 0x30800010
    // Test aarch32_ADD_rr_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: Rn=0, Rs=0, cond=3, Rd=0, type1=0, Rm=0, S=0
    let encoding: u32 = 0x30800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_rr_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_add_rr_a1_a_special_cond_4_condition_mi_16_40800010() {
    // Encoding: 0x40800010
    // Test aarch32_ADD_rr_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: cond=4, S=0, Rd=0, Rn=0, Rs=0, Rm=0, type1=0
    let encoding: u32 = 0x40800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_rr_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_add_rr_a1_a_special_cond_5_condition_pl_16_50800010() {
    // Encoding: 0x50800010
    // Test aarch32_ADD_rr_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: Rs=0, Rm=0, cond=5, Rd=0, type1=0, Rn=0, S=0
    let encoding: u32 = 0x50800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_rr_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_add_rr_a1_a_special_cond_6_condition_vs_16_60800010() {
    // Encoding: 0x60800010
    // Test aarch32_ADD_rr_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: S=0, Rs=0, type1=0, Rn=0, Rm=0, cond=6, Rd=0
    let encoding: u32 = 0x60800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_rr_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_add_rr_a1_a_special_cond_7_condition_vc_16_70800010() {
    // Encoding: 0x70800010
    // Test aarch32_ADD_rr_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: type1=0, Rm=0, Rn=0, Rd=0, cond=7, S=0, Rs=0
    let encoding: u32 = 0x70800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_rr_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_add_rr_a1_a_special_cond_8_condition_hi_16_80800010() {
    // Encoding: 0x80800010
    // Test aarch32_ADD_rr_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: cond=8, Rs=0, S=0, Rm=0, Rd=0, type1=0, Rn=0
    let encoding: u32 = 0x80800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_rr_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_add_rr_a1_a_special_cond_9_condition_ls_16_90800010() {
    // Encoding: 0x90800010
    // Test aarch32_ADD_rr_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: S=0, type1=0, Rs=0, Rm=0, Rd=0, Rn=0, cond=9
    let encoding: u32 = 0x90800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_rr_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_add_rr_a1_a_special_cond_10_condition_ge_16_a0800010() {
    // Encoding: 0xA0800010
    // Test aarch32_ADD_rr_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: cond=10, Rn=0, Rd=0, S=0, Rs=0, type1=0, Rm=0
    let encoding: u32 = 0xA0800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_rr_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_add_rr_a1_a_special_cond_11_condition_lt_16_b0800010() {
    // Encoding: 0xB0800010
    // Test aarch32_ADD_rr_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: S=0, Rd=0, cond=11, Rn=0, Rs=0, type1=0, Rm=0
    let encoding: u32 = 0xB0800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_rr_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_add_rr_a1_a_special_cond_12_condition_gt_16_c0800010() {
    // Encoding: 0xC0800010
    // Test aarch32_ADD_rr_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: Rd=0, type1=0, Rn=0, cond=12, Rs=0, S=0, Rm=0
    let encoding: u32 = 0xC0800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_rr_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_add_rr_a1_a_special_cond_13_condition_le_16_d0800010() {
    // Encoding: 0xD0800010
    // Test aarch32_ADD_rr_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: type1=0, Rm=0, Rd=0, Rs=0, S=0, Rn=0, cond=13
    let encoding: u32 = 0xD0800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_rr_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_add_rr_a1_a_special_cond_14_condition_al_16_e0800010() {
    // Encoding: 0xE0800010
    // Test aarch32_ADD_rr_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: Rd=0, type1=0, Rm=0, S=0, Rn=0, Rs=0, cond=14
    let encoding: u32 = 0xE0800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_rr_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_add_rr_a1_a_special_cond_15_condition_nv_16_f0800010() {
    // Encoding: 0xF0800010
    // Test aarch32_ADD_rr_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: Rd=0, Rm=0, cond=15, type1=0, Rn=0, Rs=0, S=0
    let encoding: u32 = 0xF0800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_rr_A1_A
/// ASL: `field S = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "S", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_add_rr_a1_a_special_s_0_size_variant_0_16_00800010() {
    // Encoding: 0x00800010
    // Test aarch32_ADD_rr_A1_A special value S = 0 (Size variant 0)
    // ISET: A32
    // Fields: type1=0, Rd=0, Rn=0, S=0, Rm=0, cond=0, Rs=0
    let encoding: u32 = 0x00800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_rr_A1_A
/// ASL: `field S = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "S", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_add_rr_a1_a_special_s_1_size_variant_1_16_00900010() {
    // Encoding: 0x00900010
    // Test aarch32_ADD_rr_A1_A special value S = 1 (Size variant 1)
    // ISET: A32
    // Fields: S=1, Rn=0, Rd=0, Rs=0, cond=0, type1=0, Rm=0
    let encoding: u32 = 0x00900010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_rr_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "s" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"s\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_add_rr_a1_a_invalid_0_10_00800010() {
    // Encoding: 0x00800010
    // Test aarch32_ADD_rr_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "s" }) } }, rhs: LitInt(15) }
    // ISET: A32
    // Fields: S=0, Rs=0, Rn=0, cond=0, type1=0, Rm=0, Rd=0
    let encoding: u32 = 0x00800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_ADD_rr_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_add_rr_a1_a_invalid_1_10_00800010() {
    // Encoding: 0x00800010
    // Test aarch32_ADD_rr_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: type1=0, Rn=0, Rs=0, Rd=0, Rm=0, cond=0, S=0
    let encoding: u32 = 0x00800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_ADD_rr_A1_A
/// ASL: `ADD X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// no shift (32)
#[test]
fn test_aarch32_add_rr_a1_a_add_shifted_oracle_32_0_00820030() {
    // Test ADD shifted 32-bit: no shift (oracle)
    // Encoding: 0x00820030
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xA);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x00820030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6E, "W0 should be 0x0000006E");
}

/// Provenance: aarch32_ADD_rr_A1_A
/// ASL: `ADD X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// no shift (64)
#[test]
fn test_aarch32_add_rr_a1_a_add_shifted_oracle_64_0_80820030() {
    // Test ADD shifted 64-bit: no shift (oracle)
    // Encoding: 0x80820030
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0xA);
    let encoding: u32 = 0x80820030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6E, "X0 should be 0x000000000000006E");
}

/// Provenance: aarch32_ADD_rr_A1_A
/// ASL: `ADD X0, X1, X2, shift #3`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// LSL #3 (multiply by 8) (32)
#[test]
fn test_aarch32_add_rr_a1_a_add_shifted_oracle_32_1_00820c30() {
    // Test ADD shifted 32-bit: LSL #3 (multiply by 8) (oracle)
    // Encoding: 0x00820C30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x00820C30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6C, "W0 should be 0x0000006C");
}

/// Provenance: aarch32_ADD_rr_A1_A
/// ASL: `ADD X0, X1, X2, shift #3`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// LSL #3 (multiply by 8) (64)
#[test]
fn test_aarch32_add_rr_a1_a_add_shifted_oracle_64_1_80820c30() {
    // Test ADD shifted 64-bit: LSL #3 (multiply by 8) (oracle)
    // Encoding: 0x80820C30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x80820C30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6C, "X0 should be 0x000000000000006C");
}

/// Provenance: aarch32_ADD_rr_A1_A
/// ASL: `ADD X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// overflow test (32)
#[test]
fn test_aarch32_add_rr_a1_a_add_shifted_oracle_32_2_00820030() {
    // Test ADD shifted 32-bit: overflow test (oracle)
    // Encoding: 0x00820030
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x00820030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_ADD_rr_A1_A
/// ASL: `ADD X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// overflow test (64)
#[test]
fn test_aarch32_add_rr_a1_a_add_shifted_oracle_64_2_80820030() {
    // Test ADD shifted 64-bit: overflow test (oracle)
    // Encoding: 0x80820030
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x80820030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_ADD_rr_A1_A
/// ASL: `ADD X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// subtract from zero (32)
#[test]
fn test_aarch32_add_rr_a1_a_add_shifted_oracle_32_3_00820030() {
    // Test ADD shifted 32-bit: subtract from zero (oracle)
    // Encoding: 0x00820030
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x00820030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "W0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_ADD_rr_A1_A
/// ASL: `ADD X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// subtract from zero (64)
#[test]
fn test_aarch32_add_rr_a1_a_add_shifted_oracle_64_3_80820030() {
    // Test ADD shifted 64-bit: subtract from zero (oracle)
    // Encoding: 0x80820030
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x80820030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
}

/// Provenance: aarch32_ADD_rr_A1_A
/// ASL: `ADDS X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// no shift (32)
#[test]
fn test_aarch32_add_rr_a1_a_adds_shifted_oracle_32_0_20820030() {
    // Test ADDS shifted 32-bit: no shift (oracle)
    // Encoding: 0x20820030
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0xA);
    let encoding: u32 = 0x20820030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6E, "W0 should be 0x0000006E");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_rr_A1_A
/// ASL: `ADDS X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// no shift (64)
#[test]
fn test_aarch32_add_rr_a1_a_adds_shifted_oracle_64_0_a0820030() {
    // Test ADDS shifted 64-bit: no shift (oracle)
    // Encoding: 0xA0820030
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0xA);
    let encoding: u32 = 0xA0820030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6E, "X0 should be 0x000000000000006E");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_rr_A1_A
/// ASL: `ADDS X0, X1, X2, shift #3`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// LSL #3 (multiply by 8) (32)
#[test]
fn test_aarch32_add_rr_a1_a_adds_shifted_oracle_32_1_20820c30() {
    // Test ADDS shifted 32-bit: LSL #3 (multiply by 8) (oracle)
    // Encoding: 0x20820C30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x20820C30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6C, "W0 should be 0x0000006C");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_rr_A1_A
/// ASL: `ADDS X0, X1, X2, shift #3`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// LSL #3 (multiply by 8) (64)
#[test]
fn test_aarch32_add_rr_a1_a_adds_shifted_oracle_64_1_a0820c30() {
    // Test ADDS shifted 64-bit: LSL #3 (multiply by 8) (oracle)
    // Encoding: 0xA0820C30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xA0820C30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6C, "X0 should be 0x000000000000006C");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_rr_A1_A
/// ASL: `ADDS X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// overflow test (32)
#[test]
fn test_aarch32_add_rr_a1_a_adds_shifted_oracle_32_2_20820030() {
    // Test ADDS shifted 32-bit: overflow test (oracle)
    // Encoding: 0x20820030
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x20820030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_rr_A1_A
/// ASL: `ADDS X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// overflow test (64)
#[test]
fn test_aarch32_add_rr_a1_a_adds_shifted_oracle_64_2_a0820030() {
    // Test ADDS shifted 64-bit: overflow test (oracle)
    // Encoding: 0xA0820030
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xA0820030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, true, "V flag should be true");
}

/// Provenance: aarch32_ADD_rr_A1_A
/// ASL: `ADDS X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// subtract from zero (32)
#[test]
fn test_aarch32_add_rr_a1_a_adds_shifted_oracle_32_3_20820030() {
    // Test ADDS shifted 32-bit: subtract from zero (oracle)
    // Encoding: 0x20820030
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x20820030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "W0 should be 0xFFFFFFFF");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_rr_A1_A
/// ASL: `ADDS X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// subtract from zero (64)
#[test]
fn test_aarch32_add_rr_a1_a_adds_shifted_oracle_64_3_a0820030() {
    // Test ADDS shifted 64-bit: subtract from zero (oracle)
    // Encoding: 0xA0820030
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xA0820030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_rr_A1_A
/// ASL: `SUB X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// no shift (32)
#[test]
fn test_aarch32_add_rr_a1_a_sub_shifted_oracle_32_0_40820030() {
    // Test SUB shifted 32-bit: no shift (oracle)
    // Encoding: 0x40820030
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0xA);
    let encoding: u32 = 0x40820030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x5A, "W0 should be 0x0000005A");
}

/// Provenance: aarch32_ADD_rr_A1_A
/// ASL: `SUB X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// no shift (64)
#[test]
fn test_aarch32_add_rr_a1_a_sub_shifted_oracle_64_0_c0820030() {
    // Test SUB shifted 64-bit: no shift (oracle)
    // Encoding: 0xC0820030
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0xA);
    let encoding: u32 = 0xC0820030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x5A, "X0 should be 0x000000000000005A");
}

/// Provenance: aarch32_ADD_rr_A1_A
/// ASL: `SUB X0, X1, X2, shift #3`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// LSL #3 (multiply by 8) (32)
#[test]
fn test_aarch32_add_rr_a1_a_sub_shifted_oracle_32_1_40820c30() {
    // Test SUB shifted 32-bit: LSL #3 (multiply by 8) (oracle)
    // Encoding: 0x40820C30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x40820C30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x5C, "W0 should be 0x0000005C");
}

/// Provenance: aarch32_ADD_rr_A1_A
/// ASL: `SUB X0, X1, X2, shift #3`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// LSL #3 (multiply by 8) (64)
#[test]
fn test_aarch32_add_rr_a1_a_sub_shifted_oracle_64_1_c0820c30() {
    // Test SUB shifted 64-bit: LSL #3 (multiply by 8) (oracle)
    // Encoding: 0xC0820C30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xC0820C30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x5C, "X0 should be 0x000000000000005C");
}

/// Provenance: aarch32_ADD_rr_A1_A
/// ASL: `SUB X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// overflow test (32)
#[test]
fn test_aarch32_add_rr_a1_a_sub_shifted_oracle_32_2_40820030() {
    // Test SUB shifted 32-bit: overflow test (oracle)
    // Encoding: 0x40820030
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x40820030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_ADD_rr_A1_A
/// ASL: `SUB X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// overflow test (64)
#[test]
fn test_aarch32_add_rr_a1_a_sub_shifted_oracle_64_2_c0820030() {
    // Test SUB shifted 64-bit: overflow test (oracle)
    // Encoding: 0xC0820030
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xC0820030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_ADD_rr_A1_A
/// ASL: `SUB X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// subtract from zero (32)
#[test]
fn test_aarch32_add_rr_a1_a_sub_shifted_oracle_32_3_40820030() {
    // Test SUB shifted 32-bit: subtract from zero (oracle)
    // Encoding: 0x40820030
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x40820030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_ADD_rr_A1_A
/// ASL: `SUB X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// subtract from zero (64)
#[test]
fn test_aarch32_add_rr_a1_a_sub_shifted_oracle_64_3_c0820030() {
    // Test SUB shifted 64-bit: subtract from zero (oracle)
    // Encoding: 0xC0820030
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xC0820030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x0000000000000001");
}

/// Provenance: aarch32_ADD_rr_A1_A
/// ASL: `SUBS X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// no shift (32)
#[test]
fn test_aarch32_add_rr_a1_a_subs_shifted_oracle_32_0_60820030() {
    // Test SUBS shifted 32-bit: no shift (oracle)
    // Encoding: 0x60820030
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xA);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x60820030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x5A, "W0 should be 0x0000005A");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_rr_A1_A
/// ASL: `SUBS X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// no shift (64)
#[test]
fn test_aarch32_add_rr_a1_a_subs_shifted_oracle_64_0_e0820030() {
    // Test SUBS shifted 64-bit: no shift (oracle)
    // Encoding: 0xE0820030
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0xA);
    let encoding: u32 = 0xE0820030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x5A, "X0 should be 0x000000000000005A");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_rr_A1_A
/// ASL: `SUBS X0, X1, X2, shift #3`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// LSL #3 (multiply by 8) (32)
#[test]
fn test_aarch32_add_rr_a1_a_subs_shifted_oracle_32_1_60820c30() {
    // Test SUBS shifted 32-bit: LSL #3 (multiply by 8) (oracle)
    // Encoding: 0x60820C30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x60820C30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x5C, "W0 should be 0x0000005C");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_rr_A1_A
/// ASL: `SUBS X0, X1, X2, shift #3`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// LSL #3 (multiply by 8) (64)
#[test]
fn test_aarch32_add_rr_a1_a_subs_shifted_oracle_64_1_e0820c30() {
    // Test SUBS shifted 64-bit: LSL #3 (multiply by 8) (oracle)
    // Encoding: 0xE0820C30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xE0820C30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x5C, "X0 should be 0x000000000000005C");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_rr_A1_A
/// ASL: `SUBS X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// overflow test (32)
#[test]
fn test_aarch32_add_rr_a1_a_subs_shifted_oracle_32_2_60820030() {
    // Test SUBS shifted 32-bit: overflow test (oracle)
    // Encoding: 0x60820030
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x60820030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_rr_A1_A
/// ASL: `SUBS X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// overflow test (64)
#[test]
fn test_aarch32_add_rr_a1_a_subs_shifted_oracle_64_2_e0820030() {
    // Test SUBS shifted 64-bit: overflow test (oracle)
    // Encoding: 0xE0820030
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xE0820030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_rr_A1_A
/// ASL: `SUBS X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// subtract from zero (32)
#[test]
fn test_aarch32_add_rr_a1_a_subs_shifted_oracle_32_3_60820030() {
    // Test SUBS shifted 32-bit: subtract from zero (oracle)
    // Encoding: 0x60820030
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x60820030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_rr_A1_A
/// ASL: `SUBS X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// subtract from zero (64)
#[test]
fn test_aarch32_add_rr_a1_a_subs_shifted_oracle_64_3_e0820030() {
    // Test SUBS shifted 64-bit: subtract from zero (oracle)
    // Encoding: 0xE0820030
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xE0820030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x0000000000000001");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_rr_A1_A
/// ASL: `ADD R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple values
#[test]
fn test_aarch32_add_rr_a1_a_a32_add_sub_reg_0_00810002() {
    // Test A32 ADD: simple values (oracle)
    // Encoding: 0x00810002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x32);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x00810002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x96, "R0 should be 0x00000096");
}

/// Provenance: aarch32_ADD_rr_A1_A
/// ASL: `ADD R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero values
#[test]
fn test_aarch32_add_rr_a1_a_a32_add_sub_reg_1_00810002() {
    // Test A32 ADD: zero values (oracle)
    // Encoding: 0x00810002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x00810002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_ADD_rr_A1_A
/// ASL: `ADD R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max value
#[test]
fn test_aarch32_add_rr_a1_a_a32_add_sub_reg_2_00810002() {
    // Test A32 ADD: max value (oracle)
    // Encoding: 0x00810002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x00810002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_ADD_rr_A1_A
/// ASL: `ADD R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set
#[test]
fn test_aarch32_add_rr_a1_a_a32_add_sub_reg_3_00810002() {
    // Test A32 ADD: MSB set (oracle)
    // Encoding: 0x00810002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x80000000);
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0x00810002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_ADD_rr_A1_A
/// ASL: `ADD R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// mixed pattern
#[test]
fn test_aarch32_add_rr_a1_a_a32_add_sub_reg_4_00810002() {
    // Test A32 ADD: mixed pattern (oracle)
    // Encoding: 0x00810002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x9ABCDEF0);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u32 = 0x00810002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xACF13568, "R0 should be 0xACF13568");
}

/// Provenance: aarch32_ADD_rr_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_aarch32_add_rr_a1_a_flags_zeroresult_0_00910012() {
    // Test aarch32_ADD_rr_A1_A flag computation: ZeroResult
    // Encoding: 0x00910012
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x00910012;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_rr_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_aarch32_add_rr_a1_a_flags_zeroresult_1_00910012() {
    // Test aarch32_ADD_rr_A1_A flag computation: ZeroResult
    // Encoding: 0x00910012
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x00910012;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_rr_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_aarch32_add_rr_a1_a_flags_negativeresult_2_00910012() {
    // Test aarch32_ADD_rr_A1_A flag computation: NegativeResult
    // Encoding: 0x00910012
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x00910012;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_rr_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_aarch32_add_rr_a1_a_flags_unsignedoverflow_3_00910012() {
    // Test aarch32_ADD_rr_A1_A flag computation: UnsignedOverflow
    // Encoding: 0x00910012
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x00910012;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_rr_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_aarch32_add_rr_a1_a_flags_unsignedoverflow_4_00910012() {
    // Test aarch32_ADD_rr_A1_A flag computation: UnsignedOverflow
    // Encoding: 0x00910012
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x00910012;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_rr_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_aarch32_add_rr_a1_a_flags_signedoverflow_5_00910012() {
    // Test aarch32_ADD_rr_A1_A flag computation: SignedOverflow
    // Encoding: 0x00910012
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x00910012;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_ADD_rr_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_aarch32_add_rr_a1_a_flags_signedoverflow_6_00910012() {
    // Test aarch32_ADD_rr_A1_A flag computation: SignedOverflow
    // Encoding: 0x00910012
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x00910012;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_ADD_rr_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_aarch32_add_rr_a1_a_flags_positiveresult_7_00910012() {
    // Test aarch32_ADD_rr_A1_A flag computation: PositiveResult
    // Encoding: 0x00910012
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x32);
    let encoding: u32 = 0x00910012;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

// ============================================================================
// aarch32_ADD_SP_r_A Tests
// ============================================================================

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_add_sp_r_a1_a_field_cond_0_min_0_008d0000() {
    // Encoding: 0x008D0000
    // Test aarch32_ADD_SP_r_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: imm5=0, cond=0, Rd=0, type1=0, Rm=0, S=0
    let encoding: u32 = 0x008D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_add_sp_r_a1_a_field_cond_1_poweroftwo_0_108d0000() {
    // Encoding: 0x108D0000
    // Test aarch32_ADD_SP_r_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=1, Rd=0, S=0, imm5=0, type1=0, Rm=0
    let encoding: u32 = 0x108D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_add_sp_r_a1_a_field_cond_2_poweroftwo_0_208d0000() {
    // Encoding: 0x208D0000
    // Test aarch32_ADD_SP_r_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, type1=0, cond=2, imm5=0, S=0, Rm=0
    let encoding: u32 = 0x208D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_add_sp_r_a1_a_field_cond_3_poweroftwo_0_308d0000() {
    // Encoding: 0x308D0000
    // Test aarch32_ADD_SP_r_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: imm5=0, S=0, Rd=0, type1=0, Rm=0, cond=3
    let encoding: u32 = 0x308D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_add_sp_r_a1_a_field_cond_4_poweroftwo_0_408d0000() {
    // Encoding: 0x408D0000
    // Test aarch32_ADD_SP_r_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: imm5=0, type1=0, Rd=0, S=0, cond=4, Rm=0
    let encoding: u32 = 0x408D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_add_sp_r_a1_a_field_cond_5_poweroftwo_0_508d0000() {
    // Encoding: 0x508D0000
    // Test aarch32_ADD_SP_r_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: imm5=0, S=0, type1=0, cond=5, Rm=0, Rd=0
    let encoding: u32 = 0x508D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_add_sp_r_a1_a_field_cond_6_poweroftwo_0_608d0000() {
    // Encoding: 0x608D0000
    // Test aarch32_ADD_SP_r_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=6, S=0, imm5=0, type1=0, Rd=0, Rm=0
    let encoding: u32 = 0x608D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_add_sp_r_a1_a_field_cond_7_poweroftwo_0_708d0000() {
    // Encoding: 0x708D0000
    // Test aarch32_ADD_SP_r_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: imm5=0, Rm=0, type1=0, Rd=0, cond=7, S=0
    let encoding: u32 = 0x708D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_add_sp_r_a1_a_field_cond_8_poweroftwo_0_808d0000() {
    // Encoding: 0x808D0000
    // Test aarch32_ADD_SP_r_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: type1=0, Rd=0, S=0, Rm=0, imm5=0, cond=8
    let encoding: u32 = 0x808D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_add_sp_r_a1_a_field_cond_9_poweroftwo_0_908d0000() {
    // Encoding: 0x908D0000
    // Test aarch32_ADD_SP_r_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: imm5=0, S=0, type1=0, Rm=0, cond=9, Rd=0
    let encoding: u32 = 0x908D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_add_sp_r_a1_a_field_cond_10_poweroftwo_0_a08d0000() {
    // Encoding: 0xA08D0000
    // Test aarch32_ADD_SP_r_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: imm5=0, Rd=0, S=0, Rm=0, type1=0, cond=10
    let encoding: u32 = 0xA08D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_add_sp_r_a1_a_field_cond_11_poweroftwo_0_b08d0000() {
    // Encoding: 0xB08D0000
    // Test aarch32_ADD_SP_r_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=11, S=0, imm5=0, type1=0, Rm=0, Rd=0
    let encoding: u32 = 0xB08D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_add_sp_r_a1_a_field_cond_12_poweroftwo_0_c08d0000() {
    // Encoding: 0xC08D0000
    // Test aarch32_ADD_SP_r_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, S=0, cond=12, imm5=0, Rd=0, type1=0
    let encoding: u32 = 0xC08D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_add_sp_r_a1_a_field_cond_13_poweroftwo_0_d08d0000() {
    // Encoding: 0xD08D0000
    // Test aarch32_ADD_SP_r_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, cond=13, Rd=0, imm5=0, type1=0, Rm=0
    let encoding: u32 = 0xD08D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_add_sp_r_a1_a_field_cond_14_poweroftwo_0_e08d0000() {
    // Encoding: 0xE08D0000
    // Test aarch32_ADD_SP_r_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, S=0, cond=14, Rm=0, type1=0, imm5=0
    let encoding: u32 = 0xE08D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_add_sp_r_a1_a_field_cond_15_max_0_f08d0000() {
    // Encoding: 0xF08D0000
    // Test aarch32_ADD_SP_r_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: imm5=0, Rd=0, type1=0, Rm=0, S=0, cond=15
    let encoding: u32 = 0xF08D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_add_sp_r_a1_a_field_s_0_min_0_008d0000() {
    // Encoding: 0x008D0000
    // Test aarch32_ADD_SP_r_A1_A field S = 0 (Min)
    // ISET: A32
    // Fields: cond=0, type1=0, Rm=0, imm5=0, Rd=0, S=0
    let encoding: u32 = 0x008D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_add_sp_r_a1_a_field_s_1_max_0_009d0000() {
    // Encoding: 0x009D0000
    // Test aarch32_ADD_SP_r_A1_A field S = 1 (Max)
    // ISET: A32
    // Fields: type1=0, imm5=0, Rd=0, S=1, Rm=0, cond=0
    let encoding: u32 = 0x009D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_add_sp_r_a1_a_field_rd_0_min_0_008d0000() {
    // Encoding: 0x008D0000
    // Test aarch32_ADD_SP_r_A1_A field Rd = 0 (Min)
    // ISET: A32
    // Fields: imm5=0, type1=0, Rm=0, S=0, Rd=0, cond=0
    let encoding: u32 = 0x008D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_add_sp_r_a1_a_field_rd_1_poweroftwo_0_008d1000() {
    // Encoding: 0x008D1000
    // Test aarch32_ADD_SP_r_A1_A field Rd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=1, imm5=0, S=0, cond=0, type1=0, Rm=0
    let encoding: u32 = 0x008D1000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_add_sp_r_a1_a_field_imm5_0_zero_0_008d0000() {
    // Encoding: 0x008D0000
    // Test aarch32_ADD_SP_r_A1_A field imm5 = 0 (Zero)
    // ISET: A32
    // Fields: cond=0, type1=0, Rm=0, Rd=0, imm5=0, S=0
    let encoding: u32 = 0x008D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_add_sp_r_a1_a_field_imm5_1_poweroftwo_0_008d0080() {
    // Encoding: 0x008D0080
    // Test aarch32_ADD_SP_r_A1_A field imm5 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, Rd=0, cond=0, type1=0, Rm=0, imm5=1
    let encoding: u32 = 0x008D0080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_add_sp_r_a1_a_field_imm5_3_poweroftwominusone_0_008d0180() {
    // Encoding: 0x008D0180
    // Test aarch32_ADD_SP_r_A1_A field imm5 = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rm=0, S=0, type1=0, cond=0, Rd=0, imm5=3
    let encoding: u32 = 0x008D0180;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_add_sp_r_a1_a_field_imm5_4_poweroftwo_0_008d0200() {
    // Encoding: 0x008D0200
    // Test aarch32_ADD_SP_r_A1_A field imm5 = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Rm=0, S=0, Rd=0, type1=0, imm5=4
    let encoding: u32 = 0x008D0200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_add_sp_r_a1_a_field_imm5_7_poweroftwominusone_0_008d0380() {
    // Encoding: 0x008D0380
    // Test aarch32_ADD_SP_r_A1_A field imm5 = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm5=7, Rd=0, S=0, cond=0, type1=0, Rm=0
    let encoding: u32 = 0x008D0380;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_add_sp_r_a1_a_field_imm5_8_poweroftwo_0_008d0400() {
    // Encoding: 0x008D0400
    // Test aarch32_ADD_SP_r_A1_A field imm5 = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, imm5=8, cond=0, type1=0, Rm=0, S=0
    let encoding: u32 = 0x008D0400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 15, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (15)
#[test]
fn test_aarch32_add_sp_r_a1_a_field_imm5_15_poweroftwominusone_0_008d0780() {
    // Encoding: 0x008D0780
    // Test aarch32_ADD_SP_r_A1_A field imm5 = 15 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rm=0, cond=0, S=0, Rd=0, type1=0, imm5=15
    let encoding: u32 = 0x008D0780;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_add_sp_r_a1_a_field_imm5_16_poweroftwo_0_008d0800() {
    // Encoding: 0x008D0800
    // Test aarch32_ADD_SP_r_A1_A field imm5 = 16 (PowerOfTwo)
    // ISET: A32
    // Fields: imm5=16, Rd=0, S=0, type1=0, cond=0, Rm=0
    let encoding: u32 = 0x008D0800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 31, boundary: Max }
/// maximum immediate (31)
#[test]
fn test_aarch32_add_sp_r_a1_a_field_imm5_31_max_0_008d0f80() {
    // Encoding: 0x008D0F80
    // Test aarch32_ADD_SP_r_A1_A field imm5 = 31 (Max)
    // ISET: A32
    // Fields: Rm=0, S=0, cond=0, imm5=31, type1=0, Rd=0
    let encoding: u32 = 0x008D0F80;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `field type1 5 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_add_sp_r_a1_a_field_type1_0_min_0_008d0000() {
    // Encoding: 0x008D0000
    // Test aarch32_ADD_SP_r_A1_A field type1 = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, Rd=0, imm5=0, S=0, cond=0, type1=0
    let encoding: u32 = 0x008D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `field type1 5 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_add_sp_r_a1_a_field_type1_1_poweroftwo_0_008d0020() {
    // Encoding: 0x008D0020
    // Test aarch32_ADD_SP_r_A1_A field type1 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, cond=0, Rd=0, imm5=0, S=0, type1=1
    let encoding: u32 = 0x008D0020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `field type1 5 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_aarch32_add_sp_r_a1_a_field_type1_3_max_0_008d0060() {
    // Encoding: 0x008D0060
    // Test aarch32_ADD_SP_r_A1_A field type1 = 3 (Max)
    // ISET: A32
    // Fields: S=0, cond=0, imm5=0, type1=3, Rm=0, Rd=0
    let encoding: u32 = 0x008D0060;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_add_sp_r_a1_a_field_rm_0_min_0_008d0000() {
    // Encoding: 0x008D0000
    // Test aarch32_ADD_SP_r_A1_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: imm5=0, type1=0, Rd=0, cond=0, Rm=0, S=0
    let encoding: u32 = 0x008D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_add_sp_r_a1_a_field_rm_1_poweroftwo_0_008d0001() {
    // Encoding: 0x008D0001
    // Test aarch32_ADD_SP_r_A1_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: type1=0, Rm=1, S=0, cond=0, imm5=0, Rd=0
    let encoding: u32 = 0x008D0001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_add_sp_r_a1_a_combo_0_0_008d0000() {
    // Encoding: 0x008D0000
    // Test aarch32_ADD_SP_r_A1_A field combination: cond=0, S=0, Rd=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: Rm=0, imm5=0, Rd=0, S=0, cond=0, type1=0
    let encoding: u32 = 0x008D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_add_sp_r_a1_a_special_cond_0_condition_eq_0_008d0000() {
    // Encoding: 0x008D0000
    // Test aarch32_ADD_SP_r_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: imm5=0, type1=0, Rm=0, cond=0, Rd=0, S=0
    let encoding: u32 = 0x008D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_add_sp_r_a1_a_special_cond_1_condition_ne_0_108d0000() {
    // Encoding: 0x108D0000
    // Test aarch32_ADD_SP_r_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: cond=1, Rd=0, imm5=0, type1=0, Rm=0, S=0
    let encoding: u32 = 0x108D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_add_sp_r_a1_a_special_cond_2_condition_cs_hs_0_208d0000() {
    // Encoding: 0x208D0000
    // Test aarch32_ADD_SP_r_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: imm5=0, type1=0, Rm=0, Rd=0, cond=2, S=0
    let encoding: u32 = 0x208D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_add_sp_r_a1_a_special_cond_3_condition_cc_lo_0_308d0000() {
    // Encoding: 0x308D0000
    // Test aarch32_ADD_SP_r_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: type1=0, imm5=0, S=0, Rd=0, Rm=0, cond=3
    let encoding: u32 = 0x308D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_add_sp_r_a1_a_special_cond_4_condition_mi_0_408d0000() {
    // Encoding: 0x408D0000
    // Test aarch32_ADD_SP_r_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: imm5=0, cond=4, S=0, Rm=0, type1=0, Rd=0
    let encoding: u32 = 0x408D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_add_sp_r_a1_a_special_cond_5_condition_pl_0_508d0000() {
    // Encoding: 0x508D0000
    // Test aarch32_ADD_SP_r_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: cond=5, type1=0, Rm=0, S=0, Rd=0, imm5=0
    let encoding: u32 = 0x508D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_add_sp_r_a1_a_special_cond_6_condition_vs_0_608d0000() {
    // Encoding: 0x608D0000
    // Test aarch32_ADD_SP_r_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: cond=6, imm5=0, Rd=0, Rm=0, type1=0, S=0
    let encoding: u32 = 0x608D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_add_sp_r_a1_a_special_cond_7_condition_vc_0_708d0000() {
    // Encoding: 0x708D0000
    // Test aarch32_ADD_SP_r_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: S=0, Rd=0, type1=0, imm5=0, Rm=0, cond=7
    let encoding: u32 = 0x708D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_add_sp_r_a1_a_special_cond_8_condition_hi_0_808d0000() {
    // Encoding: 0x808D0000
    // Test aarch32_ADD_SP_r_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: Rm=0, S=0, Rd=0, imm5=0, type1=0, cond=8
    let encoding: u32 = 0x808D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_add_sp_r_a1_a_special_cond_9_condition_ls_0_908d0000() {
    // Encoding: 0x908D0000
    // Test aarch32_ADD_SP_r_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: S=0, Rd=0, type1=0, imm5=0, cond=9, Rm=0
    let encoding: u32 = 0x908D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_add_sp_r_a1_a_special_cond_10_condition_ge_0_a08d0000() {
    // Encoding: 0xA08D0000
    // Test aarch32_ADD_SP_r_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: imm5=0, Rm=0, S=0, type1=0, Rd=0, cond=10
    let encoding: u32 = 0xA08D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_add_sp_r_a1_a_special_cond_11_condition_lt_0_b08d0000() {
    // Encoding: 0xB08D0000
    // Test aarch32_ADD_SP_r_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: Rd=0, Rm=0, imm5=0, S=0, cond=11, type1=0
    let encoding: u32 = 0xB08D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_add_sp_r_a1_a_special_cond_12_condition_gt_0_c08d0000() {
    // Encoding: 0xC08D0000
    // Test aarch32_ADD_SP_r_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: Rm=0, cond=12, imm5=0, type1=0, S=0, Rd=0
    let encoding: u32 = 0xC08D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_add_sp_r_a1_a_special_cond_13_condition_le_0_d08d0000() {
    // Encoding: 0xD08D0000
    // Test aarch32_ADD_SP_r_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: Rm=0, Rd=0, cond=13, imm5=0, S=0, type1=0
    let encoding: u32 = 0xD08D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_add_sp_r_a1_a_special_cond_14_condition_al_0_e08d0000() {
    // Encoding: 0xE08D0000
    // Test aarch32_ADD_SP_r_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: cond=14, S=0, imm5=0, Rd=0, type1=0, Rm=0
    let encoding: u32 = 0xE08D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_add_sp_r_a1_a_special_cond_15_condition_nv_0_f08d0000() {
    // Encoding: 0xF08D0000
    // Test aarch32_ADD_SP_r_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: type1=0, Rd=0, imm5=0, cond=15, S=0, Rm=0
    let encoding: u32 = 0xF08D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `field S = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "S", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_add_sp_r_a1_a_special_s_0_size_variant_0_0_008d0000() {
    // Encoding: 0x008D0000
    // Test aarch32_ADD_SP_r_A1_A special value S = 0 (Size variant 0)
    // ISET: A32
    // Fields: Rm=0, cond=0, S=0, Rd=0, imm5=0, type1=0
    let encoding: u32 = 0x008D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `field S = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "S", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_add_sp_r_a1_a_special_s_1_size_variant_1_0_009d0000() {
    // Encoding: 0x009D0000
    // Test aarch32_ADD_SP_r_A1_A special value S = 1 (Size variant 1)
    // ISET: A32
    // Fields: S=1, type1=0, Rm=0, Rd=0, cond=0, imm5=0
    let encoding: u32 = 0x009D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_r_T1_A
/// ASL: `field DM 23 +: 1`
/// Requirement: FieldBoundary { field: "DM", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_add_sp_r_t1_a_field_dm_0_min_0_44680000() {
    // Thumb encoding (32): 0x44680000
    // Test aarch32_ADD_SP_r_T1_A field DM = 0 (Min)
    // ISET: T32
    // Fields: Rdm=0, DM=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x44680000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_r_T1_A
/// ASL: `field DM 23 +: 1`
/// Requirement: FieldBoundary { field: "DM", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_add_sp_r_t1_a_field_dm_1_max_0_44e80000() {
    // Thumb encoding (32): 0x44E80000
    // Test aarch32_ADD_SP_r_T1_A field DM = 1 (Max)
    // ISET: T32
    // Fields: DM=1, Rdm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x44E80000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_r_T1_A
/// ASL: `field Rdm 16 +: 3`
/// Requirement: FieldBoundary { field: "Rdm", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_add_sp_r_t1_a_field_rdm_0_min_0_44680000() {
    // Thumb encoding (32): 0x44680000
    // Test aarch32_ADD_SP_r_T1_A field Rdm = 0 (Min)
    // ISET: T32
    // Fields: DM=0, Rdm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x44680000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_r_T1_A
/// ASL: `field Rdm 16 +: 3`
/// Requirement: FieldBoundary { field: "Rdm", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_add_sp_r_t1_a_field_rdm_1_poweroftwo_0_44690000() {
    // Thumb encoding (32): 0x44690000
    // Test aarch32_ADD_SP_r_T1_A field Rdm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rdm=1, DM=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x44690000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_r_T1_A
/// ASL: `field Rdm 16 +: 3`
/// Requirement: FieldBoundary { field: "Rdm", value: 7, boundary: Max }
/// maximum value (7)
#[test]
fn test_aarch32_add_sp_r_t1_a_field_rdm_7_max_0_446f0000() {
    // Thumb encoding (32): 0x446F0000
    // Test aarch32_ADD_SP_r_T1_A field Rdm = 7 (Max)
    // ISET: T32
    // Fields: DM=0, Rdm=7
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x446F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_r_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// DM=0 (minimum value)
#[test]
fn test_aarch32_add_sp_r_t1_a_combo_0_0_44680000() {
    // Thumb encoding (32): 0x44680000
    // Test aarch32_ADD_SP_r_T1_A field combination: DM=0, Rdm=0
    // ISET: T32
    // Fields: DM=0, Rdm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x44680000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_r_T1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: And, lhs: Binary { op: And, lhs: LitInt(15), rhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] } }, rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "LastInITBlock" }, args: [] } } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: And, lhs: Binary { op: And, lhs: LitInt(15), rhs: Call { name: QualifiedIdentifier { qualifier: Any, name: \"InITBlock\" }, args: [] } }, rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"LastInITBlock\" }, args: [] } } } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_add_sp_r_t1_a_invalid_0_0_44680000() {
    // Thumb encoding (32): 0x44680000
    // Test aarch32_ADD_SP_r_T1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: And, lhs: Binary { op: And, lhs: LitInt(15), rhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] } }, rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "LastInITBlock" }, args: [] } } } }
    // ISET: T32
    // Fields: DM=0, Rdm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x44680000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_ADD_SP_r_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_add_sp_r_t1_a_invalid_1_0_44680000() {
    // Thumb encoding (32): 0x44680000
    // Test aarch32_ADD_SP_r_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rdm=0, DM=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x44680000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_ADD_SP_r_T2_A
/// ASL: `field Rm 19 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_add_sp_r_t2_a_field_rm_0_min_0_44850000() {
    // Thumb encoding (32): 0x44850000
    // Test aarch32_ADD_SP_r_T2_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x44850000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_r_T2_A
/// ASL: `field Rm 19 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_add_sp_r_t2_a_field_rm_1_poweroftwo_0_448d0000() {
    // Thumb encoding (32): 0x448D0000
    // Test aarch32_ADD_SP_r_T2_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x448D0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_r_T2_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch32_add_sp_r_t2_a_combo_0_0_44850000() {
    // Thumb encoding (32): 0x44850000
    // Test aarch32_ADD_SP_r_T2_A field combination: Rm=0
    // ISET: T32
    // Fields: Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x44850000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_r_T3_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_add_sp_r_t3_a_field_s_0_min_0_eb0d0000() {
    // Thumb encoding (32): 0xEB0D0000
    // Test aarch32_ADD_SP_r_T3_A field S = 0 (Min)
    // ISET: T32
    // Fields: imm3=0, type1=0, imm2=0, Rm=0, S=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEB0D0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_r_T3_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_add_sp_r_t3_a_field_s_1_max_0_eb1d0000() {
    // Thumb encoding (32): 0xEB1D0000
    // Test aarch32_ADD_SP_r_T3_A field S = 1 (Max)
    // ISET: T32
    // Fields: imm3=0, Rd=0, type1=0, Rm=0, imm2=0, S=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEB1D0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_r_T3_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_add_sp_r_t3_a_field_imm3_0_zero_0_eb0d0000() {
    // Thumb encoding (32): 0xEB0D0000
    // Test aarch32_ADD_SP_r_T3_A field imm3 = 0 (Zero)
    // ISET: T32
    // Fields: type1=0, Rm=0, Rd=0, S=0, imm3=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEB0D0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_r_T3_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_add_sp_r_t3_a_field_imm3_1_poweroftwo_0_eb0d1000() {
    // Thumb encoding (32): 0xEB0D1000
    // Test aarch32_ADD_SP_r_T3_A field imm3 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: type1=0, imm3=1, Rd=0, imm2=0, Rm=0, S=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEB0D1000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_r_T3_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 3, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (3)
#[test]
fn test_aarch32_add_sp_r_t3_a_field_imm3_3_poweroftwominusone_0_eb0d3000() {
    // Thumb encoding (32): 0xEB0D3000
    // Test aarch32_ADD_SP_r_T3_A field imm3 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: type1=0, Rm=0, imm3=3, Rd=0, S=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEB0D3000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_r_T3_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 7, boundary: Max }
/// maximum immediate (7)
#[test]
fn test_aarch32_add_sp_r_t3_a_field_imm3_7_max_0_eb0d7000() {
    // Thumb encoding (32): 0xEB0D7000
    // Test aarch32_ADD_SP_r_T3_A field imm3 = 7 (Max)
    // ISET: T32
    // Fields: imm2=0, imm3=7, Rm=0, type1=0, S=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEB0D7000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_r_T3_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_add_sp_r_t3_a_field_rd_0_min_0_eb0d0000() {
    // Thumb encoding (32): 0xEB0D0000
    // Test aarch32_ADD_SP_r_T3_A field Rd = 0 (Min)
    // ISET: T32
    // Fields: imm2=0, Rm=0, S=0, imm3=0, Rd=0, type1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEB0D0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_r_T3_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_add_sp_r_t3_a_field_rd_1_poweroftwo_0_eb0d0100() {
    // Thumb encoding (32): 0xEB0D0100
    // Test aarch32_ADD_SP_r_T3_A field Rd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm3=0, Rm=0, Rd=1, S=0, imm2=0, type1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEB0D0100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_r_T3_A
/// ASL: `field imm2 6 +: 2`
/// Requirement: FieldBoundary { field: "imm2", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_add_sp_r_t3_a_field_imm2_0_zero_0_eb0d0000() {
    // Thumb encoding (32): 0xEB0D0000
    // Test aarch32_ADD_SP_r_T3_A field imm2 = 0 (Zero)
    // ISET: T32
    // Fields: Rm=0, imm3=0, Rd=0, imm2=0, S=0, type1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEB0D0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_r_T3_A
/// ASL: `field imm2 6 +: 2`
/// Requirement: FieldBoundary { field: "imm2", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_add_sp_r_t3_a_field_imm2_1_poweroftwo_0_eb0d0040() {
    // Thumb encoding (32): 0xEB0D0040
    // Test aarch32_ADD_SP_r_T3_A field imm2 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm3=0, Rm=0, S=0, Rd=0, imm2=1, type1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEB0D0040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_r_T3_A
/// ASL: `field imm2 6 +: 2`
/// Requirement: FieldBoundary { field: "imm2", value: 3, boundary: Max }
/// maximum immediate (3)
#[test]
fn test_aarch32_add_sp_r_t3_a_field_imm2_3_max_0_eb0d00c0() {
    // Thumb encoding (32): 0xEB0D00C0
    // Test aarch32_ADD_SP_r_T3_A field imm2 = 3 (Max)
    // ISET: T32
    // Fields: type1=0, imm2=3, S=0, Rd=0, imm3=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEB0D00C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_r_T3_A
/// ASL: `field type1 4 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_add_sp_r_t3_a_field_type1_0_min_0_eb0d0000() {
    // Thumb encoding (32): 0xEB0D0000
    // Test aarch32_ADD_SP_r_T3_A field type1 = 0 (Min)
    // ISET: T32
    // Fields: imm2=0, Rd=0, imm3=0, S=0, Rm=0, type1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEB0D0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_r_T3_A
/// ASL: `field type1 4 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_add_sp_r_t3_a_field_type1_1_poweroftwo_0_eb0d0010() {
    // Thumb encoding (32): 0xEB0D0010
    // Test aarch32_ADD_SP_r_T3_A field type1 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: S=0, Rd=0, imm2=0, type1=1, Rm=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEB0D0010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_r_T3_A
/// ASL: `field type1 4 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_aarch32_add_sp_r_t3_a_field_type1_3_max_0_eb0d0030() {
    // Thumb encoding (32): 0xEB0D0030
    // Test aarch32_ADD_SP_r_T3_A field type1 = 3 (Max)
    // ISET: T32
    // Fields: imm2=0, type1=3, Rd=0, S=0, Rm=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEB0D0030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_r_T3_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_add_sp_r_t3_a_field_rm_0_min_0_eb0d0000() {
    // Thumb encoding (32): 0xEB0D0000
    // Test aarch32_ADD_SP_r_T3_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: S=0, imm3=0, Rd=0, imm2=0, type1=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEB0D0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_r_T3_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_add_sp_r_t3_a_field_rm_1_poweroftwo_0_eb0d0001() {
    // Thumb encoding (32): 0xEB0D0001
    // Test aarch32_ADD_SP_r_T3_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm3=0, type1=0, S=0, Rm=1, imm2=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEB0D0001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_r_T3_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// S=0 (8-bit / byte size)
#[test]
fn test_aarch32_add_sp_r_t3_a_combo_0_0_eb0d0000() {
    // Thumb encoding (32): 0xEB0D0000
    // Test aarch32_ADD_SP_r_T3_A field combination: S=0, imm3=0, Rd=0, imm2=0, type1=0, Rm=0
    // ISET: T32
    // Fields: S=0, Rd=0, imm2=0, imm3=0, Rm=0, type1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEB0D0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_r_T3_A
/// ASL: `field S = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "S", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_add_sp_r_t3_a_special_s_0_size_variant_0_0_eb0d0000() {
    // Thumb encoding (32): 0xEB0D0000
    // Test aarch32_ADD_SP_r_T3_A special value S = 0 (Size variant 0)
    // ISET: T32
    // Fields: S=0, Rd=0, Rm=0, imm2=0, type1=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEB0D0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_r_T3_A
/// ASL: `field S = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "S", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_add_sp_r_t3_a_special_s_1_size_variant_1_0_eb1d0000() {
    // Thumb encoding (32): 0xEB1D0000
    // Test aarch32_ADD_SP_r_T3_A special value S = 1 (Size variant 1)
    // ISET: T32
    // Fields: Rm=0, S=1, type1=0, imm2=0, Rd=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEB1D0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_r_T3_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Or, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: And, lhs: LitInt(15), rhs: Unary { op: Not, operand: Var(QualifiedIdentifier { qualifier: Any, name: "setflags" }) } } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Or, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: And, lhs: LitInt(15), rhs: Unary { op: Not, operand: Var(QualifiedIdentifier { qualifier: Any, name: \"setflags\" }) } } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_add_sp_r_t3_a_invalid_0_0_eb0d0000() {
    // Thumb encoding (32): 0xEB0D0000
    // Test aarch32_ADD_SP_r_T3_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Or, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: And, lhs: LitInt(15), rhs: Unary { op: Not, operand: Var(QualifiedIdentifier { qualifier: Any, name: "setflags" }) } } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) }, rhs: LitInt(15) }
    // ISET: T32
    // Fields: S=0, imm3=0, type1=0, Rd=0, imm2=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEB0D0000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_ADD_SP_r_T3_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_add_sp_r_t3_a_invalid_1_0_eb0d0000() {
    // Thumb encoding (32): 0xEB0D0000
    // Test aarch32_ADD_SP_r_T3_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rd=0, imm3=0, S=0, imm2=0, type1=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEB0D0000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `ADD X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// no shift (32)
#[test]
fn test_aarch32_add_sp_r_a1_a_add_shifted_oracle_32_0_008f0020() {
    // Test ADD shifted 32-bit: no shift (oracle)
    // Encoding: 0x008F0020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xA);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x008F0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6E, "W0 should be 0x0000006E");
}

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `ADD X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// no shift (64)
#[test]
fn test_aarch32_add_sp_r_a1_a_add_shifted_oracle_64_0_808f0020() {
    // Test ADD shifted 64-bit: no shift (oracle)
    // Encoding: 0x808F0020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0xA);
    let encoding: u32 = 0x808F0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6E, "X0 should be 0x000000000000006E");
}

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `ADD X0, X1, X2, shift #3`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// LSL #3 (multiply by 8) (32)
#[test]
fn test_aarch32_add_sp_r_a1_a_add_shifted_oracle_32_1_008f0c20() {
    // Test ADD shifted 32-bit: LSL #3 (multiply by 8) (oracle)
    // Encoding: 0x008F0C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x008F0C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6C, "W0 should be 0x0000006C");
}

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `ADD X0, X1, X2, shift #3`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// LSL #3 (multiply by 8) (64)
#[test]
fn test_aarch32_add_sp_r_a1_a_add_shifted_oracle_64_1_808f0c20() {
    // Test ADD shifted 64-bit: LSL #3 (multiply by 8) (oracle)
    // Encoding: 0x808F0C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x808F0C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6C, "X0 should be 0x000000000000006C");
}

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `ADD X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// overflow test (32)
#[test]
fn test_aarch32_add_sp_r_a1_a_add_shifted_oracle_32_2_008f0020() {
    // Test ADD shifted 32-bit: overflow test (oracle)
    // Encoding: 0x008F0020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x008F0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `ADD X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// overflow test (64)
#[test]
fn test_aarch32_add_sp_r_a1_a_add_shifted_oracle_64_2_808f0020() {
    // Test ADD shifted 64-bit: overflow test (oracle)
    // Encoding: 0x808F0020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x808F0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `ADD X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// subtract from zero (32)
#[test]
fn test_aarch32_add_sp_r_a1_a_add_shifted_oracle_32_3_008f0020() {
    // Test ADD shifted 32-bit: subtract from zero (oracle)
    // Encoding: 0x008F0020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x008F0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "W0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `ADD X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// subtract from zero (64)
#[test]
fn test_aarch32_add_sp_r_a1_a_add_shifted_oracle_64_3_808f0020() {
    // Test ADD shifted 64-bit: subtract from zero (oracle)
    // Encoding: 0x808F0020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x808F0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
}

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `ADDS X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// no shift (32)
#[test]
fn test_aarch32_add_sp_r_a1_a_adds_shifted_oracle_32_0_208f0020() {
    // Test ADDS shifted 32-bit: no shift (oracle)
    // Encoding: 0x208F0020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0xA);
    let encoding: u32 = 0x208F0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6E, "W0 should be 0x0000006E");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `ADDS X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// no shift (64)
#[test]
fn test_aarch32_add_sp_r_a1_a_adds_shifted_oracle_64_0_a08f0020() {
    // Test ADDS shifted 64-bit: no shift (oracle)
    // Encoding: 0xA08F0020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0xA);
    let encoding: u32 = 0xA08F0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6E, "X0 should be 0x000000000000006E");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `ADDS X0, X1, X2, shift #3`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// LSL #3 (multiply by 8) (32)
#[test]
fn test_aarch32_add_sp_r_a1_a_adds_shifted_oracle_32_1_208f0c20() {
    // Test ADDS shifted 32-bit: LSL #3 (multiply by 8) (oracle)
    // Encoding: 0x208F0C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x208F0C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6C, "W0 should be 0x0000006C");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `ADDS X0, X1, X2, shift #3`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// LSL #3 (multiply by 8) (64)
#[test]
fn test_aarch32_add_sp_r_a1_a_adds_shifted_oracle_64_1_a08f0c20() {
    // Test ADDS shifted 64-bit: LSL #3 (multiply by 8) (oracle)
    // Encoding: 0xA08F0C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0xA08F0C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6C, "X0 should be 0x000000000000006C");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `ADDS X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// overflow test (32)
#[test]
fn test_aarch32_add_sp_r_a1_a_adds_shifted_oracle_32_2_208f0020() {
    // Test ADDS shifted 32-bit: overflow test (oracle)
    // Encoding: 0x208F0020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x208F0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `ADDS X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// overflow test (64)
#[test]
fn test_aarch32_add_sp_r_a1_a_adds_shifted_oracle_64_2_a08f0020() {
    // Test ADDS shifted 64-bit: overflow test (oracle)
    // Encoding: 0xA08F0020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xA08F0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, true, "V flag should be true");
}

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `ADDS X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// subtract from zero (32)
#[test]
fn test_aarch32_add_sp_r_a1_a_adds_shifted_oracle_32_3_208f0020() {
    // Test ADDS shifted 32-bit: subtract from zero (oracle)
    // Encoding: 0x208F0020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x208F0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "W0 should be 0xFFFFFFFF");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `ADDS X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// subtract from zero (64)
#[test]
fn test_aarch32_add_sp_r_a1_a_adds_shifted_oracle_64_3_a08f0020() {
    // Test ADDS shifted 64-bit: subtract from zero (oracle)
    // Encoding: 0xA08F0020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0xA08F0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `SUB X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// no shift (32)
#[test]
fn test_aarch32_add_sp_r_a1_a_sub_shifted_oracle_32_0_408f0020() {
    // Test SUB shifted 32-bit: no shift (oracle)
    // Encoding: 0x408F0020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0xA);
    let encoding: u32 = 0x408F0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x5A, "W0 should be 0x0000005A");
}

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `SUB X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// no shift (64)
#[test]
fn test_aarch32_add_sp_r_a1_a_sub_shifted_oracle_64_0_c08f0020() {
    // Test SUB shifted 64-bit: no shift (oracle)
    // Encoding: 0xC08F0020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xA);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xC08F0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x5A, "X0 should be 0x000000000000005A");
}

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `SUB X0, X1, X2, shift #3`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// LSL #3 (multiply by 8) (32)
#[test]
fn test_aarch32_add_sp_r_a1_a_sub_shifted_oracle_32_1_408f0c20() {
    // Test SUB shifted 32-bit: LSL #3 (multiply by 8) (oracle)
    // Encoding: 0x408F0C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x408F0C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x5C, "W0 should be 0x0000005C");
}

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `SUB X0, X1, X2, shift #3`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// LSL #3 (multiply by 8) (64)
#[test]
fn test_aarch32_add_sp_r_a1_a_sub_shifted_oracle_64_1_c08f0c20() {
    // Test SUB shifted 64-bit: LSL #3 (multiply by 8) (oracle)
    // Encoding: 0xC08F0C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0xC08F0C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x5C, "X0 should be 0x000000000000005C");
}

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `SUB X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// overflow test (32)
#[test]
fn test_aarch32_add_sp_r_a1_a_sub_shifted_oracle_32_2_408f0020() {
    // Test SUB shifted 32-bit: overflow test (oracle)
    // Encoding: 0x408F0020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x408F0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `SUB X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// overflow test (64)
#[test]
fn test_aarch32_add_sp_r_a1_a_sub_shifted_oracle_64_2_c08f0020() {
    // Test SUB shifted 64-bit: overflow test (oracle)
    // Encoding: 0xC08F0020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xC08F0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `SUB X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// subtract from zero (32)
#[test]
fn test_aarch32_add_sp_r_a1_a_sub_shifted_oracle_32_3_408f0020() {
    // Test SUB shifted 32-bit: subtract from zero (oracle)
    // Encoding: 0x408F0020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x408F0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `SUB X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// subtract from zero (64)
#[test]
fn test_aarch32_add_sp_r_a1_a_sub_shifted_oracle_64_3_c08f0020() {
    // Test SUB shifted 64-bit: subtract from zero (oracle)
    // Encoding: 0xC08F0020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0xC08F0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x0000000000000001");
}

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `SUBS X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// no shift (32)
#[test]
fn test_aarch32_add_sp_r_a1_a_subs_shifted_oracle_32_0_608f0020() {
    // Test SUBS shifted 32-bit: no shift (oracle)
    // Encoding: 0x608F0020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0xA);
    let encoding: u32 = 0x608F0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x5A, "W0 should be 0x0000005A");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `SUBS X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// no shift (64)
#[test]
fn test_aarch32_add_sp_r_a1_a_subs_shifted_oracle_64_0_e08f0020() {
    // Test SUBS shifted 64-bit: no shift (oracle)
    // Encoding: 0xE08F0020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xA);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xE08F0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x5A, "X0 should be 0x000000000000005A");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `SUBS X0, X1, X2, shift #3`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// LSL #3 (multiply by 8) (32)
#[test]
fn test_aarch32_add_sp_r_a1_a_subs_shifted_oracle_32_1_608f0c20() {
    // Test SUBS shifted 32-bit: LSL #3 (multiply by 8) (oracle)
    // Encoding: 0x608F0C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x608F0C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x5C, "W0 should be 0x0000005C");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `SUBS X0, X1, X2, shift #3`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// LSL #3 (multiply by 8) (64)
#[test]
fn test_aarch32_add_sp_r_a1_a_subs_shifted_oracle_64_1_e08f0c20() {
    // Test SUBS shifted 64-bit: LSL #3 (multiply by 8) (oracle)
    // Encoding: 0xE08F0C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xE08F0C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x5C, "X0 should be 0x000000000000005C");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `SUBS X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// overflow test (32)
#[test]
fn test_aarch32_add_sp_r_a1_a_subs_shifted_oracle_32_2_608f0020() {
    // Test SUBS shifted 32-bit: overflow test (oracle)
    // Encoding: 0x608F0020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x608F0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `SUBS X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// overflow test (64)
#[test]
fn test_aarch32_add_sp_r_a1_a_subs_shifted_oracle_64_2_e08f0020() {
    // Test SUBS shifted 64-bit: overflow test (oracle)
    // Encoding: 0xE08F0020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xE08F0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `SUBS X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// subtract from zero (32)
#[test]
fn test_aarch32_add_sp_r_a1_a_subs_shifted_oracle_32_3_608f0020() {
    // Test SUBS shifted 32-bit: subtract from zero (oracle)
    // Encoding: 0x608F0020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x608F0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `SUBS X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// subtract from zero (64)
#[test]
fn test_aarch32_add_sp_r_a1_a_subs_shifted_oracle_64_3_e08f0020() {
    // Test SUBS shifted 64-bit: subtract from zero (oracle)
    // Encoding: 0xE08F0020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0xE08F0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x0000000000000001");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `ADD R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple values
#[test]
fn test_aarch32_add_sp_r_a1_a_a32_add_sub_reg_0_00810002() {
    // Test A32 ADD: simple values (oracle)
    // Encoding: 0x00810002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x32);
    let encoding: u32 = 0x00810002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x96, "R0 should be 0x00000096");
}

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `ADD R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero values
#[test]
fn test_aarch32_add_sp_r_a1_a_a32_add_sub_reg_1_00810002() {
    // Test A32 ADD: zero values (oracle)
    // Encoding: 0x00810002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x00810002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `ADD R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max value
#[test]
fn test_aarch32_add_sp_r_a1_a_a32_add_sub_reg_2_00810002() {
    // Test A32 ADD: max value (oracle)
    // Encoding: 0x00810002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x00810002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `ADD R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set
#[test]
fn test_aarch32_add_sp_r_a1_a_a32_add_sub_reg_3_00810002() {
    // Test A32 ADD: MSB set (oracle)
    // Encoding: 0x00810002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    set_w(&mut cpu, 2, 0x80000000);
    let encoding: u32 = 0x00810002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `ADD R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// mixed pattern
#[test]
fn test_aarch32_add_sp_r_a1_a_a32_add_sub_reg_4_00810002() {
    // Test A32 ADD: mixed pattern (oracle)
    // Encoding: 0x00810002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x9ABCDEF0);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u32 = 0x00810002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xACF13568, "R0 should be 0xACF13568");
}

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_aarch32_add_sp_r_a1_a_flags_zeroresult_0_009d0002() {
    // Test aarch32_ADD_SP_r_A1_A flag computation: ZeroResult
    // Encoding: 0x009D0002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x009D0002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_aarch32_add_sp_r_a1_a_flags_zeroresult_1_009d0002() {
    // Test aarch32_ADD_SP_r_A1_A flag computation: ZeroResult
    // Encoding: 0x009D0002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x009D0002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_aarch32_add_sp_r_a1_a_flags_negativeresult_2_009d0002() {
    // Test aarch32_ADD_SP_r_A1_A flag computation: NegativeResult
    // Encoding: 0x009D0002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x009D0002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_aarch32_add_sp_r_a1_a_flags_unsignedoverflow_3_009d0002() {
    // Test aarch32_ADD_SP_r_A1_A flag computation: UnsignedOverflow
    // Encoding: 0x009D0002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x009D0002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_aarch32_add_sp_r_a1_a_flags_unsignedoverflow_4_009d0002() {
    // Test aarch32_ADD_SP_r_A1_A flag computation: UnsignedOverflow
    // Encoding: 0x009D0002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x009D0002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_aarch32_add_sp_r_a1_a_flags_signedoverflow_5_009d0002() {
    // Test aarch32_ADD_SP_r_A1_A flag computation: SignedOverflow
    // Encoding: 0x009D0002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x009D0002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_aarch32_add_sp_r_a1_a_flags_signedoverflow_6_009d0002() {
    // Test aarch32_ADD_SP_r_A1_A flag computation: SignedOverflow
    // Encoding: 0x009D0002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x009D0002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_ADD_SP_r_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_aarch32_add_sp_r_a1_a_flags_positiveresult_7_009d0002() {
    // Test aarch32_ADD_SP_r_A1_A flag computation: PositiveResult
    // Encoding: 0x009D0002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x32);
    let encoding: u32 = 0x009D0002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_SP_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 0 (32)
#[test]
fn test_aarch32_add_sp_r_t1_a_lslv_oracle_32_0_446a0020() {
    // Test LSLV 32-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x12345678, "W0 should be 0x12345678");
}

/// Provenance: aarch32_ADD_SP_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 0 (64)
#[test]
fn test_aarch32_add_sp_r_t1_a_lslv_oracle_64_0_c46a0020() {
    // Test LSLV 64-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x12345678,
        "X0 should be 0x0000000012345678"
    );
}

/// Provenance: aarch32_ADD_SP_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4 (32)
#[test]
fn test_aarch32_add_sp_r_t1_a_lslv_oracle_32_1_446a0020() {
    // Test LSLV 32-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x4);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x23456780, "W0 should be 0x23456780");
}

/// Provenance: aarch32_ADD_SP_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 4 (64)
#[test]
fn test_aarch32_add_sp_r_t1_a_lslv_oracle_64_1_c46a0020() {
    // Test LSLV 64-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x4);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x23456780,
        "X0 should be 0x0000000123456780"
    );
}

/// Provenance: aarch32_ADD_SP_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 8 (32)
#[test]
fn test_aarch32_add_sp_r_t1_a_lslv_oracle_32_2_446a0020() {
    // Test LSLV 32-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x8);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x34567800, "W0 should be 0x34567800");
}

/// Provenance: aarch32_ADD_SP_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 8 (64)
#[test]
fn test_aarch32_add_sp_r_t1_a_lslv_oracle_64_2_c46a0020() {
    // Test LSLV 64-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x8);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x34567800,
        "X0 should be 0x0000001234567800"
    );
}

/// Provenance: aarch32_ADD_SP_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1 (32)
#[test]
fn test_aarch32_add_sp_r_t1_a_lslv_oracle_32_3_446a0020() {
    // Test LSLV 32-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_ADD_SP_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// MSB set, shift 1 (64)
#[test]
fn test_aarch32_add_sp_r_t1_a_lslv_oracle_64_3_c46a0020() {
    // Test LSLV 64-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_ADD_SP_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// LSB set, max shift (32)
#[test]
fn test_aarch32_add_sp_r_t1_a_lslv_oracle_32_4_446a0020() {
    // Test LSLV 32-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x3F);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "W0 should be 0x80000000");
}

/// Provenance: aarch32_ADD_SP_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// LSB set, max shift (64)
#[test]
fn test_aarch32_add_sp_r_t1_a_lslv_oracle_64_4_c46a0020() {
    // Test LSLV 64-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x3F);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x8000000000000000");
}

/// Provenance: aarch32_ADD_SP_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// all ones, shift 32 (32)
#[test]
fn test_aarch32_add_sp_r_t1_a_lslv_oracle_32_5_446a0020() {
    // Test LSLV 32-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x20);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "W0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_ADD_SP_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// all ones, shift 32 (64)
#[test]
fn test_aarch32_add_sp_r_t1_a_lslv_oracle_64_5_c46a0020() {
    // Test LSLV 64-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x20);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0xFFFFFFFF00000000");
}

/// Provenance: aarch32_ADD_SP_r_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// no shift
#[test]
fn test_aarch32_add_sp_r_t1_a_t16_oracle_0_44680000() {
    // Test T16 LSLS: no shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_ADD_SP_r_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4
#[test]
fn test_aarch32_add_sp_r_t1_a_t16_oracle_1_44680000() {
    // Test T16 LSLS: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x4);
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF0, "R0 should be 0x00000FF0");
}

/// Provenance: aarch32_ADD_SP_r_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1
#[test]
fn test_aarch32_add_sp_r_t1_a_t16_oracle_2_44680000() {
    // Test T16 LSLS: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_ADD_SP_r_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift to MSB
#[test]
fn test_aarch32_add_sp_r_t1_a_t16_oracle_3_44680000() {
    // Test T16 LSLS: shift to MSB (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1F);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "R0 should be 0x80000000");
}

/// Provenance: aarch32_ADD_SP_r_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_aarch32_add_sp_r_t1_a_flags_zeroresult_0_44680000() {
    // Test aarch32_ADD_SP_r_T1_A flag computation: ZeroResult
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_SP_r_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_aarch32_add_sp_r_t1_a_flags_zeroresult_1_44680000() {
    // Test aarch32_ADD_SP_r_T1_A flag computation: ZeroResult
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_SP_r_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_aarch32_add_sp_r_t1_a_flags_negativeresult_2_44680000() {
    // Test aarch32_ADD_SP_r_T1_A flag computation: NegativeResult
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_SP_r_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_aarch32_add_sp_r_t1_a_flags_unsignedoverflow_3_44680000() {
    // Test aarch32_ADD_SP_r_T1_A flag computation: UnsignedOverflow
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_SP_r_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_aarch32_add_sp_r_t1_a_flags_unsignedoverflow_4_44680000() {
    // Test aarch32_ADD_SP_r_T1_A flag computation: UnsignedOverflow
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_SP_r_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_aarch32_add_sp_r_t1_a_flags_signedoverflow_5_44680000() {
    // Test aarch32_ADD_SP_r_T1_A flag computation: SignedOverflow
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_ADD_SP_r_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_aarch32_add_sp_r_t1_a_flags_signedoverflow_6_44680000() {
    // Test aarch32_ADD_SP_r_T1_A flag computation: SignedOverflow
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_ADD_SP_r_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_aarch32_add_sp_r_t1_a_flags_positiveresult_7_44680000() {
    // Test aarch32_ADD_SP_r_T1_A flag computation: PositiveResult
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x32);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_SP_r_T2_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 0 (32)
#[test]
fn test_aarch32_add_sp_r_t2_a_lslv_oracle_32_0_44870020() {
    // Test LSLV 32-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x12345678, "W0 should be 0x12345678");
}

/// Provenance: aarch32_ADD_SP_r_T2_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 0 (64)
#[test]
fn test_aarch32_add_sp_r_t2_a_lslv_oracle_64_0_c4870020() {
    // Test LSLV 64-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x12345678,
        "X0 should be 0x0000000012345678"
    );
}

/// Provenance: aarch32_ADD_SP_r_T2_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4 (32)
#[test]
fn test_aarch32_add_sp_r_t2_a_lslv_oracle_32_1_44870020() {
    // Test LSLV 32-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x4);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x23456780, "W0 should be 0x23456780");
}

/// Provenance: aarch32_ADD_SP_r_T2_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 4 (64)
#[test]
fn test_aarch32_add_sp_r_t2_a_lslv_oracle_64_1_c4870020() {
    // Test LSLV 64-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x4);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x23456780,
        "X0 should be 0x0000000123456780"
    );
}

/// Provenance: aarch32_ADD_SP_r_T2_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 8 (32)
#[test]
fn test_aarch32_add_sp_r_t2_a_lslv_oracle_32_2_44870020() {
    // Test LSLV 32-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x8);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x34567800, "W0 should be 0x34567800");
}

/// Provenance: aarch32_ADD_SP_r_T2_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 8 (64)
#[test]
fn test_aarch32_add_sp_r_t2_a_lslv_oracle_64_2_c4870020() {
    // Test LSLV 64-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x8);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x34567800,
        "X0 should be 0x0000001234567800"
    );
}

/// Provenance: aarch32_ADD_SP_r_T2_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1 (32)
#[test]
fn test_aarch32_add_sp_r_t2_a_lslv_oracle_32_3_44870020() {
    // Test LSLV 32-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_ADD_SP_r_T2_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// MSB set, shift 1 (64)
#[test]
fn test_aarch32_add_sp_r_t2_a_lslv_oracle_64_3_c4870020() {
    // Test LSLV 64-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_ADD_SP_r_T2_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// LSB set, max shift (32)
#[test]
fn test_aarch32_add_sp_r_t2_a_lslv_oracle_32_4_44870020() {
    // Test LSLV 32-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3F);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "W0 should be 0x80000000");
}

/// Provenance: aarch32_ADD_SP_r_T2_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// LSB set, max shift (64)
#[test]
fn test_aarch32_add_sp_r_t2_a_lslv_oracle_64_4_c4870020() {
    // Test LSLV 64-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x3F);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x8000000000000000");
}

/// Provenance: aarch32_ADD_SP_r_T2_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// all ones, shift 32 (32)
#[test]
fn test_aarch32_add_sp_r_t2_a_lslv_oracle_32_5_44870020() {
    // Test LSLV 32-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x20);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "W0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_ADD_SP_r_T2_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// all ones, shift 32 (64)
#[test]
fn test_aarch32_add_sp_r_t2_a_lslv_oracle_64_5_c4870020() {
    // Test LSLV 64-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x20);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0xFFFFFFFF00000000");
}

/// Provenance: aarch32_ADD_SP_r_T2_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// no shift
#[test]
fn test_aarch32_add_sp_r_t2_a_t16_oracle_0_44950000() {
    // Test T16 LSLS: no shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_ADD_SP_r_T2_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4
#[test]
fn test_aarch32_add_sp_r_t2_a_t16_oracle_1_44950000() {
    // Test T16 LSLS: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x4);
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF0, "R0 should be 0x00000FF0");
}

/// Provenance: aarch32_ADD_SP_r_T2_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1
#[test]
fn test_aarch32_add_sp_r_t2_a_t16_oracle_2_44950000() {
    // Test T16 LSLS: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_ADD_SP_r_T2_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift to MSB
#[test]
fn test_aarch32_add_sp_r_t2_a_t16_oracle_3_44950000() {
    // Test T16 LSLS: shift to MSB (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x1F);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "R0 should be 0x80000000");
}

/// Provenance: aarch32_ADD_SP_r_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_aarch32_add_sp_r_t2_a_flags_zeroresult_0_44950000() {
    // Test aarch32_ADD_SP_r_T2_A flag computation: ZeroResult
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_SP_r_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_aarch32_add_sp_r_t2_a_flags_zeroresult_1_44950000() {
    // Test aarch32_ADD_SP_r_T2_A flag computation: ZeroResult
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_SP_r_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_aarch32_add_sp_r_t2_a_flags_negativeresult_2_44950000() {
    // Test aarch32_ADD_SP_r_T2_A flag computation: NegativeResult
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_SP_r_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_aarch32_add_sp_r_t2_a_flags_unsignedoverflow_3_44950000() {
    // Test aarch32_ADD_SP_r_T2_A flag computation: UnsignedOverflow
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_SP_r_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_aarch32_add_sp_r_t2_a_flags_unsignedoverflow_4_44950000() {
    // Test aarch32_ADD_SP_r_T2_A flag computation: UnsignedOverflow
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_SP_r_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_aarch32_add_sp_r_t2_a_flags_signedoverflow_5_44950000() {
    // Test aarch32_ADD_SP_r_T2_A flag computation: SignedOverflow
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_ADD_SP_r_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_aarch32_add_sp_r_t2_a_flags_signedoverflow_6_44950000() {
    // Test aarch32_ADD_SP_r_T2_A flag computation: SignedOverflow
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_ADD_SP_r_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_aarch32_add_sp_r_t2_a_flags_positiveresult_7_44950000() {
    // Test aarch32_ADD_SP_r_T2_A flag computation: PositiveResult
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x32);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_SP_r_T3_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_aarch32_add_sp_r_t3_a_flags_zeroresult_0_eb1d0002() {
    // Test aarch32_ADD_SP_r_T3_A flag computation: ZeroResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xEB1D0002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_SP_r_T3_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_aarch32_add_sp_r_t3_a_flags_zeroresult_1_eb1d0002() {
    // Test aarch32_ADD_SP_r_T3_A flag computation: ZeroResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0xEB1D0002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_SP_r_T3_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_aarch32_add_sp_r_t3_a_flags_negativeresult_2_eb1d0002() {
    // Test aarch32_ADD_SP_r_T3_A flag computation: NegativeResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xEB1D0002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_SP_r_T3_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_aarch32_add_sp_r_t3_a_flags_unsignedoverflow_3_eb1d0002() {
    // Test aarch32_ADD_SP_r_T3_A flag computation: UnsignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0xEB1D0002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_SP_r_T3_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_aarch32_add_sp_r_t3_a_flags_unsignedoverflow_4_eb1d0002() {
    // Test aarch32_ADD_SP_r_T3_A flag computation: UnsignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xEB1D0002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_SP_r_T3_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_aarch32_add_sp_r_t3_a_flags_signedoverflow_5_eb1d0002() {
    // Test aarch32_ADD_SP_r_T3_A flag computation: SignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0xEB1D0002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_ADD_SP_r_T3_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_aarch32_add_sp_r_t3_a_flags_signedoverflow_6_eb1d0002() {
    // Test aarch32_ADD_SP_r_T3_A flag computation: SignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0xEB1D0002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_ADD_SP_r_T3_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_aarch32_add_sp_r_t3_a_flags_positiveresult_7_eb1d0002() {
    // Test aarch32_ADD_SP_r_T3_A flag computation: PositiveResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x32);
    let encoding: u32 = 0xEB1D0002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

// ============================================================================
// aarch32_SUB_i_A Tests
// ============================================================================

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_sub_i_a1_a_field_cond_0_min_0_02400000() {
    // Encoding: 0x02400000
    // Test aarch32_SUB_i_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: cond=0, imm12=0, Rd=0, Rn=0, S=0
    let encoding: u32 = 0x02400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_sub_i_a1_a_field_cond_1_poweroftwo_0_12400000() {
    // Encoding: 0x12400000
    // Test aarch32_SUB_i_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, Rn=0, cond=1, imm12=0, Rd=0
    let encoding: u32 = 0x12400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_sub_i_a1_a_field_cond_2_poweroftwo_0_22400000() {
    // Encoding: 0x22400000
    // Test aarch32_SUB_i_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, Rn=0, imm12=0, Rd=0, cond=2
    let encoding: u32 = 0x22400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_sub_i_a1_a_field_cond_3_poweroftwo_0_32400000() {
    // Encoding: 0x32400000
    // Test aarch32_SUB_i_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=0, Rn=0, cond=3, S=0, Rd=0
    let encoding: u32 = 0x32400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_sub_i_a1_a_field_cond_4_poweroftwo_0_42400000() {
    // Encoding: 0x42400000
    // Test aarch32_SUB_i_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, cond=4, Rn=0, S=0, imm12=0
    let encoding: u32 = 0x42400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_sub_i_a1_a_field_cond_5_poweroftwo_0_52400000() {
    // Encoding: 0x52400000
    // Test aarch32_SUB_i_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, S=0, Rn=0, cond=5, imm12=0
    let encoding: u32 = 0x52400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_sub_i_a1_a_field_cond_6_poweroftwo_0_62400000() {
    // Encoding: 0x62400000
    // Test aarch32_SUB_i_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=6, Rd=0, S=0, imm12=0
    let encoding: u32 = 0x62400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_sub_i_a1_a_field_cond_7_poweroftwo_0_72400000() {
    // Encoding: 0x72400000
    // Test aarch32_SUB_i_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, S=0, imm12=0, Rd=0, cond=7
    let encoding: u32 = 0x72400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_sub_i_a1_a_field_cond_8_poweroftwo_0_82400000() {
    // Encoding: 0x82400000
    // Test aarch32_SUB_i_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=8, Rn=0, S=0, imm12=0, Rd=0
    let encoding: u32 = 0x82400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_sub_i_a1_a_field_cond_9_poweroftwo_0_92400000() {
    // Encoding: 0x92400000
    // Test aarch32_SUB_i_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, cond=9, Rn=0, imm12=0, Rd=0
    let encoding: u32 = 0x92400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_sub_i_a1_a_field_cond_10_poweroftwo_0_a2400000() {
    // Encoding: 0xA2400000
    // Test aarch32_SUB_i_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, S=0, cond=10, Rn=0, imm12=0
    let encoding: u32 = 0xA2400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_sub_i_a1_a_field_cond_11_poweroftwo_0_b2400000() {
    // Encoding: 0xB2400000
    // Test aarch32_SUB_i_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=11, Rn=0, S=0, Rd=0, imm12=0
    let encoding: u32 = 0xB2400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_sub_i_a1_a_field_cond_12_poweroftwo_0_c2400000() {
    // Encoding: 0xC2400000
    // Test aarch32_SUB_i_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=0, S=0, Rd=0, Rn=0, cond=12
    let encoding: u32 = 0xC2400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_sub_i_a1_a_field_cond_13_poweroftwo_0_d2400000() {
    // Encoding: 0xD2400000
    // Test aarch32_SUB_i_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=0, S=0, Rd=0, Rn=0, cond=13
    let encoding: u32 = 0xD2400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_sub_i_a1_a_field_cond_14_poweroftwo_0_e2400000() {
    // Encoding: 0xE2400000
    // Test aarch32_SUB_i_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=14, imm12=0, S=0, Rd=0
    let encoding: u32 = 0xE2400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_sub_i_a1_a_field_cond_15_max_0_f2400000() {
    // Encoding: 0xF2400000
    // Test aarch32_SUB_i_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: cond=15, Rn=0, S=0, Rd=0, imm12=0
    let encoding: u32 = 0xF2400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_sub_i_a1_a_field_s_0_min_0_02400000() {
    // Encoding: 0x02400000
    // Test aarch32_SUB_i_A1_A field S = 0 (Min)
    // ISET: A32
    // Fields: cond=0, S=0, Rd=0, imm12=0, Rn=0
    let encoding: u32 = 0x02400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_sub_i_a1_a_field_s_1_max_0_02500000() {
    // Encoding: 0x02500000
    // Test aarch32_SUB_i_A1_A field S = 1 (Max)
    // ISET: A32
    // Fields: imm12=0, Rd=0, S=1, cond=0, Rn=0
    let encoding: u32 = 0x02500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_sub_i_a1_a_field_rn_0_min_0_02400000() {
    // Encoding: 0x02400000
    // Test aarch32_SUB_i_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: imm12=0, S=0, cond=0, Rd=0, Rn=0
    let encoding: u32 = 0x02400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_sub_i_a1_a_field_rn_1_poweroftwo_0_02410000() {
    // Encoding: 0x02410000
    // Test aarch32_SUB_i_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, imm12=0, Rn=1, cond=0, Rd=0
    let encoding: u32 = 0x02410000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_sub_i_a1_a_field_rd_0_min_0_02400000() {
    // Encoding: 0x02400000
    // Test aarch32_SUB_i_A1_A field Rd = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, imm12=0, cond=0, S=0, Rd=0
    let encoding: u32 = 0x02400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_sub_i_a1_a_field_rd_1_poweroftwo_0_02401000() {
    // Encoding: 0x02401000
    // Test aarch32_SUB_i_A1_A field Rd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=1, imm12=0, Rn=0, cond=0, S=0
    let encoding: u32 = 0x02401000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_sub_i_a1_a_field_imm12_0_zero_0_02400000() {
    // Encoding: 0x02400000
    // Test aarch32_SUB_i_A1_A field imm12 = 0 (Zero)
    // ISET: A32
    // Fields: S=0, Rn=0, cond=0, Rd=0, imm12=0
    let encoding: u32 = 0x02400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_sub_i_a1_a_field_imm12_1_poweroftwo_0_02400001() {
    // Encoding: 0x02400001
    // Test aarch32_SUB_i_A1_A field imm12 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, imm12=1, Rn=0, cond=0, Rd=0
    let encoding: u32 = 0x02400001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_sub_i_a1_a_field_imm12_3_poweroftwominusone_0_02400003() {
    // Encoding: 0x02400003
    // Test aarch32_SUB_i_A1_A field imm12 = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rd=0, imm12=3, Rn=0, S=0, cond=0
    let encoding: u32 = 0x02400003;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_sub_i_a1_a_field_imm12_4_poweroftwo_0_02400004() {
    // Encoding: 0x02400004
    // Test aarch32_SUB_i_A1_A field imm12 = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=4, S=0, Rn=0, cond=0, Rd=0
    let encoding: u32 = 0x02400004;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_sub_i_a1_a_field_imm12_7_poweroftwominusone_0_02400007() {
    // Encoding: 0x02400007
    // Test aarch32_SUB_i_A1_A field imm12 = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rn=0, cond=0, imm12=7, S=0, Rd=0
    let encoding: u32 = 0x02400007;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_sub_i_a1_a_field_imm12_8_poweroftwo_0_02400008() {
    // Encoding: 0x02400008
    // Test aarch32_SUB_i_A1_A field imm12 = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=8, Rd=0, cond=0, S=0, Rn=0
    let encoding: u32 = 0x02400008;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_sub_i_a1_a_field_imm12_15_poweroftwominusone_0_0240000f() {
    // Encoding: 0x0240000F
    // Test aarch32_SUB_i_A1_A field imm12 = 15 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rd=0, S=0, imm12=15, Rn=0, cond=0
    let encoding: u32 = 0x0240000F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_sub_i_a1_a_field_imm12_16_poweroftwo_0_02400010() {
    // Encoding: 0x02400010
    // Test aarch32_SUB_i_A1_A field imm12 = 16 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, cond=0, Rn=0, S=0, imm12=16
    let encoding: u32 = 0x02400010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_sub_i_a1_a_field_imm12_31_poweroftwominusone_0_0240001f() {
    // Encoding: 0x0240001F
    // Test aarch32_SUB_i_A1_A field imm12 = 31 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rn=0, Rd=0, S=0, imm12=31, cond=0
    let encoding: u32 = 0x0240001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_sub_i_a1_a_field_imm12_32_poweroftwo_0_02400020() {
    // Encoding: 0x02400020
    // Test aarch32_SUB_i_A1_A field imm12 = 32 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, imm12=32, cond=0, Rn=0, Rd=0
    let encoding: u32 = 0x02400020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_sub_i_a1_a_field_imm12_63_poweroftwominusone_0_0240003f() {
    // Encoding: 0x0240003F
    // Test aarch32_SUB_i_A1_A field imm12 = 63 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, S=0, Rn=0, Rd=0, imm12=63
    let encoding: u32 = 0x0240003F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_sub_i_a1_a_field_imm12_64_poweroftwo_0_02400040() {
    // Encoding: 0x02400040
    // Test aarch32_SUB_i_A1_A field imm12 = 64 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, imm12=64, S=0, Rn=0, cond=0
    let encoding: u32 = 0x02400040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 127, boundary: PowerOfTwoMinusOne }
/// 2^7 - 1 = 127
#[test]
fn test_aarch32_sub_i_a1_a_field_imm12_127_poweroftwominusone_0_0240007f() {
    // Encoding: 0x0240007F
    // Test aarch32_SUB_i_A1_A field imm12 = 127 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rn=0, Rd=0, S=0, cond=0, imm12=127
    let encoding: u32 = 0x0240007F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_sub_i_a1_a_field_imm12_128_poweroftwo_0_02400080() {
    // Encoding: 0x02400080
    // Test aarch32_SUB_i_A1_A field imm12 = 128 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=128, Rn=0, cond=0, S=0, Rd=0
    let encoding: u32 = 0x02400080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 255, boundary: PowerOfTwoMinusOne }
/// 2^8 - 1 = 255
#[test]
fn test_aarch32_sub_i_a1_a_field_imm12_255_poweroftwominusone_0_024000ff() {
    // Encoding: 0x024000FF
    // Test aarch32_SUB_i_A1_A field imm12 = 255 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: S=0, Rd=0, cond=0, imm12=255, Rn=0
    let encoding: u32 = 0x024000FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 256, boundary: PowerOfTwo }
/// power of 2 (2^8 = 256)
#[test]
fn test_aarch32_sub_i_a1_a_field_imm12_256_poweroftwo_0_02400100() {
    // Encoding: 0x02400100
    // Test aarch32_SUB_i_A1_A field imm12 = 256 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=0, Rd=0, imm12=256, S=0
    let encoding: u32 = 0x02400100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 511, boundary: PowerOfTwoMinusOne }
/// 2^9 - 1 = 511
#[test]
fn test_aarch32_sub_i_a1_a_field_imm12_511_poweroftwominusone_0_024001ff() {
    // Encoding: 0x024001FF
    // Test aarch32_SUB_i_A1_A field imm12 = 511 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rn=0, Rd=0, cond=0, S=0, imm12=511
    let encoding: u32 = 0x024001FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 512, boundary: PowerOfTwo }
/// power of 2 (2^9 = 512)
#[test]
fn test_aarch32_sub_i_a1_a_field_imm12_512_poweroftwo_0_02400200() {
    // Encoding: 0x02400200
    // Test aarch32_SUB_i_A1_A field imm12 = 512 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, imm12=512, Rn=0, cond=0, Rd=0
    let encoding: u32 = 0x02400200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1023, boundary: PowerOfTwoMinusOne }
/// 2^10 - 1 = 1023
#[test]
fn test_aarch32_sub_i_a1_a_field_imm12_1023_poweroftwominusone_0_024003ff() {
    // Encoding: 0x024003FF
    // Test aarch32_SUB_i_A1_A field imm12 = 1023 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm12=1023, Rn=0, S=0, Rd=0, cond=0
    let encoding: u32 = 0x024003FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1024, boundary: PowerOfTwo }
/// power of 2 (2^10 = 1024)
#[test]
fn test_aarch32_sub_i_a1_a_field_imm12_1024_poweroftwo_0_02400400() {
    // Encoding: 0x02400400
    // Test aarch32_SUB_i_A1_A field imm12 = 1024 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, imm12=1024, cond=0, Rd=0, Rn=0
    let encoding: u32 = 0x02400400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2047, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (2047)
#[test]
fn test_aarch32_sub_i_a1_a_field_imm12_2047_poweroftwominusone_0_024007ff() {
    // Encoding: 0x024007FF
    // Test aarch32_SUB_i_A1_A field imm12 = 2047 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rd=0, imm12=2047, S=0, Rn=0, cond=0
    let encoding: u32 = 0x024007FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2048, boundary: PowerOfTwo }
/// power of 2 (2^11 = 2048)
#[test]
fn test_aarch32_sub_i_a1_a_field_imm12_2048_poweroftwo_0_02400800() {
    // Encoding: 0x02400800
    // Test aarch32_SUB_i_A1_A field imm12 = 2048 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, Rd=0, imm12=2048, cond=0, Rn=0
    let encoding: u32 = 0x02400800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4095, boundary: Max }
/// maximum immediate (4095)
#[test]
fn test_aarch32_sub_i_a1_a_field_imm12_4095_max_0_02400fff() {
    // Encoding: 0x02400FFF
    // Test aarch32_SUB_i_A1_A field imm12 = 4095 (Max)
    // ISET: A32
    // Fields: imm12=4095, Rd=0, S=0, cond=0, Rn=0
    let encoding: u32 = 0x02400FFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_sub_i_a1_a_combo_0_0_02400000() {
    // Encoding: 0x02400000
    // Test aarch32_SUB_i_A1_A field combination: cond=0, S=0, Rn=0, Rd=0, imm12=0
    // ISET: A32
    // Fields: Rd=0, imm12=0, cond=0, S=0, Rn=0
    let encoding: u32 = 0x02400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_sub_i_a1_a_special_cond_0_condition_eq_0_02400000() {
    // Encoding: 0x02400000
    // Test aarch32_SUB_i_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: cond=0, Rn=0, imm12=0, Rd=0, S=0
    let encoding: u32 = 0x02400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_sub_i_a1_a_special_cond_1_condition_ne_0_12400000() {
    // Encoding: 0x12400000
    // Test aarch32_SUB_i_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: Rd=0, imm12=0, S=0, cond=1, Rn=0
    let encoding: u32 = 0x12400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_sub_i_a1_a_special_cond_2_condition_cs_hs_0_22400000() {
    // Encoding: 0x22400000
    // Test aarch32_SUB_i_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: S=0, Rn=0, cond=2, Rd=0, imm12=0
    let encoding: u32 = 0x22400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_sub_i_a1_a_special_cond_3_condition_cc_lo_0_32400000() {
    // Encoding: 0x32400000
    // Test aarch32_SUB_i_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: cond=3, S=0, Rn=0, imm12=0, Rd=0
    let encoding: u32 = 0x32400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_sub_i_a1_a_special_cond_4_condition_mi_0_42400000() {
    // Encoding: 0x42400000
    // Test aarch32_SUB_i_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: Rn=0, Rd=0, S=0, imm12=0, cond=4
    let encoding: u32 = 0x42400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_sub_i_a1_a_special_cond_5_condition_pl_0_52400000() {
    // Encoding: 0x52400000
    // Test aarch32_SUB_i_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: Rd=0, imm12=0, S=0, cond=5, Rn=0
    let encoding: u32 = 0x52400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_sub_i_a1_a_special_cond_6_condition_vs_0_62400000() {
    // Encoding: 0x62400000
    // Test aarch32_SUB_i_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: cond=6, imm12=0, S=0, Rn=0, Rd=0
    let encoding: u32 = 0x62400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_sub_i_a1_a_special_cond_7_condition_vc_0_72400000() {
    // Encoding: 0x72400000
    // Test aarch32_SUB_i_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: Rd=0, imm12=0, Rn=0, S=0, cond=7
    let encoding: u32 = 0x72400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_sub_i_a1_a_special_cond_8_condition_hi_0_82400000() {
    // Encoding: 0x82400000
    // Test aarch32_SUB_i_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: Rn=0, Rd=0, imm12=0, S=0, cond=8
    let encoding: u32 = 0x82400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_sub_i_a1_a_special_cond_9_condition_ls_0_92400000() {
    // Encoding: 0x92400000
    // Test aarch32_SUB_i_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: S=0, Rn=0, Rd=0, cond=9, imm12=0
    let encoding: u32 = 0x92400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_sub_i_a1_a_special_cond_10_condition_ge_0_a2400000() {
    // Encoding: 0xA2400000
    // Test aarch32_SUB_i_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: Rd=0, imm12=0, S=0, cond=10, Rn=0
    let encoding: u32 = 0xA2400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_sub_i_a1_a_special_cond_11_condition_lt_0_b2400000() {
    // Encoding: 0xB2400000
    // Test aarch32_SUB_i_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: Rn=0, S=0, Rd=0, cond=11, imm12=0
    let encoding: u32 = 0xB2400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_sub_i_a1_a_special_cond_12_condition_gt_0_c2400000() {
    // Encoding: 0xC2400000
    // Test aarch32_SUB_i_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: Rn=0, Rd=0, S=0, imm12=0, cond=12
    let encoding: u32 = 0xC2400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_sub_i_a1_a_special_cond_13_condition_le_0_d2400000() {
    // Encoding: 0xD2400000
    // Test aarch32_SUB_i_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: Rd=0, cond=13, Rn=0, imm12=0, S=0
    let encoding: u32 = 0xD2400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_sub_i_a1_a_special_cond_14_condition_al_0_e2400000() {
    // Encoding: 0xE2400000
    // Test aarch32_SUB_i_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: imm12=0, cond=14, S=0, Rn=0, Rd=0
    let encoding: u32 = 0xE2400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_sub_i_a1_a_special_cond_15_condition_nv_0_f2400000() {
    // Encoding: 0xF2400000
    // Test aarch32_SUB_i_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: cond=15, S=0, Rd=0, imm12=0, Rn=0
    let encoding: u32 = 0xF2400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `field S = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "S", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_sub_i_a1_a_special_s_0_size_variant_0_0_02400000() {
    // Encoding: 0x02400000
    // Test aarch32_SUB_i_A1_A special value S = 0 (Size variant 0)
    // ISET: A32
    // Fields: Rn=0, imm12=0, cond=0, S=0, Rd=0
    let encoding: u32 = 0x02400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `field S = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "S", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_sub_i_a1_a_special_s_1_size_variant_1_0_02500000() {
    // Encoding: 0x02500000
    // Test aarch32_SUB_i_A1_A special value S = 1 (Size variant 1)
    // ISET: A32
    // Fields: S=1, Rd=0, imm12=0, cond=0, Rn=0
    let encoding: u32 = 0x02500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_i_T1_A
/// ASL: `field imm3 22 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_sub_i_t1_a_field_imm3_0_zero_0_1e000000() {
    // Thumb encoding (32): 0x1E000000
    // Test aarch32_SUB_i_T1_A field imm3 = 0 (Zero)
    // ISET: T32
    // Fields: Rd=0, imm3=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x1E000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T1_A
/// ASL: `field imm3 22 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_sub_i_t1_a_field_imm3_1_poweroftwo_0_1e400000() {
    // Thumb encoding (32): 0x1E400000
    // Test aarch32_SUB_i_T1_A field imm3 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rd=0, Rn=0, imm3=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x1E400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T1_A
/// ASL: `field imm3 22 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 3, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (3)
#[test]
fn test_aarch32_sub_i_t1_a_field_imm3_3_poweroftwominusone_0_1ec00000() {
    // Thumb encoding (32): 0x1EC00000
    // Test aarch32_SUB_i_T1_A field imm3 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm3=3, Rn=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x1EC00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T1_A
/// ASL: `field imm3 22 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 7, boundary: Max }
/// maximum immediate (7)
#[test]
fn test_aarch32_sub_i_t1_a_field_imm3_7_max_0_1fc00000() {
    // Thumb encoding (32): 0x1FC00000
    // Test aarch32_SUB_i_T1_A field imm3 = 7 (Max)
    // ISET: T32
    // Fields: Rd=0, imm3=7, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x1FC00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T1_A
/// ASL: `field Rn 19 +: 3`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_sub_i_t1_a_field_rn_0_min_0_1e000000() {
    // Thumb encoding (32): 0x1E000000
    // Test aarch32_SUB_i_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: imm3=0, Rn=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x1E000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T1_A
/// ASL: `field Rn 19 +: 3`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_sub_i_t1_a_field_rn_1_poweroftwo_0_1e080000() {
    // Thumb encoding (32): 0x1E080000
    // Test aarch32_SUB_i_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=1, Rd=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x1E080000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T1_A
/// ASL: `field Rd 16 +: 3`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_sub_i_t1_a_field_rd_0_min_0_1e000000() {
    // Thumb encoding (32): 0x1E000000
    // Test aarch32_SUB_i_T1_A field Rd = 0 (Min)
    // ISET: T32
    // Fields: imm3=0, Rn=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x1E000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T1_A
/// ASL: `field Rd 16 +: 3`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_sub_i_t1_a_field_rd_1_poweroftwo_0_1e010000() {
    // Thumb encoding (32): 0x1E010000
    // Test aarch32_SUB_i_T1_A field Rd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rd=1, imm3=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x1E010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm3=0 (immediate value 0)
#[test]
fn test_aarch32_sub_i_t1_a_combo_0_0_1e000000() {
    // Thumb encoding (32): 0x1E000000
    // Test aarch32_SUB_i_T1_A field combination: imm3=0, Rn=0, Rd=0
    // ISET: T32
    // Fields: Rd=0, imm3=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x1E000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T2_A
/// ASL: `field Rdn 24 +: 3`
/// Requirement: FieldBoundary { field: "Rdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_sub_i_t2_a_field_rdn_0_min_0_38000000() {
    // Thumb encoding (32): 0x38000000
    // Test aarch32_SUB_i_T2_A field Rdn = 0 (Min)
    // ISET: T32
    // Fields: imm8=0, Rdn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x38000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T2_A
/// ASL: `field Rdn 24 +: 3`
/// Requirement: FieldBoundary { field: "Rdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_sub_i_t2_a_field_rdn_1_poweroftwo_0_39000000() {
    // Thumb encoding (32): 0x39000000
    // Test aarch32_SUB_i_T2_A field Rdn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=0, Rdn=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x39000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T2_A
/// ASL: `field Rdn 24 +: 3`
/// Requirement: FieldBoundary { field: "Rdn", value: 7, boundary: Max }
/// maximum value (7)
#[test]
fn test_aarch32_sub_i_t2_a_field_rdn_7_max_0_3f000000() {
    // Thumb encoding (32): 0x3F000000
    // Test aarch32_SUB_i_T2_A field Rdn = 7 (Max)
    // ISET: T32
    // Fields: imm8=0, Rdn=7
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x3F000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T2_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_sub_i_t2_a_field_imm8_0_zero_0_38000000() {
    // Thumb encoding (32): 0x38000000
    // Test aarch32_SUB_i_T2_A field imm8 = 0 (Zero)
    // ISET: T32
    // Fields: imm8=0, Rdn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x38000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T2_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_sub_i_t2_a_field_imm8_1_poweroftwo_0_38010000() {
    // Thumb encoding (32): 0x38010000
    // Test aarch32_SUB_i_T2_A field imm8 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rdn=0, imm8=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x38010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T2_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_sub_i_t2_a_field_imm8_3_poweroftwominusone_0_38030000() {
    // Thumb encoding (32): 0x38030000
    // Test aarch32_SUB_i_T2_A field imm8 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm8=3, Rdn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x38030000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T2_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_sub_i_t2_a_field_imm8_4_poweroftwo_0_38040000() {
    // Thumb encoding (32): 0x38040000
    // Test aarch32_SUB_i_T2_A field imm8 = 4 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=4, Rdn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x38040000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T2_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_sub_i_t2_a_field_imm8_7_poweroftwominusone_0_38070000() {
    // Thumb encoding (32): 0x38070000
    // Test aarch32_SUB_i_T2_A field imm8 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm8=7, Rdn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x38070000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T2_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_sub_i_t2_a_field_imm8_8_poweroftwo_0_38080000() {
    // Thumb encoding (32): 0x38080000
    // Test aarch32_SUB_i_T2_A field imm8 = 8 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=8, Rdn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x38080000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T2_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_sub_i_t2_a_field_imm8_15_poweroftwominusone_0_380f0000() {
    // Thumb encoding (32): 0x380F0000
    // Test aarch32_SUB_i_T2_A field imm8 = 15 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rdn=0, imm8=15
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x380F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T2_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_sub_i_t2_a_field_imm8_16_poweroftwo_0_38100000() {
    // Thumb encoding (32): 0x38100000
    // Test aarch32_SUB_i_T2_A field imm8 = 16 (PowerOfTwo)
    // ISET: T32
    // Fields: Rdn=0, imm8=16
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x38100000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T2_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_sub_i_t2_a_field_imm8_31_poweroftwominusone_0_381f0000() {
    // Thumb encoding (32): 0x381F0000
    // Test aarch32_SUB_i_T2_A field imm8 = 31 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rdn=0, imm8=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x381F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T2_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_sub_i_t2_a_field_imm8_32_poweroftwo_0_38200000() {
    // Thumb encoding (32): 0x38200000
    // Test aarch32_SUB_i_T2_A field imm8 = 32 (PowerOfTwo)
    // ISET: T32
    // Fields: Rdn=0, imm8=32
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x38200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T2_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_sub_i_t2_a_field_imm8_63_poweroftwominusone_0_383f0000() {
    // Thumb encoding (32): 0x383F0000
    // Test aarch32_SUB_i_T2_A field imm8 = 63 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rdn=0, imm8=63
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x383F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T2_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_sub_i_t2_a_field_imm8_64_poweroftwo_0_38400000() {
    // Thumb encoding (32): 0x38400000
    // Test aarch32_SUB_i_T2_A field imm8 = 64 (PowerOfTwo)
    // ISET: T32
    // Fields: Rdn=0, imm8=64
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x38400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T2_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 127, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (127)
#[test]
fn test_aarch32_sub_i_t2_a_field_imm8_127_poweroftwominusone_0_387f0000() {
    // Thumb encoding (32): 0x387F0000
    // Test aarch32_SUB_i_T2_A field imm8 = 127 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rdn=0, imm8=127
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x387F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T2_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_sub_i_t2_a_field_imm8_128_poweroftwo_0_38800000() {
    // Thumb encoding (32): 0x38800000
    // Test aarch32_SUB_i_T2_A field imm8 = 128 (PowerOfTwo)
    // ISET: T32
    // Fields: Rdn=0, imm8=128
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x38800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T2_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 255, boundary: Max }
/// maximum immediate (255)
#[test]
fn test_aarch32_sub_i_t2_a_field_imm8_255_max_0_38ff0000() {
    // Thumb encoding (32): 0x38FF0000
    // Test aarch32_SUB_i_T2_A field imm8 = 255 (Max)
    // ISET: T32
    // Fields: Rdn=0, imm8=255
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x38FF0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T2_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rdn=0 (minimum value)
#[test]
fn test_aarch32_sub_i_t2_a_combo_0_0_38000000() {
    // Thumb encoding (32): 0x38000000
    // Test aarch32_SUB_i_T2_A field combination: Rdn=0, imm8=0
    // ISET: T32
    // Fields: Rdn=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x38000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `field i 26 +: 1`
/// Requirement: FieldBoundary { field: "i", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_sub_i_t3_a_field_i_0_min_0_f1a00000() {
    // Thumb encoding (32): 0xF1A00000
    // Test aarch32_SUB_i_T3_A field i = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, i=0, imm3=0, Rd=0, S=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `field i 26 +: 1`
/// Requirement: FieldBoundary { field: "i", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_sub_i_t3_a_field_i_1_max_0_f5a00000() {
    // Thumb encoding (32): 0xF5A00000
    // Test aarch32_SUB_i_T3_A field i = 1 (Max)
    // ISET: T32
    // Fields: imm8=0, i=1, Rd=0, Rn=0, S=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF5A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_sub_i_t3_a_field_s_0_min_0_f1a00000() {
    // Thumb encoding (32): 0xF1A00000
    // Test aarch32_SUB_i_T3_A field S = 0 (Min)
    // ISET: T32
    // Fields: S=0, Rn=0, imm3=0, i=0, Rd=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_sub_i_t3_a_field_s_1_max_0_f1b00000() {
    // Thumb encoding (32): 0xF1B00000
    // Test aarch32_SUB_i_T3_A field S = 1 (Max)
    // ISET: T32
    // Fields: Rd=0, S=1, Rn=0, i=0, imm3=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1B00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_sub_i_t3_a_field_rn_0_min_0_f1a00000() {
    // Thumb encoding (32): 0xF1A00000
    // Test aarch32_SUB_i_T3_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: i=0, S=0, Rn=0, imm8=0, imm3=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_sub_i_t3_a_field_rn_1_poweroftwo_0_f1a10000() {
    // Thumb encoding (32): 0xF1A10000
    // Test aarch32_SUB_i_T3_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm3=0, i=0, Rd=0, S=0, Rn=1, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1A10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_sub_i_t3_a_field_imm3_0_zero_0_f1a00000() {
    // Thumb encoding (32): 0xF1A00000
    // Test aarch32_SUB_i_T3_A field imm3 = 0 (Zero)
    // ISET: T32
    // Fields: S=0, imm3=0, imm8=0, Rd=0, i=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_sub_i_t3_a_field_imm3_1_poweroftwo_0_f1a01000() {
    // Thumb encoding (32): 0xF1A01000
    // Test aarch32_SUB_i_T3_A field imm3 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: i=0, S=0, imm3=1, imm8=0, Rd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1A01000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 3, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (3)
#[test]
fn test_aarch32_sub_i_t3_a_field_imm3_3_poweroftwominusone_0_f1a03000() {
    // Thumb encoding (32): 0xF1A03000
    // Test aarch32_SUB_i_T3_A field imm3 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: i=0, Rn=0, S=0, imm3=3, Rd=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1A03000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 7, boundary: Max }
/// maximum immediate (7)
#[test]
fn test_aarch32_sub_i_t3_a_field_imm3_7_max_0_f1a07000() {
    // Thumb encoding (32): 0xF1A07000
    // Test aarch32_SUB_i_T3_A field imm3 = 7 (Max)
    // ISET: T32
    // Fields: imm8=0, Rn=0, i=0, imm3=7, S=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1A07000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_sub_i_t3_a_field_rd_0_min_0_f1a00000() {
    // Thumb encoding (32): 0xF1A00000
    // Test aarch32_SUB_i_T3_A field Rd = 0 (Min)
    // ISET: T32
    // Fields: imm3=0, imm8=0, i=0, Rd=0, Rn=0, S=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_sub_i_t3_a_field_rd_1_poweroftwo_0_f1a00100() {
    // Thumb encoding (32): 0xF1A00100
    // Test aarch32_SUB_i_T3_A field Rd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rd=1, Rn=0, i=0, imm3=0, S=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1A00100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_sub_i_t3_a_field_imm8_0_zero_0_f1a00000() {
    // Thumb encoding (32): 0xF1A00000
    // Test aarch32_SUB_i_T3_A field imm8 = 0 (Zero)
    // ISET: T32
    // Fields: i=0, Rd=0, Rn=0, imm3=0, imm8=0, S=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_sub_i_t3_a_field_imm8_1_poweroftwo_0_f1a00001() {
    // Thumb encoding (32): 0xF1A00001
    // Test aarch32_SUB_i_T3_A field imm8 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: i=0, S=0, Rd=0, imm8=1, Rn=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1A00001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_sub_i_t3_a_field_imm8_3_poweroftwominusone_0_f1a00003() {
    // Thumb encoding (32): 0xF1A00003
    // Test aarch32_SUB_i_T3_A field imm8 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, imm8=3, Rd=0, S=0, i=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1A00003;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_sub_i_t3_a_field_imm8_4_poweroftwo_0_f1a00004() {
    // Thumb encoding (32): 0xF1A00004
    // Test aarch32_SUB_i_T3_A field imm8 = 4 (PowerOfTwo)
    // ISET: T32
    // Fields: i=0, S=0, Rd=0, Rn=0, imm8=4, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1A00004;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_sub_i_t3_a_field_imm8_7_poweroftwominusone_0_f1a00007() {
    // Thumb encoding (32): 0xF1A00007
    // Test aarch32_SUB_i_T3_A field imm8 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: i=0, S=0, Rn=0, imm3=0, imm8=7, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1A00007;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_sub_i_t3_a_field_imm8_8_poweroftwo_0_f1a00008() {
    // Thumb encoding (32): 0xF1A00008
    // Test aarch32_SUB_i_T3_A field imm8 = 8 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=8, i=0, imm3=0, S=0, Rd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1A00008;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_sub_i_t3_a_field_imm8_15_poweroftwominusone_0_f1a0000f() {
    // Thumb encoding (32): 0xF1A0000F
    // Test aarch32_SUB_i_T3_A field imm8 = 15 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: i=0, S=0, Rn=0, Rd=0, imm3=0, imm8=15
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1A0000F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_sub_i_t3_a_field_imm8_16_poweroftwo_0_f1a00010() {
    // Thumb encoding (32): 0xF1A00010
    // Test aarch32_SUB_i_T3_A field imm8 = 16 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, imm8=16, i=0, imm3=0, Rd=0, S=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1A00010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_sub_i_t3_a_field_imm8_31_poweroftwominusone_0_f1a0001f() {
    // Thumb encoding (32): 0xF1A0001F
    // Test aarch32_SUB_i_T3_A field imm8 = 31 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: i=0, S=0, Rn=0, imm3=0, Rd=0, imm8=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1A0001F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_sub_i_t3_a_field_imm8_32_poweroftwo_0_f1a00020() {
    // Thumb encoding (32): 0xF1A00020
    // Test aarch32_SUB_i_T3_A field imm8 = 32 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=32, Rn=0, S=0, imm3=0, Rd=0, i=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1A00020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_sub_i_t3_a_field_imm8_63_poweroftwominusone_0_f1a0003f() {
    // Thumb encoding (32): 0xF1A0003F
    // Test aarch32_SUB_i_T3_A field imm8 = 63 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rd=0, S=0, Rn=0, imm8=63, i=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1A0003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_sub_i_t3_a_field_imm8_64_poweroftwo_0_f1a00040() {
    // Thumb encoding (32): 0xF1A00040
    // Test aarch32_SUB_i_T3_A field imm8 = 64 (PowerOfTwo)
    // ISET: T32
    // Fields: Rd=0, S=0, Rn=0, imm3=0, imm8=64, i=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1A00040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 127, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (127)
#[test]
fn test_aarch32_sub_i_t3_a_field_imm8_127_poweroftwominusone_0_f1a0007f() {
    // Thumb encoding (32): 0xF1A0007F
    // Test aarch32_SUB_i_T3_A field imm8 = 127 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: i=0, imm3=0, imm8=127, Rd=0, Rn=0, S=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1A0007F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_sub_i_t3_a_field_imm8_128_poweroftwo_0_f1a00080() {
    // Thumb encoding (32): 0xF1A00080
    // Test aarch32_SUB_i_T3_A field imm8 = 128 (PowerOfTwo)
    // ISET: T32
    // Fields: i=0, imm3=0, S=0, Rd=0, imm8=128, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1A00080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 255, boundary: Max }
/// maximum immediate (255)
#[test]
fn test_aarch32_sub_i_t3_a_field_imm8_255_max_0_f1a000ff() {
    // Thumb encoding (32): 0xF1A000FF
    // Test aarch32_SUB_i_T3_A field imm8 = 255 (Max)
    // ISET: T32
    // Fields: S=0, imm3=0, imm8=255, i=0, Rd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1A000FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// i=0 (minimum value)
#[test]
fn test_aarch32_sub_i_t3_a_combo_0_0_f1a00000() {
    // Thumb encoding (32): 0xF1A00000
    // Test aarch32_SUB_i_T3_A field combination: i=0, S=0, Rn=0, imm3=0, Rd=0, imm8=0
    // ISET: T32
    // Fields: Rd=0, imm8=0, imm3=0, i=0, S=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `field S = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "S", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_sub_i_t3_a_special_s_0_size_variant_0_0_f1a00000() {
    // Thumb encoding (32): 0xF1A00000
    // Test aarch32_SUB_i_T3_A special value S = 0 (Size variant 0)
    // ISET: T32
    // Fields: S=0, imm8=0, i=0, Rn=0, imm3=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `field S = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "S", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_sub_i_t3_a_special_s_1_size_variant_1_0_f1b00000() {
    // Thumb encoding (32): 0xF1B00000
    // Test aarch32_SUB_i_T3_A special value S = 1 (Size variant 1)
    // ISET: T32
    // Fields: imm8=0, imm3=0, S=1, Rn=0, i=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1B00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Or, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: And, lhs: LitInt(15), rhs: Unary { op: Not, operand: Var(QualifiedIdentifier { qualifier: Any, name: "setflags" }) } } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Or, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: And, lhs: LitInt(15), rhs: Unary { op: Not, operand: Var(QualifiedIdentifier { qualifier: Any, name: \"setflags\" }) } } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_sub_i_t3_a_invalid_0_0_f1a00000() {
    // Thumb encoding (32): 0xF1A00000
    // Test aarch32_SUB_i_T3_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Or, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: And, lhs: LitInt(15), rhs: Unary { op: Not, operand: Var(QualifiedIdentifier { qualifier: Any, name: "setflags" }) } } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) }, rhs: LitInt(15) }
    // ISET: T32
    // Fields: i=0, imm8=0, S=0, Rn=0, imm3=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1A00000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_sub_i_t3_a_invalid_1_0_f1a00000() {
    // Thumb encoding (32): 0xF1A00000
    // Test aarch32_SUB_i_T3_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: i=0, Rd=0, Rn=0, imm8=0, imm3=0, S=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1A00000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_SUB_i_T4_A
/// ASL: `field i 26 +: 1`
/// Requirement: FieldBoundary { field: "i", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_sub_i_t4_a_field_i_0_min_0_f2a00000() {
    // Thumb encoding (32): 0xF2A00000
    // Test aarch32_SUB_i_T4_A field i = 0 (Min)
    // ISET: T32
    // Fields: imm3=0, Rn=0, i=0, Rd=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T4_A
/// ASL: `field i 26 +: 1`
/// Requirement: FieldBoundary { field: "i", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_sub_i_t4_a_field_i_1_max_0_f6a00000() {
    // Thumb encoding (32): 0xF6A00000
    // Test aarch32_SUB_i_T4_A field i = 1 (Max)
    // ISET: T32
    // Fields: i=1, Rd=0, Rn=0, imm8=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF6A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T4_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_sub_i_t4_a_field_rn_0_min_0_f2a00000() {
    // Thumb encoding (32): 0xF2A00000
    // Test aarch32_SUB_i_T4_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, i=0, Rd=0, imm3=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T4_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_sub_i_t4_a_field_rn_1_poweroftwo_0_f2a10000() {
    // Thumb encoding (32): 0xF2A10000
    // Test aarch32_SUB_i_T4_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm3=0, i=0, imm8=0, Rd=0, Rn=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2A10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T4_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_sub_i_t4_a_field_imm3_0_zero_0_f2a00000() {
    // Thumb encoding (32): 0xF2A00000
    // Test aarch32_SUB_i_T4_A field imm3 = 0 (Zero)
    // ISET: T32
    // Fields: i=0, Rn=0, Rd=0, imm8=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T4_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_sub_i_t4_a_field_imm3_1_poweroftwo_0_f2a01000() {
    // Thumb encoding (32): 0xF2A01000
    // Test aarch32_SUB_i_T4_A field imm3 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: i=0, Rn=0, imm8=0, Rd=0, imm3=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2A01000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T4_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 3, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (3)
#[test]
fn test_aarch32_sub_i_t4_a_field_imm3_3_poweroftwominusone_0_f2a03000() {
    // Thumb encoding (32): 0xF2A03000
    // Test aarch32_SUB_i_T4_A field imm3 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm8=0, i=0, Rn=0, imm3=3, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2A03000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T4_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 7, boundary: Max }
/// maximum immediate (7)
#[test]
fn test_aarch32_sub_i_t4_a_field_imm3_7_max_0_f2a07000() {
    // Thumb encoding (32): 0xF2A07000
    // Test aarch32_SUB_i_T4_A field imm3 = 7 (Max)
    // ISET: T32
    // Fields: i=0, imm3=7, Rd=0, imm8=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2A07000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T4_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_sub_i_t4_a_field_rd_0_min_0_f2a00000() {
    // Thumb encoding (32): 0xF2A00000
    // Test aarch32_SUB_i_T4_A field Rd = 0 (Min)
    // ISET: T32
    // Fields: Rd=0, Rn=0, imm3=0, i=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T4_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_sub_i_t4_a_field_rd_1_poweroftwo_0_f2a00100() {
    // Thumb encoding (32): 0xF2A00100
    // Test aarch32_SUB_i_T4_A field Rd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=0, Rd=1, imm3=0, Rn=0, i=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2A00100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T4_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_sub_i_t4_a_field_imm8_0_zero_0_f2a00000() {
    // Thumb encoding (32): 0xF2A00000
    // Test aarch32_SUB_i_T4_A field imm8 = 0 (Zero)
    // ISET: T32
    // Fields: imm3=0, Rd=0, i=0, imm8=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T4_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_sub_i_t4_a_field_imm8_1_poweroftwo_0_f2a00001() {
    // Thumb encoding (32): 0xF2A00001
    // Test aarch32_SUB_i_T4_A field imm8 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm3=0, Rn=0, imm8=1, Rd=0, i=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2A00001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T4_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_sub_i_t4_a_field_imm8_3_poweroftwominusone_0_f2a00003() {
    // Thumb encoding (32): 0xF2A00003
    // Test aarch32_SUB_i_T4_A field imm8 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, Rd=0, imm8=3, i=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2A00003;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T4_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_sub_i_t4_a_field_imm8_4_poweroftwo_0_f2a00004() {
    // Thumb encoding (32): 0xF2A00004
    // Test aarch32_SUB_i_T4_A field imm8 = 4 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=4, i=0, imm3=0, Rn=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2A00004;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T4_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_sub_i_t4_a_field_imm8_7_poweroftwominusone_0_f2a00007() {
    // Thumb encoding (32): 0xF2A00007
    // Test aarch32_SUB_i_T4_A field imm8 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm3=0, Rd=0, imm8=7, i=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2A00007;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T4_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_sub_i_t4_a_field_imm8_8_poweroftwo_0_f2a00008() {
    // Thumb encoding (32): 0xF2A00008
    // Test aarch32_SUB_i_T4_A field imm8 = 8 (PowerOfTwo)
    // ISET: T32
    // Fields: Rd=0, imm8=8, i=0, Rn=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2A00008;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T4_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_sub_i_t4_a_field_imm8_15_poweroftwominusone_0_f2a0000f() {
    // Thumb encoding (32): 0xF2A0000F
    // Test aarch32_SUB_i_T4_A field imm8 = 15 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, i=0, imm3=0, Rd=0, imm8=15
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2A0000F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T4_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_sub_i_t4_a_field_imm8_16_poweroftwo_0_f2a00010() {
    // Thumb encoding (32): 0xF2A00010
    // Test aarch32_SUB_i_T4_A field imm8 = 16 (PowerOfTwo)
    // ISET: T32
    // Fields: i=0, Rn=0, imm3=0, Rd=0, imm8=16
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2A00010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T4_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_sub_i_t4_a_field_imm8_31_poweroftwominusone_0_f2a0001f() {
    // Thumb encoding (32): 0xF2A0001F
    // Test aarch32_SUB_i_T4_A field imm8 = 31 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm3=0, Rd=0, Rn=0, imm8=31, i=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2A0001F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T4_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_sub_i_t4_a_field_imm8_32_poweroftwo_0_f2a00020() {
    // Thumb encoding (32): 0xF2A00020
    // Test aarch32_SUB_i_T4_A field imm8 = 32 (PowerOfTwo)
    // ISET: T32
    // Fields: i=0, Rd=0, imm8=32, Rn=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2A00020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T4_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_sub_i_t4_a_field_imm8_63_poweroftwominusone_0_f2a0003f() {
    // Thumb encoding (32): 0xF2A0003F
    // Test aarch32_SUB_i_T4_A field imm8 = 63 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: i=0, Rd=0, imm8=63, imm3=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2A0003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T4_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_sub_i_t4_a_field_imm8_64_poweroftwo_0_f2a00040() {
    // Thumb encoding (32): 0xF2A00040
    // Test aarch32_SUB_i_T4_A field imm8 = 64 (PowerOfTwo)
    // ISET: T32
    // Fields: i=0, imm8=64, imm3=0, Rn=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2A00040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T4_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 127, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (127)
#[test]
fn test_aarch32_sub_i_t4_a_field_imm8_127_poweroftwominusone_0_f2a0007f() {
    // Thumb encoding (32): 0xF2A0007F
    // Test aarch32_SUB_i_T4_A field imm8 = 127 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, imm3=0, i=0, Rd=0, imm8=127
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2A0007F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T4_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_sub_i_t4_a_field_imm8_128_poweroftwo_0_f2a00080() {
    // Thumb encoding (32): 0xF2A00080
    // Test aarch32_SUB_i_T4_A field imm8 = 128 (PowerOfTwo)
    // ISET: T32
    // Fields: imm3=0, imm8=128, Rn=0, Rd=0, i=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2A00080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T4_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 255, boundary: Max }
/// maximum immediate (255)
#[test]
fn test_aarch32_sub_i_t4_a_field_imm8_255_max_0_f2a000ff() {
    // Thumb encoding (32): 0xF2A000FF
    // Test aarch32_SUB_i_T4_A field imm8 = 255 (Max)
    // ISET: T32
    // Fields: Rn=0, imm3=0, Rd=0, imm8=255, i=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2A000FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T4_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// i=0 (minimum value)
#[test]
fn test_aarch32_sub_i_t4_a_combo_0_0_f2a00000() {
    // Thumb encoding (32): 0xF2A00000
    // Test aarch32_SUB_i_T4_A field combination: i=0, Rn=0, imm3=0, Rd=0, imm8=0
    // ISET: T32
    // Fields: imm8=0, Rn=0, i=0, imm3=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T4_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_sub_i_t4_a_invalid_0_0_f2a00000() {
    // Thumb encoding (32): 0xF2A00000
    // Test aarch32_SUB_i_T4_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: LitInt(15) }
    // ISET: T32
    // Fields: Rn=0, i=0, Rd=0, imm3=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2A00000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_SUB_i_T4_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_sub_i_t4_a_invalid_1_0_f2a00000() {
    // Thumb encoding (32): 0xF2A00000
    // Test aarch32_SUB_i_T4_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: imm3=0, i=0, Rn=0, Rd=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2A00000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_SUB_i_T5_AS
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_sub_i_t5_as_field_rn_0_min_8000_f3d08000() {
    // Thumb encoding (32): 0xF3D08000
    // Test aarch32_SUB_i_T5_AS field Rn = 0 (Min)
    // ISET: T32
    // Fields: imm8=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3D08000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T5_AS
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_sub_i_t5_as_field_rn_1_poweroftwo_8000_f3d18000() {
    // Thumb encoding (32): 0xF3D18000
    // Test aarch32_SUB_i_T5_AS field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=1, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3D18000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T5_AS
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_sub_i_t5_as_field_imm8_0_zero_8000_f3d08000() {
    // Thumb encoding (32): 0xF3D08000
    // Test aarch32_SUB_i_T5_AS field imm8 = 0 (Zero)
    // ISET: T32
    // Fields: Rn=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3D08000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T5_AS
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_sub_i_t5_as_field_imm8_1_poweroftwo_8000_f3d08001() {
    // Thumb encoding (32): 0xF3D08001
    // Test aarch32_SUB_i_T5_AS field imm8 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, imm8=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3D08001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T5_AS
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_sub_i_t5_as_field_imm8_3_poweroftwominusone_8000_f3d08003() {
    // Thumb encoding (32): 0xF3D08003
    // Test aarch32_SUB_i_T5_AS field imm8 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, imm8=3
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3D08003;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T5_AS
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_sub_i_t5_as_field_imm8_4_poweroftwo_8000_f3d08004() {
    // Thumb encoding (32): 0xF3D08004
    // Test aarch32_SUB_i_T5_AS field imm8 = 4 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, imm8=4
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3D08004;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T5_AS
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_sub_i_t5_as_field_imm8_7_poweroftwominusone_8000_f3d08007() {
    // Thumb encoding (32): 0xF3D08007
    // Test aarch32_SUB_i_T5_AS field imm8 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, imm8=7
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3D08007;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T5_AS
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_sub_i_t5_as_field_imm8_8_poweroftwo_8000_f3d08008() {
    // Thumb encoding (32): 0xF3D08008
    // Test aarch32_SUB_i_T5_AS field imm8 = 8 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=8, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3D08008;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T5_AS
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_sub_i_t5_as_field_imm8_15_poweroftwominusone_8000_f3d0800f() {
    // Thumb encoding (32): 0xF3D0800F
    // Test aarch32_SUB_i_T5_AS field imm8 = 15 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm8=15, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3D0800F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T5_AS
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_sub_i_t5_as_field_imm8_16_poweroftwo_8000_f3d08010() {
    // Thumb encoding (32): 0xF3D08010
    // Test aarch32_SUB_i_T5_AS field imm8 = 16 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, imm8=16
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3D08010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T5_AS
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_sub_i_t5_as_field_imm8_31_poweroftwominusone_8000_f3d0801f() {
    // Thumb encoding (32): 0xF3D0801F
    // Test aarch32_SUB_i_T5_AS field imm8 = 31 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, imm8=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3D0801F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T5_AS
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_sub_i_t5_as_field_imm8_32_poweroftwo_8000_f3d08020() {
    // Thumb encoding (32): 0xF3D08020
    // Test aarch32_SUB_i_T5_AS field imm8 = 32 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=32, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3D08020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T5_AS
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_sub_i_t5_as_field_imm8_63_poweroftwominusone_8000_f3d0803f() {
    // Thumb encoding (32): 0xF3D0803F
    // Test aarch32_SUB_i_T5_AS field imm8 = 63 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm8=63, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3D0803F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T5_AS
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_sub_i_t5_as_field_imm8_64_poweroftwo_8000_f3d08040() {
    // Thumb encoding (32): 0xF3D08040
    // Test aarch32_SUB_i_T5_AS field imm8 = 64 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, imm8=64
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3D08040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T5_AS
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 127, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (127)
#[test]
fn test_aarch32_sub_i_t5_as_field_imm8_127_poweroftwominusone_8000_f3d0807f() {
    // Thumb encoding (32): 0xF3D0807F
    // Test aarch32_SUB_i_T5_AS field imm8 = 127 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, imm8=127
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3D0807F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T5_AS
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_sub_i_t5_as_field_imm8_128_poweroftwo_8000_f3d08080() {
    // Thumb encoding (32): 0xF3D08080
    // Test aarch32_SUB_i_T5_AS field imm8 = 128 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=128, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3D08080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T5_AS
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 255, boundary: Max }
/// maximum immediate (255)
#[test]
fn test_aarch32_sub_i_t5_as_field_imm8_255_max_8000_f3d080ff() {
    // Thumb encoding (32): 0xF3D080FF
    // Test aarch32_SUB_i_T5_AS field imm8 = 255 (Max)
    // ISET: T32
    // Fields: Rn=0, imm8=255
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3D080FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T5_AS
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_sub_i_t5_as_combo_0_8000_f3d08000() {
    // Thumb encoding (32): 0xF3D08000
    // Test aarch32_SUB_i_T5_AS field combination: Rn=0, imm8=0
    // ISET: T32
    // Fields: imm8=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3D08000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_i_T5_AS
/// ASL: `Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: LitInt(14) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: LitInt(14) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_sub_i_t5_as_invalid_0_8000_f3d08000() {
    // Thumb encoding (32): 0xF3D08000
    // Test aarch32_SUB_i_T5_AS invalid encoding: Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: LitInt(14) }
    // ISET: T32
    // Fields: imm8=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3D08000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_SUB_i_T5_AS
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_sub_i_t5_as_invalid_1_8000_f3d08000() {
    // Thumb encoding (32): 0xF3D08000
    // Test aarch32_SUB_i_T5_AS invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rn=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3D08000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_SUB_i_T5_AS
/// ASL: `Binary { op: And, lhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] }, rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "LastInITBlock" }, args: [] } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: And, lhs: Call { name: QualifiedIdentifier { qualifier: Any, name: \"InITBlock\" }, args: [] }, rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"LastInITBlock\" }, args: [] } } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_sub_i_t5_as_invalid_2_8000_f3d08000() {
    // Thumb encoding (32): 0xF3D08000
    // Test aarch32_SUB_i_T5_AS invalid encoding: Binary { op: And, lhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] }, rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "LastInITBlock" }, args: [] } } }
    // ISET: T32
    // Fields: Rn=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3D08000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_SUB_i_T5_AS
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_sub_i_t5_as_invalid_3_8000_f3d08000() {
    // Thumb encoding (32): 0xF3D08000
    // Test aarch32_SUB_i_T5_AS invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rn=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3D08000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `ADD X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_sub_i_a1_a_add_oracle_32_0_02402820() {
    // Test ADD 32-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0x02402820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x02402820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA064, "W0 should be 0xA064");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `ADD X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_sub_i_a1_a_add_oracle_64_0_82402820() {
    // Test ADD 64-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0x82402820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x82402820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA064, "X0 should be 0x000000000000A064");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `ADD X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero operands (32)
#[test]
fn test_aarch32_sub_i_a1_a_add_oracle_32_1_02400020() {
    // Test ADD 32-bit: zero operands (with oracle verification)
    // Encoding: 0x02400020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x02400020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x0");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `ADD X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero operands (64)
#[test]
fn test_aarch32_sub_i_a1_a_add_oracle_64_1_82400020() {
    // Test ADD 64-bit: zero operands (with oracle verification)
    // Encoding: 0x82400020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x82400020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small values (32)
#[test]
fn test_aarch32_sub_i_a1_a_add_oracle_32_2_02400420() {
    // Test ADD 32-bit: small values (with oracle verification)
    // Encoding: 0x02400420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x02400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1001, "W0 should be 0x1001");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// small values (64)
#[test]
fn test_aarch32_sub_i_a1_a_add_oracle_64_2_82400420() {
    // Test ADD 64-bit: small values (with oracle verification)
    // Encoding: 0x82400420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x82400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1001, "X0 should be 0x0000000000001001");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `ADD X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_sub_i_a1_a_add_oracle_32_3_027ffc20() {
    // Test ADD 32-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0x027FFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x027FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF000, "W0 should be 0xFFF000");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `ADD X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_sub_i_a1_a_add_oracle_64_3_827ffc20() {
    // Test ADD 64-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0x827FFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x827FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF000, "X0 should be 0x0000000000FFF000");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `ADD X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_sub_i_a1_a_add_oracle_32_4_027ffc20() {
    // Test ADD 32-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0x027FFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x027FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF000, "W0 should be 0xFFF000");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `ADD X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_sub_i_a1_a_add_oracle_64_4_827ffc20() {
    // Test ADD 64-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0x827FFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x827FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF000, "X0 should be 0x0000000000FFF000");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max u64 operand (32)
#[test]
fn test_aarch32_sub_i_a1_a_add_oracle_32_5_02400420() {
    // Test ADD 32-bit: max u64 operand (with oracle verification)
    // Encoding: 0x02400420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x02400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF, "W0 should be 0xFFF");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max u64 operand (64)
#[test]
fn test_aarch32_sub_i_a1_a_add_oracle_64_5_82400420() {
    // Test ADD 64-bit: max u64 operand (with oracle verification)
    // Encoding: 0x82400420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x82400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF, "X0 should be 0x0000000000000FFF");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_sub_i_a1_a_add_oracle_32_6_02400420() {
    // Test ADD 32-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0x02400420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x02400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1000, "W0 should be 0x1000");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_sub_i_a1_a_add_oracle_64_6_82400420() {
    // Test ADD 64-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0x82400420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x82400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1000, "X0 should be 0x0000000000001000");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_sub_i_a1_a_add_oracle_32_7_02400420() {
    // Test ADD 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0x02400420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x02400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF, "W0 should be 0xFFF");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_sub_i_a1_a_add_oracle_64_7_82400420() {
    // Test ADD 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0x82400420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x82400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF, "X0 should be 0x8000000000000FFF");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_sub_i_a1_a_add_oracle_32_8_02400420() {
    // Test ADD 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0x02400420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x02400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000FFF, "W0 should be 0x80000FFF");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_sub_i_a1_a_add_oracle_64_8_82400420() {
    // Test ADD 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0x82400420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x82400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x80000FFF,
        "X0 should be 0x0000000080000FFF"
    );
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_sub_i_a1_a_add_oracle_32_9_02400420() {
    // Test ADD 32-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0x02400420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x02400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF, "W0 should be 0xFFF");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_sub_i_a1_a_add_oracle_64_9_82400420() {
    // Test ADD 64-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0x82400420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x82400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF, "X0 should be 0x0000000000000FFF");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_sub_i_a1_a_add_oracle_32_10_02400420() {
    // Test ADD 32-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0x02400420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x02400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF, "W0 should be 0xFFF");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_sub_i_a1_a_add_oracle_64_10_82400420() {
    // Test ADD 64-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0x82400420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x82400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF, "X0 should be 0x0000000100000FFF");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `ADD SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (32)
#[test]
fn test_aarch32_sub_i_a1_a_add_oracle_32_rd31_sp_0240283f() {
    // Test ADD 32-bit with Rd=31 (SP)
    // Encoding: 0x0240283F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x0240283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    // TODO: assertion - TestAssertion { check: Sp, expected: U64(41060), message: "SP should be 0xA064" }
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `ADD SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (64)
#[test]
fn test_aarch32_sub_i_a1_a_add_oracle_64_rd31_sp_8240283f() {
    // Test ADD 64-bit with Rd=31 (SP)
    // Encoding: 0x8240283F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x8240283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    // TODO: assertion - TestAssertion { check: Sp, expected: U64(41060), message: "SP should be 0xA064" }
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `ADDS X0, X1, #10`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_sub_i_a1_a_adds_oracle_32_0_22402820() {
    // Test ADDS 32-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0x22402820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x22402820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA064, "W0 should be 0xA064");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `ADDS X0, X1, #10`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_sub_i_a1_a_adds_oracle_64_0_a2402820() {
    // Test ADDS 64-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0xA2402820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xA2402820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA064, "X0 should be 0x000000000000A064");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `ADDS X0, X1, #0`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero operands (32)
#[test]
fn test_aarch32_sub_i_a1_a_adds_oracle_32_1_22400020() {
    // Test ADDS 32-bit: zero operands (with oracle verification)
    // Encoding: 0x22400020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x22400020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x0");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `ADDS X0, X1, #0`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero operands (64)
#[test]
fn test_aarch32_sub_i_a1_a_adds_oracle_64_1_a2400020() {
    // Test ADDS 64-bit: zero operands (with oracle verification)
    // Encoding: 0xA2400020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xA2400020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// small values (32)
#[test]
fn test_aarch32_sub_i_a1_a_adds_oracle_32_2_22400420() {
    // Test ADDS 32-bit: small values (with oracle verification)
    // Encoding: 0x22400420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x22400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1001, "W0 should be 0x1001");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// small values (64)
#[test]
fn test_aarch32_sub_i_a1_a_adds_oracle_64_2_a2400420() {
    // Test ADDS 64-bit: small values (with oracle verification)
    // Encoding: 0xA2400420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xA2400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1001, "X0 should be 0x0000000000001001");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `ADDS X0, X1, #4095`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_sub_i_a1_a_adds_oracle_32_3_227ffc20() {
    // Test ADDS 32-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0x227FFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x227FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF000, "W0 should be 0xFFF000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `ADDS X0, X1, #4095`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_sub_i_a1_a_adds_oracle_64_3_a27ffc20() {
    // Test ADDS 64-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0xA27FFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xA27FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF000, "X0 should be 0x0000000000FFF000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `ADDS X0, X1, #4095, LSL #12`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_sub_i_a1_a_adds_oracle_32_4_227ffc20() {
    // Test ADDS 32-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0x227FFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x227FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF000, "W0 should be 0xFFF000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `ADDS X0, X1, #4095, LSL #12`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_sub_i_a1_a_adds_oracle_64_4_a27ffc20() {
    // Test ADDS 64-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0xA27FFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xA27FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF000, "X0 should be 0x0000000000FFF000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max u64 operand (32)
#[test]
fn test_aarch32_sub_i_a1_a_adds_oracle_32_5_22400420() {
    // Test ADDS 32-bit: max u64 operand (with oracle verification)
    // Encoding: 0x22400420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x22400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF, "W0 should be 0xFFF");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max u64 operand (64)
#[test]
fn test_aarch32_sub_i_a1_a_adds_oracle_64_5_a2400420() {
    // Test ADDS 64-bit: max u64 operand (with oracle verification)
    // Encoding: 0xA2400420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xA2400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF, "X0 should be 0x0000000000000FFF");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_sub_i_a1_a_adds_oracle_32_6_22400420() {
    // Test ADDS 32-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0x22400420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x22400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1000, "W0 should be 0x1000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_sub_i_a1_a_adds_oracle_64_6_a2400420() {
    // Test ADDS 64-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0xA2400420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xA2400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1000, "X0 should be 0x0000000000001000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_sub_i_a1_a_adds_oracle_32_7_22400420() {
    // Test ADDS 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0x22400420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x22400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF, "W0 should be 0xFFF");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_sub_i_a1_a_adds_oracle_64_7_a2400420() {
    // Test ADDS 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0xA2400420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xA2400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF, "X0 should be 0x8000000000000FFF");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, true, "V flag should be true");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_sub_i_a1_a_adds_oracle_32_8_22400420() {
    // Test ADDS 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0x22400420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x22400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000FFF, "W0 should be 0x80000FFF");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, true, "V flag should be true");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_sub_i_a1_a_adds_oracle_64_8_a2400420() {
    // Test ADDS 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0xA2400420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xA2400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x80000FFF,
        "X0 should be 0x0000000080000FFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_sub_i_a1_a_adds_oracle_32_9_22400420() {
    // Test ADDS 32-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0x22400420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x22400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF, "W0 should be 0xFFF");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_sub_i_a1_a_adds_oracle_64_9_a2400420() {
    // Test ADDS 64-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0xA2400420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xA2400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF, "X0 should be 0x0000000000000FFF");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_sub_i_a1_a_adds_oracle_32_10_22400420() {
    // Test ADDS 32-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0x22400420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x22400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF, "W0 should be 0xFFF");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_sub_i_a1_a_adds_oracle_64_10_a2400420() {
    // Test ADDS 64-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0xA2400420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xA2400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF, "X0 should be 0x0000000100000FFF");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `ADDS ZR, X1, #10`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "result discarded, flags set" }
/// ZR destination (32)
#[test]
fn test_aarch32_sub_i_a1_a_adds_oracle_32_rd31_zr_2240283f() {
    // Test ADDS 32-bit with Rd=31 (ZR)
    // Encoding: 0x2240283F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x2240283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `ADDS ZR, X1, #10`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "result discarded, flags set" }
/// ZR destination (64)
#[test]
fn test_aarch32_sub_i_a1_a_adds_oracle_64_rd31_zr_a240283f() {
    // Test ADDS 64-bit with Rd=31 (ZR)
    // Encoding: 0xA240283F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xA240283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `SUB X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_sub_i_a1_a_sub_oracle_32_0_42402820() {
    // Test SUB 32-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0x42402820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x42402820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFF6064, "W0 should be 0xFFFF6064");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `SUB X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_sub_i_a1_a_sub_oracle_64_0_c2402820() {
    // Test SUB 64-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0xC2402820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xC2402820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFF6064,
        "X0 should be 0xFFFFFFFFFFFF6064"
    );
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `SUB X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero operands (32)
#[test]
fn test_aarch32_sub_i_a1_a_sub_oracle_32_1_42400020() {
    // Test SUB 32-bit: zero operands (with oracle verification)
    // Encoding: 0x42400020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x42400020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x0");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `SUB X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero operands (64)
#[test]
fn test_aarch32_sub_i_a1_a_sub_oracle_64_1_c2400020() {
    // Test SUB 64-bit: zero operands (with oracle verification)
    // Encoding: 0xC2400020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xC2400020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small values (32)
#[test]
fn test_aarch32_sub_i_a1_a_sub_oracle_32_2_42400420() {
    // Test SUB 32-bit: small values (with oracle verification)
    // Encoding: 0x42400420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x42400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFF001, "W0 should be 0xFFFFF001");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// small values (64)
#[test]
fn test_aarch32_sub_i_a1_a_sub_oracle_64_2_c2400420() {
    // Test SUB 64-bit: small values (with oracle verification)
    // Encoding: 0xC2400420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xC2400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `SUB X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_sub_i_a1_a_sub_oracle_32_3_427ffc20() {
    // Test SUB 32-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0x427FFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x427FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF001000, "W0 should be 0xFF001000");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `SUB X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_sub_i_a1_a_sub_oracle_64_3_c27ffc20() {
    // Test SUB 64-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0xC27FFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xC27FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `SUB X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_sub_i_a1_a_sub_oracle_32_4_427ffc20() {
    // Test SUB 32-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0x427FFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x427FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF001000, "W0 should be 0xFF001000");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `SUB X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_sub_i_a1_a_sub_oracle_64_4_c27ffc20() {
    // Test SUB 64-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0xC27FFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xC27FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max u64 operand (32)
#[test]
fn test_aarch32_sub_i_a1_a_sub_oracle_32_5_42400420() {
    // Test SUB 32-bit: max u64 operand (with oracle verification)
    // Encoding: 0x42400420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x42400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFEFFF, "W0 should be 0xFFFFEFFF");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max u64 operand (64)
#[test]
fn test_aarch32_sub_i_a1_a_sub_oracle_64_5_c2400420() {
    // Test SUB 64-bit: max u64 operand (with oracle verification)
    // Encoding: 0xC2400420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xC2400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFEFFF,
        "X0 should be 0xFFFFFFFFFFFFEFFF"
    );
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_sub_i_a1_a_sub_oracle_32_6_42400420() {
    // Test SUB 32-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0x42400420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x42400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFF000, "W0 should be 0xFFFFF000");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_sub_i_a1_a_sub_oracle_64_6_c2400420() {
    // Test SUB 64-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0xC2400420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xC2400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF000,
        "X0 should be 0xFFFFFFFFFFFFF000"
    );
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_sub_i_a1_a_sub_oracle_32_7_42400420() {
    // Test SUB 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0x42400420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x42400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFEFFF, "W0 should be 0xFFFFEFFF");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_sub_i_a1_a_sub_oracle_64_7_c2400420() {
    // Test SUB 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0xC2400420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xC2400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFEFFF,
        "X0 should be 0x7FFFFFFFFFFFEFFF"
    );
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_sub_i_a1_a_sub_oracle_32_8_42400420() {
    // Test SUB 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0x42400420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x42400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FFFEFFF, "W0 should be 0x7FFFEFFF");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_sub_i_a1_a_sub_oracle_64_8_c2400420() {
    // Test SUB 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0xC2400420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xC2400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x7FFFEFFF,
        "X0 should be 0x000000007FFFEFFF"
    );
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_sub_i_a1_a_sub_oracle_32_9_42400420() {
    // Test SUB 32-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0x42400420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x42400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFEFFF, "W0 should be 0xFFFFEFFF");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_sub_i_a1_a_sub_oracle_64_9_c2400420() {
    // Test SUB 64-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0xC2400420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xC2400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFEFFF,
        "X0 should be 0xFFFFFFFFFFFFEFFF"
    );
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_sub_i_a1_a_sub_oracle_32_10_42400420() {
    // Test SUB 32-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0x42400420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x42400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFEFFF, "W0 should be 0xFFFFEFFF");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_sub_i_a1_a_sub_oracle_64_10_c2400420() {
    // Test SUB 64-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0xC2400420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xC2400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFEFFF,
        "X0 should be 0x00000000FFFFEFFF"
    );
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `SUB SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (32)
#[test]
fn test_aarch32_sub_i_a1_a_sub_oracle_32_rd31_sp_4240283f() {
    // Test SUB 32-bit with Rd=31 (SP)
    // Encoding: 0x4240283F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x4240283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    // TODO: assertion - TestAssertion { check: Sp, expected: U64(4294926436), message: "SP should be 0xFFFF6064" }
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `SUB SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (64)
#[test]
fn test_aarch32_sub_i_a1_a_sub_oracle_64_rd31_sp_c240283f() {
    // Test SUB 64-bit with Rd=31 (SP)
    // Encoding: 0xC240283F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xC240283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    // TODO: assertion - TestAssertion { check: Sp, expected: U64(18446744073709510756), message: "SP should be 0xFFFFFFFFFFFF6064" }
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `SUBS X0, X1, #10`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_sub_i_a1_a_subs_oracle_32_0_62402820() {
    // Test SUBS 32-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0x62402820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x62402820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFF6064, "W0 should be 0xFFFF6064");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `SUBS X0, X1, #10`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_sub_i_a1_a_subs_oracle_64_0_e2402820() {
    // Test SUBS 64-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0xE2402820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xE2402820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFF6064,
        "X0 should be 0xFFFFFFFFFFFF6064"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `SUBS X0, X1, #0`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero operands (32)
#[test]
fn test_aarch32_sub_i_a1_a_subs_oracle_32_1_62400020() {
    // Test SUBS 32-bit: zero operands (with oracle verification)
    // Encoding: 0x62400020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x62400020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x0");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `SUBS X0, X1, #0`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero operands (64)
#[test]
fn test_aarch32_sub_i_a1_a_subs_oracle_64_1_e2400020() {
    // Test SUBS 64-bit: zero operands (with oracle verification)
    // Encoding: 0xE2400020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xE2400020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// small values (32)
#[test]
fn test_aarch32_sub_i_a1_a_subs_oracle_32_2_62400420() {
    // Test SUBS 32-bit: small values (with oracle verification)
    // Encoding: 0x62400420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x62400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFF001, "W0 should be 0xFFFFF001");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// small values (64)
#[test]
fn test_aarch32_sub_i_a1_a_subs_oracle_64_2_e2400420() {
    // Test SUBS 64-bit: small values (with oracle verification)
    // Encoding: 0xE2400420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xE2400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `SUBS X0, X1, #4095`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_sub_i_a1_a_subs_oracle_32_3_627ffc20() {
    // Test SUBS 32-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0x627FFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x627FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF001000, "W0 should be 0xFF001000");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `SUBS X0, X1, #4095`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_sub_i_a1_a_subs_oracle_64_3_e27ffc20() {
    // Test SUBS 64-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0xE27FFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xE27FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `SUBS X0, X1, #4095, LSL #12`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_sub_i_a1_a_subs_oracle_32_4_627ffc20() {
    // Test SUBS 32-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0x627FFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x627FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF001000, "W0 should be 0xFF001000");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `SUBS X0, X1, #4095, LSL #12`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_sub_i_a1_a_subs_oracle_64_4_e27ffc20() {
    // Test SUBS 64-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0xE27FFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xE27FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max u64 operand (32)
#[test]
fn test_aarch32_sub_i_a1_a_subs_oracle_32_5_62400420() {
    // Test SUBS 32-bit: max u64 operand (with oracle verification)
    // Encoding: 0x62400420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x62400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFEFFF, "W0 should be 0xFFFFEFFF");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max u64 operand (64)
#[test]
fn test_aarch32_sub_i_a1_a_subs_oracle_64_5_e2400420() {
    // Test SUBS 64-bit: max u64 operand (with oracle verification)
    // Encoding: 0xE2400420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xE2400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFEFFF,
        "X0 should be 0xFFFFFFFFFFFFEFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_sub_i_a1_a_subs_oracle_32_6_62400420() {
    // Test SUBS 32-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0x62400420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x62400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFF000, "W0 should be 0xFFFFF000");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_sub_i_a1_a_subs_oracle_64_6_e2400420() {
    // Test SUBS 64-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0xE2400420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xE2400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF000,
        "X0 should be 0xFFFFFFFFFFFFF000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_sub_i_a1_a_subs_oracle_32_7_62400420() {
    // Test SUBS 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0x62400420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x62400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFEFFF, "W0 should be 0xFFFFEFFF");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_sub_i_a1_a_subs_oracle_64_7_e2400420() {
    // Test SUBS 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0xE2400420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xE2400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFEFFF,
        "X0 should be 0x7FFFFFFFFFFFEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_sub_i_a1_a_subs_oracle_32_8_62400420() {
    // Test SUBS 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0x62400420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x62400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FFFEFFF, "W0 should be 0x7FFFEFFF");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_sub_i_a1_a_subs_oracle_64_8_e2400420() {
    // Test SUBS 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0xE2400420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xE2400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x7FFFEFFF,
        "X0 should be 0x000000007FFFEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_sub_i_a1_a_subs_oracle_32_9_62400420() {
    // Test SUBS 32-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0x62400420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x62400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFEFFF, "W0 should be 0xFFFFEFFF");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_sub_i_a1_a_subs_oracle_64_9_e2400420() {
    // Test SUBS 64-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0xE2400420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xE2400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFEFFF,
        "X0 should be 0xFFFFFFFFFFFFEFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_sub_i_a1_a_subs_oracle_32_10_62400420() {
    // Test SUBS 32-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0x62400420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x62400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFEFFF, "W0 should be 0xFFFFEFFF");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_sub_i_a1_a_subs_oracle_64_10_e2400420() {
    // Test SUBS 64-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0xE2400420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xE2400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFEFFF,
        "X0 should be 0x00000000FFFFEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `SUBS ZR, X1, #10`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "result discarded, flags set" }
/// ZR destination (32)
#[test]
fn test_aarch32_sub_i_a1_a_subs_oracle_32_rd31_zr_6240283f() {
    // Test SUBS 32-bit with Rd=31 (ZR)
    // Encoding: 0x6240283F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x6240283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `SUBS ZR, X1, #10`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "result discarded, flags set" }
/// ZR destination (64)
#[test]
fn test_aarch32_sub_i_a1_a_subs_oracle_64_rd31_zr_e240283f() {
    // Test SUBS 64-bit with Rd=31 (ZR)
    // Encoding: 0xE240283F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xE240283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `SUB R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x00000000)
#[test]
fn test_aarch32_sub_i_a1_a_a32_add_sub_imm_0_0_0241000a() {
    // Test A32 SUB: small immediate (oracle)
    // Encoding: 0x0241000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x0241000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFF6, "R0 should be 0xFFFFFFF6");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `SUB R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x00000064)
#[test]
fn test_aarch32_sub_i_a1_a_a32_add_sub_imm_0_64_0241000a() {
    // Test A32 SUB: small immediate (oracle)
    // Encoding: 0x0241000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x0241000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x5A, "R0 should be 0x0000005A");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `SUB R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_sub_i_a1_a_a32_add_sub_imm_0_7fffffff_0241000a() {
    // Test A32 SUB: small immediate (oracle)
    // Encoding: 0x0241000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x0241000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FFFFFF5, "R0 should be 0x7FFFFFF5");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `SUB R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x80000000)
#[test]
fn test_aarch32_sub_i_a1_a_a32_add_sub_imm_0_80000000_0241000a() {
    // Test A32 SUB: small immediate (oracle)
    // Encoding: 0x0241000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0x0241000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FFFFFF6, "R0 should be 0x7FFFFFF6");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `SUB R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_sub_i_a1_a_a32_add_sub_imm_0_ffffffff_0241000a() {
    // Test A32 SUB: small immediate (oracle)
    // Encoding: 0x0241000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x0241000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFF5, "R0 should be 0xFFFFFFF5");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `SUB R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x00000000)
#[test]
fn test_aarch32_sub_i_a1_a_a32_add_sub_imm_1_0_024100ff() {
    // Test A32 SUB: max imm8 (oracle)
    // Encoding: 0x024100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x024100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFF01, "R0 should be 0xFFFFFF01");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `SUB R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x00000064)
#[test]
fn test_aarch32_sub_i_a1_a_a32_add_sub_imm_1_64_024100ff() {
    // Test A32 SUB: max imm8 (oracle)
    // Encoding: 0x024100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x024100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFF65, "R0 should be 0xFFFFFF65");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `SUB R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_sub_i_a1_a_a32_add_sub_imm_1_7fffffff_024100ff() {
    // Test A32 SUB: max imm8 (oracle)
    // Encoding: 0x024100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x024100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FFFFF00, "R0 should be 0x7FFFFF00");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `SUB R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x80000000)
#[test]
fn test_aarch32_sub_i_a1_a_a32_add_sub_imm_1_80000000_024100ff() {
    // Test A32 SUB: max imm8 (oracle)
    // Encoding: 0x024100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0x024100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FFFFF01, "R0 should be 0x7FFFFF01");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `SUB R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_sub_i_a1_a_a32_add_sub_imm_1_ffffffff_024100ff() {
    // Test A32 SUB: max imm8 (oracle)
    // Encoding: 0x024100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x024100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFF00, "R0 should be 0xFFFFFF00");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `SUB R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x00000000)
#[test]
fn test_aarch32_sub_i_a1_a_a32_add_sub_imm_2_0_02410180() {
    // Test A32 SUB: rotated by 2 (oracle)
    // Encoding: 0x02410180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x02410180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFE0, "R0 should be 0xFFFFFFE0");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `SUB R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x00000064)
#[test]
fn test_aarch32_sub_i_a1_a_a32_add_sub_imm_2_64_02410180() {
    // Test A32 SUB: rotated by 2 (oracle)
    // Encoding: 0x02410180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x02410180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x44, "R0 should be 0x00000044");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `SUB R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_sub_i_a1_a_a32_add_sub_imm_2_7fffffff_02410180() {
    // Test A32 SUB: rotated by 2 (oracle)
    // Encoding: 0x02410180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x02410180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FFFFFDF, "R0 should be 0x7FFFFFDF");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `SUB R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x80000000)
#[test]
fn test_aarch32_sub_i_a1_a_a32_add_sub_imm_2_80000000_02410180() {
    // Test A32 SUB: rotated by 2 (oracle)
    // Encoding: 0x02410180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0x02410180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FFFFFE0, "R0 should be 0x7FFFFFE0");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `SUB R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_sub_i_a1_a_a32_add_sub_imm_2_ffffffff_02410180() {
    // Test A32 SUB: rotated by 2 (oracle)
    // Encoding: 0x02410180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x02410180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFDF, "R0 should be 0xFFFFFFDF");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `SUB R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x00000000)
#[test]
fn test_aarch32_sub_i_a1_a_a32_add_sub_imm_3_0_0241040f() {
    // Test A32 SUB: rotated by 8 (oracle)
    // Encoding: 0x0241040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x0241040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xF1000000, "R0 should be 0xF1000000");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `SUB R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x00000064)
#[test]
fn test_aarch32_sub_i_a1_a_a32_add_sub_imm_3_64_0241040f() {
    // Test A32 SUB: rotated by 8 (oracle)
    // Encoding: 0x0241040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x0241040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xF1000064, "R0 should be 0xF1000064");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `SUB R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_sub_i_a1_a_a32_add_sub_imm_3_7fffffff_0241040f() {
    // Test A32 SUB: rotated by 8 (oracle)
    // Encoding: 0x0241040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x0241040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x70FFFFFF, "R0 should be 0x70FFFFFF");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `SUB R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x80000000)
#[test]
fn test_aarch32_sub_i_a1_a_a32_add_sub_imm_3_80000000_0241040f() {
    // Test A32 SUB: rotated by 8 (oracle)
    // Encoding: 0x0241040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0x0241040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x71000000, "R0 should be 0x71000000");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `SUB R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_sub_i_a1_a_a32_add_sub_imm_3_ffffffff_0241040f() {
    // Test A32 SUB: rotated by 8 (oracle)
    // Encoding: 0x0241040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x0241040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xF0FFFFFF, "R0 should be 0xF0FFFFFF");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `SUB R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x00000000)
#[test]
fn test_aarch32_sub_i_a1_a_a32_add_sub_imm_4_0_02410000() {
    // Test A32 SUB: zero immediate (oracle)
    // Encoding: 0x02410000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x02410000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `SUB R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x00000064)
#[test]
fn test_aarch32_sub_i_a1_a_a32_add_sub_imm_4_64_02410000() {
    // Test A32 SUB: zero immediate (oracle)
    // Encoding: 0x02410000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x02410000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x64, "R0 should be 0x00000064");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `SUB R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_sub_i_a1_a_a32_add_sub_imm_4_7fffffff_02410000() {
    // Test A32 SUB: zero immediate (oracle)
    // Encoding: 0x02410000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x02410000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FFFFFFF, "R0 should be 0x7FFFFFFF");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `SUB R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x80000000)
#[test]
fn test_aarch32_sub_i_a1_a_a32_add_sub_imm_4_80000000_02410000() {
    // Test A32 SUB: zero immediate (oracle)
    // Encoding: 0x02410000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0x02410000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "R0 should be 0x80000000");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `SUB R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_sub_i_a1_a_a32_add_sub_imm_4_ffffffff_02410000() {
    // Test A32 SUB: zero immediate (oracle)
    // Encoding: 0x02410000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x02410000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "R0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_aarch32_sub_i_a1_a_flags_zeroresult_0_02510000() {
    // Test aarch32_SUB_i_A1_A flag computation: ZeroResult
    // Encoding: 0x02510000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x02510000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_aarch32_sub_i_a1_a_flags_zeroresult_1_02510000() {
    // Test aarch32_SUB_i_A1_A flag computation: ZeroResult
    // Encoding: 0x02510000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x02510000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_aarch32_sub_i_a1_a_flags_negativeresult_2_02510000() {
    // Test aarch32_SUB_i_A1_A flag computation: NegativeResult
    // Encoding: 0x02510000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x02510000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_aarch32_sub_i_a1_a_flags_unsignedoverflow_3_02510000() {
    // Test aarch32_SUB_i_A1_A flag computation: UnsignedOverflow
    // Encoding: 0x02510000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x02510000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_aarch32_sub_i_a1_a_flags_unsignedoverflow_4_02510000() {
    // Test aarch32_SUB_i_A1_A flag computation: UnsignedOverflow
    // Encoding: 0x02510000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x02510000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_aarch32_sub_i_a1_a_flags_signedoverflow_5_02510000() {
    // Test aarch32_SUB_i_A1_A flag computation: SignedOverflow
    // Encoding: 0x02510000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x02510000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_aarch32_sub_i_a1_a_flags_signedoverflow_6_02510000() {
    // Test aarch32_SUB_i_A1_A flag computation: SignedOverflow
    // Encoding: 0x02510000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x02510000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_SUB_i_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_aarch32_sub_i_a1_a_flags_positiveresult_7_02510000() {
    // Test aarch32_SUB_i_A1_A flag computation: PositiveResult
    // Encoding: 0x02510000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x32);
    let encoding: u32 = 0x02510000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SUB_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 0 (32)
#[test]
fn test_aarch32_sub_i_t1_a_lslv_oracle_32_0_1e020020() {
    // Test LSLV 32-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x12345678, "W0 should be 0x12345678");
}

/// Provenance: aarch32_SUB_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 0 (64)
#[test]
fn test_aarch32_sub_i_t1_a_lslv_oracle_64_0_9e020020() {
    // Test LSLV 64-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x12345678,
        "X0 should be 0x0000000012345678"
    );
}

/// Provenance: aarch32_SUB_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4 (32)
#[test]
fn test_aarch32_sub_i_t1_a_lslv_oracle_32_1_1e020020() {
    // Test LSLV 32-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x4);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x23456780, "W0 should be 0x23456780");
}

/// Provenance: aarch32_SUB_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 4 (64)
#[test]
fn test_aarch32_sub_i_t1_a_lslv_oracle_64_1_9e020020() {
    // Test LSLV 64-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x4);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x23456780,
        "X0 should be 0x0000000123456780"
    );
}

/// Provenance: aarch32_SUB_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 8 (32)
#[test]
fn test_aarch32_sub_i_t1_a_lslv_oracle_32_2_1e020020() {
    // Test LSLV 32-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x8);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x34567800, "W0 should be 0x34567800");
}

/// Provenance: aarch32_SUB_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 8 (64)
#[test]
fn test_aarch32_sub_i_t1_a_lslv_oracle_64_2_9e020020() {
    // Test LSLV 64-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x8);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x34567800,
        "X0 should be 0x0000001234567800"
    );
}

/// Provenance: aarch32_SUB_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1 (32)
#[test]
fn test_aarch32_sub_i_t1_a_lslv_oracle_32_3_1e020020() {
    // Test LSLV 32-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_SUB_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// MSB set, shift 1 (64)
#[test]
fn test_aarch32_sub_i_t1_a_lslv_oracle_64_3_9e020020() {
    // Test LSLV 64-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_SUB_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// LSB set, max shift (32)
#[test]
fn test_aarch32_sub_i_t1_a_lslv_oracle_32_4_1e020020() {
    // Test LSLV 32-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x3F);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "W0 should be 0x80000000");
}

/// Provenance: aarch32_SUB_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// LSB set, max shift (64)
#[test]
fn test_aarch32_sub_i_t1_a_lslv_oracle_64_4_9e020020() {
    // Test LSLV 64-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x3F);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x8000000000000000");
}

/// Provenance: aarch32_SUB_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// all ones, shift 32 (32)
#[test]
fn test_aarch32_sub_i_t1_a_lslv_oracle_32_5_1e020020() {
    // Test LSLV 32-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x20);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "W0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_SUB_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// all ones, shift 32 (64)
#[test]
fn test_aarch32_sub_i_t1_a_lslv_oracle_64_5_9e020020() {
    // Test LSLV 64-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x20);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0xFFFFFFFF00000000");
}

/// Provenance: aarch32_SUB_i_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// no shift
#[test]
fn test_aarch32_sub_i_t1_a_t16_oracle_0_1e080000() {
    // Test T16 LSLS: no shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_SUB_i_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4
#[test]
fn test_aarch32_sub_i_t1_a_t16_oracle_1_1e080000() {
    // Test T16 LSLS: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x4);
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF0, "R0 should be 0x00000FF0");
}

/// Provenance: aarch32_SUB_i_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1
#[test]
fn test_aarch32_sub_i_t1_a_t16_oracle_2_1e080000() {
    // Test T16 LSLS: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_SUB_i_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift to MSB
#[test]
fn test_aarch32_sub_i_t1_a_t16_oracle_3_1e080000() {
    // Test T16 LSLS: shift to MSB (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x1F);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "R0 should be 0x80000000");
}

/// Provenance: aarch32_SUB_i_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_aarch32_sub_i_t1_a_flags_zeroresult_0_1e080000() {
    // Test aarch32_SUB_i_T1_A flag computation: ZeroResult
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SUB_i_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_aarch32_sub_i_t1_a_flags_zeroresult_1_1e080000() {
    // Test aarch32_SUB_i_T1_A flag computation: ZeroResult
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SUB_i_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_aarch32_sub_i_t1_a_flags_negativeresult_2_1e080000() {
    // Test aarch32_SUB_i_T1_A flag computation: NegativeResult
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SUB_i_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_aarch32_sub_i_t1_a_flags_unsignedoverflow_3_1e080000() {
    // Test aarch32_SUB_i_T1_A flag computation: UnsignedOverflow
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SUB_i_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_aarch32_sub_i_t1_a_flags_unsignedoverflow_4_1e080000() {
    // Test aarch32_SUB_i_T1_A flag computation: UnsignedOverflow
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SUB_i_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_aarch32_sub_i_t1_a_flags_signedoverflow_5_1e080000() {
    // Test aarch32_SUB_i_T1_A flag computation: SignedOverflow
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_SUB_i_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_aarch32_sub_i_t1_a_flags_signedoverflow_6_1e080000() {
    // Test aarch32_SUB_i_T1_A flag computation: SignedOverflow
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_SUB_i_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_aarch32_sub_i_t1_a_flags_positiveresult_7_1e080000() {
    // Test aarch32_SUB_i_T1_A flag computation: PositiveResult
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x32);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SUB_i_T2_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 0 (32)
#[test]
fn test_aarch32_sub_i_t2_a_lslv_oracle_32_0_38020020() {
    // Test LSLV 32-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x12345678, "W0 should be 0x12345678");
}

/// Provenance: aarch32_SUB_i_T2_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 0 (64)
#[test]
fn test_aarch32_sub_i_t2_a_lslv_oracle_64_0_b8020020() {
    // Test LSLV 64-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x12345678,
        "X0 should be 0x0000000012345678"
    );
}

/// Provenance: aarch32_SUB_i_T2_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4 (32)
#[test]
fn test_aarch32_sub_i_t2_a_lslv_oracle_32_1_38020020() {
    // Test LSLV 32-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x4);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x23456780, "W0 should be 0x23456780");
}

/// Provenance: aarch32_SUB_i_T2_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 4 (64)
#[test]
fn test_aarch32_sub_i_t2_a_lslv_oracle_64_1_b8020020() {
    // Test LSLV 64-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x4);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x23456780,
        "X0 should be 0x0000000123456780"
    );
}

/// Provenance: aarch32_SUB_i_T2_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 8 (32)
#[test]
fn test_aarch32_sub_i_t2_a_lslv_oracle_32_2_38020020() {
    // Test LSLV 32-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x8);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x34567800, "W0 should be 0x34567800");
}

/// Provenance: aarch32_SUB_i_T2_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 8 (64)
#[test]
fn test_aarch32_sub_i_t2_a_lslv_oracle_64_2_b8020020() {
    // Test LSLV 64-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x8);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x34567800,
        "X0 should be 0x0000001234567800"
    );
}

/// Provenance: aarch32_SUB_i_T2_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1 (32)
#[test]
fn test_aarch32_sub_i_t2_a_lslv_oracle_32_3_38020020() {
    // Test LSLV 32-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_SUB_i_T2_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// MSB set, shift 1 (64)
#[test]
fn test_aarch32_sub_i_t2_a_lslv_oracle_64_3_b8020020() {
    // Test LSLV 64-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_SUB_i_T2_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// LSB set, max shift (32)
#[test]
fn test_aarch32_sub_i_t2_a_lslv_oracle_32_4_38020020() {
    // Test LSLV 32-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x3F);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "W0 should be 0x80000000");
}

/// Provenance: aarch32_SUB_i_T2_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// LSB set, max shift (64)
#[test]
fn test_aarch32_sub_i_t2_a_lslv_oracle_64_4_b8020020() {
    // Test LSLV 64-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3F);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x8000000000000000");
}

/// Provenance: aarch32_SUB_i_T2_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// all ones, shift 32 (32)
#[test]
fn test_aarch32_sub_i_t2_a_lslv_oracle_32_5_38020020() {
    // Test LSLV 32-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x20);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "W0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_SUB_i_T2_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// all ones, shift 32 (64)
#[test]
fn test_aarch32_sub_i_t2_a_lslv_oracle_64_5_b8020020() {
    // Test LSLV 64-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x20);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0xFFFFFFFF00000000");
}

/// Provenance: aarch32_SUB_i_T2_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// no shift
#[test]
fn test_aarch32_sub_i_t2_a_t16_oracle_0_38000000() {
    // Test T16 LSLS: no shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_SUB_i_T2_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4
#[test]
fn test_aarch32_sub_i_t2_a_t16_oracle_1_38000000() {
    // Test T16 LSLS: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x4);
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF0, "R0 should be 0x00000FF0");
}

/// Provenance: aarch32_SUB_i_T2_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1
#[test]
fn test_aarch32_sub_i_t2_a_t16_oracle_2_38000000() {
    // Test T16 LSLS: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_SUB_i_T2_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift to MSB
#[test]
fn test_aarch32_sub_i_t2_a_t16_oracle_3_38000000() {
    // Test T16 LSLS: shift to MSB (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x1F);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "R0 should be 0x80000000");
}

/// Provenance: aarch32_SUB_i_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_aarch32_sub_i_t2_a_flags_zeroresult_0_38000000() {
    // Test aarch32_SUB_i_T2_A flag computation: ZeroResult
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SUB_i_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_aarch32_sub_i_t2_a_flags_zeroresult_1_38000000() {
    // Test aarch32_SUB_i_T2_A flag computation: ZeroResult
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SUB_i_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_aarch32_sub_i_t2_a_flags_negativeresult_2_38000000() {
    // Test aarch32_SUB_i_T2_A flag computation: NegativeResult
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SUB_i_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_aarch32_sub_i_t2_a_flags_unsignedoverflow_3_38000000() {
    // Test aarch32_SUB_i_T2_A flag computation: UnsignedOverflow
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SUB_i_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_aarch32_sub_i_t2_a_flags_unsignedoverflow_4_38000000() {
    // Test aarch32_SUB_i_T2_A flag computation: UnsignedOverflow
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SUB_i_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_aarch32_sub_i_t2_a_flags_signedoverflow_5_38000000() {
    // Test aarch32_SUB_i_T2_A flag computation: SignedOverflow
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_SUB_i_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_aarch32_sub_i_t2_a_flags_signedoverflow_6_38000000() {
    // Test aarch32_SUB_i_T2_A flag computation: SignedOverflow
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_SUB_i_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_aarch32_sub_i_t2_a_flags_positiveresult_7_38000000() {
    // Test aarch32_SUB_i_T2_A flag computation: PositiveResult
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x32);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `ADD X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_sub_i_t3_a_add_oracle_32_0_f1a02820() {
    // Test ADD 32-bit: simple addition/subtraction (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF1A02820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF85A,
        "X0 should be 0xFFFFFFFFFFFFF85A"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `ADD X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_sub_i_t3_a_add_oracle_64_0_f1a02820() {
    // Test ADD 64-bit: simple addition/subtraction (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF1A02820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF85A,
        "X0 should be 0xFFFFFFFFFFFFF85A"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `ADD X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero operands (32)
#[test]
fn test_aarch32_sub_i_t3_a_add_oracle_32_1_f1a00020() {
    // Test ADD 32-bit: zero operands (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1A00020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF800,
        "X0 should be 0xFFFFFFFFFFFFF800"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `ADD X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero operands (64)
#[test]
fn test_aarch32_sub_i_t3_a_add_oracle_64_1_f1a00020() {
    // Test ADD 64-bit: zero operands (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1A00020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF800,
        "X0 should be 0xFFFFFFFFFFFFF800"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small values (32)
#[test]
fn test_aarch32_sub_i_t3_a_add_oracle_32_2_f1a00420() {
    // Test ADD 32-bit: small values (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF1A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF800,
        "X0 should be 0xFFFFFFFFFFFFF800"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// small values (64)
#[test]
fn test_aarch32_sub_i_t3_a_add_oracle_64_2_f1a00420() {
    // Test ADD 64-bit: small values (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF1A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF800,
        "X0 should be 0xFFFFFFFFFFFFF800"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `ADD X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_sub_i_t3_a_add_oracle_32_3_f1bffc20() {
    // Test ADD 32-bit: max imm12 unshifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1BFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `ADD X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_sub_i_t3_a_add_oracle_64_3_f1bffc20() {
    // Test ADD 64-bit: max imm12 unshifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1BFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `ADD X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_sub_i_t3_a_add_oracle_32_4_f1fffc20() {
    // Test ADD 32-bit: max imm12 shifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `ADD X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_sub_i_t3_a_add_oracle_64_4_f1fffc20() {
    // Test ADD 64-bit: max imm12 shifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max u64 operand (32)
#[test]
fn test_aarch32_sub_i_t3_a_add_oracle_32_5_f1a00420() {
    // Test ADD 32-bit: max u64 operand (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF7FE,
        "X0 should be 0x00000000FFFFF7FE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max u64 operand (64)
#[test]
fn test_aarch32_sub_i_t3_a_add_oracle_64_5_f1a00420() {
    // Test ADD 64-bit: max u64 operand (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF7FE,
        "X0 should be 0xFFFFFFFFFFFFF7FE"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_sub_i_t3_a_add_oracle_32_6_f1a00420() {
    // Test ADD 32-bit: zero result (for sub 1-1) (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF7FF,
        "X0 should be 0xFFFFFFFFFFFFF7FF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_sub_i_t3_a_add_oracle_64_6_f1a00420() {
    // Test ADD 64-bit: zero result (for sub 1-1) (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF7FF,
        "X0 should be 0xFFFFFFFFFFFFF7FF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_sub_i_t3_a_add_oracle_32_7_f1a00420() {
    // Test ADD 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF7FE,
        "X0 should be 0x00000000FFFFF7FE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_sub_i_t3_a_add_oracle_64_7_f1a00420() {
    // Test ADD 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF7FE,
        "X0 should be 0x7FFFFFFFFFFFF7FE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_sub_i_t3_a_add_oracle_32_8_f1a00420() {
    // Test ADD 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF1A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x7FFFF7FE,
        "X0 should be 0x000000007FFFF7FE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_sub_i_t3_a_add_oracle_64_8_f1a00420() {
    // Test ADD 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF1A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x7FFFF7FE,
        "X0 should be 0x000000007FFFF7FE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_sub_i_t3_a_add_oracle_32_9_f1a00420() {
    // Test ADD 32-bit: unsigned overflow 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF7FE,
        "X0 should be 0x00000000FFFFF7FE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_sub_i_t3_a_add_oracle_64_9_f1a00420() {
    // Test ADD 64-bit: unsigned overflow 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF7FE,
        "X0 should be 0xFFFFFFFFFFFFF7FE"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_sub_i_t3_a_add_oracle_32_10_f1a00420() {
    // Test ADD 32-bit: unsigned overflow 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF7FE,
        "X0 should be 0x00000000FFFFF7FE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_sub_i_t3_a_add_oracle_64_10_f1a00420() {
    // Test ADD 64-bit: unsigned overflow 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF7FE,
        "X0 should be 0x00000000FFFFF7FE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `ADD SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (32)
#[test]
fn test_aarch32_sub_i_t3_a_add_oracle_32_rd31_sp_f1a0283f() {
    // Test ADD 32-bit with Rd=31 (SP)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF1A0283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `ADD SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (64)
#[test]
fn test_aarch32_sub_i_t3_a_add_oracle_64_rd31_sp_f1a0283f() {
    // Test ADD 64-bit with Rd=31 (SP)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF1A0283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `ADDS X0, X1, #10`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_sub_i_t3_a_adds_oracle_32_0_f1a02820() {
    // Test ADDS 32-bit: simple addition/subtraction (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF1A02820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF85A,
        "X0 should be 0xFFFFFFFFFFFFF85A"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `ADDS X0, X1, #10`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_sub_i_t3_a_adds_oracle_64_0_f1a02820() {
    // Test ADDS 64-bit: simple addition/subtraction (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF1A02820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF85A,
        "X0 should be 0xFFFFFFFFFFFFF85A"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `ADDS X0, X1, #0`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero operands (32)
#[test]
fn test_aarch32_sub_i_t3_a_adds_oracle_32_1_f1a00020() {
    // Test ADDS 32-bit: zero operands (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1A00020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF800,
        "X0 should be 0xFFFFFFFFFFFFF800"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `ADDS X0, X1, #0`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero operands (64)
#[test]
fn test_aarch32_sub_i_t3_a_adds_oracle_64_1_f1a00020() {
    // Test ADDS 64-bit: zero operands (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1A00020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF800,
        "X0 should be 0xFFFFFFFFFFFFF800"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// small values (32)
#[test]
fn test_aarch32_sub_i_t3_a_adds_oracle_32_2_f1a00420() {
    // Test ADDS 32-bit: small values (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF1A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF800,
        "X0 should be 0xFFFFFFFFFFFFF800"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// small values (64)
#[test]
fn test_aarch32_sub_i_t3_a_adds_oracle_64_2_f1a00420() {
    // Test ADDS 64-bit: small values (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF1A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF800,
        "X0 should be 0xFFFFFFFFFFFFF800"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `ADDS X0, X1, #4095`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_sub_i_t3_a_adds_oracle_32_3_f1bffc20() {
    // Test ADDS 32-bit: max imm12 unshifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1BFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `ADDS X0, X1, #4095`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_sub_i_t3_a_adds_oracle_64_3_f1bffc20() {
    // Test ADDS 64-bit: max imm12 unshifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1BFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `ADDS X0, X1, #4095, LSL #12`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_sub_i_t3_a_adds_oracle_32_4_f1fffc20() {
    // Test ADDS 32-bit: max imm12 shifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `ADDS X0, X1, #4095, LSL #12`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_sub_i_t3_a_adds_oracle_64_4_f1fffc20() {
    // Test ADDS 64-bit: max imm12 shifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max u64 operand (32)
#[test]
fn test_aarch32_sub_i_t3_a_adds_oracle_32_5_f1a00420() {
    // Test ADDS 32-bit: max u64 operand (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF7FE,
        "X0 should be 0x00000000FFFFF7FE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max u64 operand (64)
#[test]
fn test_aarch32_sub_i_t3_a_adds_oracle_64_5_f1a00420() {
    // Test ADDS 64-bit: max u64 operand (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF7FE,
        "X0 should be 0xFFFFFFFFFFFFF7FE"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_sub_i_t3_a_adds_oracle_32_6_f1a00420() {
    // Test ADDS 32-bit: zero result (for sub 1-1) (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF7FF,
        "X0 should be 0xFFFFFFFFFFFFF7FF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_sub_i_t3_a_adds_oracle_64_6_f1a00420() {
    // Test ADDS 64-bit: zero result (for sub 1-1) (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF7FF,
        "X0 should be 0xFFFFFFFFFFFFF7FF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_sub_i_t3_a_adds_oracle_32_7_f1a00420() {
    // Test ADDS 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF7FE,
        "X0 should be 0x00000000FFFFF7FE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_sub_i_t3_a_adds_oracle_64_7_f1a00420() {
    // Test ADDS 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF7FE,
        "X0 should be 0x7FFFFFFFFFFFF7FE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_sub_i_t3_a_adds_oracle_32_8_f1a00420() {
    // Test ADDS 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF1A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x7FFFF7FE,
        "X0 should be 0x000000007FFFF7FE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_sub_i_t3_a_adds_oracle_64_8_f1a00420() {
    // Test ADDS 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF1A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x7FFFF7FE,
        "X0 should be 0x000000007FFFF7FE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_sub_i_t3_a_adds_oracle_32_9_f1a00420() {
    // Test ADDS 32-bit: unsigned overflow 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF7FE,
        "X0 should be 0x00000000FFFFF7FE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_sub_i_t3_a_adds_oracle_64_9_f1a00420() {
    // Test ADDS 64-bit: unsigned overflow 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF7FE,
        "X0 should be 0xFFFFFFFFFFFFF7FE"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_sub_i_t3_a_adds_oracle_32_10_f1a00420() {
    // Test ADDS 32-bit: unsigned overflow 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF7FE,
        "X0 should be 0x00000000FFFFF7FE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_sub_i_t3_a_adds_oracle_64_10_f1a00420() {
    // Test ADDS 64-bit: unsigned overflow 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF7FE,
        "X0 should be 0x00000000FFFFF7FE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `ADDS ZR, X1, #10`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "result discarded, flags set" }
/// ZR destination (32)
#[test]
fn test_aarch32_sub_i_t3_a_adds_oracle_32_rd31_zr_f1a0283f() {
    // Test ADDS 32-bit with Rd=31 (ZR)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF1A0283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `ADDS ZR, X1, #10`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "result discarded, flags set" }
/// ZR destination (64)
#[test]
fn test_aarch32_sub_i_t3_a_adds_oracle_64_rd31_zr_f1a0283f() {
    // Test ADDS 64-bit with Rd=31 (ZR)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF1A0283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `SUB X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_sub_i_t3_a_sub_oracle_32_0_f1a02820() {
    // Test SUB 32-bit: simple addition/subtraction (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF1A02820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF85A,
        "X0 should be 0xFFFFFFFFFFFFF85A"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `SUB X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_sub_i_t3_a_sub_oracle_64_0_f1a02820() {
    // Test SUB 64-bit: simple addition/subtraction (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF1A02820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF85A,
        "X0 should be 0xFFFFFFFFFFFFF85A"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `SUB X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero operands (32)
#[test]
fn test_aarch32_sub_i_t3_a_sub_oracle_32_1_f1a00020() {
    // Test SUB 32-bit: zero operands (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1A00020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF800,
        "X0 should be 0xFFFFFFFFFFFFF800"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `SUB X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero operands (64)
#[test]
fn test_aarch32_sub_i_t3_a_sub_oracle_64_1_f1a00020() {
    // Test SUB 64-bit: zero operands (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1A00020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF800,
        "X0 should be 0xFFFFFFFFFFFFF800"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small values (32)
#[test]
fn test_aarch32_sub_i_t3_a_sub_oracle_32_2_f1a00420() {
    // Test SUB 32-bit: small values (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF1A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF800,
        "X0 should be 0xFFFFFFFFFFFFF800"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// small values (64)
#[test]
fn test_aarch32_sub_i_t3_a_sub_oracle_64_2_f1a00420() {
    // Test SUB 64-bit: small values (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF1A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF800,
        "X0 should be 0xFFFFFFFFFFFFF800"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `SUB X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_sub_i_t3_a_sub_oracle_32_3_f1bffc20() {
    // Test SUB 32-bit: max imm12 unshifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1BFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `SUB X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_sub_i_t3_a_sub_oracle_64_3_f1bffc20() {
    // Test SUB 64-bit: max imm12 unshifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1BFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `SUB X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_sub_i_t3_a_sub_oracle_32_4_f1fffc20() {
    // Test SUB 32-bit: max imm12 shifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `SUB X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_sub_i_t3_a_sub_oracle_64_4_f1fffc20() {
    // Test SUB 64-bit: max imm12 shifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max u64 operand (32)
#[test]
fn test_aarch32_sub_i_t3_a_sub_oracle_32_5_f1a00420() {
    // Test SUB 32-bit: max u64 operand (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF7FE,
        "X0 should be 0x00000000FFFFF7FE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max u64 operand (64)
#[test]
fn test_aarch32_sub_i_t3_a_sub_oracle_64_5_f1a00420() {
    // Test SUB 64-bit: max u64 operand (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF7FE,
        "X0 should be 0xFFFFFFFFFFFFF7FE"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_sub_i_t3_a_sub_oracle_32_6_f1a00420() {
    // Test SUB 32-bit: zero result (for sub 1-1) (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF7FF,
        "X0 should be 0xFFFFFFFFFFFFF7FF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_sub_i_t3_a_sub_oracle_64_6_f1a00420() {
    // Test SUB 64-bit: zero result (for sub 1-1) (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF7FF,
        "X0 should be 0xFFFFFFFFFFFFF7FF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_sub_i_t3_a_sub_oracle_32_7_f1a00420() {
    // Test SUB 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF7FE,
        "X0 should be 0x00000000FFFFF7FE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_sub_i_t3_a_sub_oracle_64_7_f1a00420() {
    // Test SUB 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF7FE,
        "X0 should be 0x7FFFFFFFFFFFF7FE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_sub_i_t3_a_sub_oracle_32_8_f1a00420() {
    // Test SUB 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF1A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x7FFFF7FE,
        "X0 should be 0x000000007FFFF7FE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_sub_i_t3_a_sub_oracle_64_8_f1a00420() {
    // Test SUB 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF1A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x7FFFF7FE,
        "X0 should be 0x000000007FFFF7FE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_sub_i_t3_a_sub_oracle_32_9_f1a00420() {
    // Test SUB 32-bit: unsigned overflow 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF7FE,
        "X0 should be 0x00000000FFFFF7FE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_sub_i_t3_a_sub_oracle_64_9_f1a00420() {
    // Test SUB 64-bit: unsigned overflow 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF7FE,
        "X0 should be 0xFFFFFFFFFFFFF7FE"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_sub_i_t3_a_sub_oracle_32_10_f1a00420() {
    // Test SUB 32-bit: unsigned overflow 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF7FE,
        "X0 should be 0x00000000FFFFF7FE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_sub_i_t3_a_sub_oracle_64_10_f1a00420() {
    // Test SUB 64-bit: unsigned overflow 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF7FE,
        "X0 should be 0x00000000FFFFF7FE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `SUB SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (32)
#[test]
fn test_aarch32_sub_i_t3_a_sub_oracle_32_rd31_sp_f1a0283f() {
    // Test SUB 32-bit with Rd=31 (SP)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF1A0283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `SUB SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (64)
#[test]
fn test_aarch32_sub_i_t3_a_sub_oracle_64_rd31_sp_f1a0283f() {
    // Test SUB 64-bit with Rd=31 (SP)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF1A0283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `SUBS X0, X1, #10`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_sub_i_t3_a_subs_oracle_32_0_f1a02820() {
    // Test SUBS 32-bit: simple addition/subtraction (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF1A02820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF85A,
        "X0 should be 0xFFFFFFFFFFFFF85A"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `SUBS X0, X1, #10`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_sub_i_t3_a_subs_oracle_64_0_f1a02820() {
    // Test SUBS 64-bit: simple addition/subtraction (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF1A02820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF85A,
        "X0 should be 0xFFFFFFFFFFFFF85A"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `SUBS X0, X1, #0`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero operands (32)
#[test]
fn test_aarch32_sub_i_t3_a_subs_oracle_32_1_f1a00020() {
    // Test SUBS 32-bit: zero operands (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1A00020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF800,
        "X0 should be 0xFFFFFFFFFFFFF800"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `SUBS X0, X1, #0`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero operands (64)
#[test]
fn test_aarch32_sub_i_t3_a_subs_oracle_64_1_f1a00020() {
    // Test SUBS 64-bit: zero operands (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1A00020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF800,
        "X0 should be 0xFFFFFFFFFFFFF800"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// small values (32)
#[test]
fn test_aarch32_sub_i_t3_a_subs_oracle_32_2_f1a00420() {
    // Test SUBS 32-bit: small values (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF1A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF800,
        "X0 should be 0xFFFFFFFFFFFFF800"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// small values (64)
#[test]
fn test_aarch32_sub_i_t3_a_subs_oracle_64_2_f1a00420() {
    // Test SUBS 64-bit: small values (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF1A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF800,
        "X0 should be 0xFFFFFFFFFFFFF800"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `SUBS X0, X1, #4095`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_sub_i_t3_a_subs_oracle_32_3_f1bffc20() {
    // Test SUBS 32-bit: max imm12 unshifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1BFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `SUBS X0, X1, #4095`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_sub_i_t3_a_subs_oracle_64_3_f1bffc20() {
    // Test SUBS 64-bit: max imm12 unshifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1BFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `SUBS X0, X1, #4095, LSL #12`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_sub_i_t3_a_subs_oracle_32_4_f1fffc20() {
    // Test SUBS 32-bit: max imm12 shifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `SUBS X0, X1, #4095, LSL #12`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_sub_i_t3_a_subs_oracle_64_4_f1fffc20() {
    // Test SUBS 64-bit: max imm12 shifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max u64 operand (32)
#[test]
fn test_aarch32_sub_i_t3_a_subs_oracle_32_5_f1a00420() {
    // Test SUBS 32-bit: max u64 operand (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF7FE,
        "X0 should be 0x00000000FFFFF7FE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max u64 operand (64)
#[test]
fn test_aarch32_sub_i_t3_a_subs_oracle_64_5_f1a00420() {
    // Test SUBS 64-bit: max u64 operand (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF7FE,
        "X0 should be 0xFFFFFFFFFFFFF7FE"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_sub_i_t3_a_subs_oracle_32_6_f1a00420() {
    // Test SUBS 32-bit: zero result (for sub 1-1) (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF7FF,
        "X0 should be 0xFFFFFFFFFFFFF7FF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_sub_i_t3_a_subs_oracle_64_6_f1a00420() {
    // Test SUBS 64-bit: zero result (for sub 1-1) (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF7FF,
        "X0 should be 0xFFFFFFFFFFFFF7FF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_sub_i_t3_a_subs_oracle_32_7_f1a00420() {
    // Test SUBS 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF7FE,
        "X0 should be 0x00000000FFFFF7FE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_sub_i_t3_a_subs_oracle_64_7_f1a00420() {
    // Test SUBS 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF7FE,
        "X0 should be 0x7FFFFFFFFFFFF7FE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_sub_i_t3_a_subs_oracle_32_8_f1a00420() {
    // Test SUBS 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF1A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x7FFFF7FE,
        "X0 should be 0x000000007FFFF7FE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_sub_i_t3_a_subs_oracle_64_8_f1a00420() {
    // Test SUBS 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF1A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x7FFFF7FE,
        "X0 should be 0x000000007FFFF7FE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_sub_i_t3_a_subs_oracle_32_9_f1a00420() {
    // Test SUBS 32-bit: unsigned overflow 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF7FE,
        "X0 should be 0x00000000FFFFF7FE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_sub_i_t3_a_subs_oracle_64_9_f1a00420() {
    // Test SUBS 64-bit: unsigned overflow 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF7FE,
        "X0 should be 0xFFFFFFFFFFFFF7FE"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_sub_i_t3_a_subs_oracle_32_10_f1a00420() {
    // Test SUBS 32-bit: unsigned overflow 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF7FE,
        "X0 should be 0x00000000FFFFF7FE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_sub_i_t3_a_subs_oracle_64_10_f1a00420() {
    // Test SUBS 64-bit: unsigned overflow 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF7FE,
        "X0 should be 0x00000000FFFFF7FE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `SUBS ZR, X1, #10`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "result discarded, flags set" }
/// ZR destination (32)
#[test]
fn test_aarch32_sub_i_t3_a_subs_oracle_32_rd31_zr_f1a0283f() {
    // Test SUBS 32-bit with Rd=31 (ZR)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF1A0283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `SUBS ZR, X1, #10`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "result discarded, flags set" }
/// ZR destination (64)
#[test]
fn test_aarch32_sub_i_t3_a_subs_oracle_64_rd31_zr_f1a0283f() {
    // Test SUBS 64-bit with Rd=31 (ZR)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF1A0283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `SUB.W R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple values
#[test]
fn test_aarch32_sub_i_t3_a_t32_oracle_0_f1a10000() {
    // Test T32 SUB: simple values (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x32);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF1A10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x32, "R0 should be 0x00000032");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `SUB.W R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero values
#[test]
fn test_aarch32_sub_i_t3_a_t32_oracle_1_f1a10000() {
    // Test T32 SUB: zero values (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xF1A10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `SUB.W R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max value
#[test]
fn test_aarch32_sub_i_t3_a_t32_oracle_2_f1a10000() {
    // Test T32 SUB: max value (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0xF1A10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFE, "R0 should be 0xFFFFFFFE");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `SUB.W R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// mixed pattern
#[test]
fn test_aarch32_sub_i_t3_a_t32_oracle_3_f1a10000() {
    // Test T32 SUB: mixed pattern (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0xABCDEF01);
    let encoding: u32 = 0xF1A10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x66666777, "R0 should be 0x66666777");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_aarch32_sub_i_t3_a_flags_zeroresult_0_f1b10000() {
    // Test aarch32_SUB_i_T3_A flag computation: ZeroResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xF1B10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_aarch32_sub_i_t3_a_flags_zeroresult_1_f1b10000() {
    // Test aarch32_SUB_i_T3_A flag computation: ZeroResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0xF1B10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_aarch32_sub_i_t3_a_flags_negativeresult_2_f1b10000() {
    // Test aarch32_SUB_i_T3_A flag computation: NegativeResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xF1B10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_aarch32_sub_i_t3_a_flags_unsignedoverflow_3_f1b10000() {
    // Test aarch32_SUB_i_T3_A flag computation: UnsignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1B10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_aarch32_sub_i_t3_a_flags_unsignedoverflow_4_f1b10000() {
    // Test aarch32_SUB_i_T3_A flag computation: UnsignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0xF1B10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_aarch32_sub_i_t3_a_flags_signedoverflow_5_f1b10000() {
    // Test aarch32_SUB_i_T3_A flag computation: SignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1B10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_aarch32_sub_i_t3_a_flags_signedoverflow_6_f1b10000() {
    // Test aarch32_SUB_i_T3_A flag computation: SignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0xF1B10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_SUB_i_T3_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_aarch32_sub_i_t3_a_flags_positiveresult_7_f1b10000() {
    // Test aarch32_SUB_i_T3_A flag computation: PositiveResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x32);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF1B10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SUB_i_T4_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_aarch32_sub_i_t4_a_flags_zeroresult_0_f2a10000() {
    // Test aarch32_SUB_i_T4_A flag computation: ZeroResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xF2A10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SUB_i_T4_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_aarch32_sub_i_t4_a_flags_zeroresult_1_f2a10000() {
    // Test aarch32_SUB_i_T4_A flag computation: ZeroResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF2A10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SUB_i_T4_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_aarch32_sub_i_t4_a_flags_negativeresult_2_f2a10000() {
    // Test aarch32_SUB_i_T4_A flag computation: NegativeResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xF2A10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SUB_i_T4_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_aarch32_sub_i_t4_a_flags_unsignedoverflow_3_f2a10000() {
    // Test aarch32_SUB_i_T4_A flag computation: UnsignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2A10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SUB_i_T4_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_aarch32_sub_i_t4_a_flags_unsignedoverflow_4_f2a10000() {
    // Test aarch32_SUB_i_T4_A flag computation: UnsignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0xF2A10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SUB_i_T4_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_aarch32_sub_i_t4_a_flags_signedoverflow_5_f2a10000() {
    // Test aarch32_SUB_i_T4_A flag computation: SignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0xF2A10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_SUB_i_T4_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_aarch32_sub_i_t4_a_flags_signedoverflow_6_f2a10000() {
    // Test aarch32_SUB_i_T4_A flag computation: SignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0xF2A10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_SUB_i_T4_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_aarch32_sub_i_t4_a_flags_positiveresult_7_f2a10000() {
    // Test aarch32_SUB_i_T4_A flag computation: PositiveResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x32);
    let encoding: u32 = 0xF2A10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SUB_i_T5_AS
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_aarch32_sub_i_t5_as_flags_zeroresult_0_f3d18000() {
    // Test aarch32_SUB_i_T5_AS flag computation: ZeroResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xF3D18000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SUB_i_T5_AS
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_aarch32_sub_i_t5_as_flags_zeroresult_1_f3d18000() {
    // Test aarch32_SUB_i_T5_AS flag computation: ZeroResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0xF3D18000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SUB_i_T5_AS
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_aarch32_sub_i_t5_as_flags_negativeresult_2_f3d18000() {
    // Test aarch32_SUB_i_T5_AS flag computation: NegativeResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xF3D18000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SUB_i_T5_AS
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_aarch32_sub_i_t5_as_flags_unsignedoverflow_3_f3d18000() {
    // Test aarch32_SUB_i_T5_AS flag computation: UnsignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0xF3D18000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SUB_i_T5_AS
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_aarch32_sub_i_t5_as_flags_unsignedoverflow_4_f3d18000() {
    // Test aarch32_SUB_i_T5_AS flag computation: UnsignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0xF3D18000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SUB_i_T5_AS
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_aarch32_sub_i_t5_as_flags_signedoverflow_5_f3d18000() {
    // Test aarch32_SUB_i_T5_AS flag computation: SignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0xF3D18000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_SUB_i_T5_AS
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_aarch32_sub_i_t5_as_flags_signedoverflow_6_f3d18000() {
    // Test aarch32_SUB_i_T5_AS flag computation: SignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0xF3D18000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_SUB_i_T5_AS
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_aarch32_sub_i_t5_as_flags_positiveresult_7_f3d18000() {
    // Test aarch32_SUB_i_T5_AS flag computation: PositiveResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x32);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF3D18000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

// ============================================================================
// aarch32_SBC_r_A Tests
// ============================================================================

/// Provenance: aarch32_SBC_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_sbc_r_a1_a_field_cond_0_min_0_00c00000() {
    // Encoding: 0x00C00000
    // Test aarch32_SBC_r_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: imm5=0, type1=0, Rm=0, cond=0, S=0, Rn=0, Rd=0
    let encoding: u32 = 0x00C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_sbc_r_a1_a_field_cond_1_poweroftwo_0_10c00000() {
    // Encoding: 0x10C00000
    // Test aarch32_SBC_r_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, imm5=0, S=0, Rn=0, cond=1, type1=0, Rm=0
    let encoding: u32 = 0x10C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_sbc_r_a1_a_field_cond_2_poweroftwo_0_20c00000() {
    // Encoding: 0x20C00000
    // Test aarch32_SBC_r_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=2, S=0, imm5=0, Rd=0, type1=0, Rm=0
    let encoding: u32 = 0x20C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_sbc_r_a1_a_field_cond_3_poweroftwo_0_30c00000() {
    // Encoding: 0x30C00000
    // Test aarch32_SBC_r_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, cond=3, Rn=0, imm5=0, type1=0, Rm=0, S=0
    let encoding: u32 = 0x30C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_sbc_r_a1_a_field_cond_4_poweroftwo_0_40c00000() {
    // Encoding: 0x40C00000
    // Test aarch32_SBC_r_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rd=0, imm5=0, type1=0, Rm=0, cond=4, S=0
    let encoding: u32 = 0x40C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_sbc_r_a1_a_field_cond_5_poweroftwo_0_50c00000() {
    // Encoding: 0x50C00000
    // Test aarch32_SBC_r_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, cond=5, Rn=0, S=0, type1=0, Rd=0, imm5=0
    let encoding: u32 = 0x50C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_sbc_r_a1_a_field_cond_6_poweroftwo_0_60c00000() {
    // Encoding: 0x60C00000
    // Test aarch32_SBC_r_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=6, Rd=0, type1=0, imm5=0, Rm=0, S=0, Rn=0
    let encoding: u32 = 0x60C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_sbc_r_a1_a_field_cond_7_poweroftwo_0_70c00000() {
    // Encoding: 0x70C00000
    // Test aarch32_SBC_r_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, type1=0, Rn=0, cond=7, imm5=0, S=0, Rd=0
    let encoding: u32 = 0x70C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_sbc_r_a1_a_field_cond_8_poweroftwo_0_80c00000() {
    // Encoding: 0x80C00000
    // Test aarch32_SBC_r_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, Rn=0, cond=8, Rd=0, type1=0, imm5=0, Rm=0
    let encoding: u32 = 0x80C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_sbc_r_a1_a_field_cond_9_poweroftwo_0_90c00000() {
    // Encoding: 0x90C00000
    // Test aarch32_SBC_r_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rm=0, S=0, imm5=0, type1=0, cond=9, Rd=0
    let encoding: u32 = 0x90C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_sbc_r_a1_a_field_cond_10_poweroftwo_0_a0c00000() {
    // Encoding: 0xA0C00000
    // Test aarch32_SBC_r_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, Rm=0, Rn=0, type1=0, cond=10, imm5=0, Rd=0
    let encoding: u32 = 0xA0C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_sbc_r_a1_a_field_cond_11_poweroftwo_0_b0c00000() {
    // Encoding: 0xB0C00000
    // Test aarch32_SBC_r_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=11, S=0, Rd=0, type1=0, Rn=0, imm5=0, Rm=0
    let encoding: u32 = 0xB0C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_sbc_r_a1_a_field_cond_12_poweroftwo_0_c0c00000() {
    // Encoding: 0xC0C00000
    // Test aarch32_SBC_r_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, cond=12, S=0, imm5=0, Rn=0, Rd=0, type1=0
    let encoding: u32 = 0xC0C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_sbc_r_a1_a_field_cond_13_poweroftwo_0_d0c00000() {
    // Encoding: 0xD0C00000
    // Test aarch32_SBC_r_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: type1=0, cond=13, Rn=0, Rd=0, imm5=0, Rm=0, S=0
    let encoding: u32 = 0xD0C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_sbc_r_a1_a_field_cond_14_poweroftwo_0_e0c00000() {
    // Encoding: 0xE0C00000
    // Test aarch32_SBC_r_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, cond=14, Rn=0, Rd=0, imm5=0, type1=0, Rm=0
    let encoding: u32 = 0xE0C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_sbc_r_a1_a_field_cond_15_max_0_f0c00000() {
    // Encoding: 0xF0C00000
    // Test aarch32_SBC_r_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: imm5=0, type1=0, cond=15, Rn=0, S=0, Rd=0, Rm=0
    let encoding: u32 = 0xF0C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_r_A1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_sbc_r_a1_a_field_s_0_min_0_00c00000() {
    // Encoding: 0x00C00000
    // Test aarch32_SBC_r_A1_A field S = 0 (Min)
    // ISET: A32
    // Fields: Rd=0, imm5=0, type1=0, Rm=0, cond=0, S=0, Rn=0
    let encoding: u32 = 0x00C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_r_A1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_sbc_r_a1_a_field_s_1_max_0_00d00000() {
    // Encoding: 0x00D00000
    // Test aarch32_SBC_r_A1_A field S = 1 (Max)
    // ISET: A32
    // Fields: imm5=0, Rd=0, cond=0, S=1, Rn=0, type1=0, Rm=0
    let encoding: u32 = 0x00D00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_r_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_sbc_r_a1_a_field_rn_0_min_0_00c00000() {
    // Encoding: 0x00C00000
    // Test aarch32_SBC_r_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: imm5=0, Rn=0, S=0, Rm=0, Rd=0, cond=0, type1=0
    let encoding: u32 = 0x00C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_r_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_sbc_r_a1_a_field_rn_1_poweroftwo_0_00c10000() {
    // Encoding: 0x00C10000
    // Test aarch32_SBC_r_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Rd=0, Rn=1, type1=0, Rm=0, S=0, imm5=0
    let encoding: u32 = 0x00C10000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_r_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_sbc_r_a1_a_field_rd_0_min_0_00c00000() {
    // Encoding: 0x00C00000
    // Test aarch32_SBC_r_A1_A field Rd = 0 (Min)
    // ISET: A32
    // Fields: cond=0, type1=0, Rn=0, Rd=0, S=0, imm5=0, Rm=0
    let encoding: u32 = 0x00C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_r_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_sbc_r_a1_a_field_rd_1_poweroftwo_0_00c01000() {
    // Encoding: 0x00C01000
    // Test aarch32_SBC_r_A1_A field Rd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: type1=0, cond=0, Rm=0, Rn=0, S=0, Rd=1, imm5=0
    let encoding: u32 = 0x00C01000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_sbc_r_a1_a_field_imm5_0_zero_0_00c00000() {
    // Encoding: 0x00C00000
    // Test aarch32_SBC_r_A1_A field imm5 = 0 (Zero)
    // ISET: A32
    // Fields: imm5=0, type1=0, Rm=0, cond=0, S=0, Rd=0, Rn=0
    let encoding: u32 = 0x00C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_sbc_r_a1_a_field_imm5_1_poweroftwo_0_00c00080() {
    // Encoding: 0x00C00080
    // Test aarch32_SBC_r_A1_A field imm5 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Rd=0, Rn=0, type1=0, imm5=1, Rm=0, S=0
    let encoding: u32 = 0x00C00080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_sbc_r_a1_a_field_imm5_3_poweroftwominusone_0_00c00180() {
    // Encoding: 0x00C00180
    // Test aarch32_SBC_r_A1_A field imm5 = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: type1=0, cond=0, imm5=3, Rm=0, Rn=0, Rd=0, S=0
    let encoding: u32 = 0x00C00180;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_sbc_r_a1_a_field_imm5_4_poweroftwo_0_00c00200() {
    // Encoding: 0x00C00200
    // Test aarch32_SBC_r_A1_A field imm5 = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, Rd=0, type1=0, Rm=0, cond=0, imm5=4, Rn=0
    let encoding: u32 = 0x00C00200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_sbc_r_a1_a_field_imm5_7_poweroftwominusone_0_00c00380() {
    // Encoding: 0x00C00380
    // Test aarch32_SBC_r_A1_A field imm5 = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: S=0, type1=0, Rm=0, Rd=0, cond=0, imm5=7, Rn=0
    let encoding: u32 = 0x00C00380;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_sbc_r_a1_a_field_imm5_8_poweroftwo_0_00c00400() {
    // Encoding: 0x00C00400
    // Test aarch32_SBC_r_A1_A field imm5 = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Rd=0, imm5=8, cond=0, S=0, Rn=0, type1=0
    let encoding: u32 = 0x00C00400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 15, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (15)
#[test]
fn test_aarch32_sbc_r_a1_a_field_imm5_15_poweroftwominusone_0_00c00780() {
    // Encoding: 0x00C00780
    // Test aarch32_SBC_r_A1_A field imm5 = 15 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rd=0, type1=0, cond=0, S=0, Rn=0, Rm=0, imm5=15
    let encoding: u32 = 0x00C00780;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_sbc_r_a1_a_field_imm5_16_poweroftwo_0_00c00800() {
    // Encoding: 0x00C00800
    // Test aarch32_SBC_r_A1_A field imm5 = 16 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=0, Rd=0, S=0, imm5=16, type1=0, Rm=0
    let encoding: u32 = 0x00C00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 31, boundary: Max }
/// maximum immediate (31)
#[test]
fn test_aarch32_sbc_r_a1_a_field_imm5_31_max_0_00c00f80() {
    // Encoding: 0x00C00F80
    // Test aarch32_SBC_r_A1_A field imm5 = 31 (Max)
    // ISET: A32
    // Fields: cond=0, Rd=0, S=0, type1=0, Rn=0, imm5=31, Rm=0
    let encoding: u32 = 0x00C00F80;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_r_A1_A
/// ASL: `field type1 5 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_sbc_r_a1_a_field_type1_0_min_0_00c00000() {
    // Encoding: 0x00C00000
    // Test aarch32_SBC_r_A1_A field type1 = 0 (Min)
    // ISET: A32
    // Fields: type1=0, cond=0, imm5=0, Rn=0, S=0, Rd=0, Rm=0
    let encoding: u32 = 0x00C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_r_A1_A
/// ASL: `field type1 5 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_sbc_r_a1_a_field_type1_1_poweroftwo_0_00c00020() {
    // Encoding: 0x00C00020
    // Test aarch32_SBC_r_A1_A field type1 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rm=0, cond=0, type1=1, S=0, Rd=0, imm5=0
    let encoding: u32 = 0x00C00020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_r_A1_A
/// ASL: `field type1 5 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_aarch32_sbc_r_a1_a_field_type1_3_max_0_00c00060() {
    // Encoding: 0x00C00060
    // Test aarch32_SBC_r_A1_A field type1 = 3 (Max)
    // ISET: A32
    // Fields: type1=3, Rm=0, Rn=0, cond=0, S=0, Rd=0, imm5=0
    let encoding: u32 = 0x00C00060;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_r_A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_sbc_r_a1_a_field_rm_0_min_0_00c00000() {
    // Encoding: 0x00C00000
    // Test aarch32_SBC_r_A1_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, Rn=0, Rd=0, cond=0, S=0, imm5=0, type1=0
    let encoding: u32 = 0x00C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_r_A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_sbc_r_a1_a_field_rm_1_poweroftwo_0_00c00001() {
    // Encoding: 0x00C00001
    // Test aarch32_SBC_r_A1_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, type1=0, S=0, Rm=1, cond=0, Rn=0, imm5=0
    let encoding: u32 = 0x00C00001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_r_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_sbc_r_a1_a_combo_0_0_00c00000() {
    // Encoding: 0x00C00000
    // Test aarch32_SBC_r_A1_A field combination: cond=0, S=0, Rn=0, Rd=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: imm5=0, type1=0, Rm=0, S=0, Rn=0, Rd=0, cond=0
    let encoding: u32 = 0x00C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_r_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_sbc_r_a1_a_special_cond_0_condition_eq_0_00c00000() {
    // Encoding: 0x00C00000
    // Test aarch32_SBC_r_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: Rd=0, type1=0, cond=0, S=0, imm5=0, Rm=0, Rn=0
    let encoding: u32 = 0x00C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_r_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_sbc_r_a1_a_special_cond_1_condition_ne_0_10c00000() {
    // Encoding: 0x10C00000
    // Test aarch32_SBC_r_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: imm5=0, Rm=0, cond=1, type1=0, Rn=0, Rd=0, S=0
    let encoding: u32 = 0x10C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_r_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_sbc_r_a1_a_special_cond_2_condition_cs_hs_0_20c00000() {
    // Encoding: 0x20C00000
    // Test aarch32_SBC_r_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: Rm=0, Rn=0, Rd=0, cond=2, S=0, imm5=0, type1=0
    let encoding: u32 = 0x20C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_r_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_sbc_r_a1_a_special_cond_3_condition_cc_lo_0_30c00000() {
    // Encoding: 0x30C00000
    // Test aarch32_SBC_r_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: Rn=0, Rd=0, S=0, Rm=0, type1=0, cond=3, imm5=0
    let encoding: u32 = 0x30C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_r_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_sbc_r_a1_a_special_cond_4_condition_mi_0_40c00000() {
    // Encoding: 0x40C00000
    // Test aarch32_SBC_r_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: S=0, type1=0, cond=4, Rm=0, imm5=0, Rd=0, Rn=0
    let encoding: u32 = 0x40C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_r_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_sbc_r_a1_a_special_cond_5_condition_pl_0_50c00000() {
    // Encoding: 0x50C00000
    // Test aarch32_SBC_r_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: cond=5, S=0, Rn=0, Rd=0, Rm=0, imm5=0, type1=0
    let encoding: u32 = 0x50C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_r_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_sbc_r_a1_a_special_cond_6_condition_vs_0_60c00000() {
    // Encoding: 0x60C00000
    // Test aarch32_SBC_r_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: imm5=0, Rm=0, cond=6, Rd=0, type1=0, S=0, Rn=0
    let encoding: u32 = 0x60C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_r_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_sbc_r_a1_a_special_cond_7_condition_vc_0_70c00000() {
    // Encoding: 0x70C00000
    // Test aarch32_SBC_r_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: Rd=0, imm5=0, Rn=0, type1=0, cond=7, S=0, Rm=0
    let encoding: u32 = 0x70C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_r_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_sbc_r_a1_a_special_cond_8_condition_hi_0_80c00000() {
    // Encoding: 0x80C00000
    // Test aarch32_SBC_r_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: cond=8, imm5=0, S=0, Rm=0, Rn=0, Rd=0, type1=0
    let encoding: u32 = 0x80C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_r_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_sbc_r_a1_a_special_cond_9_condition_ls_0_90c00000() {
    // Encoding: 0x90C00000
    // Test aarch32_SBC_r_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: Rn=0, Rd=0, imm5=0, cond=9, type1=0, Rm=0, S=0
    let encoding: u32 = 0x90C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_r_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_sbc_r_a1_a_special_cond_10_condition_ge_0_a0c00000() {
    // Encoding: 0xA0C00000
    // Test aarch32_SBC_r_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: S=0, imm5=0, Rm=0, cond=10, type1=0, Rn=0, Rd=0
    let encoding: u32 = 0xA0C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_r_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_sbc_r_a1_a_special_cond_11_condition_lt_0_b0c00000() {
    // Encoding: 0xB0C00000
    // Test aarch32_SBC_r_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: cond=11, S=0, Rd=0, Rn=0, imm5=0, type1=0, Rm=0
    let encoding: u32 = 0xB0C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_r_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_sbc_r_a1_a_special_cond_12_condition_gt_0_c0c00000() {
    // Encoding: 0xC0C00000
    // Test aarch32_SBC_r_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: Rn=0, Rd=0, S=0, imm5=0, type1=0, cond=12, Rm=0
    let encoding: u32 = 0xC0C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_r_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_sbc_r_a1_a_special_cond_13_condition_le_0_d0c00000() {
    // Encoding: 0xD0C00000
    // Test aarch32_SBC_r_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: type1=0, S=0, Rn=0, Rd=0, Rm=0, cond=13, imm5=0
    let encoding: u32 = 0xD0C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_r_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_sbc_r_a1_a_special_cond_14_condition_al_0_e0c00000() {
    // Encoding: 0xE0C00000
    // Test aarch32_SBC_r_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: Rd=0, imm5=0, type1=0, cond=14, S=0, Rn=0, Rm=0
    let encoding: u32 = 0xE0C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_r_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_sbc_r_a1_a_special_cond_15_condition_nv_0_f0c00000() {
    // Encoding: 0xF0C00000
    // Test aarch32_SBC_r_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: imm5=0, type1=0, cond=15, Rm=0, Rn=0, S=0, Rd=0
    let encoding: u32 = 0xF0C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_r_A1_A
/// ASL: `field S = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "S", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_sbc_r_a1_a_special_s_0_size_variant_0_0_00c00000() {
    // Encoding: 0x00C00000
    // Test aarch32_SBC_r_A1_A special value S = 0 (Size variant 0)
    // ISET: A32
    // Fields: cond=0, Rn=0, imm5=0, S=0, type1=0, Rm=0, Rd=0
    let encoding: u32 = 0x00C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_r_A1_A
/// ASL: `field S = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "S", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_sbc_r_a1_a_special_s_1_size_variant_1_0_00d00000() {
    // Encoding: 0x00D00000
    // Test aarch32_SBC_r_A1_A special value S = 1 (Size variant 1)
    // ISET: A32
    // Fields: imm5=0, Rn=0, type1=0, Rm=0, S=1, cond=0, Rd=0
    let encoding: u32 = 0x00D00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_r_T1_A
/// ASL: `field Rm 19 +: 3`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_sbc_r_t1_a_field_rm_0_min_0_41800000() {
    // Thumb encoding (32): 0x41800000
    // Test aarch32_SBC_r_T1_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: Rdn=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x41800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SBC_r_T1_A
/// ASL: `field Rm 19 +: 3`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_sbc_r_t1_a_field_rm_1_poweroftwo_0_41880000() {
    // Thumb encoding (32): 0x41880000
    // Test aarch32_SBC_r_T1_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=1, Rdn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x41880000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SBC_r_T1_A
/// ASL: `field Rdn 16 +: 3`
/// Requirement: FieldBoundary { field: "Rdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_sbc_r_t1_a_field_rdn_0_min_0_41800000() {
    // Thumb encoding (32): 0x41800000
    // Test aarch32_SBC_r_T1_A field Rdn = 0 (Min)
    // ISET: T32
    // Fields: Rm=0, Rdn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x41800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SBC_r_T1_A
/// ASL: `field Rdn 16 +: 3`
/// Requirement: FieldBoundary { field: "Rdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_sbc_r_t1_a_field_rdn_1_poweroftwo_0_41810000() {
    // Thumb encoding (32): 0x41810000
    // Test aarch32_SBC_r_T1_A field Rdn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=0, Rdn=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x41810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SBC_r_T1_A
/// ASL: `field Rdn 16 +: 3`
/// Requirement: FieldBoundary { field: "Rdn", value: 7, boundary: Max }
/// maximum value (7)
#[test]
fn test_aarch32_sbc_r_t1_a_field_rdn_7_max_0_41870000() {
    // Thumb encoding (32): 0x41870000
    // Test aarch32_SBC_r_T1_A field Rdn = 7 (Max)
    // ISET: T32
    // Fields: Rdn=7, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x41870000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SBC_r_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch32_sbc_r_t1_a_combo_0_0_41800000() {
    // Thumb encoding (32): 0x41800000
    // Test aarch32_SBC_r_T1_A field combination: Rm=0, Rdn=0
    // ISET: T32
    // Fields: Rm=0, Rdn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x41800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SBC_r_T2_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_sbc_r_t2_a_field_s_0_min_0_eb600000() {
    // Thumb encoding (32): 0xEB600000
    // Test aarch32_SBC_r_T2_A field S = 0 (Min)
    // ISET: T32
    // Fields: S=0, imm3=0, type1=0, Rd=0, Rm=0, imm2=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEB600000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SBC_r_T2_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_sbc_r_t2_a_field_s_1_max_0_eb700000() {
    // Thumb encoding (32): 0xEB700000
    // Test aarch32_SBC_r_T2_A field S = 1 (Max)
    // ISET: T32
    // Fields: S=1, type1=0, Rd=0, imm2=0, Rm=0, imm3=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEB700000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SBC_r_T2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_sbc_r_t2_a_field_rn_0_min_0_eb600000() {
    // Thumb encoding (32): 0xEB600000
    // Test aarch32_SBC_r_T2_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: imm2=0, S=0, Rm=0, Rd=0, imm3=0, type1=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEB600000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SBC_r_T2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_sbc_r_t2_a_field_rn_1_poweroftwo_0_eb610000() {
    // Thumb encoding (32): 0xEB610000
    // Test aarch32_SBC_r_T2_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: S=0, imm3=0, Rn=1, Rd=0, type1=0, imm2=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEB610000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SBC_r_T2_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_sbc_r_t2_a_field_imm3_0_zero_0_eb600000() {
    // Thumb encoding (32): 0xEB600000
    // Test aarch32_SBC_r_T2_A field imm3 = 0 (Zero)
    // ISET: T32
    // Fields: type1=0, Rm=0, Rd=0, Rn=0, S=0, imm3=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEB600000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SBC_r_T2_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_sbc_r_t2_a_field_imm3_1_poweroftwo_0_eb601000() {
    // Thumb encoding (32): 0xEB601000
    // Test aarch32_SBC_r_T2_A field imm3 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: type1=0, Rm=0, imm3=1, S=0, Rn=0, Rd=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEB601000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SBC_r_T2_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 3, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (3)
#[test]
fn test_aarch32_sbc_r_t2_a_field_imm3_3_poweroftwominusone_0_eb603000() {
    // Thumb encoding (32): 0xEB603000
    // Test aarch32_SBC_r_T2_A field imm3 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: type1=0, Rn=0, Rd=0, S=0, Rm=0, imm3=3, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEB603000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SBC_r_T2_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 7, boundary: Max }
/// maximum immediate (7)
#[test]
fn test_aarch32_sbc_r_t2_a_field_imm3_7_max_0_eb607000() {
    // Thumb encoding (32): 0xEB607000
    // Test aarch32_SBC_r_T2_A field imm3 = 7 (Max)
    // ISET: T32
    // Fields: imm2=0, Rn=0, type1=0, S=0, imm3=7, Rm=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEB607000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SBC_r_T2_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_sbc_r_t2_a_field_rd_0_min_0_eb600000() {
    // Thumb encoding (32): 0xEB600000
    // Test aarch32_SBC_r_T2_A field Rd = 0 (Min)
    // ISET: T32
    // Fields: type1=0, Rm=0, imm3=0, Rn=0, S=0, Rd=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEB600000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SBC_r_T2_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_sbc_r_t2_a_field_rd_1_poweroftwo_0_eb600100() {
    // Thumb encoding (32): 0xEB600100
    // Test aarch32_SBC_r_T2_A field Rd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: S=0, type1=0, Rm=0, Rd=1, imm2=0, Rn=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEB600100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SBC_r_T2_A
/// ASL: `field imm2 6 +: 2`
/// Requirement: FieldBoundary { field: "imm2", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_sbc_r_t2_a_field_imm2_0_zero_0_eb600000() {
    // Thumb encoding (32): 0xEB600000
    // Test aarch32_SBC_r_T2_A field imm2 = 0 (Zero)
    // ISET: T32
    // Fields: Rn=0, imm3=0, imm2=0, S=0, Rd=0, type1=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEB600000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SBC_r_T2_A
/// ASL: `field imm2 6 +: 2`
/// Requirement: FieldBoundary { field: "imm2", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_sbc_r_t2_a_field_imm2_1_poweroftwo_0_eb600040() {
    // Thumb encoding (32): 0xEB600040
    // Test aarch32_SBC_r_T2_A field imm2 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm3=0, Rn=0, S=0, Rm=0, Rd=0, imm2=1, type1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEB600040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SBC_r_T2_A
/// ASL: `field imm2 6 +: 2`
/// Requirement: FieldBoundary { field: "imm2", value: 3, boundary: Max }
/// maximum immediate (3)
#[test]
fn test_aarch32_sbc_r_t2_a_field_imm2_3_max_0_eb6000c0() {
    // Thumb encoding (32): 0xEB6000C0
    // Test aarch32_SBC_r_T2_A field imm2 = 3 (Max)
    // ISET: T32
    // Fields: type1=0, Rm=0, imm3=0, S=0, Rd=0, Rn=0, imm2=3
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEB6000C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SBC_r_T2_A
/// ASL: `field type1 4 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_sbc_r_t2_a_field_type1_0_min_0_eb600000() {
    // Thumb encoding (32): 0xEB600000
    // Test aarch32_SBC_r_T2_A field type1 = 0 (Min)
    // ISET: T32
    // Fields: Rd=0, type1=0, imm3=0, Rn=0, Rm=0, S=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEB600000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SBC_r_T2_A
/// ASL: `field type1 4 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_sbc_r_t2_a_field_type1_1_poweroftwo_0_eb600010() {
    // Thumb encoding (32): 0xEB600010
    // Test aarch32_SBC_r_T2_A field type1 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: S=0, Rn=0, imm3=0, type1=1, Rm=0, Rd=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEB600010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SBC_r_T2_A
/// ASL: `field type1 4 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_aarch32_sbc_r_t2_a_field_type1_3_max_0_eb600030() {
    // Thumb encoding (32): 0xEB600030
    // Test aarch32_SBC_r_T2_A field type1 = 3 (Max)
    // ISET: T32
    // Fields: Rd=0, imm2=0, imm3=0, type1=3, Rn=0, S=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEB600030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SBC_r_T2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_sbc_r_t2_a_field_rm_0_min_0_eb600000() {
    // Thumb encoding (32): 0xEB600000
    // Test aarch32_SBC_r_T2_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: Rm=0, imm3=0, S=0, Rn=0, Rd=0, imm2=0, type1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEB600000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SBC_r_T2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_sbc_r_t2_a_field_rm_1_poweroftwo_0_eb600001() {
    // Thumb encoding (32): 0xEB600001
    // Test aarch32_SBC_r_T2_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm3=0, Rn=0, Rm=1, imm2=0, S=0, Rd=0, type1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEB600001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SBC_r_T2_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// S=0 (8-bit / byte size)
#[test]
fn test_aarch32_sbc_r_t2_a_combo_0_0_eb600000() {
    // Thumb encoding (32): 0xEB600000
    // Test aarch32_SBC_r_T2_A field combination: S=0, Rn=0, imm3=0, Rd=0, imm2=0, type1=0, Rm=0
    // ISET: T32
    // Fields: Rm=0, type1=0, imm2=0, Rn=0, imm3=0, Rd=0, S=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEB600000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SBC_r_T2_A
/// ASL: `field S = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "S", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_sbc_r_t2_a_special_s_0_size_variant_0_0_eb600000() {
    // Thumb encoding (32): 0xEB600000
    // Test aarch32_SBC_r_T2_A special value S = 0 (Size variant 0)
    // ISET: T32
    // Fields: Rm=0, Rd=0, type1=0, Rn=0, S=0, imm3=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEB600000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SBC_r_T2_A
/// ASL: `field S = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "S", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_sbc_r_t2_a_special_s_1_size_variant_1_0_eb700000() {
    // Thumb encoding (32): 0xEB700000
    // Test aarch32_SBC_r_T2_A special value S = 1 (Size variant 1)
    // ISET: T32
    // Fields: Rm=0, type1=0, Rn=0, S=1, Rd=0, imm3=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEB700000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SBC_r_T2_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_sbc_r_t2_a_invalid_0_0_eb600000() {
    // Thumb encoding (32): 0xEB600000
    // Test aarch32_SBC_r_T2_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }
    // ISET: T32
    // Fields: Rn=0, type1=0, Rd=0, S=0, Rm=0, imm3=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEB600000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_SBC_r_T2_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_sbc_r_t2_a_invalid_1_0_eb600000() {
    // Thumb encoding (32): 0xEB600000
    // Test aarch32_SBC_r_T2_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rd=0, type1=0, Rm=0, imm3=0, imm2=0, Rn=0, S=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEB600000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_SBC_r_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_aarch32_sbc_r_a1_a_flags_zeroresult_0_00d10002() {
    // Test aarch32_SBC_r_A1_A flag computation: ZeroResult
    // Encoding: 0x00D10002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x00D10002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SBC_r_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_aarch32_sbc_r_a1_a_flags_zeroresult_1_00d10002() {
    // Test aarch32_SBC_r_A1_A flag computation: ZeroResult
    // Encoding: 0x00D10002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x00D10002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SBC_r_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_aarch32_sbc_r_a1_a_flags_negativeresult_2_00d10002() {
    // Test aarch32_SBC_r_A1_A flag computation: NegativeResult
    // Encoding: 0x00D10002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x00D10002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SBC_r_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_aarch32_sbc_r_a1_a_flags_unsignedoverflow_3_00d10002() {
    // Test aarch32_SBC_r_A1_A flag computation: UnsignedOverflow
    // Encoding: 0x00D10002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x00D10002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SBC_r_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_aarch32_sbc_r_a1_a_flags_unsignedoverflow_4_00d10002() {
    // Test aarch32_SBC_r_A1_A flag computation: UnsignedOverflow
    // Encoding: 0x00D10002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x00D10002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SBC_r_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_aarch32_sbc_r_a1_a_flags_signedoverflow_5_00d10002() {
    // Test aarch32_SBC_r_A1_A flag computation: SignedOverflow
    // Encoding: 0x00D10002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x00D10002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_SBC_r_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_aarch32_sbc_r_a1_a_flags_signedoverflow_6_00d10002() {
    // Test aarch32_SBC_r_A1_A flag computation: SignedOverflow
    // Encoding: 0x00D10002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x00D10002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_SBC_r_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_aarch32_sbc_r_a1_a_flags_positiveresult_7_00d10002() {
    // Test aarch32_SBC_r_A1_A flag computation: PositiveResult
    // Encoding: 0x00D10002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x32);
    let encoding: u32 = 0x00D10002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SBC_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 0 (32)
#[test]
fn test_aarch32_sbc_r_t1_a_lslv_oracle_32_0_41820020() {
    // Test LSLV 32-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x12345678, "W0 should be 0x12345678");
}

/// Provenance: aarch32_SBC_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 0 (64)
#[test]
fn test_aarch32_sbc_r_t1_a_lslv_oracle_64_0_c1820020() {
    // Test LSLV 64-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x12345678,
        "X0 should be 0x0000000012345678"
    );
}

/// Provenance: aarch32_SBC_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4 (32)
#[test]
fn test_aarch32_sbc_r_t1_a_lslv_oracle_32_1_41820020() {
    // Test LSLV 32-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x4);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x23456780, "W0 should be 0x23456780");
}

/// Provenance: aarch32_SBC_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 4 (64)
#[test]
fn test_aarch32_sbc_r_t1_a_lslv_oracle_64_1_c1820020() {
    // Test LSLV 64-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x4);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x23456780,
        "X0 should be 0x0000000123456780"
    );
}

/// Provenance: aarch32_SBC_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 8 (32)
#[test]
fn test_aarch32_sbc_r_t1_a_lslv_oracle_32_2_41820020() {
    // Test LSLV 32-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x8);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x34567800, "W0 should be 0x34567800");
}

/// Provenance: aarch32_SBC_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 8 (64)
#[test]
fn test_aarch32_sbc_r_t1_a_lslv_oracle_64_2_c1820020() {
    // Test LSLV 64-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x8);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x34567800,
        "X0 should be 0x0000001234567800"
    );
}

/// Provenance: aarch32_SBC_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1 (32)
#[test]
fn test_aarch32_sbc_r_t1_a_lslv_oracle_32_3_41820020() {
    // Test LSLV 32-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_SBC_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// MSB set, shift 1 (64)
#[test]
fn test_aarch32_sbc_r_t1_a_lslv_oracle_64_3_c1820020() {
    // Test LSLV 64-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_SBC_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// LSB set, max shift (32)
#[test]
fn test_aarch32_sbc_r_t1_a_lslv_oracle_32_4_41820020() {
    // Test LSLV 32-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3F);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "W0 should be 0x80000000");
}

/// Provenance: aarch32_SBC_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// LSB set, max shift (64)
#[test]
fn test_aarch32_sbc_r_t1_a_lslv_oracle_64_4_c1820020() {
    // Test LSLV 64-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3F);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x8000000000000000");
}

/// Provenance: aarch32_SBC_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// all ones, shift 32 (32)
#[test]
fn test_aarch32_sbc_r_t1_a_lslv_oracle_32_5_41820020() {
    // Test LSLV 32-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x20);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "W0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_SBC_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// all ones, shift 32 (64)
#[test]
fn test_aarch32_sbc_r_t1_a_lslv_oracle_64_5_c1820020() {
    // Test LSLV 64-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x20);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0xFFFFFFFF00000000");
}

/// Provenance: aarch32_SBC_r_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// no shift
#[test]
fn test_aarch32_sbc_r_t1_a_t16_oracle_0_41900000() {
    // Test T16 LSLS: no shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_SBC_r_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4
#[test]
fn test_aarch32_sbc_r_t1_a_t16_oracle_1_41900000() {
    // Test T16 LSLS: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    set_w(&mut cpu, 2, 0x4);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF0, "R0 should be 0x00000FF0");
}

/// Provenance: aarch32_SBC_r_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1
#[test]
fn test_aarch32_sbc_r_t1_a_t16_oracle_2_41900000() {
    // Test T16 LSLS: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_SBC_r_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift to MSB
#[test]
fn test_aarch32_sbc_r_t1_a_t16_oracle_3_41900000() {
    // Test T16 LSLS: shift to MSB (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1F);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "R0 should be 0x80000000");
}

/// Provenance: aarch32_SBC_r_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_aarch32_sbc_r_t1_a_flags_zeroresult_0_41900000() {
    // Test aarch32_SBC_r_T1_A flag computation: ZeroResult
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SBC_r_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_aarch32_sbc_r_t1_a_flags_zeroresult_1_41900000() {
    // Test aarch32_SBC_r_T1_A flag computation: ZeroResult
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SBC_r_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_aarch32_sbc_r_t1_a_flags_negativeresult_2_41900000() {
    // Test aarch32_SBC_r_T1_A flag computation: NegativeResult
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SBC_r_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_aarch32_sbc_r_t1_a_flags_unsignedoverflow_3_41900000() {
    // Test aarch32_SBC_r_T1_A flag computation: UnsignedOverflow
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SBC_r_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_aarch32_sbc_r_t1_a_flags_unsignedoverflow_4_41900000() {
    // Test aarch32_SBC_r_T1_A flag computation: UnsignedOverflow
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SBC_r_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_aarch32_sbc_r_t1_a_flags_signedoverflow_5_41900000() {
    // Test aarch32_SBC_r_T1_A flag computation: SignedOverflow
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_SBC_r_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_aarch32_sbc_r_t1_a_flags_signedoverflow_6_41900000() {
    // Test aarch32_SBC_r_T1_A flag computation: SignedOverflow
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_SBC_r_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_aarch32_sbc_r_t1_a_flags_positiveresult_7_41900000() {
    // Test aarch32_SBC_r_T1_A flag computation: PositiveResult
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x32);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SBC_r_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_aarch32_sbc_r_t2_a_flags_zeroresult_0_eb710002() {
    // Test aarch32_SBC_r_T2_A flag computation: ZeroResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xEB710002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SBC_r_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_aarch32_sbc_r_t2_a_flags_zeroresult_1_eb710002() {
    // Test aarch32_SBC_r_T2_A flag computation: ZeroResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0xEB710002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SBC_r_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_aarch32_sbc_r_t2_a_flags_negativeresult_2_eb710002() {
    // Test aarch32_SBC_r_T2_A flag computation: NegativeResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xEB710002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SBC_r_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_aarch32_sbc_r_t2_a_flags_unsignedoverflow_3_eb710002() {
    // Test aarch32_SBC_r_T2_A flag computation: UnsignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xEB710002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SBC_r_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_aarch32_sbc_r_t2_a_flags_unsignedoverflow_4_eb710002() {
    // Test aarch32_SBC_r_T2_A flag computation: UnsignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0xEB710002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SBC_r_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_aarch32_sbc_r_t2_a_flags_signedoverflow_5_eb710002() {
    // Test aarch32_SBC_r_T2_A flag computation: SignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0xEB710002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_SBC_r_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_aarch32_sbc_r_t2_a_flags_signedoverflow_6_eb710002() {
    // Test aarch32_SBC_r_T2_A flag computation: SignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0xEB710002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_SBC_r_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_aarch32_sbc_r_t2_a_flags_positiveresult_7_eb710002() {
    // Test aarch32_SBC_r_T2_A flag computation: PositiveResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x32);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xEB710002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

// ============================================================================
// aarch32_SUB_SP_r_A Tests
// ============================================================================

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_sub_sp_r_a1_a_field_cond_0_min_0_004d0000() {
    // Encoding: 0x004D0000
    // Test aarch32_SUB_SP_r_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: cond=0, imm5=0, Rd=0, Rm=0, S=0, type1=0
    let encoding: u32 = 0x004D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_sub_sp_r_a1_a_field_cond_1_poweroftwo_0_104d0000() {
    // Encoding: 0x104D0000
    // Test aarch32_SUB_SP_r_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=1, S=0, Rd=0, type1=0, Rm=0, imm5=0
    let encoding: u32 = 0x104D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_sub_sp_r_a1_a_field_cond_2_poweroftwo_0_204d0000() {
    // Encoding: 0x204D0000
    // Test aarch32_SUB_SP_r_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rm=0, type1=0, cond=2, S=0, imm5=0
    let encoding: u32 = 0x204D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_sub_sp_r_a1_a_field_cond_3_poweroftwo_0_304d0000() {
    // Encoding: 0x304D0000
    // Test aarch32_SUB_SP_r_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: type1=0, Rm=0, imm5=0, S=0, cond=3, Rd=0
    let encoding: u32 = 0x304D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_sub_sp_r_a1_a_field_cond_4_poweroftwo_0_404d0000() {
    // Encoding: 0x404D0000
    // Test aarch32_SUB_SP_r_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=4, Rd=0, S=0, type1=0, Rm=0, imm5=0
    let encoding: u32 = 0x404D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_sub_sp_r_a1_a_field_cond_5_poweroftwo_0_504d0000() {
    // Encoding: 0x504D0000
    // Test aarch32_SUB_SP_r_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=5, S=0, Rm=0, Rd=0, imm5=0, type1=0
    let encoding: u32 = 0x504D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_sub_sp_r_a1_a_field_cond_6_poweroftwo_0_604d0000() {
    // Encoding: 0x604D0000
    // Test aarch32_SUB_SP_r_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: type1=0, Rd=0, S=0, cond=6, imm5=0, Rm=0
    let encoding: u32 = 0x604D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_sub_sp_r_a1_a_field_cond_7_poweroftwo_0_704d0000() {
    // Encoding: 0x704D0000
    // Test aarch32_SUB_SP_r_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, cond=7, Rd=0, S=0, type1=0, imm5=0
    let encoding: u32 = 0x704D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_sub_sp_r_a1_a_field_cond_8_poweroftwo_0_804d0000() {
    // Encoding: 0x804D0000
    // Test aarch32_SUB_SP_r_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=8, imm5=0, type1=0, Rm=0, S=0, Rd=0
    let encoding: u32 = 0x804D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_sub_sp_r_a1_a_field_cond_9_poweroftwo_0_904d0000() {
    // Encoding: 0x904D0000
    // Test aarch32_SUB_SP_r_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=9, Rm=0, Rd=0, S=0, imm5=0, type1=0
    let encoding: u32 = 0x904D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_sub_sp_r_a1_a_field_cond_10_poweroftwo_0_a04d0000() {
    // Encoding: 0xA04D0000
    // Test aarch32_SUB_SP_r_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, cond=10, imm5=0, type1=0, S=0, Rd=0
    let encoding: u32 = 0xA04D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_sub_sp_r_a1_a_field_cond_11_poweroftwo_0_b04d0000() {
    // Encoding: 0xB04D0000
    // Test aarch32_SUB_SP_r_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=11, imm5=0, Rd=0, S=0, type1=0, Rm=0
    let encoding: u32 = 0xB04D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_sub_sp_r_a1_a_field_cond_12_poweroftwo_0_c04d0000() {
    // Encoding: 0xC04D0000
    // Test aarch32_SUB_SP_r_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: type1=0, cond=12, imm5=0, Rm=0, Rd=0, S=0
    let encoding: u32 = 0xC04D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_sub_sp_r_a1_a_field_cond_13_poweroftwo_0_d04d0000() {
    // Encoding: 0xD04D0000
    // Test aarch32_SUB_SP_r_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, imm5=0, cond=13, Rd=0, type1=0, Rm=0
    let encoding: u32 = 0xD04D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_sub_sp_r_a1_a_field_cond_14_poweroftwo_0_e04d0000() {
    // Encoding: 0xE04D0000
    // Test aarch32_SUB_SP_r_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: type1=0, Rm=0, S=0, imm5=0, cond=14, Rd=0
    let encoding: u32 = 0xE04D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_sub_sp_r_a1_a_field_cond_15_max_0_f04d0000() {
    // Encoding: 0xF04D0000
    // Test aarch32_SUB_SP_r_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: cond=15, S=0, imm5=0, type1=0, Rd=0, Rm=0
    let encoding: u32 = 0xF04D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_sub_sp_r_a1_a_field_s_0_min_0_004d0000() {
    // Encoding: 0x004D0000
    // Test aarch32_SUB_SP_r_A1_A field S = 0 (Min)
    // ISET: A32
    // Fields: cond=0, type1=0, imm5=0, S=0, Rm=0, Rd=0
    let encoding: u32 = 0x004D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_sub_sp_r_a1_a_field_s_1_max_0_005d0000() {
    // Encoding: 0x005D0000
    // Test aarch32_SUB_SP_r_A1_A field S = 1 (Max)
    // ISET: A32
    // Fields: Rd=0, imm5=0, Rm=0, type1=0, S=1, cond=0
    let encoding: u32 = 0x005D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_sub_sp_r_a1_a_field_rd_0_min_0_004d0000() {
    // Encoding: 0x004D0000
    // Test aarch32_SUB_SP_r_A1_A field Rd = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, cond=0, type1=0, S=0, Rd=0, imm5=0
    let encoding: u32 = 0x004D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_sub_sp_r_a1_a_field_rd_1_poweroftwo_0_004d1000() {
    // Encoding: 0x004D1000
    // Test aarch32_SUB_SP_r_A1_A field Rd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: imm5=0, type1=0, S=0, Rd=1, cond=0, Rm=0
    let encoding: u32 = 0x004D1000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_sub_sp_r_a1_a_field_imm5_0_zero_0_004d0000() {
    // Encoding: 0x004D0000
    // Test aarch32_SUB_SP_r_A1_A field imm5 = 0 (Zero)
    // ISET: A32
    // Fields: Rm=0, imm5=0, type1=0, Rd=0, cond=0, S=0
    let encoding: u32 = 0x004D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_sub_sp_r_a1_a_field_imm5_1_poweroftwo_0_004d0080() {
    // Encoding: 0x004D0080
    // Test aarch32_SUB_SP_r_A1_A field imm5 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, Rd=0, cond=0, type1=0, imm5=1, Rm=0
    let encoding: u32 = 0x004D0080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_sub_sp_r_a1_a_field_imm5_3_poweroftwominusone_0_004d0180() {
    // Encoding: 0x004D0180
    // Test aarch32_SUB_SP_r_A1_A field imm5 = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rd=0, imm5=3, cond=0, type1=0, Rm=0, S=0
    let encoding: u32 = 0x004D0180;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_sub_sp_r_a1_a_field_imm5_4_poweroftwo_0_004d0200() {
    // Encoding: 0x004D0200
    // Test aarch32_SUB_SP_r_A1_A field imm5 = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: imm5=4, Rm=0, type1=0, Rd=0, S=0, cond=0
    let encoding: u32 = 0x004D0200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_sub_sp_r_a1_a_field_imm5_7_poweroftwominusone_0_004d0380() {
    // Encoding: 0x004D0380
    // Test aarch32_SUB_SP_r_A1_A field imm5 = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm5=7, Rd=0, type1=0, Rm=0, S=0, cond=0
    let encoding: u32 = 0x004D0380;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_sub_sp_r_a1_a_field_imm5_8_poweroftwo_0_004d0400() {
    // Encoding: 0x004D0400
    // Test aarch32_SUB_SP_r_A1_A field imm5 = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, type1=0, imm5=8, Rm=0, Rd=0, S=0
    let encoding: u32 = 0x004D0400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 15, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (15)
#[test]
fn test_aarch32_sub_sp_r_a1_a_field_imm5_15_poweroftwominusone_0_004d0780() {
    // Encoding: 0x004D0780
    // Test aarch32_SUB_SP_r_A1_A field imm5 = 15 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: S=0, cond=0, type1=0, Rm=0, Rd=0, imm5=15
    let encoding: u32 = 0x004D0780;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_sub_sp_r_a1_a_field_imm5_16_poweroftwo_0_004d0800() {
    // Encoding: 0x004D0800
    // Test aarch32_SUB_SP_r_A1_A field imm5 = 16 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, S=0, type1=0, imm5=16, Rd=0, Rm=0
    let encoding: u32 = 0x004D0800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 31, boundary: Max }
/// maximum immediate (31)
#[test]
fn test_aarch32_sub_sp_r_a1_a_field_imm5_31_max_0_004d0f80() {
    // Encoding: 0x004D0F80
    // Test aarch32_SUB_SP_r_A1_A field imm5 = 31 (Max)
    // ISET: A32
    // Fields: type1=0, Rm=0, Rd=0, cond=0, S=0, imm5=31
    let encoding: u32 = 0x004D0F80;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `field type1 5 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_sub_sp_r_a1_a_field_type1_0_min_0_004d0000() {
    // Encoding: 0x004D0000
    // Test aarch32_SUB_SP_r_A1_A field type1 = 0 (Min)
    // ISET: A32
    // Fields: imm5=0, cond=0, Rd=0, type1=0, Rm=0, S=0
    let encoding: u32 = 0x004D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `field type1 5 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_sub_sp_r_a1_a_field_type1_1_poweroftwo_0_004d0020() {
    // Encoding: 0x004D0020
    // Test aarch32_SUB_SP_r_A1_A field type1 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, imm5=0, Rm=0, Rd=0, S=0, type1=1
    let encoding: u32 = 0x004D0020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `field type1 5 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_aarch32_sub_sp_r_a1_a_field_type1_3_max_0_004d0060() {
    // Encoding: 0x004D0060
    // Test aarch32_SUB_SP_r_A1_A field type1 = 3 (Max)
    // ISET: A32
    // Fields: cond=0, Rm=0, S=0, Rd=0, type1=3, imm5=0
    let encoding: u32 = 0x004D0060;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_sub_sp_r_a1_a_field_rm_0_min_0_004d0000() {
    // Encoding: 0x004D0000
    // Test aarch32_SUB_SP_r_A1_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: imm5=0, S=0, Rm=0, cond=0, Rd=0, type1=0
    let encoding: u32 = 0x004D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_sub_sp_r_a1_a_field_rm_1_poweroftwo_0_004d0001() {
    // Encoding: 0x004D0001
    // Test aarch32_SUB_SP_r_A1_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, S=0, Rd=0, imm5=0, type1=0, Rm=1
    let encoding: u32 = 0x004D0001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_sub_sp_r_a1_a_combo_0_0_004d0000() {
    // Encoding: 0x004D0000
    // Test aarch32_SUB_SP_r_A1_A field combination: cond=0, S=0, Rd=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: type1=0, Rd=0, cond=0, imm5=0, Rm=0, S=0
    let encoding: u32 = 0x004D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_sub_sp_r_a1_a_special_cond_0_condition_eq_0_004d0000() {
    // Encoding: 0x004D0000
    // Test aarch32_SUB_SP_r_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: imm5=0, S=0, Rm=0, type1=0, Rd=0, cond=0
    let encoding: u32 = 0x004D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_sub_sp_r_a1_a_special_cond_1_condition_ne_0_104d0000() {
    // Encoding: 0x104D0000
    // Test aarch32_SUB_SP_r_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: Rd=0, S=0, Rm=0, cond=1, imm5=0, type1=0
    let encoding: u32 = 0x104D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_sub_sp_r_a1_a_special_cond_2_condition_cs_hs_0_204d0000() {
    // Encoding: 0x204D0000
    // Test aarch32_SUB_SP_r_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: type1=0, cond=2, S=0, Rd=0, imm5=0, Rm=0
    let encoding: u32 = 0x204D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_sub_sp_r_a1_a_special_cond_3_condition_cc_lo_0_304d0000() {
    // Encoding: 0x304D0000
    // Test aarch32_SUB_SP_r_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: cond=3, imm5=0, S=0, type1=0, Rd=0, Rm=0
    let encoding: u32 = 0x304D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_sub_sp_r_a1_a_special_cond_4_condition_mi_0_404d0000() {
    // Encoding: 0x404D0000
    // Test aarch32_SUB_SP_r_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: cond=4, type1=0, Rd=0, S=0, imm5=0, Rm=0
    let encoding: u32 = 0x404D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_sub_sp_r_a1_a_special_cond_5_condition_pl_0_504d0000() {
    // Encoding: 0x504D0000
    // Test aarch32_SUB_SP_r_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: cond=5, type1=0, Rm=0, imm5=0, S=0, Rd=0
    let encoding: u32 = 0x504D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_sub_sp_r_a1_a_special_cond_6_condition_vs_0_604d0000() {
    // Encoding: 0x604D0000
    // Test aarch32_SUB_SP_r_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: Rm=0, cond=6, S=0, imm5=0, Rd=0, type1=0
    let encoding: u32 = 0x604D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_sub_sp_r_a1_a_special_cond_7_condition_vc_0_704d0000() {
    // Encoding: 0x704D0000
    // Test aarch32_SUB_SP_r_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: Rd=0, cond=7, Rm=0, S=0, imm5=0, type1=0
    let encoding: u32 = 0x704D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_sub_sp_r_a1_a_special_cond_8_condition_hi_0_804d0000() {
    // Encoding: 0x804D0000
    // Test aarch32_SUB_SP_r_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: Rm=0, imm5=0, cond=8, S=0, type1=0, Rd=0
    let encoding: u32 = 0x804D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_sub_sp_r_a1_a_special_cond_9_condition_ls_0_904d0000() {
    // Encoding: 0x904D0000
    // Test aarch32_SUB_SP_r_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: Rm=0, type1=0, imm5=0, Rd=0, cond=9, S=0
    let encoding: u32 = 0x904D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_sub_sp_r_a1_a_special_cond_10_condition_ge_0_a04d0000() {
    // Encoding: 0xA04D0000
    // Test aarch32_SUB_SP_r_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: imm5=0, type1=0, Rd=0, cond=10, S=0, Rm=0
    let encoding: u32 = 0xA04D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_sub_sp_r_a1_a_special_cond_11_condition_lt_0_b04d0000() {
    // Encoding: 0xB04D0000
    // Test aarch32_SUB_SP_r_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: type1=0, Rm=0, Rd=0, cond=11, imm5=0, S=0
    let encoding: u32 = 0xB04D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_sub_sp_r_a1_a_special_cond_12_condition_gt_0_c04d0000() {
    // Encoding: 0xC04D0000
    // Test aarch32_SUB_SP_r_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: type1=0, S=0, Rm=0, cond=12, Rd=0, imm5=0
    let encoding: u32 = 0xC04D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_sub_sp_r_a1_a_special_cond_13_condition_le_0_d04d0000() {
    // Encoding: 0xD04D0000
    // Test aarch32_SUB_SP_r_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: cond=13, Rd=0, S=0, type1=0, Rm=0, imm5=0
    let encoding: u32 = 0xD04D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_sub_sp_r_a1_a_special_cond_14_condition_al_0_e04d0000() {
    // Encoding: 0xE04D0000
    // Test aarch32_SUB_SP_r_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: cond=14, type1=0, S=0, Rd=0, imm5=0, Rm=0
    let encoding: u32 = 0xE04D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_sub_sp_r_a1_a_special_cond_15_condition_nv_0_f04d0000() {
    // Encoding: 0xF04D0000
    // Test aarch32_SUB_SP_r_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: S=0, cond=15, Rd=0, type1=0, imm5=0, Rm=0
    let encoding: u32 = 0xF04D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `field S = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "S", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_sub_sp_r_a1_a_special_s_0_size_variant_0_0_004d0000() {
    // Encoding: 0x004D0000
    // Test aarch32_SUB_SP_r_A1_A special value S = 0 (Size variant 0)
    // ISET: A32
    // Fields: imm5=0, S=0, Rd=0, cond=0, type1=0, Rm=0
    let encoding: u32 = 0x004D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `field S = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "S", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_sub_sp_r_a1_a_special_s_1_size_variant_1_0_005d0000() {
    // Encoding: 0x005D0000
    // Test aarch32_SUB_SP_r_A1_A special value S = 1 (Size variant 1)
    // ISET: A32
    // Fields: imm5=0, Rd=0, cond=0, S=1, type1=0, Rm=0
    let encoding: u32 = 0x005D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_r_T1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_sub_sp_r_t1_a_field_s_0_min_0_ebad0000() {
    // Thumb encoding (32): 0xEBAD0000
    // Test aarch32_SUB_SP_r_T1_A field S = 0 (Min)
    // ISET: T32
    // Fields: imm3=0, Rd=0, S=0, imm2=0, type1=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEBAD0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_SP_r_T1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_sub_sp_r_t1_a_field_s_1_max_0_ebbd0000() {
    // Thumb encoding (32): 0xEBBD0000
    // Test aarch32_SUB_SP_r_T1_A field S = 1 (Max)
    // ISET: T32
    // Fields: type1=0, Rd=0, S=1, imm2=0, imm3=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEBBD0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_SP_r_T1_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_sub_sp_r_t1_a_field_imm3_0_zero_0_ebad0000() {
    // Thumb encoding (32): 0xEBAD0000
    // Test aarch32_SUB_SP_r_T1_A field imm3 = 0 (Zero)
    // ISET: T32
    // Fields: type1=0, imm2=0, Rm=0, S=0, imm3=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEBAD0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_SP_r_T1_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_sub_sp_r_t1_a_field_imm3_1_poweroftwo_0_ebad1000() {
    // Thumb encoding (32): 0xEBAD1000
    // Test aarch32_SUB_SP_r_T1_A field imm3 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: S=0, Rm=0, Rd=0, imm3=1, type1=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEBAD1000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_SP_r_T1_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 3, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (3)
#[test]
fn test_aarch32_sub_sp_r_t1_a_field_imm3_3_poweroftwominusone_0_ebad3000() {
    // Thumb encoding (32): 0xEBAD3000
    // Test aarch32_SUB_SP_r_T1_A field imm3 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: S=0, Rd=0, imm2=0, Rm=0, imm3=3, type1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEBAD3000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_SP_r_T1_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 7, boundary: Max }
/// maximum immediate (7)
#[test]
fn test_aarch32_sub_sp_r_t1_a_field_imm3_7_max_0_ebad7000() {
    // Thumb encoding (32): 0xEBAD7000
    // Test aarch32_SUB_SP_r_T1_A field imm3 = 7 (Max)
    // ISET: T32
    // Fields: Rd=0, imm3=7, type1=0, imm2=0, S=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEBAD7000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_SP_r_T1_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_sub_sp_r_t1_a_field_rd_0_min_0_ebad0000() {
    // Thumb encoding (32): 0xEBAD0000
    // Test aarch32_SUB_SP_r_T1_A field Rd = 0 (Min)
    // ISET: T32
    // Fields: type1=0, Rm=0, imm2=0, Rd=0, S=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEBAD0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_SP_r_T1_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_sub_sp_r_t1_a_field_rd_1_poweroftwo_0_ebad0100() {
    // Thumb encoding (32): 0xEBAD0100
    // Test aarch32_SUB_SP_r_T1_A field Rd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm3=0, Rd=1, type1=0, imm2=0, Rm=0, S=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEBAD0100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_SP_r_T1_A
/// ASL: `field imm2 6 +: 2`
/// Requirement: FieldBoundary { field: "imm2", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_sub_sp_r_t1_a_field_imm2_0_zero_0_ebad0000() {
    // Thumb encoding (32): 0xEBAD0000
    // Test aarch32_SUB_SP_r_T1_A field imm2 = 0 (Zero)
    // ISET: T32
    // Fields: imm2=0, Rm=0, Rd=0, type1=0, S=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEBAD0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_SP_r_T1_A
/// ASL: `field imm2 6 +: 2`
/// Requirement: FieldBoundary { field: "imm2", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_sub_sp_r_t1_a_field_imm2_1_poweroftwo_0_ebad0040() {
    // Thumb encoding (32): 0xEBAD0040
    // Test aarch32_SUB_SP_r_T1_A field imm2 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm3=0, S=0, type1=0, Rd=0, imm2=1, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEBAD0040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_SP_r_T1_A
/// ASL: `field imm2 6 +: 2`
/// Requirement: FieldBoundary { field: "imm2", value: 3, boundary: Max }
/// maximum immediate (3)
#[test]
fn test_aarch32_sub_sp_r_t1_a_field_imm2_3_max_0_ebad00c0() {
    // Thumb encoding (32): 0xEBAD00C0
    // Test aarch32_SUB_SP_r_T1_A field imm2 = 3 (Max)
    // ISET: T32
    // Fields: S=0, imm2=3, Rd=0, type1=0, imm3=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEBAD00C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_SP_r_T1_A
/// ASL: `field type1 4 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_sub_sp_r_t1_a_field_type1_0_min_0_ebad0000() {
    // Thumb encoding (32): 0xEBAD0000
    // Test aarch32_SUB_SP_r_T1_A field type1 = 0 (Min)
    // ISET: T32
    // Fields: type1=0, Rd=0, S=0, imm3=0, imm2=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEBAD0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_SP_r_T1_A
/// ASL: `field type1 4 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_sub_sp_r_t1_a_field_type1_1_poweroftwo_0_ebad0010() {
    // Thumb encoding (32): 0xEBAD0010
    // Test aarch32_SUB_SP_r_T1_A field type1 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=0, Rd=0, S=0, type1=1, imm2=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEBAD0010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_SP_r_T1_A
/// ASL: `field type1 4 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_aarch32_sub_sp_r_t1_a_field_type1_3_max_0_ebad0030() {
    // Thumb encoding (32): 0xEBAD0030
    // Test aarch32_SUB_SP_r_T1_A field type1 = 3 (Max)
    // ISET: T32
    // Fields: S=0, Rd=0, type1=3, Rm=0, imm3=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEBAD0030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_SP_r_T1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_sub_sp_r_t1_a_field_rm_0_min_0_ebad0000() {
    // Thumb encoding (32): 0xEBAD0000
    // Test aarch32_SUB_SP_r_T1_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: imm2=0, imm3=0, Rd=0, type1=0, S=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEBAD0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_SP_r_T1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_sub_sp_r_t1_a_field_rm_1_poweroftwo_0_ebad0001() {
    // Thumb encoding (32): 0xEBAD0001
    // Test aarch32_SUB_SP_r_T1_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: type1=0, Rd=0, Rm=1, imm3=0, imm2=0, S=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEBAD0001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_SP_r_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// S=0 (8-bit / byte size)
#[test]
fn test_aarch32_sub_sp_r_t1_a_combo_0_0_ebad0000() {
    // Thumb encoding (32): 0xEBAD0000
    // Test aarch32_SUB_SP_r_T1_A field combination: S=0, imm3=0, Rd=0, imm2=0, type1=0, Rm=0
    // ISET: T32
    // Fields: imm2=0, type1=0, Rm=0, S=0, Rd=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEBAD0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_SP_r_T1_A
/// ASL: `field S = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "S", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_sub_sp_r_t1_a_special_s_0_size_variant_0_0_ebad0000() {
    // Thumb encoding (32): 0xEBAD0000
    // Test aarch32_SUB_SP_r_T1_A special value S = 0 (Size variant 0)
    // ISET: T32
    // Fields: imm3=0, Rm=0, Rd=0, type1=0, imm2=0, S=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEBAD0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_SP_r_T1_A
/// ASL: `field S = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "S", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_sub_sp_r_t1_a_special_s_1_size_variant_1_0_ebbd0000() {
    // Thumb encoding (32): 0xEBBD0000
    // Test aarch32_SUB_SP_r_T1_A special value S = 1 (Size variant 1)
    // ISET: T32
    // Fields: S=1, type1=0, imm2=0, imm3=0, Rm=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEBBD0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_SP_r_T1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Or, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: And, lhs: LitInt(15), rhs: Unary { op: Not, operand: Var(QualifiedIdentifier { qualifier: Any, name: "setflags" }) } } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Or, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: And, lhs: LitInt(15), rhs: Unary { op: Not, operand: Var(QualifiedIdentifier { qualifier: Any, name: \"setflags\" }) } } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_sub_sp_r_t1_a_invalid_0_0_ebad0000() {
    // Thumb encoding (32): 0xEBAD0000
    // Test aarch32_SUB_SP_r_T1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Or, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: And, lhs: LitInt(15), rhs: Unary { op: Not, operand: Var(QualifiedIdentifier { qualifier: Any, name: "setflags" }) } } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) }, rhs: LitInt(15) }
    // ISET: T32
    // Fields: Rm=0, imm3=0, S=0, Rd=0, imm2=0, type1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEBAD0000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_SUB_SP_r_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_sub_sp_r_t1_a_invalid_1_0_ebad0000() {
    // Thumb encoding (32): 0xEBAD0000
    // Test aarch32_SUB_SP_r_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rm=0, Rd=0, imm2=0, imm3=0, S=0, type1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEBAD0000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `ADD X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// no shift (32)
#[test]
fn test_aarch32_sub_sp_r_a1_a_add_shifted_oracle_32_0_004f0020() {
    // Test ADD shifted 32-bit: no shift (oracle)
    // Encoding: 0x004F0020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0xA);
    let encoding: u32 = 0x004F0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6E, "W0 should be 0x0000006E");
}

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `ADD X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// no shift (64)
#[test]
fn test_aarch32_sub_sp_r_a1_a_add_shifted_oracle_64_0_804f0020() {
    // Test ADD shifted 64-bit: no shift (oracle)
    // Encoding: 0x804F0020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xA);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x804F0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6E, "X0 should be 0x000000000000006E");
}

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `ADD X0, X1, X2, shift #3`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// LSL #3 (multiply by 8) (32)
#[test]
fn test_aarch32_sub_sp_r_a1_a_add_shifted_oracle_32_1_004f0c20() {
    // Test ADD shifted 32-bit: LSL #3 (multiply by 8) (oracle)
    // Encoding: 0x004F0C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x004F0C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6C, "W0 should be 0x0000006C");
}

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `ADD X0, X1, X2, shift #3`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// LSL #3 (multiply by 8) (64)
#[test]
fn test_aarch32_sub_sp_r_a1_a_add_shifted_oracle_64_1_804f0c20() {
    // Test ADD shifted 64-bit: LSL #3 (multiply by 8) (oracle)
    // Encoding: 0x804F0C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x804F0C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6C, "X0 should be 0x000000000000006C");
}

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `ADD X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// overflow test (32)
#[test]
fn test_aarch32_sub_sp_r_a1_a_add_shifted_oracle_32_2_004f0020() {
    // Test ADD shifted 32-bit: overflow test (oracle)
    // Encoding: 0x004F0020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x004F0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `ADD X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// overflow test (64)
#[test]
fn test_aarch32_sub_sp_r_a1_a_add_shifted_oracle_64_2_804f0020() {
    // Test ADD shifted 64-bit: overflow test (oracle)
    // Encoding: 0x804F0020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x804F0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `ADD X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// subtract from zero (32)
#[test]
fn test_aarch32_sub_sp_r_a1_a_add_shifted_oracle_32_3_004f0020() {
    // Test ADD shifted 32-bit: subtract from zero (oracle)
    // Encoding: 0x004F0020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x004F0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "W0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `ADD X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// subtract from zero (64)
#[test]
fn test_aarch32_sub_sp_r_a1_a_add_shifted_oracle_64_3_804f0020() {
    // Test ADD shifted 64-bit: subtract from zero (oracle)
    // Encoding: 0x804F0020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x804F0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
}

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `ADDS X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// no shift (32)
#[test]
fn test_aarch32_sub_sp_r_a1_a_adds_shifted_oracle_32_0_204f0020() {
    // Test ADDS shifted 32-bit: no shift (oracle)
    // Encoding: 0x204F0020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xA);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x204F0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6E, "W0 should be 0x0000006E");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `ADDS X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// no shift (64)
#[test]
fn test_aarch32_sub_sp_r_a1_a_adds_shifted_oracle_64_0_a04f0020() {
    // Test ADDS shifted 64-bit: no shift (oracle)
    // Encoding: 0xA04F0020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0xA);
    let encoding: u32 = 0xA04F0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6E, "X0 should be 0x000000000000006E");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `ADDS X0, X1, X2, shift #3`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// LSL #3 (multiply by 8) (32)
#[test]
fn test_aarch32_sub_sp_r_a1_a_adds_shifted_oracle_32_1_204f0c20() {
    // Test ADDS shifted 32-bit: LSL #3 (multiply by 8) (oracle)
    // Encoding: 0x204F0C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x204F0C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6C, "W0 should be 0x0000006C");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `ADDS X0, X1, X2, shift #3`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// LSL #3 (multiply by 8) (64)
#[test]
fn test_aarch32_sub_sp_r_a1_a_adds_shifted_oracle_64_1_a04f0c20() {
    // Test ADDS shifted 64-bit: LSL #3 (multiply by 8) (oracle)
    // Encoding: 0xA04F0C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0xA04F0C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6C, "X0 should be 0x000000000000006C");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `ADDS X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// overflow test (32)
#[test]
fn test_aarch32_sub_sp_r_a1_a_adds_shifted_oracle_32_2_204f0020() {
    // Test ADDS shifted 32-bit: overflow test (oracle)
    // Encoding: 0x204F0020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x204F0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `ADDS X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// overflow test (64)
#[test]
fn test_aarch32_sub_sp_r_a1_a_adds_shifted_oracle_64_2_a04f0020() {
    // Test ADDS shifted 64-bit: overflow test (oracle)
    // Encoding: 0xA04F0020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xA04F0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, true, "V flag should be true");
}

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `ADDS X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// subtract from zero (32)
#[test]
fn test_aarch32_sub_sp_r_a1_a_adds_shifted_oracle_32_3_204f0020() {
    // Test ADDS shifted 32-bit: subtract from zero (oracle)
    // Encoding: 0x204F0020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x204F0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "W0 should be 0xFFFFFFFF");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `ADDS X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// subtract from zero (64)
#[test]
fn test_aarch32_sub_sp_r_a1_a_adds_shifted_oracle_64_3_a04f0020() {
    // Test ADDS shifted 64-bit: subtract from zero (oracle)
    // Encoding: 0xA04F0020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xA04F0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `SUB X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// no shift (32)
#[test]
fn test_aarch32_sub_sp_r_a1_a_sub_shifted_oracle_32_0_404f0020() {
    // Test SUB shifted 32-bit: no shift (oracle)
    // Encoding: 0x404F0020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xA);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x404F0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x5A, "W0 should be 0x0000005A");
}

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `SUB X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// no shift (64)
#[test]
fn test_aarch32_sub_sp_r_a1_a_sub_shifted_oracle_64_0_c04f0020() {
    // Test SUB shifted 64-bit: no shift (oracle)
    // Encoding: 0xC04F0020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xA);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xC04F0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x5A, "X0 should be 0x000000000000005A");
}

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `SUB X0, X1, X2, shift #3`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// LSL #3 (multiply by 8) (32)
#[test]
fn test_aarch32_sub_sp_r_a1_a_sub_shifted_oracle_32_1_404f0c20() {
    // Test SUB shifted 32-bit: LSL #3 (multiply by 8) (oracle)
    // Encoding: 0x404F0C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x404F0C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x5C, "W0 should be 0x0000005C");
}

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `SUB X0, X1, X2, shift #3`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// LSL #3 (multiply by 8) (64)
#[test]
fn test_aarch32_sub_sp_r_a1_a_sub_shifted_oracle_64_1_c04f0c20() {
    // Test SUB shifted 64-bit: LSL #3 (multiply by 8) (oracle)
    // Encoding: 0xC04F0C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0xC04F0C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x5C, "X0 should be 0x000000000000005C");
}

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `SUB X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// overflow test (32)
#[test]
fn test_aarch32_sub_sp_r_a1_a_sub_shifted_oracle_32_2_404f0020() {
    // Test SUB shifted 32-bit: overflow test (oracle)
    // Encoding: 0x404F0020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x404F0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `SUB X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// overflow test (64)
#[test]
fn test_aarch32_sub_sp_r_a1_a_sub_shifted_oracle_64_2_c04f0020() {
    // Test SUB shifted 64-bit: overflow test (oracle)
    // Encoding: 0xC04F0020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xC04F0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `SUB X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// subtract from zero (32)
#[test]
fn test_aarch32_sub_sp_r_a1_a_sub_shifted_oracle_32_3_404f0020() {
    // Test SUB shifted 32-bit: subtract from zero (oracle)
    // Encoding: 0x404F0020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x404F0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `SUB X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// subtract from zero (64)
#[test]
fn test_aarch32_sub_sp_r_a1_a_sub_shifted_oracle_64_3_c04f0020() {
    // Test SUB shifted 64-bit: subtract from zero (oracle)
    // Encoding: 0xC04F0020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0xC04F0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x0000000000000001");
}

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `SUBS X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// no shift (32)
#[test]
fn test_aarch32_sub_sp_r_a1_a_subs_shifted_oracle_32_0_604f0020() {
    // Test SUBS shifted 32-bit: no shift (oracle)
    // Encoding: 0x604F0020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xA);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x604F0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x5A, "W0 should be 0x0000005A");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `SUBS X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// no shift (64)
#[test]
fn test_aarch32_sub_sp_r_a1_a_subs_shifted_oracle_64_0_e04f0020() {
    // Test SUBS shifted 64-bit: no shift (oracle)
    // Encoding: 0xE04F0020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xA);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xE04F0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x5A, "X0 should be 0x000000000000005A");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `SUBS X0, X1, X2, shift #3`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// LSL #3 (multiply by 8) (32)
#[test]
fn test_aarch32_sub_sp_r_a1_a_subs_shifted_oracle_32_1_604f0c20() {
    // Test SUBS shifted 32-bit: LSL #3 (multiply by 8) (oracle)
    // Encoding: 0x604F0C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x604F0C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x5C, "W0 should be 0x0000005C");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `SUBS X0, X1, X2, shift #3`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// LSL #3 (multiply by 8) (64)
#[test]
fn test_aarch32_sub_sp_r_a1_a_subs_shifted_oracle_64_1_e04f0c20() {
    // Test SUBS shifted 64-bit: LSL #3 (multiply by 8) (oracle)
    // Encoding: 0xE04F0C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xE04F0C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x5C, "X0 should be 0x000000000000005C");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `SUBS X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// overflow test (32)
#[test]
fn test_aarch32_sub_sp_r_a1_a_subs_shifted_oracle_32_2_604f0020() {
    // Test SUBS shifted 32-bit: overflow test (oracle)
    // Encoding: 0x604F0020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x604F0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `SUBS X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// overflow test (64)
#[test]
fn test_aarch32_sub_sp_r_a1_a_subs_shifted_oracle_64_2_e04f0020() {
    // Test SUBS shifted 64-bit: overflow test (oracle)
    // Encoding: 0xE04F0020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xE04F0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `SUBS X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// subtract from zero (32)
#[test]
fn test_aarch32_sub_sp_r_a1_a_subs_shifted_oracle_32_3_604f0020() {
    // Test SUBS shifted 32-bit: subtract from zero (oracle)
    // Encoding: 0x604F0020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x604F0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `SUBS X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// subtract from zero (64)
#[test]
fn test_aarch32_sub_sp_r_a1_a_subs_shifted_oracle_64_3_e04f0020() {
    // Test SUBS shifted 64-bit: subtract from zero (oracle)
    // Encoding: 0xE04F0020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0xE04F0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x0000000000000001");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `SUB R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple values
#[test]
fn test_aarch32_sub_sp_r_a1_a_a32_add_sub_reg_0_00410002() {
    // Test A32 SUB: simple values (oracle)
    // Encoding: 0x00410002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x32);
    let encoding: u32 = 0x00410002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x32, "R0 should be 0x00000032");
}

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `SUB R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero values
#[test]
fn test_aarch32_sub_sp_r_a1_a_a32_add_sub_reg_1_00410002() {
    // Test A32 SUB: zero values (oracle)
    // Encoding: 0x00410002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x00410002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `SUB R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max value
#[test]
fn test_aarch32_sub_sp_r_a1_a_a32_add_sub_reg_2_00410002() {
    // Test A32 SUB: max value (oracle)
    // Encoding: 0x00410002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x00410002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFE, "R0 should be 0xFFFFFFFE");
}

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `SUB R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set
#[test]
fn test_aarch32_sub_sp_r_a1_a_a32_add_sub_reg_3_00410002() {
    // Test A32 SUB: MSB set (oracle)
    // Encoding: 0x00410002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x80000000);
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0x00410002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `SUB R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// mixed pattern
#[test]
fn test_aarch32_sub_sp_r_a1_a_a32_add_sub_reg_4_00410002() {
    // Test A32 SUB: mixed pattern (oracle)
    // Encoding: 0x00410002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x9ABCDEF0);
    let encoding: u32 = 0x00410002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x77777788, "R0 should be 0x77777788");
}

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_aarch32_sub_sp_r_a1_a_flags_zeroresult_0_005d0002() {
    // Test aarch32_SUB_SP_r_A1_A flag computation: ZeroResult
    // Encoding: 0x005D0002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x005D0002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_aarch32_sub_sp_r_a1_a_flags_zeroresult_1_005d0002() {
    // Test aarch32_SUB_SP_r_A1_A flag computation: ZeroResult
    // Encoding: 0x005D0002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x005D0002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_aarch32_sub_sp_r_a1_a_flags_negativeresult_2_005d0002() {
    // Test aarch32_SUB_SP_r_A1_A flag computation: NegativeResult
    // Encoding: 0x005D0002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x005D0002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_aarch32_sub_sp_r_a1_a_flags_unsignedoverflow_3_005d0002() {
    // Test aarch32_SUB_SP_r_A1_A flag computation: UnsignedOverflow
    // Encoding: 0x005D0002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x005D0002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_aarch32_sub_sp_r_a1_a_flags_unsignedoverflow_4_005d0002() {
    // Test aarch32_SUB_SP_r_A1_A flag computation: UnsignedOverflow
    // Encoding: 0x005D0002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x005D0002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_aarch32_sub_sp_r_a1_a_flags_signedoverflow_5_005d0002() {
    // Test aarch32_SUB_SP_r_A1_A flag computation: SignedOverflow
    // Encoding: 0x005D0002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x005D0002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_aarch32_sub_sp_r_a1_a_flags_signedoverflow_6_005d0002() {
    // Test aarch32_SUB_SP_r_A1_A flag computation: SignedOverflow
    // Encoding: 0x005D0002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x005D0002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_SUB_SP_r_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_aarch32_sub_sp_r_a1_a_flags_positiveresult_7_005d0002() {
    // Test aarch32_SUB_SP_r_A1_A flag computation: PositiveResult
    // Encoding: 0x005D0002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x32);
    let encoding: u32 = 0x005D0002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SUB_SP_r_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_aarch32_sub_sp_r_t1_a_flags_zeroresult_0_ebbd0002() {
    // Test aarch32_SUB_SP_r_T1_A flag computation: ZeroResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xEBBD0002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SUB_SP_r_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_aarch32_sub_sp_r_t1_a_flags_zeroresult_1_ebbd0002() {
    // Test aarch32_SUB_SP_r_T1_A flag computation: ZeroResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0xEBBD0002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SUB_SP_r_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_aarch32_sub_sp_r_t1_a_flags_negativeresult_2_ebbd0002() {
    // Test aarch32_SUB_SP_r_T1_A flag computation: NegativeResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xEBBD0002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SUB_SP_r_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_aarch32_sub_sp_r_t1_a_flags_unsignedoverflow_3_ebbd0002() {
    // Test aarch32_SUB_SP_r_T1_A flag computation: UnsignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xEBBD0002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SUB_SP_r_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_aarch32_sub_sp_r_t1_a_flags_unsignedoverflow_4_ebbd0002() {
    // Test aarch32_SUB_SP_r_T1_A flag computation: UnsignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0xEBBD0002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SUB_SP_r_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_aarch32_sub_sp_r_t1_a_flags_signedoverflow_5_ebbd0002() {
    // Test aarch32_SUB_SP_r_T1_A flag computation: SignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0xEBBD0002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_SUB_SP_r_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_aarch32_sub_sp_r_t1_a_flags_signedoverflow_6_ebbd0002() {
    // Test aarch32_SUB_SP_r_T1_A flag computation: SignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0xEBBD0002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_SUB_SP_r_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_aarch32_sub_sp_r_t1_a_flags_positiveresult_7_ebbd0002() {
    // Test aarch32_SUB_SP_r_T1_A flag computation: PositiveResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x32);
    let encoding: u32 = 0xEBBD0002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

// ============================================================================
// aarch32_RSB_rr_A Tests
// ============================================================================

/// Provenance: aarch32_RSB_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_rsb_rr_a1_a_field_cond_0_min_10_00600010() {
    // Encoding: 0x00600010
    // Test aarch32_RSB_rr_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, type1=0, Rs=0, Rm=0, cond=0, Rd=0, S=0
    let encoding: u32 = 0x00600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_rsb_rr_a1_a_field_cond_1_poweroftwo_10_10600010() {
    // Encoding: 0x10600010
    // Test aarch32_RSB_rr_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, cond=1, Rs=0, Rn=0, type1=0, Rm=0, S=0
    let encoding: u32 = 0x10600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_rsb_rr_a1_a_field_cond_2_poweroftwo_10_20600010() {
    // Encoding: 0x20600010
    // Test aarch32_RSB_rr_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=2, Rm=0, Rs=0, type1=0, S=0, Rd=0, Rn=0
    let encoding: u32 = 0x20600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_rsb_rr_a1_a_field_cond_3_poweroftwo_10_30600010() {
    // Encoding: 0x30600010
    // Test aarch32_RSB_rr_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, cond=3, S=0, Rn=0, Rd=0, Rs=0, type1=0
    let encoding: u32 = 0x30600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_rsb_rr_a1_a_field_cond_4_poweroftwo_10_40600010() {
    // Encoding: 0x40600010
    // Test aarch32_RSB_rr_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rs=0, S=0, Rd=0, type1=0, cond=4, Rn=0, Rm=0
    let encoding: u32 = 0x40600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_rsb_rr_a1_a_field_cond_5_poweroftwo_10_50600010() {
    // Encoding: 0x50600010
    // Test aarch32_RSB_rr_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rs=0, S=0, type1=0, cond=5, Rm=0, Rn=0
    let encoding: u32 = 0x50600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_rsb_rr_a1_a_field_cond_6_poweroftwo_10_60600010() {
    // Encoding: 0x60600010
    // Test aarch32_RSB_rr_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, S=0, Rn=0, Rd=0, Rs=0, type1=0, cond=6
    let encoding: u32 = 0x60600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_rsb_rr_a1_a_field_cond_7_poweroftwo_10_70600010() {
    // Encoding: 0x70600010
    // Test aarch32_RSB_rr_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=7, Rd=0, type1=0, Rs=0, Rm=0, Rn=0, S=0
    let encoding: u32 = 0x70600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_rsb_rr_a1_a_field_cond_8_poweroftwo_10_80600010() {
    // Encoding: 0x80600010
    // Test aarch32_RSB_rr_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, S=0, Rd=0, Rm=0, cond=8, Rs=0, type1=0
    let encoding: u32 = 0x80600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_rsb_rr_a1_a_field_cond_9_poweroftwo_10_90600010() {
    // Encoding: 0x90600010
    // Test aarch32_RSB_rr_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rn=0, type1=0, Rm=0, Rs=0, cond=9, S=0
    let encoding: u32 = 0x90600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_rsb_rr_a1_a_field_cond_10_poweroftwo_10_a0600010() {
    // Encoding: 0xA0600010
    // Test aarch32_RSB_rr_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, cond=10, Rn=0, S=0, type1=0, Rs=0, Rd=0
    let encoding: u32 = 0xA0600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_rsb_rr_a1_a_field_cond_11_poweroftwo_10_b0600010() {
    // Encoding: 0xB0600010
    // Test aarch32_RSB_rr_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: Rs=0, S=0, Rm=0, cond=11, Rd=0, type1=0, Rn=0
    let encoding: u32 = 0xB0600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_rsb_rr_a1_a_field_cond_12_poweroftwo_10_c0600010() {
    // Encoding: 0xC0600010
    // Test aarch32_RSB_rr_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, S=0, cond=12, Rd=0, Rs=0, Rm=0, type1=0
    let encoding: u32 = 0xC0600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_rsb_rr_a1_a_field_cond_13_poweroftwo_10_d0600010() {
    // Encoding: 0xD0600010
    // Test aarch32_RSB_rr_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=13, Rn=0, Rd=0, Rs=0, type1=0, Rm=0, S=0
    let encoding: u32 = 0xD0600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_rsb_rr_a1_a_field_cond_14_poweroftwo_10_e0600010() {
    // Encoding: 0xE0600010
    // Test aarch32_RSB_rr_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, Rn=0, Rd=0, Rs=0, type1=0, cond=14, Rm=0
    let encoding: u32 = 0xE0600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_rsb_rr_a1_a_field_cond_15_max_10_f0600010() {
    // Encoding: 0xF0600010
    // Test aarch32_RSB_rr_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: S=0, Rd=0, Rn=0, cond=15, type1=0, Rs=0, Rm=0
    let encoding: u32 = 0xF0600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_rr_A1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_rsb_rr_a1_a_field_s_0_min_10_00600010() {
    // Encoding: 0x00600010
    // Test aarch32_RSB_rr_A1_A field S = 0 (Min)
    // ISET: A32
    // Fields: S=0, Rd=0, Rn=0, cond=0, Rs=0, type1=0, Rm=0
    let encoding: u32 = 0x00600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_rr_A1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_rsb_rr_a1_a_field_s_1_max_10_00700010() {
    // Encoding: 0x00700010
    // Test aarch32_RSB_rr_A1_A field S = 1 (Max)
    // ISET: A32
    // Fields: Rm=0, Rd=0, Rs=0, cond=0, type1=0, S=1, Rn=0
    let encoding: u32 = 0x00700010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_rr_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_rsb_rr_a1_a_field_rn_0_min_10_00600010() {
    // Encoding: 0x00600010
    // Test aarch32_RSB_rr_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: S=0, Rn=0, Rs=0, Rd=0, cond=0, type1=0, Rm=0
    let encoding: u32 = 0x00600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_rr_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_rsb_rr_a1_a_field_rn_1_poweroftwo_10_00610010() {
    // Encoding: 0x00610010
    // Test aarch32_RSB_rr_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, S=0, Rd=0, Rn=1, Rs=0, type1=0, Rm=0
    let encoding: u32 = 0x00610010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_rr_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_rsb_rr_a1_a_field_rd_0_min_10_00600010() {
    // Encoding: 0x00600010
    // Test aarch32_RSB_rr_A1_A field Rd = 0 (Min)
    // ISET: A32
    // Fields: type1=0, cond=0, Rd=0, S=0, Rm=0, Rs=0, Rn=0
    let encoding: u32 = 0x00600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_rr_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_rsb_rr_a1_a_field_rd_1_poweroftwo_10_00601010() {
    // Encoding: 0x00601010
    // Test aarch32_RSB_rr_A1_A field Rd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, S=0, Rn=0, type1=0, Rs=0, Rm=0, Rd=1
    let encoding: u32 = 0x00601010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_rr_A1_A
/// ASL: `field Rs 8 +: 4`
/// Requirement: FieldBoundary { field: "Rs", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_rsb_rr_a1_a_field_rs_0_min_10_00600010() {
    // Encoding: 0x00600010
    // Test aarch32_RSB_rr_A1_A field Rs = 0 (Min)
    // ISET: A32
    // Fields: Rs=0, S=0, Rn=0, Rm=0, cond=0, Rd=0, type1=0
    let encoding: u32 = 0x00600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_rr_A1_A
/// ASL: `field Rs 8 +: 4`
/// Requirement: FieldBoundary { field: "Rs", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_rsb_rr_a1_a_field_rs_1_poweroftwo_10_00600110() {
    // Encoding: 0x00600110
    // Test aarch32_RSB_rr_A1_A field Rs = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rn=0, cond=0, type1=0, Rs=1, Rm=0, S=0
    let encoding: u32 = 0x00600110;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_rr_A1_A
/// ASL: `field type1 5 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_rsb_rr_a1_a_field_type1_0_min_10_00600010() {
    // Encoding: 0x00600010
    // Test aarch32_RSB_rr_A1_A field type1 = 0 (Min)
    // ISET: A32
    // Fields: cond=0, S=0, type1=0, Rm=0, Rn=0, Rd=0, Rs=0
    let encoding: u32 = 0x00600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_rr_A1_A
/// ASL: `field type1 5 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_rsb_rr_a1_a_field_type1_1_poweroftwo_10_00600030() {
    // Encoding: 0x00600030
    // Test aarch32_RSB_rr_A1_A field type1 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: type1=1, S=0, Rn=0, Rd=0, cond=0, Rm=0, Rs=0
    let encoding: u32 = 0x00600030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_rr_A1_A
/// ASL: `field type1 5 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_aarch32_rsb_rr_a1_a_field_type1_3_max_10_00600070() {
    // Encoding: 0x00600070
    // Test aarch32_RSB_rr_A1_A field type1 = 3 (Max)
    // ISET: A32
    // Fields: Rm=0, cond=0, S=0, type1=3, Rd=0, Rn=0, Rs=0
    let encoding: u32 = 0x00600070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_rr_A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_rsb_rr_a1_a_field_rm_0_min_10_00600010() {
    // Encoding: 0x00600010
    // Test aarch32_RSB_rr_A1_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, Rs=0, Rn=0, S=0, cond=0, Rd=0, type1=0
    let encoding: u32 = 0x00600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_rr_A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_rsb_rr_a1_a_field_rm_1_poweroftwo_10_00600011() {
    // Encoding: 0x00600011
    // Test aarch32_RSB_rr_A1_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=1, cond=0, Rd=0, Rs=0, type1=0, S=0, Rn=0
    let encoding: u32 = 0x00600011;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_rr_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_rsb_rr_a1_a_combo_0_10_00600010() {
    // Encoding: 0x00600010
    // Test aarch32_RSB_rr_A1_A field combination: cond=0, S=0, Rn=0, Rd=0, Rs=0, type1=0, Rm=0
    // ISET: A32
    // Fields: Rs=0, type1=0, S=0, Rd=0, cond=0, Rn=0, Rm=0
    let encoding: u32 = 0x00600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_rr_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_rsb_rr_a1_a_special_cond_0_condition_eq_16_00600010() {
    // Encoding: 0x00600010
    // Test aarch32_RSB_rr_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: cond=0, Rn=0, Rm=0, S=0, Rs=0, Rd=0, type1=0
    let encoding: u32 = 0x00600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_rr_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_rsb_rr_a1_a_special_cond_1_condition_ne_16_10600010() {
    // Encoding: 0x10600010
    // Test aarch32_RSB_rr_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: S=0, Rd=0, cond=1, Rn=0, Rm=0, Rs=0, type1=0
    let encoding: u32 = 0x10600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_rr_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_rsb_rr_a1_a_special_cond_2_condition_cs_hs_16_20600010() {
    // Encoding: 0x20600010
    // Test aarch32_RSB_rr_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: Rn=0, S=0, type1=0, Rs=0, Rm=0, cond=2, Rd=0
    let encoding: u32 = 0x20600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_rr_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_rsb_rr_a1_a_special_cond_3_condition_cc_lo_16_30600010() {
    // Encoding: 0x30600010
    // Test aarch32_RSB_rr_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: Rm=0, type1=0, Rn=0, cond=3, Rd=0, Rs=0, S=0
    let encoding: u32 = 0x30600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_rr_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_rsb_rr_a1_a_special_cond_4_condition_mi_16_40600010() {
    // Encoding: 0x40600010
    // Test aarch32_RSB_rr_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: Rn=0, Rs=0, type1=0, Rm=0, Rd=0, S=0, cond=4
    let encoding: u32 = 0x40600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_rr_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_rsb_rr_a1_a_special_cond_5_condition_pl_16_50600010() {
    // Encoding: 0x50600010
    // Test aarch32_RSB_rr_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: cond=5, Rn=0, S=0, Rs=0, Rd=0, type1=0, Rm=0
    let encoding: u32 = 0x50600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_rr_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_rsb_rr_a1_a_special_cond_6_condition_vs_16_60600010() {
    // Encoding: 0x60600010
    // Test aarch32_RSB_rr_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: cond=6, Rd=0, S=0, Rn=0, Rm=0, type1=0, Rs=0
    let encoding: u32 = 0x60600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_rr_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_rsb_rr_a1_a_special_cond_7_condition_vc_16_70600010() {
    // Encoding: 0x70600010
    // Test aarch32_RSB_rr_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: Rm=0, Rd=0, S=0, Rn=0, cond=7, Rs=0, type1=0
    let encoding: u32 = 0x70600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_rr_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_rsb_rr_a1_a_special_cond_8_condition_hi_16_80600010() {
    // Encoding: 0x80600010
    // Test aarch32_RSB_rr_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: Rs=0, Rm=0, Rd=0, type1=0, S=0, cond=8, Rn=0
    let encoding: u32 = 0x80600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_rr_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_rsb_rr_a1_a_special_cond_9_condition_ls_16_90600010() {
    // Encoding: 0x90600010
    // Test aarch32_RSB_rr_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: cond=9, S=0, Rd=0, type1=0, Rs=0, Rn=0, Rm=0
    let encoding: u32 = 0x90600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_rr_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_rsb_rr_a1_a_special_cond_10_condition_ge_16_a0600010() {
    // Encoding: 0xA0600010
    // Test aarch32_RSB_rr_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: cond=10, Rn=0, Rm=0, S=0, Rd=0, Rs=0, type1=0
    let encoding: u32 = 0xA0600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_rr_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_rsb_rr_a1_a_special_cond_11_condition_lt_16_b0600010() {
    // Encoding: 0xB0600010
    // Test aarch32_RSB_rr_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: Rm=0, Rd=0, S=0, cond=11, type1=0, Rn=0, Rs=0
    let encoding: u32 = 0xB0600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_rr_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_rsb_rr_a1_a_special_cond_12_condition_gt_16_c0600010() {
    // Encoding: 0xC0600010
    // Test aarch32_RSB_rr_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: cond=12, Rn=0, S=0, Rd=0, Rs=0, type1=0, Rm=0
    let encoding: u32 = 0xC0600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_rr_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_rsb_rr_a1_a_special_cond_13_condition_le_16_d0600010() {
    // Encoding: 0xD0600010
    // Test aarch32_RSB_rr_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: Rm=0, Rn=0, type1=0, S=0, cond=13, Rd=0, Rs=0
    let encoding: u32 = 0xD0600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_rr_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_rsb_rr_a1_a_special_cond_14_condition_al_16_e0600010() {
    // Encoding: 0xE0600010
    // Test aarch32_RSB_rr_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: Rm=0, Rd=0, type1=0, Rn=0, cond=14, Rs=0, S=0
    let encoding: u32 = 0xE0600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_rr_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_rsb_rr_a1_a_special_cond_15_condition_nv_16_f0600010() {
    // Encoding: 0xF0600010
    // Test aarch32_RSB_rr_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: type1=0, Rn=0, Rs=0, Rm=0, cond=15, S=0, Rd=0
    let encoding: u32 = 0xF0600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_rr_A1_A
/// ASL: `field S = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "S", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_rsb_rr_a1_a_special_s_0_size_variant_0_16_00600010() {
    // Encoding: 0x00600010
    // Test aarch32_RSB_rr_A1_A special value S = 0 (Size variant 0)
    // ISET: A32
    // Fields: cond=0, Rd=0, Rs=0, type1=0, S=0, Rn=0, Rm=0
    let encoding: u32 = 0x00600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_rr_A1_A
/// ASL: `field S = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "S", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_rsb_rr_a1_a_special_s_1_size_variant_1_16_00700010() {
    // Encoding: 0x00700010
    // Test aarch32_RSB_rr_A1_A special value S = 1 (Size variant 1)
    // ISET: A32
    // Fields: Rd=0, Rn=0, S=1, Rs=0, cond=0, Rm=0, type1=0
    let encoding: u32 = 0x00700010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_rr_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "s" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"s\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_rsb_rr_a1_a_invalid_0_10_00600010() {
    // Encoding: 0x00600010
    // Test aarch32_RSB_rr_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "s" }) } }, rhs: LitInt(15) }
    // ISET: A32
    // Fields: cond=0, Rn=0, type1=0, S=0, Rm=0, Rs=0, Rd=0
    let encoding: u32 = 0x00600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_RSB_rr_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_rsb_rr_a1_a_invalid_1_10_00600010() {
    // Encoding: 0x00600010
    // Test aarch32_RSB_rr_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: cond=0, S=0, Rd=0, Rs=0, type1=0, Rm=0, Rn=0
    let encoding: u32 = 0x00600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_RSB_rr_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_aarch32_rsb_rr_a1_a_flags_zeroresult_0_00710012() {
    // Test aarch32_RSB_rr_A1_A flag computation: ZeroResult
    // Encoding: 0x00710012
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x00710012;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_RSB_rr_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_aarch32_rsb_rr_a1_a_flags_zeroresult_1_00710012() {
    // Test aarch32_RSB_rr_A1_A flag computation: ZeroResult
    // Encoding: 0x00710012
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x00710012;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_RSB_rr_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_aarch32_rsb_rr_a1_a_flags_negativeresult_2_00710012() {
    // Test aarch32_RSB_rr_A1_A flag computation: NegativeResult
    // Encoding: 0x00710012
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x00710012;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_RSB_rr_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_aarch32_rsb_rr_a1_a_flags_unsignedoverflow_3_00710012() {
    // Test aarch32_RSB_rr_A1_A flag computation: UnsignedOverflow
    // Encoding: 0x00710012
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x00710012;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_RSB_rr_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_aarch32_rsb_rr_a1_a_flags_unsignedoverflow_4_00710012() {
    // Test aarch32_RSB_rr_A1_A flag computation: UnsignedOverflow
    // Encoding: 0x00710012
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x00710012;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_RSB_rr_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_aarch32_rsb_rr_a1_a_flags_signedoverflow_5_00710012() {
    // Test aarch32_RSB_rr_A1_A flag computation: SignedOverflow
    // Encoding: 0x00710012
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x00710012;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_RSB_rr_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_aarch32_rsb_rr_a1_a_flags_signedoverflow_6_00710012() {
    // Test aarch32_RSB_rr_A1_A flag computation: SignedOverflow
    // Encoding: 0x00710012
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x00710012;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_RSB_rr_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_aarch32_rsb_rr_a1_a_flags_positiveresult_7_00710012() {
    // Test aarch32_RSB_rr_A1_A flag computation: PositiveResult
    // Encoding: 0x00710012
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x32);
    let encoding: u32 = 0x00710012;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

// ============================================================================
// aarch32_RSB_i_A Tests
// ============================================================================

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_rsb_i_a1_a_field_cond_0_min_0_02600000() {
    // Encoding: 0x02600000
    // Test aarch32_RSB_i_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: S=0, cond=0, Rd=0, imm12=0, Rn=0
    let encoding: u32 = 0x02600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_rsb_i_a1_a_field_cond_1_poweroftwo_0_12600000() {
    // Encoding: 0x12600000
    // Test aarch32_RSB_i_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, imm12=0, Rn=0, cond=1, Rd=0
    let encoding: u32 = 0x12600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_rsb_i_a1_a_field_cond_2_poweroftwo_0_22600000() {
    // Encoding: 0x22600000
    // Test aarch32_RSB_i_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=2, Rn=0, imm12=0, Rd=0, S=0
    let encoding: u32 = 0x22600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_rsb_i_a1_a_field_cond_3_poweroftwo_0_32600000() {
    // Encoding: 0x32600000
    // Test aarch32_RSB_i_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=3, Rn=0, imm12=0, S=0, Rd=0
    let encoding: u32 = 0x32600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_rsb_i_a1_a_field_cond_4_poweroftwo_0_42600000() {
    // Encoding: 0x42600000
    // Test aarch32_RSB_i_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=4, S=0, Rd=0, imm12=0, Rn=0
    let encoding: u32 = 0x42600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_rsb_i_a1_a_field_cond_5_poweroftwo_0_52600000() {
    // Encoding: 0x52600000
    // Test aarch32_RSB_i_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=0, Rn=0, Rd=0, S=0, cond=5
    let encoding: u32 = 0x52600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_rsb_i_a1_a_field_cond_6_poweroftwo_0_62600000() {
    // Encoding: 0x62600000
    // Test aarch32_RSB_i_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=0, S=0, Rd=0, Rn=0, cond=6
    let encoding: u32 = 0x62600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_rsb_i_a1_a_field_cond_7_poweroftwo_0_72600000() {
    // Encoding: 0x72600000
    // Test aarch32_RSB_i_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, cond=7, imm12=0, Rn=0, S=0
    let encoding: u32 = 0x72600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_rsb_i_a1_a_field_cond_8_poweroftwo_0_82600000() {
    // Encoding: 0x82600000
    // Test aarch32_RSB_i_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=8, Rn=0, Rd=0, imm12=0, S=0
    let encoding: u32 = 0x82600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_rsb_i_a1_a_field_cond_9_poweroftwo_0_92600000() {
    // Encoding: 0x92600000
    // Test aarch32_RSB_i_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, Rd=0, imm12=0, Rn=0, cond=9
    let encoding: u32 = 0x92600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_rsb_i_a1_a_field_cond_10_poweroftwo_0_a2600000() {
    // Encoding: 0xA2600000
    // Test aarch32_RSB_i_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=10, Rd=0, Rn=0, imm12=0, S=0
    let encoding: u32 = 0xA2600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_rsb_i_a1_a_field_cond_11_poweroftwo_0_b2600000() {
    // Encoding: 0xB2600000
    // Test aarch32_RSB_i_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=0, S=0, cond=11, Rn=0, Rd=0
    let encoding: u32 = 0xB2600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_rsb_i_a1_a_field_cond_12_poweroftwo_0_c2600000() {
    // Encoding: 0xC2600000
    // Test aarch32_RSB_i_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=12, Rd=0, Rn=0, imm12=0, S=0
    let encoding: u32 = 0xC2600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_rsb_i_a1_a_field_cond_13_poweroftwo_0_d2600000() {
    // Encoding: 0xD2600000
    // Test aarch32_RSB_i_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, S=0, cond=13, Rn=0, imm12=0
    let encoding: u32 = 0xD2600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_rsb_i_a1_a_field_cond_14_poweroftwo_0_e2600000() {
    // Encoding: 0xE2600000
    // Test aarch32_RSB_i_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=14, S=0, Rd=0, Rn=0, imm12=0
    let encoding: u32 = 0xE2600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_rsb_i_a1_a_field_cond_15_max_0_f2600000() {
    // Encoding: 0xF2600000
    // Test aarch32_RSB_i_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: Rn=0, Rd=0, imm12=0, cond=15, S=0
    let encoding: u32 = 0xF2600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_rsb_i_a1_a_field_s_0_min_0_02600000() {
    // Encoding: 0x02600000
    // Test aarch32_RSB_i_A1_A field S = 0 (Min)
    // ISET: A32
    // Fields: cond=0, S=0, Rd=0, imm12=0, Rn=0
    let encoding: u32 = 0x02600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_rsb_i_a1_a_field_s_1_max_0_02700000() {
    // Encoding: 0x02700000
    // Test aarch32_RSB_i_A1_A field S = 1 (Max)
    // ISET: A32
    // Fields: Rd=0, S=1, cond=0, Rn=0, imm12=0
    let encoding: u32 = 0x02700000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_rsb_i_a1_a_field_rn_0_min_0_02600000() {
    // Encoding: 0x02600000
    // Test aarch32_RSB_i_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: Rd=0, imm12=0, cond=0, S=0, Rn=0
    let encoding: u32 = 0x02600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_rsb_i_a1_a_field_rn_1_poweroftwo_0_02610000() {
    // Encoding: 0x02610000
    // Test aarch32_RSB_i_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, S=0, Rn=1, imm12=0, Rd=0
    let encoding: u32 = 0x02610000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_rsb_i_a1_a_field_rd_0_min_0_02600000() {
    // Encoding: 0x02600000
    // Test aarch32_RSB_i_A1_A field Rd = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rn=0, S=0, Rd=0, imm12=0
    let encoding: u32 = 0x02600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_rsb_i_a1_a_field_rd_1_poweroftwo_0_02601000() {
    // Encoding: 0x02601000
    // Test aarch32_RSB_i_A1_A field Rd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, Rd=1, Rn=0, imm12=0, cond=0
    let encoding: u32 = 0x02601000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_rsb_i_a1_a_field_imm12_0_zero_0_02600000() {
    // Encoding: 0x02600000
    // Test aarch32_RSB_i_A1_A field imm12 = 0 (Zero)
    // ISET: A32
    // Fields: cond=0, Rd=0, Rn=0, imm12=0, S=0
    let encoding: u32 = 0x02600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_rsb_i_a1_a_field_imm12_1_poweroftwo_0_02600001() {
    // Encoding: 0x02600001
    // Test aarch32_RSB_i_A1_A field imm12 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, S=0, Rd=0, cond=0, imm12=1
    let encoding: u32 = 0x02600001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_rsb_i_a1_a_field_imm12_3_poweroftwominusone_0_02600003() {
    // Encoding: 0x02600003
    // Test aarch32_RSB_i_A1_A field imm12 = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rn=0, S=0, cond=0, Rd=0, imm12=3
    let encoding: u32 = 0x02600003;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_rsb_i_a1_a_field_imm12_4_poweroftwo_0_02600004() {
    // Encoding: 0x02600004
    // Test aarch32_RSB_i_A1_A field imm12 = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=4, cond=0, S=0, Rn=0, Rd=0
    let encoding: u32 = 0x02600004;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_rsb_i_a1_a_field_imm12_7_poweroftwominusone_0_02600007() {
    // Encoding: 0x02600007
    // Test aarch32_RSB_i_A1_A field imm12 = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rn=0, Rd=0, cond=0, S=0, imm12=7
    let encoding: u32 = 0x02600007;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_rsb_i_a1_a_field_imm12_8_poweroftwo_0_02600008() {
    // Encoding: 0x02600008
    // Test aarch32_RSB_i_A1_A field imm12 = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, Rn=0, Rd=0, cond=0, imm12=8
    let encoding: u32 = 0x02600008;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_rsb_i_a1_a_field_imm12_15_poweroftwominusone_0_0260000f() {
    // Encoding: 0x0260000F
    // Test aarch32_RSB_i_A1_A field imm12 = 15 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rd=0, cond=0, Rn=0, S=0, imm12=15
    let encoding: u32 = 0x0260000F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_rsb_i_a1_a_field_imm12_16_poweroftwo_0_02600010() {
    // Encoding: 0x02600010
    // Test aarch32_RSB_i_A1_A field imm12 = 16 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, cond=0, imm12=16, S=0, Rn=0
    let encoding: u32 = 0x02600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_rsb_i_a1_a_field_imm12_31_poweroftwominusone_0_0260001f() {
    // Encoding: 0x0260001F
    // Test aarch32_RSB_i_A1_A field imm12 = 31 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: S=0, imm12=31, Rd=0, cond=0, Rn=0
    let encoding: u32 = 0x0260001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_rsb_i_a1_a_field_imm12_32_poweroftwo_0_02600020() {
    // Encoding: 0x02600020
    // Test aarch32_RSB_i_A1_A field imm12 = 32 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, S=0, Rd=0, Rn=0, imm12=32
    let encoding: u32 = 0x02600020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_rsb_i_a1_a_field_imm12_63_poweroftwominusone_0_0260003f() {
    // Encoding: 0x0260003F
    // Test aarch32_RSB_i_A1_A field imm12 = 63 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rd=0, S=0, Rn=0, imm12=63, cond=0
    let encoding: u32 = 0x0260003F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_rsb_i_a1_a_field_imm12_64_poweroftwo_0_02600040() {
    // Encoding: 0x02600040
    // Test aarch32_RSB_i_A1_A field imm12 = 64 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, S=0, imm12=64, Rn=0, cond=0
    let encoding: u32 = 0x02600040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 127, boundary: PowerOfTwoMinusOne }
/// 2^7 - 1 = 127
#[test]
fn test_aarch32_rsb_i_a1_a_field_imm12_127_poweroftwominusone_0_0260007f() {
    // Encoding: 0x0260007F
    // Test aarch32_RSB_i_A1_A field imm12 = 127 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rd=0, cond=0, S=0, Rn=0, imm12=127
    let encoding: u32 = 0x0260007F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_rsb_i_a1_a_field_imm12_128_poweroftwo_0_02600080() {
    // Encoding: 0x02600080
    // Test aarch32_RSB_i_A1_A field imm12 = 128 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=128, cond=0, S=0, Rn=0, Rd=0
    let encoding: u32 = 0x02600080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 255, boundary: PowerOfTwoMinusOne }
/// 2^8 - 1 = 255
#[test]
fn test_aarch32_rsb_i_a1_a_field_imm12_255_poweroftwominusone_0_026000ff() {
    // Encoding: 0x026000FF
    // Test aarch32_RSB_i_A1_A field imm12 = 255 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, Rn=0, Rd=0, imm12=255, S=0
    let encoding: u32 = 0x026000FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 256, boundary: PowerOfTwo }
/// power of 2 (2^8 = 256)
#[test]
fn test_aarch32_rsb_i_a1_a_field_imm12_256_poweroftwo_0_02600100() {
    // Encoding: 0x02600100
    // Test aarch32_RSB_i_A1_A field imm12 = 256 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=256, S=0, Rn=0, cond=0, Rd=0
    let encoding: u32 = 0x02600100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 511, boundary: PowerOfTwoMinusOne }
/// 2^9 - 1 = 511
#[test]
fn test_aarch32_rsb_i_a1_a_field_imm12_511_poweroftwominusone_0_026001ff() {
    // Encoding: 0x026001FF
    // Test aarch32_RSB_i_A1_A field imm12 = 511 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, imm12=511, S=0, Rd=0, Rn=0
    let encoding: u32 = 0x026001FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 512, boundary: PowerOfTwo }
/// power of 2 (2^9 = 512)
#[test]
fn test_aarch32_rsb_i_a1_a_field_imm12_512_poweroftwo_0_02600200() {
    // Encoding: 0x02600200
    // Test aarch32_RSB_i_A1_A field imm12 = 512 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, cond=0, S=0, Rn=0, imm12=512
    let encoding: u32 = 0x02600200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1023, boundary: PowerOfTwoMinusOne }
/// 2^10 - 1 = 1023
#[test]
fn test_aarch32_rsb_i_a1_a_field_imm12_1023_poweroftwominusone_0_026003ff() {
    // Encoding: 0x026003FF
    // Test aarch32_RSB_i_A1_A field imm12 = 1023 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, Rn=0, Rd=0, imm12=1023, S=0
    let encoding: u32 = 0x026003FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1024, boundary: PowerOfTwo }
/// power of 2 (2^10 = 1024)
#[test]
fn test_aarch32_rsb_i_a1_a_field_imm12_1024_poweroftwo_0_02600400() {
    // Encoding: 0x02600400
    // Test aarch32_RSB_i_A1_A field imm12 = 1024 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, cond=0, Rd=0, imm12=1024, Rn=0
    let encoding: u32 = 0x02600400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2047, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (2047)
#[test]
fn test_aarch32_rsb_i_a1_a_field_imm12_2047_poweroftwominusone_0_026007ff() {
    // Encoding: 0x026007FF
    // Test aarch32_RSB_i_A1_A field imm12 = 2047 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rn=0, Rd=0, imm12=2047, cond=0, S=0
    let encoding: u32 = 0x026007FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2048, boundary: PowerOfTwo }
/// power of 2 (2^11 = 2048)
#[test]
fn test_aarch32_rsb_i_a1_a_field_imm12_2048_poweroftwo_0_02600800() {
    // Encoding: 0x02600800
    // Test aarch32_RSB_i_A1_A field imm12 = 2048 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rd=0, cond=0, S=0, imm12=2048
    let encoding: u32 = 0x02600800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4095, boundary: Max }
/// maximum immediate (4095)
#[test]
fn test_aarch32_rsb_i_a1_a_field_imm12_4095_max_0_02600fff() {
    // Encoding: 0x02600FFF
    // Test aarch32_RSB_i_A1_A field imm12 = 4095 (Max)
    // ISET: A32
    // Fields: Rn=0, S=0, imm12=4095, cond=0, Rd=0
    let encoding: u32 = 0x02600FFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_rsb_i_a1_a_combo_0_0_02600000() {
    // Encoding: 0x02600000
    // Test aarch32_RSB_i_A1_A field combination: cond=0, S=0, Rn=0, Rd=0, imm12=0
    // ISET: A32
    // Fields: cond=0, Rd=0, imm12=0, Rn=0, S=0
    let encoding: u32 = 0x02600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_rsb_i_a1_a_special_cond_0_condition_eq_0_02600000() {
    // Encoding: 0x02600000
    // Test aarch32_RSB_i_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: Rd=0, S=0, cond=0, Rn=0, imm12=0
    let encoding: u32 = 0x02600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_rsb_i_a1_a_special_cond_1_condition_ne_0_12600000() {
    // Encoding: 0x12600000
    // Test aarch32_RSB_i_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: cond=1, Rd=0, S=0, imm12=0, Rn=0
    let encoding: u32 = 0x12600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_rsb_i_a1_a_special_cond_2_condition_cs_hs_0_22600000() {
    // Encoding: 0x22600000
    // Test aarch32_RSB_i_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: Rn=0, S=0, cond=2, Rd=0, imm12=0
    let encoding: u32 = 0x22600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_rsb_i_a1_a_special_cond_3_condition_cc_lo_0_32600000() {
    // Encoding: 0x32600000
    // Test aarch32_RSB_i_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: cond=3, imm12=0, Rn=0, S=0, Rd=0
    let encoding: u32 = 0x32600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_rsb_i_a1_a_special_cond_4_condition_mi_0_42600000() {
    // Encoding: 0x42600000
    // Test aarch32_RSB_i_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: cond=4, S=0, Rn=0, imm12=0, Rd=0
    let encoding: u32 = 0x42600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_rsb_i_a1_a_special_cond_5_condition_pl_0_52600000() {
    // Encoding: 0x52600000
    // Test aarch32_RSB_i_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: S=0, Rd=0, cond=5, imm12=0, Rn=0
    let encoding: u32 = 0x52600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_rsb_i_a1_a_special_cond_6_condition_vs_0_62600000() {
    // Encoding: 0x62600000
    // Test aarch32_RSB_i_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: cond=6, Rn=0, imm12=0, S=0, Rd=0
    let encoding: u32 = 0x62600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_rsb_i_a1_a_special_cond_7_condition_vc_0_72600000() {
    // Encoding: 0x72600000
    // Test aarch32_RSB_i_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: S=0, Rn=0, cond=7, Rd=0, imm12=0
    let encoding: u32 = 0x72600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_rsb_i_a1_a_special_cond_8_condition_hi_0_82600000() {
    // Encoding: 0x82600000
    // Test aarch32_RSB_i_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: Rd=0, imm12=0, S=0, cond=8, Rn=0
    let encoding: u32 = 0x82600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_rsb_i_a1_a_special_cond_9_condition_ls_0_92600000() {
    // Encoding: 0x92600000
    // Test aarch32_RSB_i_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: Rd=0, Rn=0, imm12=0, cond=9, S=0
    let encoding: u32 = 0x92600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_rsb_i_a1_a_special_cond_10_condition_ge_0_a2600000() {
    // Encoding: 0xA2600000
    // Test aarch32_RSB_i_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: cond=10, imm12=0, Rn=0, S=0, Rd=0
    let encoding: u32 = 0xA2600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_rsb_i_a1_a_special_cond_11_condition_lt_0_b2600000() {
    // Encoding: 0xB2600000
    // Test aarch32_RSB_i_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: Rd=0, cond=11, Rn=0, imm12=0, S=0
    let encoding: u32 = 0xB2600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_rsb_i_a1_a_special_cond_12_condition_gt_0_c2600000() {
    // Encoding: 0xC2600000
    // Test aarch32_RSB_i_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: cond=12, Rd=0, S=0, Rn=0, imm12=0
    let encoding: u32 = 0xC2600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_rsb_i_a1_a_special_cond_13_condition_le_0_d2600000() {
    // Encoding: 0xD2600000
    // Test aarch32_RSB_i_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: S=0, imm12=0, cond=13, Rn=0, Rd=0
    let encoding: u32 = 0xD2600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_rsb_i_a1_a_special_cond_14_condition_al_0_e2600000() {
    // Encoding: 0xE2600000
    // Test aarch32_RSB_i_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: cond=14, Rn=0, Rd=0, imm12=0, S=0
    let encoding: u32 = 0xE2600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_rsb_i_a1_a_special_cond_15_condition_nv_0_f2600000() {
    // Encoding: 0xF2600000
    // Test aarch32_RSB_i_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: cond=15, Rn=0, S=0, imm12=0, Rd=0
    let encoding: u32 = 0xF2600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `field S = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "S", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_rsb_i_a1_a_special_s_0_size_variant_0_0_02600000() {
    // Encoding: 0x02600000
    // Test aarch32_RSB_i_A1_A special value S = 0 (Size variant 0)
    // ISET: A32
    // Fields: imm12=0, cond=0, Rn=0, Rd=0, S=0
    let encoding: u32 = 0x02600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `field S = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "S", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_rsb_i_a1_a_special_s_1_size_variant_1_0_02700000() {
    // Encoding: 0x02700000
    // Test aarch32_RSB_i_A1_A special value S = 1 (Size variant 1)
    // ISET: A32
    // Fields: Rn=0, S=1, Rd=0, imm12=0, cond=0
    let encoding: u32 = 0x02700000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_i_T1_A
/// ASL: `field Rn 19 +: 3`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_rsb_i_t1_a_field_rn_0_min_0_42400000() {
    // Thumb encoding (32): 0x42400000
    // Test aarch32_RSB_i_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x42400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_RSB_i_T1_A
/// ASL: `field Rn 19 +: 3`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_rsb_i_t1_a_field_rn_1_poweroftwo_0_42480000() {
    // Thumb encoding (32): 0x42480000
    // Test aarch32_RSB_i_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rd=0, Rn=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x42480000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_RSB_i_T1_A
/// ASL: `field Rd 16 +: 3`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_rsb_i_t1_a_field_rd_0_min_0_42400000() {
    // Thumb encoding (32): 0x42400000
    // Test aarch32_RSB_i_T1_A field Rd = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x42400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_RSB_i_T1_A
/// ASL: `field Rd 16 +: 3`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_rsb_i_t1_a_field_rd_1_poweroftwo_0_42410000() {
    // Thumb encoding (32): 0x42410000
    // Test aarch32_RSB_i_T1_A field Rd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rd=1, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x42410000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_RSB_i_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_rsb_i_t1_a_combo_0_0_42400000() {
    // Thumb encoding (32): 0x42400000
    // Test aarch32_RSB_i_T1_A field combination: Rn=0, Rd=0
    // ISET: T32
    // Fields: Rd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x42400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `field i 26 +: 1`
/// Requirement: FieldBoundary { field: "i", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_rsb_i_t2_a_field_i_0_min_0_f1c00000() {
    // Thumb encoding (32): 0xF1C00000
    // Test aarch32_RSB_i_T2_A field i = 0 (Min)
    // ISET: T32
    // Fields: Rd=0, imm3=0, Rn=0, i=0, imm8=0, S=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1C00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `field i 26 +: 1`
/// Requirement: FieldBoundary { field: "i", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_rsb_i_t2_a_field_i_1_max_0_f5c00000() {
    // Thumb encoding (32): 0xF5C00000
    // Test aarch32_RSB_i_T2_A field i = 1 (Max)
    // ISET: T32
    // Fields: Rd=0, S=0, Rn=0, i=1, imm3=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF5C00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_rsb_i_t2_a_field_s_0_min_0_f1c00000() {
    // Thumb encoding (32): 0xF1C00000
    // Test aarch32_RSB_i_T2_A field S = 0 (Min)
    // ISET: T32
    // Fields: imm8=0, S=0, Rn=0, i=0, imm3=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1C00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_rsb_i_t2_a_field_s_1_max_0_f1d00000() {
    // Thumb encoding (32): 0xF1D00000
    // Test aarch32_RSB_i_T2_A field S = 1 (Max)
    // ISET: T32
    // Fields: i=0, S=1, Rd=0, imm8=0, Rn=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1D00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_rsb_i_t2_a_field_rn_0_min_0_f1c00000() {
    // Thumb encoding (32): 0xF1C00000
    // Test aarch32_RSB_i_T2_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: i=0, S=0, Rn=0, imm3=0, Rd=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1C00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_rsb_i_t2_a_field_rn_1_poweroftwo_0_f1c10000() {
    // Thumb encoding (32): 0xF1C10000
    // Test aarch32_RSB_i_T2_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=0, S=0, i=0, Rd=0, Rn=1, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1C10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_rsb_i_t2_a_field_imm3_0_zero_0_f1c00000() {
    // Thumb encoding (32): 0xF1C00000
    // Test aarch32_RSB_i_T2_A field imm3 = 0 (Zero)
    // ISET: T32
    // Fields: i=0, S=0, imm8=0, Rd=0, Rn=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1C00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_rsb_i_t2_a_field_imm3_1_poweroftwo_0_f1c01000() {
    // Thumb encoding (32): 0xF1C01000
    // Test aarch32_RSB_i_T2_A field imm3 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: S=0, imm3=1, imm8=0, Rn=0, i=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1C01000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 3, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (3)
#[test]
fn test_aarch32_rsb_i_t2_a_field_imm3_3_poweroftwominusone_0_f1c03000() {
    // Thumb encoding (32): 0xF1C03000
    // Test aarch32_RSB_i_T2_A field imm3 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm3=3, Rn=0, Rd=0, S=0, i=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1C03000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 7, boundary: Max }
/// maximum immediate (7)
#[test]
fn test_aarch32_rsb_i_t2_a_field_imm3_7_max_0_f1c07000() {
    // Thumb encoding (32): 0xF1C07000
    // Test aarch32_RSB_i_T2_A field imm3 = 7 (Max)
    // ISET: T32
    // Fields: i=0, Rd=0, imm8=0, imm3=7, Rn=0, S=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1C07000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_rsb_i_t2_a_field_rd_0_min_0_f1c00000() {
    // Thumb encoding (32): 0xF1C00000
    // Test aarch32_RSB_i_T2_A field Rd = 0 (Min)
    // ISET: T32
    // Fields: S=0, i=0, imm3=0, imm8=0, Rn=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1C00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_rsb_i_t2_a_field_rd_1_poweroftwo_0_f1c00100() {
    // Thumb encoding (32): 0xF1C00100
    // Test aarch32_RSB_i_T2_A field Rd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, S=0, imm3=0, Rd=1, imm8=0, i=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1C00100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_rsb_i_t2_a_field_imm8_0_zero_0_f1c00000() {
    // Thumb encoding (32): 0xF1C00000
    // Test aarch32_RSB_i_T2_A field imm8 = 0 (Zero)
    // ISET: T32
    // Fields: i=0, Rd=0, S=0, imm8=0, Rn=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1C00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_rsb_i_t2_a_field_imm8_1_poweroftwo_0_f1c00001() {
    // Thumb encoding (32): 0xF1C00001
    // Test aarch32_RSB_i_T2_A field imm8 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: S=0, i=0, Rn=0, imm3=0, Rd=0, imm8=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1C00001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_rsb_i_t2_a_field_imm8_3_poweroftwominusone_0_f1c00003() {
    // Thumb encoding (32): 0xF1C00003
    // Test aarch32_RSB_i_T2_A field imm8 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: i=0, imm8=3, S=0, Rn=0, Rd=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1C00003;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_rsb_i_t2_a_field_imm8_4_poweroftwo_0_f1c00004() {
    // Thumb encoding (32): 0xF1C00004
    // Test aarch32_RSB_i_T2_A field imm8 = 4 (PowerOfTwo)
    // ISET: T32
    // Fields: imm3=0, Rd=0, Rn=0, imm8=4, i=0, S=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1C00004;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_rsb_i_t2_a_field_imm8_7_poweroftwominusone_0_f1c00007() {
    // Thumb encoding (32): 0xF1C00007
    // Test aarch32_RSB_i_T2_A field imm8 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm8=7, Rn=0, S=0, i=0, imm3=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1C00007;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_rsb_i_t2_a_field_imm8_8_poweroftwo_0_f1c00008() {
    // Thumb encoding (32): 0xF1C00008
    // Test aarch32_RSB_i_T2_A field imm8 = 8 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, imm3=0, i=0, S=0, Rd=0, imm8=8
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1C00008;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_rsb_i_t2_a_field_imm8_15_poweroftwominusone_0_f1c0000f() {
    // Thumb encoding (32): 0xF1C0000F
    // Test aarch32_RSB_i_T2_A field imm8 = 15 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rd=0, imm3=0, imm8=15, i=0, S=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1C0000F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_rsb_i_t2_a_field_imm8_16_poweroftwo_0_f1c00010() {
    // Thumb encoding (32): 0xF1C00010
    // Test aarch32_RSB_i_T2_A field imm8 = 16 (PowerOfTwo)
    // ISET: T32
    // Fields: Rd=0, imm8=16, i=0, Rn=0, imm3=0, S=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1C00010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_rsb_i_t2_a_field_imm8_31_poweroftwominusone_0_f1c0001f() {
    // Thumb encoding (32): 0xF1C0001F
    // Test aarch32_RSB_i_T2_A field imm8 = 31 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rd=0, imm3=0, Rn=0, imm8=31, i=0, S=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1C0001F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_rsb_i_t2_a_field_imm8_32_poweroftwo_0_f1c00020() {
    // Thumb encoding (32): 0xF1C00020
    // Test aarch32_RSB_i_T2_A field imm8 = 32 (PowerOfTwo)
    // ISET: T32
    // Fields: S=0, i=0, imm8=32, Rd=0, Rn=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1C00020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_rsb_i_t2_a_field_imm8_63_poweroftwominusone_0_f1c0003f() {
    // Thumb encoding (32): 0xF1C0003F
    // Test aarch32_RSB_i_T2_A field imm8 = 63 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rd=0, i=0, imm8=63, S=0, Rn=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1C0003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_rsb_i_t2_a_field_imm8_64_poweroftwo_0_f1c00040() {
    // Thumb encoding (32): 0xF1C00040
    // Test aarch32_RSB_i_T2_A field imm8 = 64 (PowerOfTwo)
    // ISET: T32
    // Fields: Rd=0, imm8=64, i=0, Rn=0, S=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1C00040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 127, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (127)
#[test]
fn test_aarch32_rsb_i_t2_a_field_imm8_127_poweroftwominusone_0_f1c0007f() {
    // Thumb encoding (32): 0xF1C0007F
    // Test aarch32_RSB_i_T2_A field imm8 = 127 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm3=0, Rd=0, imm8=127, Rn=0, i=0, S=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1C0007F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_rsb_i_t2_a_field_imm8_128_poweroftwo_0_f1c00080() {
    // Thumb encoding (32): 0xF1C00080
    // Test aarch32_RSB_i_T2_A field imm8 = 128 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=128, imm3=0, i=0, S=0, Rn=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1C00080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 255, boundary: Max }
/// maximum immediate (255)
#[test]
fn test_aarch32_rsb_i_t2_a_field_imm8_255_max_0_f1c000ff() {
    // Thumb encoding (32): 0xF1C000FF
    // Test aarch32_RSB_i_T2_A field imm8 = 255 (Max)
    // ISET: T32
    // Fields: imm3=0, Rd=0, Rn=0, imm8=255, i=0, S=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1C000FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// i=0 (minimum value)
#[test]
fn test_aarch32_rsb_i_t2_a_combo_0_0_f1c00000() {
    // Thumb encoding (32): 0xF1C00000
    // Test aarch32_RSB_i_T2_A field combination: i=0, S=0, Rn=0, imm3=0, Rd=0, imm8=0
    // ISET: T32
    // Fields: Rn=0, imm3=0, Rd=0, S=0, i=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1C00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `field S = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "S", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_rsb_i_t2_a_special_s_0_size_variant_0_0_f1c00000() {
    // Thumb encoding (32): 0xF1C00000
    // Test aarch32_RSB_i_T2_A special value S = 0 (Size variant 0)
    // ISET: T32
    // Fields: S=0, Rn=0, imm3=0, Rd=0, i=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1C00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `field S = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "S", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_rsb_i_t2_a_special_s_1_size_variant_1_0_f1d00000() {
    // Thumb encoding (32): 0xF1D00000
    // Test aarch32_RSB_i_T2_A special value S = 1 (Size variant 1)
    // ISET: T32
    // Fields: imm3=0, i=0, Rn=0, S=1, imm8=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1D00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_rsb_i_t2_a_invalid_0_0_f1c00000() {
    // Thumb encoding (32): 0xF1C00000
    // Test aarch32_RSB_i_T2_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }
    // ISET: T32
    // Fields: Rn=0, imm3=0, i=0, imm8=0, S=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1C00000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_rsb_i_t2_a_invalid_1_0_f1c00000() {
    // Thumb encoding (32): 0xF1C00000
    // Test aarch32_RSB_i_T2_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: S=0, i=0, Rn=0, imm8=0, Rd=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1C00000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `ADD X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_rsb_i_a1_a_add_oracle_32_0_02602820() {
    // Test ADD 32-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0x02602820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x02602820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80A064, "W0 should be 0x80A064");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `ADD X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_rsb_i_a1_a_add_oracle_64_0_82602820() {
    // Test ADD 64-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0x82602820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x82602820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80A064, "X0 should be 0x000000000080A064");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `ADD X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero operands (32)
#[test]
fn test_aarch32_rsb_i_a1_a_add_oracle_32_1_02600020() {
    // Test ADD 32-bit: zero operands (with oracle verification)
    // Encoding: 0x02600020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x02600020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x800000, "W0 should be 0x800000");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `ADD X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero operands (64)
#[test]
fn test_aarch32_rsb_i_a1_a_add_oracle_64_1_82600020() {
    // Test ADD 64-bit: zero operands (with oracle verification)
    // Encoding: 0x82600020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x82600020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x800000, "X0 should be 0x0000000000800000");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small values (32)
#[test]
fn test_aarch32_rsb_i_a1_a_add_oracle_32_2_02600420() {
    // Test ADD 32-bit: small values (with oracle verification)
    // Encoding: 0x02600420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x02600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x801001, "W0 should be 0x801001");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// small values (64)
#[test]
fn test_aarch32_rsb_i_a1_a_add_oracle_64_2_82600420() {
    // Test ADD 64-bit: small values (with oracle verification)
    // Encoding: 0x82600420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x82600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x801001, "X0 should be 0x0000000000801001");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `ADD X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_rsb_i_a1_a_add_oracle_32_3_027ffc20() {
    // Test ADD 32-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0x027FFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x027FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF000, "W0 should be 0xFFF000");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `ADD X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_rsb_i_a1_a_add_oracle_64_3_827ffc20() {
    // Test ADD 64-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0x827FFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x827FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF000, "X0 should be 0x0000000000FFF000");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `ADD X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_rsb_i_a1_a_add_oracle_32_4_027ffc20() {
    // Test ADD 32-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0x027FFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x027FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF000, "W0 should be 0xFFF000");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `ADD X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_rsb_i_a1_a_add_oracle_64_4_827ffc20() {
    // Test ADD 64-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0x827FFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x827FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF000, "X0 should be 0x0000000000FFF000");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max u64 operand (32)
#[test]
fn test_aarch32_rsb_i_a1_a_add_oracle_32_5_02600420() {
    // Test ADD 32-bit: max u64 operand (with oracle verification)
    // Encoding: 0x02600420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x02600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x800FFF, "W0 should be 0x800FFF");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max u64 operand (64)
#[test]
fn test_aarch32_rsb_i_a1_a_add_oracle_64_5_82600420() {
    // Test ADD 64-bit: max u64 operand (with oracle verification)
    // Encoding: 0x82600420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x82600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x800FFF, "X0 should be 0x0000000000800FFF");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_rsb_i_a1_a_add_oracle_32_6_02600420() {
    // Test ADD 32-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0x02600420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x02600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x801000, "W0 should be 0x801000");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_rsb_i_a1_a_add_oracle_64_6_82600420() {
    // Test ADD 64-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0x82600420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x82600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x801000, "X0 should be 0x0000000000801000");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_rsb_i_a1_a_add_oracle_32_7_02600420() {
    // Test ADD 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0x02600420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x02600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x800FFF, "W0 should be 0x800FFF");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_rsb_i_a1_a_add_oracle_64_7_82600420() {
    // Test ADD 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0x82600420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x82600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x800FFF, "X0 should be 0x8000000000800FFF");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_rsb_i_a1_a_add_oracle_32_8_02600420() {
    // Test ADD 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0x02600420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x02600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80800FFF, "W0 should be 0x80800FFF");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_rsb_i_a1_a_add_oracle_64_8_82600420() {
    // Test ADD 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0x82600420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x82600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x80800FFF,
        "X0 should be 0x0000000080800FFF"
    );
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_rsb_i_a1_a_add_oracle_32_9_02600420() {
    // Test ADD 32-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0x02600420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x02600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x800FFF, "W0 should be 0x800FFF");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_rsb_i_a1_a_add_oracle_64_9_82600420() {
    // Test ADD 64-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0x82600420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x82600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x800FFF, "X0 should be 0x0000000000800FFF");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_rsb_i_a1_a_add_oracle_32_10_02600420() {
    // Test ADD 32-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0x02600420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x02600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x800FFF, "W0 should be 0x800FFF");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_rsb_i_a1_a_add_oracle_64_10_82600420() {
    // Test ADD 64-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0x82600420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x82600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x800FFF, "X0 should be 0x0000000100800FFF");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `ADD SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (32)
#[test]
fn test_aarch32_rsb_i_a1_a_add_oracle_32_rd31_sp_0260283f() {
    // Test ADD 32-bit with Rd=31 (SP)
    // Encoding: 0x0260283F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x0260283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    // TODO: assertion - TestAssertion { check: Sp, expected: U64(8429668), message: "SP should be 0x80A064" }
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `ADD SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (64)
#[test]
fn test_aarch32_rsb_i_a1_a_add_oracle_64_rd31_sp_8260283f() {
    // Test ADD 64-bit with Rd=31 (SP)
    // Encoding: 0x8260283F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x8260283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    // TODO: assertion - TestAssertion { check: Sp, expected: U64(8429668), message: "SP should be 0x80A064" }
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `ADDS X0, X1, #10`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_rsb_i_a1_a_adds_oracle_32_0_22602820() {
    // Test ADDS 32-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0x22602820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x22602820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80A064, "W0 should be 0x80A064");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `ADDS X0, X1, #10`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_rsb_i_a1_a_adds_oracle_64_0_a2602820() {
    // Test ADDS 64-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0xA2602820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xA2602820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80A064, "X0 should be 0x000000000080A064");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `ADDS X0, X1, #0`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero operands (32)
#[test]
fn test_aarch32_rsb_i_a1_a_adds_oracle_32_1_22600020() {
    // Test ADDS 32-bit: zero operands (with oracle verification)
    // Encoding: 0x22600020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x22600020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x800000, "W0 should be 0x800000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `ADDS X0, X1, #0`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero operands (64)
#[test]
fn test_aarch32_rsb_i_a1_a_adds_oracle_64_1_a2600020() {
    // Test ADDS 64-bit: zero operands (with oracle verification)
    // Encoding: 0xA2600020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xA2600020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x800000, "X0 should be 0x0000000000800000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// small values (32)
#[test]
fn test_aarch32_rsb_i_a1_a_adds_oracle_32_2_22600420() {
    // Test ADDS 32-bit: small values (with oracle verification)
    // Encoding: 0x22600420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x22600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x801001, "W0 should be 0x801001");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// small values (64)
#[test]
fn test_aarch32_rsb_i_a1_a_adds_oracle_64_2_a2600420() {
    // Test ADDS 64-bit: small values (with oracle verification)
    // Encoding: 0xA2600420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xA2600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x801001, "X0 should be 0x0000000000801001");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `ADDS X0, X1, #4095`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_rsb_i_a1_a_adds_oracle_32_3_227ffc20() {
    // Test ADDS 32-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0x227FFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x227FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF000, "W0 should be 0xFFF000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `ADDS X0, X1, #4095`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_rsb_i_a1_a_adds_oracle_64_3_a27ffc20() {
    // Test ADDS 64-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0xA27FFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xA27FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF000, "X0 should be 0x0000000000FFF000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `ADDS X0, X1, #4095, LSL #12`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_rsb_i_a1_a_adds_oracle_32_4_227ffc20() {
    // Test ADDS 32-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0x227FFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x227FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF000, "W0 should be 0xFFF000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `ADDS X0, X1, #4095, LSL #12`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_rsb_i_a1_a_adds_oracle_64_4_a27ffc20() {
    // Test ADDS 64-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0xA27FFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xA27FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF000, "X0 should be 0x0000000000FFF000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max u64 operand (32)
#[test]
fn test_aarch32_rsb_i_a1_a_adds_oracle_32_5_22600420() {
    // Test ADDS 32-bit: max u64 operand (with oracle verification)
    // Encoding: 0x22600420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x22600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x800FFF, "W0 should be 0x800FFF");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max u64 operand (64)
#[test]
fn test_aarch32_rsb_i_a1_a_adds_oracle_64_5_a2600420() {
    // Test ADDS 64-bit: max u64 operand (with oracle verification)
    // Encoding: 0xA2600420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xA2600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x800FFF, "X0 should be 0x0000000000800FFF");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_rsb_i_a1_a_adds_oracle_32_6_22600420() {
    // Test ADDS 32-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0x22600420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x22600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x801000, "W0 should be 0x801000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_rsb_i_a1_a_adds_oracle_64_6_a2600420() {
    // Test ADDS 64-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0xA2600420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xA2600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x801000, "X0 should be 0x0000000000801000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_rsb_i_a1_a_adds_oracle_32_7_22600420() {
    // Test ADDS 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0x22600420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x22600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x800FFF, "W0 should be 0x800FFF");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_rsb_i_a1_a_adds_oracle_64_7_a2600420() {
    // Test ADDS 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0xA2600420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xA2600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x800FFF, "X0 should be 0x8000000000800FFF");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, true, "V flag should be true");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_rsb_i_a1_a_adds_oracle_32_8_22600420() {
    // Test ADDS 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0x22600420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x22600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80800FFF, "W0 should be 0x80800FFF");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, true, "V flag should be true");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_rsb_i_a1_a_adds_oracle_64_8_a2600420() {
    // Test ADDS 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0xA2600420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xA2600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x80800FFF,
        "X0 should be 0x0000000080800FFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_rsb_i_a1_a_adds_oracle_32_9_22600420() {
    // Test ADDS 32-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0x22600420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x22600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x800FFF, "W0 should be 0x800FFF");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_rsb_i_a1_a_adds_oracle_64_9_a2600420() {
    // Test ADDS 64-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0xA2600420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xA2600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x800FFF, "X0 should be 0x0000000000800FFF");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_rsb_i_a1_a_adds_oracle_32_10_22600420() {
    // Test ADDS 32-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0x22600420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x22600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x800FFF, "W0 should be 0x800FFF");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_rsb_i_a1_a_adds_oracle_64_10_a2600420() {
    // Test ADDS 64-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0xA2600420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xA2600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x800FFF, "X0 should be 0x0000000100800FFF");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `ADDS ZR, X1, #10`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "result discarded, flags set" }
/// ZR destination (32)
#[test]
fn test_aarch32_rsb_i_a1_a_adds_oracle_32_rd31_zr_2260283f() {
    // Test ADDS 32-bit with Rd=31 (ZR)
    // Encoding: 0x2260283F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x2260283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `ADDS ZR, X1, #10`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "result discarded, flags set" }
/// ZR destination (64)
#[test]
fn test_aarch32_rsb_i_a1_a_adds_oracle_64_rd31_zr_a260283f() {
    // Test ADDS 64-bit with Rd=31 (ZR)
    // Encoding: 0xA260283F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xA260283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `SUB X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_rsb_i_a1_a_sub_oracle_32_0_42602820() {
    // Test SUB 32-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0x42602820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x42602820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF7F6064, "W0 should be 0xFF7F6064");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `SUB X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_rsb_i_a1_a_sub_oracle_64_0_c2602820() {
    // Test SUB 64-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0xC2602820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xC2602820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF7F6064,
        "X0 should be 0xFFFFFFFFFF7F6064"
    );
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `SUB X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero operands (32)
#[test]
fn test_aarch32_rsb_i_a1_a_sub_oracle_32_1_42600020() {
    // Test SUB 32-bit: zero operands (with oracle verification)
    // Encoding: 0x42600020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x42600020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF800000, "W0 should be 0xFF800000");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `SUB X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero operands (64)
#[test]
fn test_aarch32_rsb_i_a1_a_sub_oracle_64_1_c2600020() {
    // Test SUB 64-bit: zero operands (with oracle verification)
    // Encoding: 0xC2600020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xC2600020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF800000,
        "X0 should be 0xFFFFFFFFFF800000"
    );
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small values (32)
#[test]
fn test_aarch32_rsb_i_a1_a_sub_oracle_32_2_42600420() {
    // Test SUB 32-bit: small values (with oracle verification)
    // Encoding: 0x42600420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x42600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF7FF001, "W0 should be 0xFF7FF001");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// small values (64)
#[test]
fn test_aarch32_rsb_i_a1_a_sub_oracle_64_2_c2600420() {
    // Test SUB 64-bit: small values (with oracle verification)
    // Encoding: 0xC2600420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xC2600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF7FF001,
        "X0 should be 0xFFFFFFFFFF7FF001"
    );
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `SUB X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_rsb_i_a1_a_sub_oracle_32_3_427ffc20() {
    // Test SUB 32-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0x427FFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x427FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF001000, "W0 should be 0xFF001000");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `SUB X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_rsb_i_a1_a_sub_oracle_64_3_c27ffc20() {
    // Test SUB 64-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0xC27FFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xC27FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `SUB X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_rsb_i_a1_a_sub_oracle_32_4_427ffc20() {
    // Test SUB 32-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0x427FFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x427FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF001000, "W0 should be 0xFF001000");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `SUB X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_rsb_i_a1_a_sub_oracle_64_4_c27ffc20() {
    // Test SUB 64-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0xC27FFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xC27FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max u64 operand (32)
#[test]
fn test_aarch32_rsb_i_a1_a_sub_oracle_32_5_42600420() {
    // Test SUB 32-bit: max u64 operand (with oracle verification)
    // Encoding: 0x42600420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x42600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF7FEFFF, "W0 should be 0xFF7FEFFF");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max u64 operand (64)
#[test]
fn test_aarch32_rsb_i_a1_a_sub_oracle_64_5_c2600420() {
    // Test SUB 64-bit: max u64 operand (with oracle verification)
    // Encoding: 0xC2600420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xC2600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF7FEFFF,
        "X0 should be 0xFFFFFFFFFF7FEFFF"
    );
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_rsb_i_a1_a_sub_oracle_32_6_42600420() {
    // Test SUB 32-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0x42600420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x42600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF7FF000, "W0 should be 0xFF7FF000");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_rsb_i_a1_a_sub_oracle_64_6_c2600420() {
    // Test SUB 64-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0xC2600420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xC2600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF7FF000,
        "X0 should be 0xFFFFFFFFFF7FF000"
    );
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_rsb_i_a1_a_sub_oracle_32_7_42600420() {
    // Test SUB 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0x42600420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x42600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF7FEFFF, "W0 should be 0xFF7FEFFF");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_rsb_i_a1_a_sub_oracle_64_7_c2600420() {
    // Test SUB 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0xC2600420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xC2600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF7FEFFF,
        "X0 should be 0x7FFFFFFFFF7FEFFF"
    );
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_rsb_i_a1_a_sub_oracle_32_8_42600420() {
    // Test SUB 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0x42600420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x42600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7F7FEFFF, "W0 should be 0x7F7FEFFF");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_rsb_i_a1_a_sub_oracle_64_8_c2600420() {
    // Test SUB 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0xC2600420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xC2600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x7F7FEFFF,
        "X0 should be 0x000000007F7FEFFF"
    );
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_rsb_i_a1_a_sub_oracle_32_9_42600420() {
    // Test SUB 32-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0x42600420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x42600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF7FEFFF, "W0 should be 0xFF7FEFFF");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_rsb_i_a1_a_sub_oracle_64_9_c2600420() {
    // Test SUB 64-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0xC2600420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xC2600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF7FEFFF,
        "X0 should be 0xFFFFFFFFFF7FEFFF"
    );
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_rsb_i_a1_a_sub_oracle_32_10_42600420() {
    // Test SUB 32-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0x42600420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x42600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF7FEFFF, "W0 should be 0xFF7FEFFF");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_rsb_i_a1_a_sub_oracle_64_10_c2600420() {
    // Test SUB 64-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0xC2600420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xC2600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF7FEFFF,
        "X0 should be 0x00000000FF7FEFFF"
    );
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `SUB SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (32)
#[test]
fn test_aarch32_rsb_i_a1_a_sub_oracle_32_rd31_sp_4260283f() {
    // Test SUB 32-bit with Rd=31 (SP)
    // Encoding: 0x4260283F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x4260283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    // TODO: assertion - TestAssertion { check: Sp, expected: U64(4286537828), message: "SP should be 0xFF7F6064" }
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `SUB SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (64)
#[test]
fn test_aarch32_rsb_i_a1_a_sub_oracle_64_rd31_sp_c260283f() {
    // Test SUB 64-bit with Rd=31 (SP)
    // Encoding: 0xC260283F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xC260283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    // TODO: assertion - TestAssertion { check: Sp, expected: U64(18446744073701122148), message: "SP should be 0xFFFFFFFFFF7F6064" }
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `SUBS X0, X1, #10`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_rsb_i_a1_a_subs_oracle_32_0_62602820() {
    // Test SUBS 32-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0x62602820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x62602820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF7F6064, "W0 should be 0xFF7F6064");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `SUBS X0, X1, #10`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_rsb_i_a1_a_subs_oracle_64_0_e2602820() {
    // Test SUBS 64-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0xE2602820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xE2602820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF7F6064,
        "X0 should be 0xFFFFFFFFFF7F6064"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `SUBS X0, X1, #0`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero operands (32)
#[test]
fn test_aarch32_rsb_i_a1_a_subs_oracle_32_1_62600020() {
    // Test SUBS 32-bit: zero operands (with oracle verification)
    // Encoding: 0x62600020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x62600020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF800000, "W0 should be 0xFF800000");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `SUBS X0, X1, #0`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero operands (64)
#[test]
fn test_aarch32_rsb_i_a1_a_subs_oracle_64_1_e2600020() {
    // Test SUBS 64-bit: zero operands (with oracle verification)
    // Encoding: 0xE2600020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xE2600020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF800000,
        "X0 should be 0xFFFFFFFFFF800000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// small values (32)
#[test]
fn test_aarch32_rsb_i_a1_a_subs_oracle_32_2_62600420() {
    // Test SUBS 32-bit: small values (with oracle verification)
    // Encoding: 0x62600420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x62600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF7FF001, "W0 should be 0xFF7FF001");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// small values (64)
#[test]
fn test_aarch32_rsb_i_a1_a_subs_oracle_64_2_e2600420() {
    // Test SUBS 64-bit: small values (with oracle verification)
    // Encoding: 0xE2600420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xE2600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF7FF001,
        "X0 should be 0xFFFFFFFFFF7FF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `SUBS X0, X1, #4095`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_rsb_i_a1_a_subs_oracle_32_3_627ffc20() {
    // Test SUBS 32-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0x627FFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x627FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF001000, "W0 should be 0xFF001000");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `SUBS X0, X1, #4095`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_rsb_i_a1_a_subs_oracle_64_3_e27ffc20() {
    // Test SUBS 64-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0xE27FFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xE27FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `SUBS X0, X1, #4095, LSL #12`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_rsb_i_a1_a_subs_oracle_32_4_627ffc20() {
    // Test SUBS 32-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0x627FFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x627FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF001000, "W0 should be 0xFF001000");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `SUBS X0, X1, #4095, LSL #12`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_rsb_i_a1_a_subs_oracle_64_4_e27ffc20() {
    // Test SUBS 64-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0xE27FFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xE27FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max u64 operand (32)
#[test]
fn test_aarch32_rsb_i_a1_a_subs_oracle_32_5_62600420() {
    // Test SUBS 32-bit: max u64 operand (with oracle verification)
    // Encoding: 0x62600420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x62600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF7FEFFF, "W0 should be 0xFF7FEFFF");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max u64 operand (64)
#[test]
fn test_aarch32_rsb_i_a1_a_subs_oracle_64_5_e2600420() {
    // Test SUBS 64-bit: max u64 operand (with oracle verification)
    // Encoding: 0xE2600420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xE2600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF7FEFFF,
        "X0 should be 0xFFFFFFFFFF7FEFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_rsb_i_a1_a_subs_oracle_32_6_62600420() {
    // Test SUBS 32-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0x62600420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x62600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF7FF000, "W0 should be 0xFF7FF000");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_rsb_i_a1_a_subs_oracle_64_6_e2600420() {
    // Test SUBS 64-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0xE2600420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xE2600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF7FF000,
        "X0 should be 0xFFFFFFFFFF7FF000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_rsb_i_a1_a_subs_oracle_32_7_62600420() {
    // Test SUBS 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0x62600420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x62600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF7FEFFF, "W0 should be 0xFF7FEFFF");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_rsb_i_a1_a_subs_oracle_64_7_e2600420() {
    // Test SUBS 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0xE2600420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xE2600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF7FEFFF,
        "X0 should be 0x7FFFFFFFFF7FEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_rsb_i_a1_a_subs_oracle_32_8_62600420() {
    // Test SUBS 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0x62600420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x62600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7F7FEFFF, "W0 should be 0x7F7FEFFF");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_rsb_i_a1_a_subs_oracle_64_8_e2600420() {
    // Test SUBS 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0xE2600420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xE2600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x7F7FEFFF,
        "X0 should be 0x000000007F7FEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_rsb_i_a1_a_subs_oracle_32_9_62600420() {
    // Test SUBS 32-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0x62600420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x62600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF7FEFFF, "W0 should be 0xFF7FEFFF");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_rsb_i_a1_a_subs_oracle_64_9_e2600420() {
    // Test SUBS 64-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0xE2600420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xE2600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF7FEFFF,
        "X0 should be 0xFFFFFFFFFF7FEFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_rsb_i_a1_a_subs_oracle_32_10_62600420() {
    // Test SUBS 32-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0x62600420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x62600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF7FEFFF, "W0 should be 0xFF7FEFFF");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_rsb_i_a1_a_subs_oracle_64_10_e2600420() {
    // Test SUBS 64-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0xE2600420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xE2600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF7FEFFF,
        "X0 should be 0x00000000FF7FEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `SUBS ZR, X1, #10`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "result discarded, flags set" }
/// ZR destination (32)
#[test]
fn test_aarch32_rsb_i_a1_a_subs_oracle_32_rd31_zr_6260283f() {
    // Test SUBS 32-bit with Rd=31 (ZR)
    // Encoding: 0x6260283F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x6260283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `SUBS ZR, X1, #10`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "result discarded, flags set" }
/// ZR destination (64)
#[test]
fn test_aarch32_rsb_i_a1_a_subs_oracle_64_rd31_zr_e260283f() {
    // Test SUBS 64-bit with Rd=31 (ZR)
    // Encoding: 0xE260283F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xE260283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `SUB R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x00000000)
#[test]
fn test_aarch32_rsb_i_a1_a_a32_add_sub_imm_0_0_0241000a() {
    // Test A32 SUB: small immediate (oracle)
    // Encoding: 0x0241000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x0241000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFF6, "R0 should be 0xFFFFFFF6");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `SUB R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x00000064)
#[test]
fn test_aarch32_rsb_i_a1_a_a32_add_sub_imm_0_64_0241000a() {
    // Test A32 SUB: small immediate (oracle)
    // Encoding: 0x0241000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x0241000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x5A, "R0 should be 0x0000005A");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `SUB R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_rsb_i_a1_a_a32_add_sub_imm_0_7fffffff_0241000a() {
    // Test A32 SUB: small immediate (oracle)
    // Encoding: 0x0241000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x0241000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FFFFFF5, "R0 should be 0x7FFFFFF5");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `SUB R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x80000000)
#[test]
fn test_aarch32_rsb_i_a1_a_a32_add_sub_imm_0_80000000_0241000a() {
    // Test A32 SUB: small immediate (oracle)
    // Encoding: 0x0241000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0x0241000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FFFFFF6, "R0 should be 0x7FFFFFF6");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `SUB R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_rsb_i_a1_a_a32_add_sub_imm_0_ffffffff_0241000a() {
    // Test A32 SUB: small immediate (oracle)
    // Encoding: 0x0241000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x0241000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFF5, "R0 should be 0xFFFFFFF5");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `SUB R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x00000000)
#[test]
fn test_aarch32_rsb_i_a1_a_a32_add_sub_imm_1_0_024100ff() {
    // Test A32 SUB: max imm8 (oracle)
    // Encoding: 0x024100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x024100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFF01, "R0 should be 0xFFFFFF01");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `SUB R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x00000064)
#[test]
fn test_aarch32_rsb_i_a1_a_a32_add_sub_imm_1_64_024100ff() {
    // Test A32 SUB: max imm8 (oracle)
    // Encoding: 0x024100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x024100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFF65, "R0 should be 0xFFFFFF65");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `SUB R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_rsb_i_a1_a_a32_add_sub_imm_1_7fffffff_024100ff() {
    // Test A32 SUB: max imm8 (oracle)
    // Encoding: 0x024100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x024100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FFFFF00, "R0 should be 0x7FFFFF00");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `SUB R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x80000000)
#[test]
fn test_aarch32_rsb_i_a1_a_a32_add_sub_imm_1_80000000_024100ff() {
    // Test A32 SUB: max imm8 (oracle)
    // Encoding: 0x024100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0x024100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FFFFF01, "R0 should be 0x7FFFFF01");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `SUB R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_rsb_i_a1_a_a32_add_sub_imm_1_ffffffff_024100ff() {
    // Test A32 SUB: max imm8 (oracle)
    // Encoding: 0x024100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x024100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFF00, "R0 should be 0xFFFFFF00");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `SUB R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x00000000)
#[test]
fn test_aarch32_rsb_i_a1_a_a32_add_sub_imm_2_0_02410180() {
    // Test A32 SUB: rotated by 2 (oracle)
    // Encoding: 0x02410180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x02410180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFE0, "R0 should be 0xFFFFFFE0");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `SUB R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x00000064)
#[test]
fn test_aarch32_rsb_i_a1_a_a32_add_sub_imm_2_64_02410180() {
    // Test A32 SUB: rotated by 2 (oracle)
    // Encoding: 0x02410180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x02410180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x44, "R0 should be 0x00000044");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `SUB R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_rsb_i_a1_a_a32_add_sub_imm_2_7fffffff_02410180() {
    // Test A32 SUB: rotated by 2 (oracle)
    // Encoding: 0x02410180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x02410180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FFFFFDF, "R0 should be 0x7FFFFFDF");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `SUB R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x80000000)
#[test]
fn test_aarch32_rsb_i_a1_a_a32_add_sub_imm_2_80000000_02410180() {
    // Test A32 SUB: rotated by 2 (oracle)
    // Encoding: 0x02410180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0x02410180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FFFFFE0, "R0 should be 0x7FFFFFE0");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `SUB R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_rsb_i_a1_a_a32_add_sub_imm_2_ffffffff_02410180() {
    // Test A32 SUB: rotated by 2 (oracle)
    // Encoding: 0x02410180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x02410180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFDF, "R0 should be 0xFFFFFFDF");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `SUB R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x00000000)
#[test]
fn test_aarch32_rsb_i_a1_a_a32_add_sub_imm_3_0_0241040f() {
    // Test A32 SUB: rotated by 8 (oracle)
    // Encoding: 0x0241040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x0241040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xF1000000, "R0 should be 0xF1000000");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `SUB R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x00000064)
#[test]
fn test_aarch32_rsb_i_a1_a_a32_add_sub_imm_3_64_0241040f() {
    // Test A32 SUB: rotated by 8 (oracle)
    // Encoding: 0x0241040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x0241040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xF1000064, "R0 should be 0xF1000064");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `SUB R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_rsb_i_a1_a_a32_add_sub_imm_3_7fffffff_0241040f() {
    // Test A32 SUB: rotated by 8 (oracle)
    // Encoding: 0x0241040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x0241040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x70FFFFFF, "R0 should be 0x70FFFFFF");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `SUB R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x80000000)
#[test]
fn test_aarch32_rsb_i_a1_a_a32_add_sub_imm_3_80000000_0241040f() {
    // Test A32 SUB: rotated by 8 (oracle)
    // Encoding: 0x0241040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0x0241040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x71000000, "R0 should be 0x71000000");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `SUB R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_rsb_i_a1_a_a32_add_sub_imm_3_ffffffff_0241040f() {
    // Test A32 SUB: rotated by 8 (oracle)
    // Encoding: 0x0241040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x0241040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xF0FFFFFF, "R0 should be 0xF0FFFFFF");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `SUB R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x00000000)
#[test]
fn test_aarch32_rsb_i_a1_a_a32_add_sub_imm_4_0_02410000() {
    // Test A32 SUB: zero immediate (oracle)
    // Encoding: 0x02410000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x02410000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `SUB R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x00000064)
#[test]
fn test_aarch32_rsb_i_a1_a_a32_add_sub_imm_4_64_02410000() {
    // Test A32 SUB: zero immediate (oracle)
    // Encoding: 0x02410000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x02410000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x64, "R0 should be 0x00000064");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `SUB R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_rsb_i_a1_a_a32_add_sub_imm_4_7fffffff_02410000() {
    // Test A32 SUB: zero immediate (oracle)
    // Encoding: 0x02410000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x02410000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FFFFFFF, "R0 should be 0x7FFFFFFF");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `SUB R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x80000000)
#[test]
fn test_aarch32_rsb_i_a1_a_a32_add_sub_imm_4_80000000_02410000() {
    // Test A32 SUB: zero immediate (oracle)
    // Encoding: 0x02410000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0x02410000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "R0 should be 0x80000000");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `SUB R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_rsb_i_a1_a_a32_add_sub_imm_4_ffffffff_02410000() {
    // Test A32 SUB: zero immediate (oracle)
    // Encoding: 0x02410000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x02410000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "R0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_aarch32_rsb_i_a1_a_flags_zeroresult_0_02710000() {
    // Test aarch32_RSB_i_A1_A flag computation: ZeroResult
    // Encoding: 0x02710000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x02710000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_aarch32_rsb_i_a1_a_flags_zeroresult_1_02710000() {
    // Test aarch32_RSB_i_A1_A flag computation: ZeroResult
    // Encoding: 0x02710000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x02710000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_aarch32_rsb_i_a1_a_flags_negativeresult_2_02710000() {
    // Test aarch32_RSB_i_A1_A flag computation: NegativeResult
    // Encoding: 0x02710000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x02710000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_aarch32_rsb_i_a1_a_flags_unsignedoverflow_3_02710000() {
    // Test aarch32_RSB_i_A1_A flag computation: UnsignedOverflow
    // Encoding: 0x02710000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x02710000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_aarch32_rsb_i_a1_a_flags_unsignedoverflow_4_02710000() {
    // Test aarch32_RSB_i_A1_A flag computation: UnsignedOverflow
    // Encoding: 0x02710000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x02710000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_aarch32_rsb_i_a1_a_flags_signedoverflow_5_02710000() {
    // Test aarch32_RSB_i_A1_A flag computation: SignedOverflow
    // Encoding: 0x02710000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x02710000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_aarch32_rsb_i_a1_a_flags_signedoverflow_6_02710000() {
    // Test aarch32_RSB_i_A1_A flag computation: SignedOverflow
    // Encoding: 0x02710000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x02710000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_RSB_i_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_aarch32_rsb_i_a1_a_flags_positiveresult_7_02710000() {
    // Test aarch32_RSB_i_A1_A flag computation: PositiveResult
    // Encoding: 0x02710000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x32);
    let encoding: u32 = 0x02710000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_RSB_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 0 (32)
#[test]
fn test_aarch32_rsb_i_t1_a_lslv_oracle_32_0_42420020() {
    // Test LSLV 32-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x12345678, "W0 should be 0x12345678");
}

/// Provenance: aarch32_RSB_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 0 (64)
#[test]
fn test_aarch32_rsb_i_t1_a_lslv_oracle_64_0_c2420020() {
    // Test LSLV 64-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x12345678,
        "X0 should be 0x0000000012345678"
    );
}

/// Provenance: aarch32_RSB_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4 (32)
#[test]
fn test_aarch32_rsb_i_t1_a_lslv_oracle_32_1_42420020() {
    // Test LSLV 32-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x4);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x23456780, "W0 should be 0x23456780");
}

/// Provenance: aarch32_RSB_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 4 (64)
#[test]
fn test_aarch32_rsb_i_t1_a_lslv_oracle_64_1_c2420020() {
    // Test LSLV 64-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x4);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x23456780,
        "X0 should be 0x0000000123456780"
    );
}

/// Provenance: aarch32_RSB_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 8 (32)
#[test]
fn test_aarch32_rsb_i_t1_a_lslv_oracle_32_2_42420020() {
    // Test LSLV 32-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x8);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x34567800, "W0 should be 0x34567800");
}

/// Provenance: aarch32_RSB_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 8 (64)
#[test]
fn test_aarch32_rsb_i_t1_a_lslv_oracle_64_2_c2420020() {
    // Test LSLV 64-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x8);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x34567800,
        "X0 should be 0x0000001234567800"
    );
}

/// Provenance: aarch32_RSB_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1 (32)
#[test]
fn test_aarch32_rsb_i_t1_a_lslv_oracle_32_3_42420020() {
    // Test LSLV 32-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_RSB_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// MSB set, shift 1 (64)
#[test]
fn test_aarch32_rsb_i_t1_a_lslv_oracle_64_3_c2420020() {
    // Test LSLV 64-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_RSB_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// LSB set, max shift (32)
#[test]
fn test_aarch32_rsb_i_t1_a_lslv_oracle_32_4_42420020() {
    // Test LSLV 32-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3F);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "W0 should be 0x80000000");
}

/// Provenance: aarch32_RSB_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// LSB set, max shift (64)
#[test]
fn test_aarch32_rsb_i_t1_a_lslv_oracle_64_4_c2420020() {
    // Test LSLV 64-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x3F);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x8000000000000000");
}

/// Provenance: aarch32_RSB_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// all ones, shift 32 (32)
#[test]
fn test_aarch32_rsb_i_t1_a_lslv_oracle_32_5_42420020() {
    // Test LSLV 32-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x20);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "W0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_RSB_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// all ones, shift 32 (64)
#[test]
fn test_aarch32_rsb_i_t1_a_lslv_oracle_64_5_c2420020() {
    // Test LSLV 64-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x20);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0xFFFFFFFF00000000");
}

/// Provenance: aarch32_RSB_i_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// no shift
#[test]
fn test_aarch32_rsb_i_t1_a_t16_oracle_0_42480000() {
    // Test T16 LSLS: no shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_RSB_i_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4
#[test]
fn test_aarch32_rsb_i_t1_a_t16_oracle_1_42480000() {
    // Test T16 LSLS: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x4);
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF0, "R0 should be 0x00000FF0");
}

/// Provenance: aarch32_RSB_i_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1
#[test]
fn test_aarch32_rsb_i_t1_a_t16_oracle_2_42480000() {
    // Test T16 LSLS: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_RSB_i_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift to MSB
#[test]
fn test_aarch32_rsb_i_t1_a_t16_oracle_3_42480000() {
    // Test T16 LSLS: shift to MSB (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1F);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "R0 should be 0x80000000");
}

/// Provenance: aarch32_RSB_i_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_aarch32_rsb_i_t1_a_flags_zeroresult_0_42480000() {
    // Test aarch32_RSB_i_T1_A flag computation: ZeroResult
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_RSB_i_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_aarch32_rsb_i_t1_a_flags_zeroresult_1_42480000() {
    // Test aarch32_RSB_i_T1_A flag computation: ZeroResult
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_RSB_i_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_aarch32_rsb_i_t1_a_flags_negativeresult_2_42480000() {
    // Test aarch32_RSB_i_T1_A flag computation: NegativeResult
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_RSB_i_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_aarch32_rsb_i_t1_a_flags_unsignedoverflow_3_42480000() {
    // Test aarch32_RSB_i_T1_A flag computation: UnsignedOverflow
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_RSB_i_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_aarch32_rsb_i_t1_a_flags_unsignedoverflow_4_42480000() {
    // Test aarch32_RSB_i_T1_A flag computation: UnsignedOverflow
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_RSB_i_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_aarch32_rsb_i_t1_a_flags_signedoverflow_5_42480000() {
    // Test aarch32_RSB_i_T1_A flag computation: SignedOverflow
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_RSB_i_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_aarch32_rsb_i_t1_a_flags_signedoverflow_6_42480000() {
    // Test aarch32_RSB_i_T1_A flag computation: SignedOverflow
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_RSB_i_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_aarch32_rsb_i_t1_a_flags_positiveresult_7_42480000() {
    // Test aarch32_RSB_i_T1_A flag computation: PositiveResult
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x32);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `ADD X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_rsb_i_t2_a_add_oracle_32_0_f1c02820() {
    // Test ADD 32-bit: simple addition/subtraction (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF1C02820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFF6064,
        "X0 should be 0xFFFFFFFFFFFF6064"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `ADD X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_rsb_i_t2_a_add_oracle_64_0_f1c02820() {
    // Test ADD 64-bit: simple addition/subtraction (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF1C02820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFF6064,
        "X0 should be 0xFFFFFFFFFFFF6064"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `ADD X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero operands (32)
#[test]
fn test_aarch32_rsb_i_t2_a_add_oracle_32_1_f1c00020() {
    // Test ADD 32-bit: zero operands (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1C00020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `ADD X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero operands (64)
#[test]
fn test_aarch32_rsb_i_t2_a_add_oracle_64_1_f1c00020() {
    // Test ADD 64-bit: zero operands (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1C00020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small values (32)
#[test]
fn test_aarch32_rsb_i_t2_a_add_oracle_32_2_f1c00420() {
    // Test ADD 32-bit: small values (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF1C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// small values (64)
#[test]
fn test_aarch32_rsb_i_t2_a_add_oracle_64_2_f1c00420() {
    // Test ADD 64-bit: small values (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF1C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `ADD X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_rsb_i_t2_a_add_oracle_32_3_f1fffc20() {
    // Test ADD 32-bit: max imm12 unshifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `ADD X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_rsb_i_t2_a_add_oracle_64_3_f1fffc20() {
    // Test ADD 64-bit: max imm12 unshifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `ADD X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_rsb_i_t2_a_add_oracle_32_4_f1fffc20() {
    // Test ADD 32-bit: max imm12 shifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `ADD X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_rsb_i_t2_a_add_oracle_64_4_f1fffc20() {
    // Test ADD 64-bit: max imm12 shifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max u64 operand (32)
#[test]
fn test_aarch32_rsb_i_t2_a_add_oracle_32_5_f1c00420() {
    // Test ADD 32-bit: max u64 operand (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFEFFF,
        "X0 should be 0x00000000FFFFEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max u64 operand (64)
#[test]
fn test_aarch32_rsb_i_t2_a_add_oracle_64_5_f1c00420() {
    // Test ADD 64-bit: max u64 operand (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFEFFF,
        "X0 should be 0xFFFFFFFFFFFFEFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_rsb_i_t2_a_add_oracle_32_6_f1c00420() {
    // Test ADD 32-bit: zero result (for sub 1-1) (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF000,
        "X0 should be 0xFFFFFFFFFFFFF000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_rsb_i_t2_a_add_oracle_64_6_f1c00420() {
    // Test ADD 64-bit: zero result (for sub 1-1) (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF000,
        "X0 should be 0xFFFFFFFFFFFFF000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_rsb_i_t2_a_add_oracle_32_7_f1c00420() {
    // Test ADD 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFEFFF,
        "X0 should be 0x00000000FFFFEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_rsb_i_t2_a_add_oracle_64_7_f1c00420() {
    // Test ADD 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFEFFF,
        "X0 should be 0x7FFFFFFFFFFFEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_rsb_i_t2_a_add_oracle_32_8_f1c00420() {
    // Test ADD 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF1C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x7FFFEFFF,
        "X0 should be 0x000000007FFFEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_rsb_i_t2_a_add_oracle_64_8_f1c00420() {
    // Test ADD 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF1C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x7FFFEFFF,
        "X0 should be 0x000000007FFFEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_rsb_i_t2_a_add_oracle_32_9_f1c00420() {
    // Test ADD 32-bit: unsigned overflow 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFEFFF,
        "X0 should be 0x00000000FFFFEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_rsb_i_t2_a_add_oracle_64_9_f1c00420() {
    // Test ADD 64-bit: unsigned overflow 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFEFFF,
        "X0 should be 0xFFFFFFFFFFFFEFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_rsb_i_t2_a_add_oracle_32_10_f1c00420() {
    // Test ADD 32-bit: unsigned overflow 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFEFFF,
        "X0 should be 0x00000000FFFFEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_rsb_i_t2_a_add_oracle_64_10_f1c00420() {
    // Test ADD 64-bit: unsigned overflow 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFEFFF,
        "X0 should be 0x00000000FFFFEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `ADD SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (32)
#[test]
fn test_aarch32_rsb_i_t2_a_add_oracle_32_rd31_sp_f1c0283f() {
    // Test ADD 32-bit with Rd=31 (SP)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF1C0283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `ADD SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (64)
#[test]
fn test_aarch32_rsb_i_t2_a_add_oracle_64_rd31_sp_f1c0283f() {
    // Test ADD 64-bit with Rd=31 (SP)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF1C0283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `ADDS X0, X1, #10`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_rsb_i_t2_a_adds_oracle_32_0_f1c02820() {
    // Test ADDS 32-bit: simple addition/subtraction (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF1C02820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFF6064,
        "X0 should be 0xFFFFFFFFFFFF6064"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `ADDS X0, X1, #10`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_rsb_i_t2_a_adds_oracle_64_0_f1c02820() {
    // Test ADDS 64-bit: simple addition/subtraction (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF1C02820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFF6064,
        "X0 should be 0xFFFFFFFFFFFF6064"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `ADDS X0, X1, #0`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero operands (32)
#[test]
fn test_aarch32_rsb_i_t2_a_adds_oracle_32_1_f1c00020() {
    // Test ADDS 32-bit: zero operands (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1C00020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `ADDS X0, X1, #0`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero operands (64)
#[test]
fn test_aarch32_rsb_i_t2_a_adds_oracle_64_1_f1c00020() {
    // Test ADDS 64-bit: zero operands (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1C00020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// small values (32)
#[test]
fn test_aarch32_rsb_i_t2_a_adds_oracle_32_2_f1c00420() {
    // Test ADDS 32-bit: small values (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF1C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// small values (64)
#[test]
fn test_aarch32_rsb_i_t2_a_adds_oracle_64_2_f1c00420() {
    // Test ADDS 64-bit: small values (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF1C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `ADDS X0, X1, #4095`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_rsb_i_t2_a_adds_oracle_32_3_f1fffc20() {
    // Test ADDS 32-bit: max imm12 unshifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `ADDS X0, X1, #4095`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_rsb_i_t2_a_adds_oracle_64_3_f1fffc20() {
    // Test ADDS 64-bit: max imm12 unshifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `ADDS X0, X1, #4095, LSL #12`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_rsb_i_t2_a_adds_oracle_32_4_f1fffc20() {
    // Test ADDS 32-bit: max imm12 shifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `ADDS X0, X1, #4095, LSL #12`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_rsb_i_t2_a_adds_oracle_64_4_f1fffc20() {
    // Test ADDS 64-bit: max imm12 shifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max u64 operand (32)
#[test]
fn test_aarch32_rsb_i_t2_a_adds_oracle_32_5_f1c00420() {
    // Test ADDS 32-bit: max u64 operand (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFEFFF,
        "X0 should be 0x00000000FFFFEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max u64 operand (64)
#[test]
fn test_aarch32_rsb_i_t2_a_adds_oracle_64_5_f1c00420() {
    // Test ADDS 64-bit: max u64 operand (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFEFFF,
        "X0 should be 0xFFFFFFFFFFFFEFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_rsb_i_t2_a_adds_oracle_32_6_f1c00420() {
    // Test ADDS 32-bit: zero result (for sub 1-1) (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF000,
        "X0 should be 0xFFFFFFFFFFFFF000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_rsb_i_t2_a_adds_oracle_64_6_f1c00420() {
    // Test ADDS 64-bit: zero result (for sub 1-1) (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF000,
        "X0 should be 0xFFFFFFFFFFFFF000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_rsb_i_t2_a_adds_oracle_32_7_f1c00420() {
    // Test ADDS 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFEFFF,
        "X0 should be 0x00000000FFFFEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_rsb_i_t2_a_adds_oracle_64_7_f1c00420() {
    // Test ADDS 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFEFFF,
        "X0 should be 0x7FFFFFFFFFFFEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_rsb_i_t2_a_adds_oracle_32_8_f1c00420() {
    // Test ADDS 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF1C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x7FFFEFFF,
        "X0 should be 0x000000007FFFEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_rsb_i_t2_a_adds_oracle_64_8_f1c00420() {
    // Test ADDS 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF1C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x7FFFEFFF,
        "X0 should be 0x000000007FFFEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_rsb_i_t2_a_adds_oracle_32_9_f1c00420() {
    // Test ADDS 32-bit: unsigned overflow 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFEFFF,
        "X0 should be 0x00000000FFFFEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_rsb_i_t2_a_adds_oracle_64_9_f1c00420() {
    // Test ADDS 64-bit: unsigned overflow 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFEFFF,
        "X0 should be 0xFFFFFFFFFFFFEFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_rsb_i_t2_a_adds_oracle_32_10_f1c00420() {
    // Test ADDS 32-bit: unsigned overflow 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFEFFF,
        "X0 should be 0x00000000FFFFEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_rsb_i_t2_a_adds_oracle_64_10_f1c00420() {
    // Test ADDS 64-bit: unsigned overflow 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFEFFF,
        "X0 should be 0x00000000FFFFEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `ADDS ZR, X1, #10`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "result discarded, flags set" }
/// ZR destination (32)
#[test]
fn test_aarch32_rsb_i_t2_a_adds_oracle_32_rd31_zr_f1c0283f() {
    // Test ADDS 32-bit with Rd=31 (ZR)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF1C0283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `ADDS ZR, X1, #10`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "result discarded, flags set" }
/// ZR destination (64)
#[test]
fn test_aarch32_rsb_i_t2_a_adds_oracle_64_rd31_zr_f1c0283f() {
    // Test ADDS 64-bit with Rd=31 (ZR)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF1C0283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `SUB X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_rsb_i_t2_a_sub_oracle_32_0_f1c02820() {
    // Test SUB 32-bit: simple addition/subtraction (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF1C02820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFF6064,
        "X0 should be 0xFFFFFFFFFFFF6064"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `SUB X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_rsb_i_t2_a_sub_oracle_64_0_f1c02820() {
    // Test SUB 64-bit: simple addition/subtraction (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF1C02820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFF6064,
        "X0 should be 0xFFFFFFFFFFFF6064"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `SUB X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero operands (32)
#[test]
fn test_aarch32_rsb_i_t2_a_sub_oracle_32_1_f1c00020() {
    // Test SUB 32-bit: zero operands (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1C00020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `SUB X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero operands (64)
#[test]
fn test_aarch32_rsb_i_t2_a_sub_oracle_64_1_f1c00020() {
    // Test SUB 64-bit: zero operands (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1C00020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small values (32)
#[test]
fn test_aarch32_rsb_i_t2_a_sub_oracle_32_2_f1c00420() {
    // Test SUB 32-bit: small values (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF1C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// small values (64)
#[test]
fn test_aarch32_rsb_i_t2_a_sub_oracle_64_2_f1c00420() {
    // Test SUB 64-bit: small values (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF1C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `SUB X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_rsb_i_t2_a_sub_oracle_32_3_f1fffc20() {
    // Test SUB 32-bit: max imm12 unshifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `SUB X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_rsb_i_t2_a_sub_oracle_64_3_f1fffc20() {
    // Test SUB 64-bit: max imm12 unshifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `SUB X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_rsb_i_t2_a_sub_oracle_32_4_f1fffc20() {
    // Test SUB 32-bit: max imm12 shifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `SUB X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_rsb_i_t2_a_sub_oracle_64_4_f1fffc20() {
    // Test SUB 64-bit: max imm12 shifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max u64 operand (32)
#[test]
fn test_aarch32_rsb_i_t2_a_sub_oracle_32_5_f1c00420() {
    // Test SUB 32-bit: max u64 operand (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFEFFF,
        "X0 should be 0x00000000FFFFEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max u64 operand (64)
#[test]
fn test_aarch32_rsb_i_t2_a_sub_oracle_64_5_f1c00420() {
    // Test SUB 64-bit: max u64 operand (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFEFFF,
        "X0 should be 0xFFFFFFFFFFFFEFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_rsb_i_t2_a_sub_oracle_32_6_f1c00420() {
    // Test SUB 32-bit: zero result (for sub 1-1) (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF000,
        "X0 should be 0xFFFFFFFFFFFFF000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_rsb_i_t2_a_sub_oracle_64_6_f1c00420() {
    // Test SUB 64-bit: zero result (for sub 1-1) (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF000,
        "X0 should be 0xFFFFFFFFFFFFF000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_rsb_i_t2_a_sub_oracle_32_7_f1c00420() {
    // Test SUB 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFEFFF,
        "X0 should be 0x00000000FFFFEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_rsb_i_t2_a_sub_oracle_64_7_f1c00420() {
    // Test SUB 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFEFFF,
        "X0 should be 0x7FFFFFFFFFFFEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_rsb_i_t2_a_sub_oracle_32_8_f1c00420() {
    // Test SUB 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF1C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x7FFFEFFF,
        "X0 should be 0x000000007FFFEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_rsb_i_t2_a_sub_oracle_64_8_f1c00420() {
    // Test SUB 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF1C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x7FFFEFFF,
        "X0 should be 0x000000007FFFEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_rsb_i_t2_a_sub_oracle_32_9_f1c00420() {
    // Test SUB 32-bit: unsigned overflow 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFEFFF,
        "X0 should be 0x00000000FFFFEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_rsb_i_t2_a_sub_oracle_64_9_f1c00420() {
    // Test SUB 64-bit: unsigned overflow 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFEFFF,
        "X0 should be 0xFFFFFFFFFFFFEFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_rsb_i_t2_a_sub_oracle_32_10_f1c00420() {
    // Test SUB 32-bit: unsigned overflow 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFEFFF,
        "X0 should be 0x00000000FFFFEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_rsb_i_t2_a_sub_oracle_64_10_f1c00420() {
    // Test SUB 64-bit: unsigned overflow 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFEFFF,
        "X0 should be 0x00000000FFFFEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `SUB SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (32)
#[test]
fn test_aarch32_rsb_i_t2_a_sub_oracle_32_rd31_sp_f1c0283f() {
    // Test SUB 32-bit with Rd=31 (SP)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF1C0283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `SUB SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (64)
#[test]
fn test_aarch32_rsb_i_t2_a_sub_oracle_64_rd31_sp_f1c0283f() {
    // Test SUB 64-bit with Rd=31 (SP)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF1C0283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `SUBS X0, X1, #10`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_rsb_i_t2_a_subs_oracle_32_0_f1c02820() {
    // Test SUBS 32-bit: simple addition/subtraction (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF1C02820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFF6064,
        "X0 should be 0xFFFFFFFFFFFF6064"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `SUBS X0, X1, #10`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_rsb_i_t2_a_subs_oracle_64_0_f1c02820() {
    // Test SUBS 64-bit: simple addition/subtraction (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF1C02820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFF6064,
        "X0 should be 0xFFFFFFFFFFFF6064"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `SUBS X0, X1, #0`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero operands (32)
#[test]
fn test_aarch32_rsb_i_t2_a_subs_oracle_32_1_f1c00020() {
    // Test SUBS 32-bit: zero operands (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1C00020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `SUBS X0, X1, #0`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero operands (64)
#[test]
fn test_aarch32_rsb_i_t2_a_subs_oracle_64_1_f1c00020() {
    // Test SUBS 64-bit: zero operands (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1C00020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// small values (32)
#[test]
fn test_aarch32_rsb_i_t2_a_subs_oracle_32_2_f1c00420() {
    // Test SUBS 32-bit: small values (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF1C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// small values (64)
#[test]
fn test_aarch32_rsb_i_t2_a_subs_oracle_64_2_f1c00420() {
    // Test SUBS 64-bit: small values (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF1C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `SUBS X0, X1, #4095`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_rsb_i_t2_a_subs_oracle_32_3_f1fffc20() {
    // Test SUBS 32-bit: max imm12 unshifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `SUBS X0, X1, #4095`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_rsb_i_t2_a_subs_oracle_64_3_f1fffc20() {
    // Test SUBS 64-bit: max imm12 unshifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `SUBS X0, X1, #4095, LSL #12`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_rsb_i_t2_a_subs_oracle_32_4_f1fffc20() {
    // Test SUBS 32-bit: max imm12 shifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `SUBS X0, X1, #4095, LSL #12`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_rsb_i_t2_a_subs_oracle_64_4_f1fffc20() {
    // Test SUBS 64-bit: max imm12 shifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max u64 operand (32)
#[test]
fn test_aarch32_rsb_i_t2_a_subs_oracle_32_5_f1c00420() {
    // Test SUBS 32-bit: max u64 operand (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFEFFF,
        "X0 should be 0x00000000FFFFEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max u64 operand (64)
#[test]
fn test_aarch32_rsb_i_t2_a_subs_oracle_64_5_f1c00420() {
    // Test SUBS 64-bit: max u64 operand (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFEFFF,
        "X0 should be 0xFFFFFFFFFFFFEFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_rsb_i_t2_a_subs_oracle_32_6_f1c00420() {
    // Test SUBS 32-bit: zero result (for sub 1-1) (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF000,
        "X0 should be 0xFFFFFFFFFFFFF000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_rsb_i_t2_a_subs_oracle_64_6_f1c00420() {
    // Test SUBS 64-bit: zero result (for sub 1-1) (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF000,
        "X0 should be 0xFFFFFFFFFFFFF000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_rsb_i_t2_a_subs_oracle_32_7_f1c00420() {
    // Test SUBS 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFEFFF,
        "X0 should be 0x00000000FFFFEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_rsb_i_t2_a_subs_oracle_64_7_f1c00420() {
    // Test SUBS 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFEFFF,
        "X0 should be 0x7FFFFFFFFFFFEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_rsb_i_t2_a_subs_oracle_32_8_f1c00420() {
    // Test SUBS 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF1C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x7FFFEFFF,
        "X0 should be 0x000000007FFFEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_rsb_i_t2_a_subs_oracle_64_8_f1c00420() {
    // Test SUBS 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF1C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x7FFFEFFF,
        "X0 should be 0x000000007FFFEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_rsb_i_t2_a_subs_oracle_32_9_f1c00420() {
    // Test SUBS 32-bit: unsigned overflow 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFEFFF,
        "X0 should be 0x00000000FFFFEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_rsb_i_t2_a_subs_oracle_64_9_f1c00420() {
    // Test SUBS 64-bit: unsigned overflow 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFEFFF,
        "X0 should be 0xFFFFFFFFFFFFEFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_rsb_i_t2_a_subs_oracle_32_10_f1c00420() {
    // Test SUBS 32-bit: unsigned overflow 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFEFFF,
        "X0 should be 0x00000000FFFFEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_rsb_i_t2_a_subs_oracle_64_10_f1c00420() {
    // Test SUBS 64-bit: unsigned overflow 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFEFFF,
        "X0 should be 0x00000000FFFFEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `SUBS ZR, X1, #10`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "result discarded, flags set" }
/// ZR destination (32)
#[test]
fn test_aarch32_rsb_i_t2_a_subs_oracle_32_rd31_zr_f1c0283f() {
    // Test SUBS 32-bit with Rd=31 (ZR)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF1C0283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `SUBS ZR, X1, #10`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "result discarded, flags set" }
/// ZR destination (64)
#[test]
fn test_aarch32_rsb_i_t2_a_subs_oracle_64_rd31_zr_f1c0283f() {
    // Test SUBS 64-bit with Rd=31 (ZR)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF1C0283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `SUB.W R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple values
#[test]
fn test_aarch32_rsb_i_t2_a_t32_oracle_0_f1c10000() {
    // Test T32 SUB: simple values (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x32);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF1C10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x32, "R0 should be 0x00000032");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `SUB.W R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero values
#[test]
fn test_aarch32_rsb_i_t2_a_t32_oracle_1_f1c10000() {
    // Test T32 SUB: zero values (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xF1C10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `SUB.W R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max value
#[test]
fn test_aarch32_rsb_i_t2_a_t32_oracle_2_f1c10000() {
    // Test T32 SUB: max value (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0xF1C10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFE, "R0 should be 0xFFFFFFFE");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `SUB.W R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// mixed pattern
#[test]
fn test_aarch32_rsb_i_t2_a_t32_oracle_3_f1c10000() {
    // Test T32 SUB: mixed pattern (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0xABCDEF01);
    let encoding: u32 = 0xF1C10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x66666777, "R0 should be 0x66666777");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_aarch32_rsb_i_t2_a_flags_zeroresult_0_f1d10000() {
    // Test aarch32_RSB_i_T2_A flag computation: ZeroResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1D10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_aarch32_rsb_i_t2_a_flags_zeroresult_1_f1d10000() {
    // Test aarch32_RSB_i_T2_A flag computation: ZeroResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF1D10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_aarch32_rsb_i_t2_a_flags_negativeresult_2_f1d10000() {
    // Test aarch32_RSB_i_T2_A flag computation: NegativeResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1D10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_aarch32_rsb_i_t2_a_flags_unsignedoverflow_3_f1d10000() {
    // Test aarch32_RSB_i_T2_A flag computation: UnsignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1D10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_aarch32_rsb_i_t2_a_flags_unsignedoverflow_4_f1d10000() {
    // Test aarch32_RSB_i_T2_A flag computation: UnsignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0xF1D10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_aarch32_rsb_i_t2_a_flags_signedoverflow_5_f1d10000() {
    // Test aarch32_RSB_i_T2_A flag computation: SignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1D10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_aarch32_rsb_i_t2_a_flags_signedoverflow_6_f1d10000() {
    // Test aarch32_RSB_i_T2_A flag computation: SignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0xF1D10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_RSB_i_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_aarch32_rsb_i_t2_a_flags_positiveresult_7_f1d10000() {
    // Test aarch32_RSB_i_T2_A flag computation: PositiveResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x32);
    let encoding: u32 = 0xF1D10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

// ============================================================================
// aarch32_ADD_i_A Tests
// ============================================================================

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_add_i_a1_a_field_cond_0_min_0_02800000() {
    // Encoding: 0x02800000
    // Test aarch32_ADD_i_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, cond=0, imm12=0, S=0, Rd=0
    let encoding: u32 = 0x02800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_add_i_a1_a_field_cond_1_poweroftwo_0_12800000() {
    // Encoding: 0x12800000
    // Test aarch32_ADD_i_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rn=0, imm12=0, S=0, cond=1
    let encoding: u32 = 0x12800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_add_i_a1_a_field_cond_2_poweroftwo_0_22800000() {
    // Encoding: 0x22800000
    // Test aarch32_ADD_i_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=2, S=0, Rd=0, imm12=0, Rn=0
    let encoding: u32 = 0x22800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_add_i_a1_a_field_cond_3_poweroftwo_0_32800000() {
    // Encoding: 0x32800000
    // Test aarch32_ADD_i_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, Rd=0, imm12=0, Rn=0, cond=3
    let encoding: u32 = 0x32800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_add_i_a1_a_field_cond_4_poweroftwo_0_42800000() {
    // Encoding: 0x42800000
    // Test aarch32_ADD_i_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, cond=4, imm12=0, Rd=0, Rn=0
    let encoding: u32 = 0x42800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_add_i_a1_a_field_cond_5_poweroftwo_0_52800000() {
    // Encoding: 0x52800000
    // Test aarch32_ADD_i_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=5, Rd=0, Rn=0, S=0, imm12=0
    let encoding: u32 = 0x52800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_add_i_a1_a_field_cond_6_poweroftwo_0_62800000() {
    // Encoding: 0x62800000
    // Test aarch32_ADD_i_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=0, cond=6, S=0, Rd=0, Rn=0
    let encoding: u32 = 0x62800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_add_i_a1_a_field_cond_7_poweroftwo_0_72800000() {
    // Encoding: 0x72800000
    // Test aarch32_ADD_i_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, Rd=0, cond=7, Rn=0, imm12=0
    let encoding: u32 = 0x72800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_add_i_a1_a_field_cond_8_poweroftwo_0_82800000() {
    // Encoding: 0x82800000
    // Test aarch32_ADD_i_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, imm12=0, cond=8, Rn=0, S=0
    let encoding: u32 = 0x82800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_add_i_a1_a_field_cond_9_poweroftwo_0_92800000() {
    // Encoding: 0x92800000
    // Test aarch32_ADD_i_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, Rn=0, Rd=0, imm12=0, cond=9
    let encoding: u32 = 0x92800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_add_i_a1_a_field_cond_10_poweroftwo_0_a2800000() {
    // Encoding: 0xA2800000
    // Test aarch32_ADD_i_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, Rn=0, Rd=0, cond=10, imm12=0
    let encoding: u32 = 0xA2800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_add_i_a1_a_field_cond_11_poweroftwo_0_b2800000() {
    // Encoding: 0xB2800000
    // Test aarch32_ADD_i_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, S=0, cond=11, imm12=0, Rd=0
    let encoding: u32 = 0xB2800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_add_i_a1_a_field_cond_12_poweroftwo_0_c2800000() {
    // Encoding: 0xC2800000
    // Test aarch32_ADD_i_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=12, imm12=0, S=0, Rn=0, Rd=0
    let encoding: u32 = 0xC2800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_add_i_a1_a_field_cond_13_poweroftwo_0_d2800000() {
    // Encoding: 0xD2800000
    // Test aarch32_ADD_i_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=13, S=0, Rn=0, Rd=0, imm12=0
    let encoding: u32 = 0xD2800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_add_i_a1_a_field_cond_14_poweroftwo_0_e2800000() {
    // Encoding: 0xE2800000
    // Test aarch32_ADD_i_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rd=0, cond=14, imm12=0, S=0
    let encoding: u32 = 0xE2800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_add_i_a1_a_field_cond_15_max_0_f2800000() {
    // Encoding: 0xF2800000
    // Test aarch32_ADD_i_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: imm12=0, Rd=0, S=0, Rn=0, cond=15
    let encoding: u32 = 0xF2800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_add_i_a1_a_field_s_0_min_0_02800000() {
    // Encoding: 0x02800000
    // Test aarch32_ADD_i_A1_A field S = 0 (Min)
    // ISET: A32
    // Fields: imm12=0, cond=0, Rn=0, S=0, Rd=0
    let encoding: u32 = 0x02800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_add_i_a1_a_field_s_1_max_0_02900000() {
    // Encoding: 0x02900000
    // Test aarch32_ADD_i_A1_A field S = 1 (Max)
    // ISET: A32
    // Fields: S=1, cond=0, imm12=0, Rd=0, Rn=0
    let encoding: u32 = 0x02900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_add_i_a1_a_field_rn_0_min_0_02800000() {
    // Encoding: 0x02800000
    // Test aarch32_ADD_i_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, S=0, imm12=0, cond=0, Rd=0
    let encoding: u32 = 0x02800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_add_i_a1_a_field_rn_1_poweroftwo_0_02810000() {
    // Encoding: 0x02810000
    // Test aarch32_ADD_i_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, cond=0, Rd=0, imm12=0, Rn=1
    let encoding: u32 = 0x02810000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_add_i_a1_a_field_rd_0_min_0_02800000() {
    // Encoding: 0x02800000
    // Test aarch32_ADD_i_A1_A field Rd = 0 (Min)
    // ISET: A32
    // Fields: S=0, Rd=0, imm12=0, Rn=0, cond=0
    let encoding: u32 = 0x02800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_add_i_a1_a_field_rd_1_poweroftwo_0_02801000() {
    // Encoding: 0x02801000
    // Test aarch32_ADD_i_A1_A field Rd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, Rn=0, cond=0, imm12=0, Rd=1
    let encoding: u32 = 0x02801000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_add_i_a1_a_field_imm12_0_zero_0_02800000() {
    // Encoding: 0x02800000
    // Test aarch32_ADD_i_A1_A field imm12 = 0 (Zero)
    // ISET: A32
    // Fields: Rn=0, imm12=0, cond=0, S=0, Rd=0
    let encoding: u32 = 0x02800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_add_i_a1_a_field_imm12_1_poweroftwo_0_02800001() {
    // Encoding: 0x02800001
    // Test aarch32_ADD_i_A1_A field imm12 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=0, Rd=0, imm12=1, S=0
    let encoding: u32 = 0x02800001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_add_i_a1_a_field_imm12_3_poweroftwominusone_0_02800003() {
    // Encoding: 0x02800003
    // Test aarch32_ADD_i_A1_A field imm12 = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: S=0, Rn=0, cond=0, Rd=0, imm12=3
    let encoding: u32 = 0x02800003;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_add_i_a1_a_field_imm12_4_poweroftwo_0_02800004() {
    // Encoding: 0x02800004
    // Test aarch32_ADD_i_A1_A field imm12 = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, imm12=4, Rd=0, cond=0, S=0
    let encoding: u32 = 0x02800004;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_add_i_a1_a_field_imm12_7_poweroftwominusone_0_02800007() {
    // Encoding: 0x02800007
    // Test aarch32_ADD_i_A1_A field imm12 = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rn=0, cond=0, S=0, Rd=0, imm12=7
    let encoding: u32 = 0x02800007;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_add_i_a1_a_field_imm12_8_poweroftwo_0_02800008() {
    // Encoding: 0x02800008
    // Test aarch32_ADD_i_A1_A field imm12 = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Rn=0, S=0, imm12=8, Rd=0
    let encoding: u32 = 0x02800008;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_add_i_a1_a_field_imm12_15_poweroftwominusone_0_0280000f() {
    // Encoding: 0x0280000F
    // Test aarch32_ADD_i_A1_A field imm12 = 15 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm12=15, S=0, Rn=0, Rd=0, cond=0
    let encoding: u32 = 0x0280000F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_add_i_a1_a_field_imm12_16_poweroftwo_0_02800010() {
    // Encoding: 0x02800010
    // Test aarch32_ADD_i_A1_A field imm12 = 16 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, cond=0, Rd=0, imm12=16, Rn=0
    let encoding: u32 = 0x02800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_add_i_a1_a_field_imm12_31_poweroftwominusone_0_0280001f() {
    // Encoding: 0x0280001F
    // Test aarch32_ADD_i_A1_A field imm12 = 31 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: S=0, imm12=31, Rn=0, Rd=0, cond=0
    let encoding: u32 = 0x0280001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_add_i_a1_a_field_imm12_32_poweroftwo_0_02800020() {
    // Encoding: 0x02800020
    // Test aarch32_ADD_i_A1_A field imm12 = 32 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, imm12=32, Rd=0, Rn=0, cond=0
    let encoding: u32 = 0x02800020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_add_i_a1_a_field_imm12_63_poweroftwominusone_0_0280003f() {
    // Encoding: 0x0280003F
    // Test aarch32_ADD_i_A1_A field imm12 = 63 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: S=0, Rn=0, imm12=63, cond=0, Rd=0
    let encoding: u32 = 0x0280003F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_add_i_a1_a_field_imm12_64_poweroftwo_0_02800040() {
    // Encoding: 0x02800040
    // Test aarch32_ADD_i_A1_A field imm12 = 64 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, imm12=64, cond=0, Rn=0, Rd=0
    let encoding: u32 = 0x02800040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 127, boundary: PowerOfTwoMinusOne }
/// 2^7 - 1 = 127
#[test]
fn test_aarch32_add_i_a1_a_field_imm12_127_poweroftwominusone_0_0280007f() {
    // Encoding: 0x0280007F
    // Test aarch32_ADD_i_A1_A field imm12 = 127 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rd=0, imm12=127, Rn=0, S=0, cond=0
    let encoding: u32 = 0x0280007F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_add_i_a1_a_field_imm12_128_poweroftwo_0_02800080() {
    // Encoding: 0x02800080
    // Test aarch32_ADD_i_A1_A field imm12 = 128 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, imm12=128, Rd=0, cond=0, S=0
    let encoding: u32 = 0x02800080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 255, boundary: PowerOfTwoMinusOne }
/// 2^8 - 1 = 255
#[test]
fn test_aarch32_add_i_a1_a_field_imm12_255_poweroftwominusone_0_028000ff() {
    // Encoding: 0x028000FF
    // Test aarch32_ADD_i_A1_A field imm12 = 255 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm12=255, Rn=0, S=0, cond=0, Rd=0
    let encoding: u32 = 0x028000FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 256, boundary: PowerOfTwo }
/// power of 2 (2^8 = 256)
#[test]
fn test_aarch32_add_i_a1_a_field_imm12_256_poweroftwo_0_02800100() {
    // Encoding: 0x02800100
    // Test aarch32_ADD_i_A1_A field imm12 = 256 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, imm12=256, S=0, cond=0, Rn=0
    let encoding: u32 = 0x02800100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 511, boundary: PowerOfTwoMinusOne }
/// 2^9 - 1 = 511
#[test]
fn test_aarch32_add_i_a1_a_field_imm12_511_poweroftwominusone_0_028001ff() {
    // Encoding: 0x028001FF
    // Test aarch32_ADD_i_A1_A field imm12 = 511 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rd=0, imm12=511, Rn=0, cond=0, S=0
    let encoding: u32 = 0x028001FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 512, boundary: PowerOfTwo }
/// power of 2 (2^9 = 512)
#[test]
fn test_aarch32_add_i_a1_a_field_imm12_512_poweroftwo_0_02800200() {
    // Encoding: 0x02800200
    // Test aarch32_ADD_i_A1_A field imm12 = 512 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=0, S=0, Rd=0, imm12=512
    let encoding: u32 = 0x02800200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1023, boundary: PowerOfTwoMinusOne }
/// 2^10 - 1 = 1023
#[test]
fn test_aarch32_add_i_a1_a_field_imm12_1023_poweroftwominusone_0_028003ff() {
    // Encoding: 0x028003FF
    // Test aarch32_ADD_i_A1_A field imm12 = 1023 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, Rn=0, Rd=0, S=0, imm12=1023
    let encoding: u32 = 0x028003FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1024, boundary: PowerOfTwo }
/// power of 2 (2^10 = 1024)
#[test]
fn test_aarch32_add_i_a1_a_field_imm12_1024_poweroftwo_0_02800400() {
    // Encoding: 0x02800400
    // Test aarch32_ADD_i_A1_A field imm12 = 1024 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rn=0, cond=0, imm12=1024, S=0
    let encoding: u32 = 0x02800400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2047, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (2047)
#[test]
fn test_aarch32_add_i_a1_a_field_imm12_2047_poweroftwominusone_0_028007ff() {
    // Encoding: 0x028007FF
    // Test aarch32_ADD_i_A1_A field imm12 = 2047 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm12=2047, cond=0, S=0, Rn=0, Rd=0
    let encoding: u32 = 0x028007FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2048, boundary: PowerOfTwo }
/// power of 2 (2^11 = 2048)
#[test]
fn test_aarch32_add_i_a1_a_field_imm12_2048_poweroftwo_0_02800800() {
    // Encoding: 0x02800800
    // Test aarch32_ADD_i_A1_A field imm12 = 2048 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, cond=0, Rn=0, Rd=0, imm12=2048
    let encoding: u32 = 0x02800800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4095, boundary: Max }
/// maximum immediate (4095)
#[test]
fn test_aarch32_add_i_a1_a_field_imm12_4095_max_0_02800fff() {
    // Encoding: 0x02800FFF
    // Test aarch32_ADD_i_A1_A field imm12 = 4095 (Max)
    // ISET: A32
    // Fields: Rn=0, cond=0, S=0, Rd=0, imm12=4095
    let encoding: u32 = 0x02800FFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_add_i_a1_a_combo_0_0_02800000() {
    // Encoding: 0x02800000
    // Test aarch32_ADD_i_A1_A field combination: cond=0, S=0, Rn=0, Rd=0, imm12=0
    // ISET: A32
    // Fields: Rn=0, S=0, cond=0, imm12=0, Rd=0
    let encoding: u32 = 0x02800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_add_i_a1_a_special_cond_0_condition_eq_0_02800000() {
    // Encoding: 0x02800000
    // Test aarch32_ADD_i_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: Rn=0, S=0, imm12=0, cond=0, Rd=0
    let encoding: u32 = 0x02800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_add_i_a1_a_special_cond_1_condition_ne_0_12800000() {
    // Encoding: 0x12800000
    // Test aarch32_ADD_i_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: cond=1, Rd=0, S=0, Rn=0, imm12=0
    let encoding: u32 = 0x12800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_add_i_a1_a_special_cond_2_condition_cs_hs_0_22800000() {
    // Encoding: 0x22800000
    // Test aarch32_ADD_i_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: cond=2, Rn=0, Rd=0, S=0, imm12=0
    let encoding: u32 = 0x22800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_add_i_a1_a_special_cond_3_condition_cc_lo_0_32800000() {
    // Encoding: 0x32800000
    // Test aarch32_ADD_i_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: cond=3, Rn=0, Rd=0, imm12=0, S=0
    let encoding: u32 = 0x32800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_add_i_a1_a_special_cond_4_condition_mi_0_42800000() {
    // Encoding: 0x42800000
    // Test aarch32_ADD_i_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: cond=4, imm12=0, Rn=0, Rd=0, S=0
    let encoding: u32 = 0x42800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_add_i_a1_a_special_cond_5_condition_pl_0_52800000() {
    // Encoding: 0x52800000
    // Test aarch32_ADD_i_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: imm12=0, cond=5, S=0, Rn=0, Rd=0
    let encoding: u32 = 0x52800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_add_i_a1_a_special_cond_6_condition_vs_0_62800000() {
    // Encoding: 0x62800000
    // Test aarch32_ADD_i_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: imm12=0, S=0, Rn=0, Rd=0, cond=6
    let encoding: u32 = 0x62800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_add_i_a1_a_special_cond_7_condition_vc_0_72800000() {
    // Encoding: 0x72800000
    // Test aarch32_ADD_i_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: Rd=0, Rn=0, S=0, cond=7, imm12=0
    let encoding: u32 = 0x72800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_add_i_a1_a_special_cond_8_condition_hi_0_82800000() {
    // Encoding: 0x82800000
    // Test aarch32_ADD_i_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: S=0, Rn=0, imm12=0, cond=8, Rd=0
    let encoding: u32 = 0x82800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_add_i_a1_a_special_cond_9_condition_ls_0_92800000() {
    // Encoding: 0x92800000
    // Test aarch32_ADD_i_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: S=0, cond=9, imm12=0, Rd=0, Rn=0
    let encoding: u32 = 0x92800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_add_i_a1_a_special_cond_10_condition_ge_0_a2800000() {
    // Encoding: 0xA2800000
    // Test aarch32_ADD_i_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: imm12=0, S=0, Rd=0, Rn=0, cond=10
    let encoding: u32 = 0xA2800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_add_i_a1_a_special_cond_11_condition_lt_0_b2800000() {
    // Encoding: 0xB2800000
    // Test aarch32_ADD_i_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: Rn=0, S=0, Rd=0, cond=11, imm12=0
    let encoding: u32 = 0xB2800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_add_i_a1_a_special_cond_12_condition_gt_0_c2800000() {
    // Encoding: 0xC2800000
    // Test aarch32_ADD_i_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: cond=12, S=0, imm12=0, Rn=0, Rd=0
    let encoding: u32 = 0xC2800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_add_i_a1_a_special_cond_13_condition_le_0_d2800000() {
    // Encoding: 0xD2800000
    // Test aarch32_ADD_i_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: cond=13, imm12=0, S=0, Rd=0, Rn=0
    let encoding: u32 = 0xD2800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_add_i_a1_a_special_cond_14_condition_al_0_e2800000() {
    // Encoding: 0xE2800000
    // Test aarch32_ADD_i_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: S=0, Rd=0, imm12=0, Rn=0, cond=14
    let encoding: u32 = 0xE2800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_add_i_a1_a_special_cond_15_condition_nv_0_f2800000() {
    // Encoding: 0xF2800000
    // Test aarch32_ADD_i_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: cond=15, S=0, imm12=0, Rd=0, Rn=0
    let encoding: u32 = 0xF2800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `field S = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "S", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_add_i_a1_a_special_s_0_size_variant_0_0_02800000() {
    // Encoding: 0x02800000
    // Test aarch32_ADD_i_A1_A special value S = 0 (Size variant 0)
    // ISET: A32
    // Fields: Rn=0, S=0, cond=0, Rd=0, imm12=0
    let encoding: u32 = 0x02800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `field S = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "S", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_add_i_a1_a_special_s_1_size_variant_1_0_02900000() {
    // Encoding: 0x02900000
    // Test aarch32_ADD_i_A1_A special value S = 1 (Size variant 1)
    // ISET: A32
    // Fields: Rn=0, S=1, Rd=0, cond=0, imm12=0
    let encoding: u32 = 0x02900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_i_T1_A
/// ASL: `field imm3 22 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_add_i_t1_a_field_imm3_0_zero_0_1c000000() {
    // Thumb encoding (32): 0x1C000000
    // Test aarch32_ADD_i_T1_A field imm3 = 0 (Zero)
    // ISET: T32
    // Fields: Rn=0, imm3=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x1C000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_i_T1_A
/// ASL: `field imm3 22 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_add_i_t1_a_field_imm3_1_poweroftwo_0_1c400000() {
    // Thumb encoding (32): 0x1C400000
    // Test aarch32_ADD_i_T1_A field imm3 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rd=0, Rn=0, imm3=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x1C400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_i_T1_A
/// ASL: `field imm3 22 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 3, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (3)
#[test]
fn test_aarch32_add_i_t1_a_field_imm3_3_poweroftwominusone_0_1cc00000() {
    // Thumb encoding (32): 0x1CC00000
    // Test aarch32_ADD_i_T1_A field imm3 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm3=3, Rd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x1CC00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_i_T1_A
/// ASL: `field imm3 22 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 7, boundary: Max }
/// maximum immediate (7)
#[test]
fn test_aarch32_add_i_t1_a_field_imm3_7_max_0_1dc00000() {
    // Thumb encoding (32): 0x1DC00000
    // Test aarch32_ADD_i_T1_A field imm3 = 7 (Max)
    // ISET: T32
    // Fields: imm3=7, Rd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x1DC00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_i_T1_A
/// ASL: `field Rn 19 +: 3`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_add_i_t1_a_field_rn_0_min_0_1c000000() {
    // Thumb encoding (32): 0x1C000000
    // Test aarch32_ADD_i_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: imm3=0, Rd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x1C000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_i_T1_A
/// ASL: `field Rn 19 +: 3`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_add_i_t1_a_field_rn_1_poweroftwo_0_1c080000() {
    // Thumb encoding (32): 0x1C080000
    // Test aarch32_ADD_i_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rd=0, imm3=0, Rn=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x1C080000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_i_T1_A
/// ASL: `field Rd 16 +: 3`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_add_i_t1_a_field_rd_0_min_0_1c000000() {
    // Thumb encoding (32): 0x1C000000
    // Test aarch32_ADD_i_T1_A field Rd = 0 (Min)
    // ISET: T32
    // Fields: Rd=0, imm3=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x1C000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_i_T1_A
/// ASL: `field Rd 16 +: 3`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_add_i_t1_a_field_rd_1_poweroftwo_0_1c010000() {
    // Thumb encoding (32): 0x1C010000
    // Test aarch32_ADD_i_T1_A field Rd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm3=0, Rn=0, Rd=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x1C010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_i_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm3=0 (immediate value 0)
#[test]
fn test_aarch32_add_i_t1_a_combo_0_0_1c000000() {
    // Thumb encoding (32): 0x1C000000
    // Test aarch32_ADD_i_T1_A field combination: imm3=0, Rn=0, Rd=0
    // ISET: T32
    // Fields: Rn=0, Rd=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x1C000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_i_T2_A
/// ASL: `field Rdn 24 +: 3`
/// Requirement: FieldBoundary { field: "Rdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_add_i_t2_a_field_rdn_0_min_0_30000000() {
    // Thumb encoding (32): 0x30000000
    // Test aarch32_ADD_i_T2_A field Rdn = 0 (Min)
    // ISET: T32
    // Fields: imm8=0, Rdn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x30000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_i_T2_A
/// ASL: `field Rdn 24 +: 3`
/// Requirement: FieldBoundary { field: "Rdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_add_i_t2_a_field_rdn_1_poweroftwo_0_31000000() {
    // Thumb encoding (32): 0x31000000
    // Test aarch32_ADD_i_T2_A field Rdn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=0, Rdn=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x31000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_i_T2_A
/// ASL: `field Rdn 24 +: 3`
/// Requirement: FieldBoundary { field: "Rdn", value: 7, boundary: Max }
/// maximum value (7)
#[test]
fn test_aarch32_add_i_t2_a_field_rdn_7_max_0_37000000() {
    // Thumb encoding (32): 0x37000000
    // Test aarch32_ADD_i_T2_A field Rdn = 7 (Max)
    // ISET: T32
    // Fields: imm8=0, Rdn=7
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x37000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_i_T2_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_add_i_t2_a_field_imm8_0_zero_0_30000000() {
    // Thumb encoding (32): 0x30000000
    // Test aarch32_ADD_i_T2_A field imm8 = 0 (Zero)
    // ISET: T32
    // Fields: imm8=0, Rdn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x30000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_i_T2_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_add_i_t2_a_field_imm8_1_poweroftwo_0_30010000() {
    // Thumb encoding (32): 0x30010000
    // Test aarch32_ADD_i_T2_A field imm8 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=1, Rdn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x30010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_i_T2_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_add_i_t2_a_field_imm8_3_poweroftwominusone_0_30030000() {
    // Thumb encoding (32): 0x30030000
    // Test aarch32_ADD_i_T2_A field imm8 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rdn=0, imm8=3
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x30030000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_i_T2_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_add_i_t2_a_field_imm8_4_poweroftwo_0_30040000() {
    // Thumb encoding (32): 0x30040000
    // Test aarch32_ADD_i_T2_A field imm8 = 4 (PowerOfTwo)
    // ISET: T32
    // Fields: Rdn=0, imm8=4
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x30040000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_i_T2_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_add_i_t2_a_field_imm8_7_poweroftwominusone_0_30070000() {
    // Thumb encoding (32): 0x30070000
    // Test aarch32_ADD_i_T2_A field imm8 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm8=7, Rdn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x30070000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_i_T2_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_add_i_t2_a_field_imm8_8_poweroftwo_0_30080000() {
    // Thumb encoding (32): 0x30080000
    // Test aarch32_ADD_i_T2_A field imm8 = 8 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=8, Rdn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x30080000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_i_T2_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_add_i_t2_a_field_imm8_15_poweroftwominusone_0_300f0000() {
    // Thumb encoding (32): 0x300F0000
    // Test aarch32_ADD_i_T2_A field imm8 = 15 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rdn=0, imm8=15
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x300F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_i_T2_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_add_i_t2_a_field_imm8_16_poweroftwo_0_30100000() {
    // Thumb encoding (32): 0x30100000
    // Test aarch32_ADD_i_T2_A field imm8 = 16 (PowerOfTwo)
    // ISET: T32
    // Fields: Rdn=0, imm8=16
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x30100000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_i_T2_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_add_i_t2_a_field_imm8_31_poweroftwominusone_0_301f0000() {
    // Thumb encoding (32): 0x301F0000
    // Test aarch32_ADD_i_T2_A field imm8 = 31 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm8=31, Rdn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x301F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_i_T2_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_add_i_t2_a_field_imm8_32_poweroftwo_0_30200000() {
    // Thumb encoding (32): 0x30200000
    // Test aarch32_ADD_i_T2_A field imm8 = 32 (PowerOfTwo)
    // ISET: T32
    // Fields: Rdn=0, imm8=32
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x30200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_i_T2_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_add_i_t2_a_field_imm8_63_poweroftwominusone_0_303f0000() {
    // Thumb encoding (32): 0x303F0000
    // Test aarch32_ADD_i_T2_A field imm8 = 63 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm8=63, Rdn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x303F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_i_T2_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_add_i_t2_a_field_imm8_64_poweroftwo_0_30400000() {
    // Thumb encoding (32): 0x30400000
    // Test aarch32_ADD_i_T2_A field imm8 = 64 (PowerOfTwo)
    // ISET: T32
    // Fields: Rdn=0, imm8=64
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x30400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_i_T2_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 127, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (127)
#[test]
fn test_aarch32_add_i_t2_a_field_imm8_127_poweroftwominusone_0_307f0000() {
    // Thumb encoding (32): 0x307F0000
    // Test aarch32_ADD_i_T2_A field imm8 = 127 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rdn=0, imm8=127
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x307F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_i_T2_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_add_i_t2_a_field_imm8_128_poweroftwo_0_30800000() {
    // Thumb encoding (32): 0x30800000
    // Test aarch32_ADD_i_T2_A field imm8 = 128 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=128, Rdn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x30800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_i_T2_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 255, boundary: Max }
/// maximum immediate (255)
#[test]
fn test_aarch32_add_i_t2_a_field_imm8_255_max_0_30ff0000() {
    // Thumb encoding (32): 0x30FF0000
    // Test aarch32_ADD_i_T2_A field imm8 = 255 (Max)
    // ISET: T32
    // Fields: Rdn=0, imm8=255
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x30FF0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_i_T2_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rdn=0 (minimum value)
#[test]
fn test_aarch32_add_i_t2_a_combo_0_0_30000000() {
    // Thumb encoding (32): 0x30000000
    // Test aarch32_ADD_i_T2_A field combination: Rdn=0, imm8=0
    // ISET: T32
    // Fields: Rdn=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x30000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `field i 26 +: 1`
/// Requirement: FieldBoundary { field: "i", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_add_i_t3_a_field_i_0_min_0_f1000000() {
    // Thumb encoding (32): 0xF1000000
    // Test aarch32_ADD_i_T3_A field i = 0 (Min)
    // ISET: T32
    // Fields: imm3=0, S=0, Rd=0, imm8=0, i=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `field i 26 +: 1`
/// Requirement: FieldBoundary { field: "i", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_add_i_t3_a_field_i_1_max_0_f5000000() {
    // Thumb encoding (32): 0xF5000000
    // Test aarch32_ADD_i_T3_A field i = 1 (Max)
    // ISET: T32
    // Fields: imm8=0, Rn=0, imm3=0, i=1, S=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF5000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_add_i_t3_a_field_s_0_min_0_f1000000() {
    // Thumb encoding (32): 0xF1000000
    // Test aarch32_ADD_i_T3_A field S = 0 (Min)
    // ISET: T32
    // Fields: S=0, Rd=0, i=0, imm8=0, Rn=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_add_i_t3_a_field_s_1_max_0_f1100000() {
    // Thumb encoding (32): 0xF1100000
    // Test aarch32_ADD_i_T3_A field S = 1 (Max)
    // ISET: T32
    // Fields: imm8=0, S=1, Rd=0, imm3=0, i=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1100000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_add_i_t3_a_field_rn_0_min_0_f1000000() {
    // Thumb encoding (32): 0xF1000000
    // Test aarch32_ADD_i_T3_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: S=0, i=0, imm3=0, Rd=0, imm8=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_add_i_t3_a_field_rn_1_poweroftwo_0_f1010000() {
    // Thumb encoding (32): 0xF1010000
    // Test aarch32_ADD_i_T3_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=0, i=0, S=0, Rn=1, imm3=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_add_i_t3_a_field_imm3_0_zero_0_f1000000() {
    // Thumb encoding (32): 0xF1000000
    // Test aarch32_ADD_i_T3_A field imm3 = 0 (Zero)
    // ISET: T32
    // Fields: Rn=0, i=0, imm8=0, S=0, imm3=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_add_i_t3_a_field_imm3_1_poweroftwo_0_f1001000() {
    // Thumb encoding (32): 0xF1001000
    // Test aarch32_ADD_i_T3_A field imm3 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=0, Rn=0, i=0, Rd=0, S=0, imm3=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1001000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 3, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (3)
#[test]
fn test_aarch32_add_i_t3_a_field_imm3_3_poweroftwominusone_0_f1003000() {
    // Thumb encoding (32): 0xF1003000
    // Test aarch32_ADD_i_T3_A field imm3 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm8=0, Rn=0, S=0, Rd=0, imm3=3, i=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1003000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 7, boundary: Max }
/// maximum immediate (7)
#[test]
fn test_aarch32_add_i_t3_a_field_imm3_7_max_0_f1007000() {
    // Thumb encoding (32): 0xF1007000
    // Test aarch32_ADD_i_T3_A field imm3 = 7 (Max)
    // ISET: T32
    // Fields: i=0, imm3=7, Rn=0, S=0, Rd=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1007000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_add_i_t3_a_field_rd_0_min_0_f1000000() {
    // Thumb encoding (32): 0xF1000000
    // Test aarch32_ADD_i_T3_A field Rd = 0 (Min)
    // ISET: T32
    // Fields: imm3=0, imm8=0, Rd=0, i=0, S=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_add_i_t3_a_field_rd_1_poweroftwo_0_f1000100() {
    // Thumb encoding (32): 0xF1000100
    // Test aarch32_ADD_i_T3_A field Rd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm3=0, i=0, S=0, Rd=1, imm8=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1000100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_add_i_t3_a_field_imm8_0_zero_0_f1000000() {
    // Thumb encoding (32): 0xF1000000
    // Test aarch32_ADD_i_T3_A field imm8 = 0 (Zero)
    // ISET: T32
    // Fields: Rd=0, imm3=0, i=0, Rn=0, S=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_add_i_t3_a_field_imm8_1_poweroftwo_0_f1000001() {
    // Thumb encoding (32): 0xF1000001
    // Test aarch32_ADD_i_T3_A field imm8 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm3=0, Rd=0, imm8=1, S=0, i=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1000001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_add_i_t3_a_field_imm8_3_poweroftwominusone_0_f1000003() {
    // Thumb encoding (32): 0xF1000003
    // Test aarch32_ADD_i_T3_A field imm8 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm8=3, S=0, i=0, imm3=0, Rd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1000003;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_add_i_t3_a_field_imm8_4_poweroftwo_0_f1000004() {
    // Thumb encoding (32): 0xF1000004
    // Test aarch32_ADD_i_T3_A field imm8 = 4 (PowerOfTwo)
    // ISET: T32
    // Fields: i=0, S=0, Rd=0, Rn=0, imm3=0, imm8=4
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1000004;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_add_i_t3_a_field_imm8_7_poweroftwominusone_0_f1000007() {
    // Thumb encoding (32): 0xF1000007
    // Test aarch32_ADD_i_T3_A field imm8 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: i=0, S=0, imm3=0, imm8=7, Rn=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1000007;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_add_i_t3_a_field_imm8_8_poweroftwo_0_f1000008() {
    // Thumb encoding (32): 0xF1000008
    // Test aarch32_ADD_i_T3_A field imm8 = 8 (PowerOfTwo)
    // ISET: T32
    // Fields: imm3=0, Rd=0, imm8=8, i=0, S=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1000008;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_add_i_t3_a_field_imm8_15_poweroftwominusone_0_f100000f() {
    // Thumb encoding (32): 0xF100000F
    // Test aarch32_ADD_i_T3_A field imm8 = 15 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: S=0, imm8=15, Rn=0, imm3=0, Rd=0, i=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF100000F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_add_i_t3_a_field_imm8_16_poweroftwo_0_f1000010() {
    // Thumb encoding (32): 0xF1000010
    // Test aarch32_ADD_i_T3_A field imm8 = 16 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=16, i=0, Rd=0, Rn=0, S=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1000010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_add_i_t3_a_field_imm8_31_poweroftwominusone_0_f100001f() {
    // Thumb encoding (32): 0xF100001F
    // Test aarch32_ADD_i_T3_A field imm8 = 31 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, imm3=0, Rd=0, imm8=31, i=0, S=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF100001F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_add_i_t3_a_field_imm8_32_poweroftwo_0_f1000020() {
    // Thumb encoding (32): 0xF1000020
    // Test aarch32_ADD_i_T3_A field imm8 = 32 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, i=0, S=0, imm3=0, Rd=0, imm8=32
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1000020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_add_i_t3_a_field_imm8_63_poweroftwominusone_0_f100003f() {
    // Thumb encoding (32): 0xF100003F
    // Test aarch32_ADD_i_T3_A field imm8 = 63 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: i=0, imm8=63, imm3=0, S=0, Rd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF100003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_add_i_t3_a_field_imm8_64_poweroftwo_0_f1000040() {
    // Thumb encoding (32): 0xF1000040
    // Test aarch32_ADD_i_T3_A field imm8 = 64 (PowerOfTwo)
    // ISET: T32
    // Fields: imm3=0, imm8=64, Rd=0, S=0, Rn=0, i=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1000040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 127, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (127)
#[test]
fn test_aarch32_add_i_t3_a_field_imm8_127_poweroftwominusone_0_f100007f() {
    // Thumb encoding (32): 0xF100007F
    // Test aarch32_ADD_i_T3_A field imm8 = 127 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: i=0, S=0, Rn=0, imm3=0, imm8=127, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF100007F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_add_i_t3_a_field_imm8_128_poweroftwo_0_f1000080() {
    // Thumb encoding (32): 0xF1000080
    // Test aarch32_ADD_i_T3_A field imm8 = 128 (PowerOfTwo)
    // ISET: T32
    // Fields: i=0, S=0, Rn=0, imm3=0, Rd=0, imm8=128
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1000080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 255, boundary: Max }
/// maximum immediate (255)
#[test]
fn test_aarch32_add_i_t3_a_field_imm8_255_max_0_f10000ff() {
    // Thumb encoding (32): 0xF10000FF
    // Test aarch32_ADD_i_T3_A field imm8 = 255 (Max)
    // ISET: T32
    // Fields: S=0, imm8=255, imm3=0, Rd=0, Rn=0, i=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF10000FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// i=0 (minimum value)
#[test]
fn test_aarch32_add_i_t3_a_combo_0_0_f1000000() {
    // Thumb encoding (32): 0xF1000000
    // Test aarch32_ADD_i_T3_A field combination: i=0, S=0, Rn=0, imm3=0, Rd=0, imm8=0
    // ISET: T32
    // Fields: imm3=0, i=0, Rn=0, S=0, Rd=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `field S = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "S", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_add_i_t3_a_special_s_0_size_variant_0_0_f1000000() {
    // Thumb encoding (32): 0xF1000000
    // Test aarch32_ADD_i_T3_A special value S = 0 (Size variant 0)
    // ISET: T32
    // Fields: imm8=0, Rn=0, imm3=0, Rd=0, i=0, S=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `field S = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "S", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_add_i_t3_a_special_s_1_size_variant_1_0_f1100000() {
    // Thumb encoding (32): 0xF1100000
    // Test aarch32_ADD_i_T3_A special value S = 1 (Size variant 1)
    // ISET: T32
    // Fields: imm3=0, Rn=0, i=0, Rd=0, S=1, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1100000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Or, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: And, lhs: LitInt(15), rhs: Unary { op: Not, operand: Var(QualifiedIdentifier { qualifier: Any, name: "setflags" }) } } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Or, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: And, lhs: LitInt(15), rhs: Unary { op: Not, operand: Var(QualifiedIdentifier { qualifier: Any, name: \"setflags\" }) } } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_add_i_t3_a_invalid_0_0_f1000000() {
    // Thumb encoding (32): 0xF1000000
    // Test aarch32_ADD_i_T3_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Or, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: And, lhs: LitInt(15), rhs: Unary { op: Not, operand: Var(QualifiedIdentifier { qualifier: Any, name: "setflags" }) } } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) }, rhs: LitInt(15) }
    // ISET: T32
    // Fields: Rd=0, Rn=0, imm3=0, imm8=0, S=0, i=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1000000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_add_i_t3_a_invalid_1_0_f1000000() {
    // Thumb encoding (32): 0xF1000000
    // Test aarch32_ADD_i_T3_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rd=0, imm8=0, imm3=0, S=0, Rn=0, i=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1000000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_ADD_i_T4_A
/// ASL: `field i 26 +: 1`
/// Requirement: FieldBoundary { field: "i", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_add_i_t4_a_field_i_0_min_0_f2000000() {
    // Thumb encoding (32): 0xF2000000
    // Test aarch32_ADD_i_T4_A field i = 0 (Min)
    // ISET: T32
    // Fields: imm8=0, imm3=0, Rd=0, Rn=0, i=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_i_T4_A
/// ASL: `field i 26 +: 1`
/// Requirement: FieldBoundary { field: "i", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_add_i_t4_a_field_i_1_max_0_f6000000() {
    // Thumb encoding (32): 0xF6000000
    // Test aarch32_ADD_i_T4_A field i = 1 (Max)
    // ISET: T32
    // Fields: Rd=0, imm8=0, imm3=0, i=1, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF6000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_i_T4_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_add_i_t4_a_field_rn_0_min_0_f2000000() {
    // Thumb encoding (32): 0xF2000000
    // Test aarch32_ADD_i_T4_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: i=0, imm3=0, imm8=0, Rn=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_i_T4_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_add_i_t4_a_field_rn_1_poweroftwo_0_f2010000() {
    // Thumb encoding (32): 0xF2010000
    // Test aarch32_ADD_i_T4_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=1, imm3=0, i=0, imm8=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_i_T4_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_add_i_t4_a_field_imm3_0_zero_0_f2000000() {
    // Thumb encoding (32): 0xF2000000
    // Test aarch32_ADD_i_T4_A field imm3 = 0 (Zero)
    // ISET: T32
    // Fields: Rd=0, imm3=0, Rn=0, imm8=0, i=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_i_T4_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_add_i_t4_a_field_imm3_1_poweroftwo_0_f2001000() {
    // Thumb encoding (32): 0xF2001000
    // Test aarch32_ADD_i_T4_A field imm3 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, i=0, Rd=0, imm3=1, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2001000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_i_T4_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 3, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (3)
#[test]
fn test_aarch32_add_i_t4_a_field_imm3_3_poweroftwominusone_0_f2003000() {
    // Thumb encoding (32): 0xF2003000
    // Test aarch32_ADD_i_T4_A field imm3 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rd=0, i=0, imm8=0, imm3=3, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2003000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_i_T4_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 7, boundary: Max }
/// maximum immediate (7)
#[test]
fn test_aarch32_add_i_t4_a_field_imm3_7_max_0_f2007000() {
    // Thumb encoding (32): 0xF2007000
    // Test aarch32_ADD_i_T4_A field imm3 = 7 (Max)
    // ISET: T32
    // Fields: i=0, imm3=7, imm8=0, Rn=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2007000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_i_T4_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_add_i_t4_a_field_rd_0_min_0_f2000000() {
    // Thumb encoding (32): 0xF2000000
    // Test aarch32_ADD_i_T4_A field Rd = 0 (Min)
    // ISET: T32
    // Fields: imm3=0, i=0, imm8=0, Rd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_i_T4_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_add_i_t4_a_field_rd_1_poweroftwo_0_f2000100() {
    // Thumb encoding (32): 0xF2000100
    // Test aarch32_ADD_i_T4_A field Rd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm3=0, i=0, imm8=0, Rd=1, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2000100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_i_T4_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_add_i_t4_a_field_imm8_0_zero_0_f2000000() {
    // Thumb encoding (32): 0xF2000000
    // Test aarch32_ADD_i_T4_A field imm8 = 0 (Zero)
    // ISET: T32
    // Fields: i=0, Rd=0, imm8=0, imm3=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_i_T4_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_add_i_t4_a_field_imm8_1_poweroftwo_0_f2000001() {
    // Thumb encoding (32): 0xF2000001
    // Test aarch32_ADD_i_T4_A field imm8 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=1, imm3=0, i=0, Rd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2000001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_i_T4_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_add_i_t4_a_field_imm8_3_poweroftwominusone_0_f2000003() {
    // Thumb encoding (32): 0xF2000003
    // Test aarch32_ADD_i_T4_A field imm8 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm3=0, i=0, Rd=0, Rn=0, imm8=3
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2000003;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_i_T4_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_add_i_t4_a_field_imm8_4_poweroftwo_0_f2000004() {
    // Thumb encoding (32): 0xF2000004
    // Test aarch32_ADD_i_T4_A field imm8 = 4 (PowerOfTwo)
    // ISET: T32
    // Fields: imm3=0, i=0, Rn=0, Rd=0, imm8=4
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2000004;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_i_T4_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_add_i_t4_a_field_imm8_7_poweroftwominusone_0_f2000007() {
    // Thumb encoding (32): 0xF2000007
    // Test aarch32_ADD_i_T4_A field imm8 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm8=7, i=0, Rn=0, Rd=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2000007;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_i_T4_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_add_i_t4_a_field_imm8_8_poweroftwo_0_f2000008() {
    // Thumb encoding (32): 0xF2000008
    // Test aarch32_ADD_i_T4_A field imm8 = 8 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=8, imm3=0, Rd=0, i=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2000008;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_i_T4_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_add_i_t4_a_field_imm8_15_poweroftwominusone_0_f200000f() {
    // Thumb encoding (32): 0xF200000F
    // Test aarch32_ADD_i_T4_A field imm8 = 15 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm3=0, imm8=15, i=0, Rd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF200000F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_i_T4_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_add_i_t4_a_field_imm8_16_poweroftwo_0_f2000010() {
    // Thumb encoding (32): 0xF2000010
    // Test aarch32_ADD_i_T4_A field imm8 = 16 (PowerOfTwo)
    // ISET: T32
    // Fields: i=0, Rd=0, imm3=0, imm8=16, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2000010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_i_T4_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_add_i_t4_a_field_imm8_31_poweroftwominusone_0_f200001f() {
    // Thumb encoding (32): 0xF200001F
    // Test aarch32_ADD_i_T4_A field imm8 = 31 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm8=31, Rn=0, imm3=0, i=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF200001F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_i_T4_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_add_i_t4_a_field_imm8_32_poweroftwo_0_f2000020() {
    // Thumb encoding (32): 0xF2000020
    // Test aarch32_ADD_i_T4_A field imm8 = 32 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, i=0, imm3=0, Rd=0, imm8=32
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2000020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_i_T4_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_add_i_t4_a_field_imm8_63_poweroftwominusone_0_f200003f() {
    // Thumb encoding (32): 0xF200003F
    // Test aarch32_ADD_i_T4_A field imm8 = 63 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm8=63, Rn=0, imm3=0, i=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF200003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_i_T4_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_add_i_t4_a_field_imm8_64_poweroftwo_0_f2000040() {
    // Thumb encoding (32): 0xF2000040
    // Test aarch32_ADD_i_T4_A field imm8 = 64 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, imm8=64, Rd=0, i=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2000040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_i_T4_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 127, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (127)
#[test]
fn test_aarch32_add_i_t4_a_field_imm8_127_poweroftwominusone_0_f200007f() {
    // Thumb encoding (32): 0xF200007F
    // Test aarch32_ADD_i_T4_A field imm8 = 127 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, imm3=0, imm8=127, i=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF200007F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_i_T4_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_add_i_t4_a_field_imm8_128_poweroftwo_0_f2000080() {
    // Thumb encoding (32): 0xF2000080
    // Test aarch32_ADD_i_T4_A field imm8 = 128 (PowerOfTwo)
    // ISET: T32
    // Fields: i=0, Rn=0, imm8=128, imm3=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2000080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_i_T4_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 255, boundary: Max }
/// maximum immediate (255)
#[test]
fn test_aarch32_add_i_t4_a_field_imm8_255_max_0_f20000ff() {
    // Thumb encoding (32): 0xF20000FF
    // Test aarch32_ADD_i_T4_A field imm8 = 255 (Max)
    // ISET: T32
    // Fields: imm8=255, Rn=0, imm3=0, i=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF20000FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_i_T4_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// i=0 (minimum value)
#[test]
fn test_aarch32_add_i_t4_a_combo_0_0_f2000000() {
    // Thumb encoding (32): 0xF2000000
    // Test aarch32_ADD_i_T4_A field combination: i=0, Rn=0, imm3=0, Rd=0, imm8=0
    // ISET: T32
    // Fields: i=0, Rd=0, imm8=0, imm3=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_i_T4_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_add_i_t4_a_invalid_0_0_f2000000() {
    // Thumb encoding (32): 0xF2000000
    // Test aarch32_ADD_i_T4_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: LitInt(15) }
    // ISET: T32
    // Fields: Rd=0, i=0, imm3=0, Rn=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2000000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_ADD_i_T4_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_add_i_t4_a_invalid_1_0_f2000000() {
    // Thumb encoding (32): 0xF2000000
    // Test aarch32_ADD_i_T4_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: imm3=0, i=0, Rd=0, imm8=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2000000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `ADD X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_add_i_a1_a_add_oracle_32_0_02802820() {
    // Test ADD 32-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0x02802820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x02802820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6E, "W0 should be 0x6E");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `ADD X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_add_i_a1_a_add_oracle_64_0_82802820() {
    // Test ADD 64-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0x82802820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x82802820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6E, "X0 should be 0x000000000000006E");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `ADD X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero operands (32)
#[test]
fn test_aarch32_add_i_a1_a_add_oracle_32_1_02800020() {
    // Test ADD 32-bit: zero operands (with oracle verification)
    // Encoding: 0x02800020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x02800020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x0");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `ADD X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero operands (64)
#[test]
fn test_aarch32_add_i_a1_a_add_oracle_64_1_82800020() {
    // Test ADD 64-bit: zero operands (with oracle verification)
    // Encoding: 0x82800020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x82800020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small values (32)
#[test]
fn test_aarch32_add_i_a1_a_add_oracle_32_2_02800420() {
    // Test ADD 32-bit: small values (with oracle verification)
    // Encoding: 0x02800420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x02800420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x2, "W0 should be 0x2");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// small values (64)
#[test]
fn test_aarch32_add_i_a1_a_add_oracle_64_2_82800420() {
    // Test ADD 64-bit: small values (with oracle verification)
    // Encoding: 0x82800420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x82800420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x2, "X0 should be 0x0000000000000002");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `ADD X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_add_i_a1_a_add_oracle_32_3_02bffc20() {
    // Test ADD 32-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0x02BFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x02BFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF, "W0 should be 0xFFF");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `ADD X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_add_i_a1_a_add_oracle_64_3_82bffc20() {
    // Test ADD 64-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0x82BFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x82BFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF, "X0 should be 0x0000000000000FFF");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `ADD X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_add_i_a1_a_add_oracle_32_4_02fffc20() {
    // Test ADD 32-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0x02FFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x02FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF000, "W0 should be 0xFFF000");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `ADD X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_add_i_a1_a_add_oracle_64_4_82fffc20() {
    // Test ADD 64-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0x82FFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x82FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF000, "X0 should be 0x0000000000FFF000");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max u64 operand (32)
#[test]
fn test_aarch32_add_i_a1_a_add_oracle_32_5_02800420() {
    // Test ADD 32-bit: max u64 operand (with oracle verification)
    // Encoding: 0x02800420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x02800420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x0");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max u64 operand (64)
#[test]
fn test_aarch32_add_i_a1_a_add_oracle_64_5_82800420() {
    // Test ADD 64-bit: max u64 operand (with oracle verification)
    // Encoding: 0x82800420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x82800420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_add_i_a1_a_add_oracle_32_6_02800420() {
    // Test ADD 32-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0x02800420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x02800420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x1");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_add_i_a1_a_add_oracle_64_6_82800420() {
    // Test ADD 64-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0x82800420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x82800420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x0000000000000001");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_add_i_a1_a_add_oracle_32_7_02800420() {
    // Test ADD 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0x02800420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x02800420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x0");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_add_i_a1_a_add_oracle_64_7_82800420() {
    // Test ADD 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0x82800420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x82800420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x8000000000000000");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_add_i_a1_a_add_oracle_32_8_02800420() {
    // Test ADD 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0x02800420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x02800420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "W0 should be 0x80000000");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_add_i_a1_a_add_oracle_64_8_82800420() {
    // Test ADD 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0x82800420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x82800420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x80000000,
        "X0 should be 0x0000000080000000"
    );
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_add_i_a1_a_add_oracle_32_9_02800420() {
    // Test ADD 32-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0x02800420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x02800420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x0");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_add_i_a1_a_add_oracle_64_9_82800420() {
    // Test ADD 64-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0x82800420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x82800420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_add_i_a1_a_add_oracle_32_10_02800420() {
    // Test ADD 32-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0x02800420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x02800420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x0");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_add_i_a1_a_add_oracle_64_10_82800420() {
    // Test ADD 64-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0x82800420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x82800420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000100000000");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `ADD SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (32)
#[test]
fn test_aarch32_add_i_a1_a_add_oracle_32_rd31_sp_0280283f() {
    // Test ADD 32-bit with Rd=31 (SP)
    // Encoding: 0x0280283F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x0280283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    // TODO: assertion - TestAssertion { check: Sp, expected: U64(110), message: "SP should be 0x6E" }
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `ADD SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (64)
#[test]
fn test_aarch32_add_i_a1_a_add_oracle_64_rd31_sp_8280283f() {
    // Test ADD 64-bit with Rd=31 (SP)
    // Encoding: 0x8280283F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x8280283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    // TODO: assertion - TestAssertion { check: Sp, expected: U64(110), message: "SP should be 0x6E" }
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `ADDS X0, X1, #10`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_add_i_a1_a_adds_oracle_32_0_22802820() {
    // Test ADDS 32-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0x22802820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x22802820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6E, "W0 should be 0x6E");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `ADDS X0, X1, #10`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_add_i_a1_a_adds_oracle_64_0_a2802820() {
    // Test ADDS 64-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0xA2802820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xA2802820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6E, "X0 should be 0x000000000000006E");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `ADDS X0, X1, #0`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero operands (32)
#[test]
fn test_aarch32_add_i_a1_a_adds_oracle_32_1_22800020() {
    // Test ADDS 32-bit: zero operands (with oracle verification)
    // Encoding: 0x22800020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x22800020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x0");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `ADDS X0, X1, #0`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero operands (64)
#[test]
fn test_aarch32_add_i_a1_a_adds_oracle_64_1_a2800020() {
    // Test ADDS 64-bit: zero operands (with oracle verification)
    // Encoding: 0xA2800020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xA2800020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// small values (32)
#[test]
fn test_aarch32_add_i_a1_a_adds_oracle_32_2_22800420() {
    // Test ADDS 32-bit: small values (with oracle verification)
    // Encoding: 0x22800420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x22800420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x2, "W0 should be 0x2");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// small values (64)
#[test]
fn test_aarch32_add_i_a1_a_adds_oracle_64_2_a2800420() {
    // Test ADDS 64-bit: small values (with oracle verification)
    // Encoding: 0xA2800420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xA2800420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x2, "X0 should be 0x0000000000000002");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `ADDS X0, X1, #4095`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_add_i_a1_a_adds_oracle_32_3_22bffc20() {
    // Test ADDS 32-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0x22BFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x22BFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF, "W0 should be 0xFFF");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `ADDS X0, X1, #4095`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_add_i_a1_a_adds_oracle_64_3_a2bffc20() {
    // Test ADDS 64-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0xA2BFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xA2BFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF, "X0 should be 0x0000000000000FFF");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `ADDS X0, X1, #4095, LSL #12`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_add_i_a1_a_adds_oracle_32_4_22fffc20() {
    // Test ADDS 32-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0x22FFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x22FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF000, "W0 should be 0xFFF000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `ADDS X0, X1, #4095, LSL #12`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_add_i_a1_a_adds_oracle_64_4_a2fffc20() {
    // Test ADDS 64-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0xA2FFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xA2FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF000, "X0 should be 0x0000000000FFF000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max u64 operand (32)
#[test]
fn test_aarch32_add_i_a1_a_adds_oracle_32_5_22800420() {
    // Test ADDS 32-bit: max u64 operand (with oracle verification)
    // Encoding: 0x22800420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x22800420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x0");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max u64 operand (64)
#[test]
fn test_aarch32_add_i_a1_a_adds_oracle_64_5_a2800420() {
    // Test ADDS 64-bit: max u64 operand (with oracle verification)
    // Encoding: 0xA2800420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xA2800420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_add_i_a1_a_adds_oracle_32_6_22800420() {
    // Test ADDS 32-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0x22800420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x22800420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x1");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_add_i_a1_a_adds_oracle_64_6_a2800420() {
    // Test ADDS 64-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0xA2800420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xA2800420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x0000000000000001");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_add_i_a1_a_adds_oracle_32_7_22800420() {
    // Test ADDS 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0x22800420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x22800420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x0");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_add_i_a1_a_adds_oracle_64_7_a2800420() {
    // Test ADDS 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0xA2800420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xA2800420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x8000000000000000");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, true, "V flag should be true");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_add_i_a1_a_adds_oracle_32_8_22800420() {
    // Test ADDS 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0x22800420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x22800420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "W0 should be 0x80000000");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, true, "V flag should be true");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_add_i_a1_a_adds_oracle_64_8_a2800420() {
    // Test ADDS 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0xA2800420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xA2800420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x80000000,
        "X0 should be 0x0000000080000000"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_add_i_a1_a_adds_oracle_32_9_22800420() {
    // Test ADDS 32-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0x22800420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x22800420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x0");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_add_i_a1_a_adds_oracle_64_9_a2800420() {
    // Test ADDS 64-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0xA2800420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xA2800420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_add_i_a1_a_adds_oracle_32_10_22800420() {
    // Test ADDS 32-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0x22800420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x22800420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x0");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_add_i_a1_a_adds_oracle_64_10_a2800420() {
    // Test ADDS 64-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0xA2800420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xA2800420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000100000000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `ADDS ZR, X1, #10`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "result discarded, flags set" }
/// ZR destination (32)
#[test]
fn test_aarch32_add_i_a1_a_adds_oracle_32_rd31_zr_2280283f() {
    // Test ADDS 32-bit with Rd=31 (ZR)
    // Encoding: 0x2280283F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x2280283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `ADDS ZR, X1, #10`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "result discarded, flags set" }
/// ZR destination (64)
#[test]
fn test_aarch32_add_i_a1_a_adds_oracle_64_rd31_zr_a280283f() {
    // Test ADDS 64-bit with Rd=31 (ZR)
    // Encoding: 0xA280283F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xA280283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `SUB X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_add_i_a1_a_sub_oracle_32_0_42802820() {
    // Test SUB 32-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0x42802820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x42802820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x5A, "W0 should be 0x5A");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `SUB X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_add_i_a1_a_sub_oracle_64_0_c2802820() {
    // Test SUB 64-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0xC2802820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xC2802820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x5A, "X0 should be 0x000000000000005A");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `SUB X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero operands (32)
#[test]
fn test_aarch32_add_i_a1_a_sub_oracle_32_1_42800020() {
    // Test SUB 32-bit: zero operands (with oracle verification)
    // Encoding: 0x42800020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x42800020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x0");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `SUB X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero operands (64)
#[test]
fn test_aarch32_add_i_a1_a_sub_oracle_64_1_c2800020() {
    // Test SUB 64-bit: zero operands (with oracle verification)
    // Encoding: 0xC2800020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xC2800020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small values (32)
#[test]
fn test_aarch32_add_i_a1_a_sub_oracle_32_2_42800420() {
    // Test SUB 32-bit: small values (with oracle verification)
    // Encoding: 0x42800420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x42800420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x0");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// small values (64)
#[test]
fn test_aarch32_add_i_a1_a_sub_oracle_64_2_c2800420() {
    // Test SUB 64-bit: small values (with oracle verification)
    // Encoding: 0xC2800420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xC2800420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `SUB X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_add_i_a1_a_sub_oracle_32_3_42bffc20() {
    // Test SUB 32-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0x42BFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x42BFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFF001, "W0 should be 0xFFFFF001");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `SUB X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_add_i_a1_a_sub_oracle_64_3_c2bffc20() {
    // Test SUB 64-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0xC2BFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xC2BFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `SUB X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_add_i_a1_a_sub_oracle_32_4_42fffc20() {
    // Test SUB 32-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0x42FFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x42FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF001000, "W0 should be 0xFF001000");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `SUB X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_add_i_a1_a_sub_oracle_64_4_c2fffc20() {
    // Test SUB 64-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0xC2FFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xC2FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max u64 operand (32)
#[test]
fn test_aarch32_add_i_a1_a_sub_oracle_32_5_42800420() {
    // Test SUB 32-bit: max u64 operand (with oracle verification)
    // Encoding: 0x42800420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x42800420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFE, "W0 should be 0xFFFFFFFE");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max u64 operand (64)
#[test]
fn test_aarch32_add_i_a1_a_sub_oracle_64_5_c2800420() {
    // Test SUB 64-bit: max u64 operand (with oracle verification)
    // Encoding: 0xC2800420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xC2800420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0xFFFFFFFFFFFFFFFE"
    );
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_add_i_a1_a_sub_oracle_32_6_42800420() {
    // Test SUB 32-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0x42800420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x42800420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "W0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_add_i_a1_a_sub_oracle_64_6_c2800420() {
    // Test SUB 64-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0xC2800420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xC2800420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_add_i_a1_a_sub_oracle_32_7_42800420() {
    // Test SUB 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0x42800420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x42800420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFE, "W0 should be 0xFFFFFFFE");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_add_i_a1_a_sub_oracle_64_7_c2800420() {
    // Test SUB 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0xC2800420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xC2800420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0x7FFFFFFFFFFFFFFE"
    );
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_add_i_a1_a_sub_oracle_32_8_42800420() {
    // Test SUB 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0x42800420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x42800420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FFFFFFE, "W0 should be 0x7FFFFFFE");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_add_i_a1_a_sub_oracle_64_8_c2800420() {
    // Test SUB 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0xC2800420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xC2800420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x7FFFFFFE,
        "X0 should be 0x000000007FFFFFFE"
    );
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_add_i_a1_a_sub_oracle_32_9_42800420() {
    // Test SUB 32-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0x42800420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x42800420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFE, "W0 should be 0xFFFFFFFE");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_add_i_a1_a_sub_oracle_64_9_c2800420() {
    // Test SUB 64-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0xC2800420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xC2800420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0xFFFFFFFFFFFFFFFE"
    );
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_add_i_a1_a_sub_oracle_32_10_42800420() {
    // Test SUB 32-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0x42800420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x42800420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFE, "W0 should be 0xFFFFFFFE");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_add_i_a1_a_sub_oracle_64_10_c2800420() {
    // Test SUB 64-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0xC2800420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xC2800420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0x00000000FFFFFFFE"
    );
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `SUB SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (32)
#[test]
fn test_aarch32_add_i_a1_a_sub_oracle_32_rd31_sp_4280283f() {
    // Test SUB 32-bit with Rd=31 (SP)
    // Encoding: 0x4280283F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x4280283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    // TODO: assertion - TestAssertion { check: Sp, expected: U64(90), message: "SP should be 0x5A" }
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `SUB SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (64)
#[test]
fn test_aarch32_add_i_a1_a_sub_oracle_64_rd31_sp_c280283f() {
    // Test SUB 64-bit with Rd=31 (SP)
    // Encoding: 0xC280283F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xC280283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    // TODO: assertion - TestAssertion { check: Sp, expected: U64(90), message: "SP should be 0x5A" }
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `SUBS X0, X1, #10`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_add_i_a1_a_subs_oracle_32_0_62802820() {
    // Test SUBS 32-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0x62802820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x62802820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x5A, "W0 should be 0x5A");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `SUBS X0, X1, #10`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_add_i_a1_a_subs_oracle_64_0_e2802820() {
    // Test SUBS 64-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0xE2802820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xE2802820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x5A, "X0 should be 0x000000000000005A");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `SUBS X0, X1, #0`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero operands (32)
#[test]
fn test_aarch32_add_i_a1_a_subs_oracle_32_1_62800020() {
    // Test SUBS 32-bit: zero operands (with oracle verification)
    // Encoding: 0x62800020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x62800020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x0");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `SUBS X0, X1, #0`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero operands (64)
#[test]
fn test_aarch32_add_i_a1_a_subs_oracle_64_1_e2800020() {
    // Test SUBS 64-bit: zero operands (with oracle verification)
    // Encoding: 0xE2800020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xE2800020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// small values (32)
#[test]
fn test_aarch32_add_i_a1_a_subs_oracle_32_2_62800420() {
    // Test SUBS 32-bit: small values (with oracle verification)
    // Encoding: 0x62800420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x62800420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x0");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// small values (64)
#[test]
fn test_aarch32_add_i_a1_a_subs_oracle_64_2_e2800420() {
    // Test SUBS 64-bit: small values (with oracle verification)
    // Encoding: 0xE2800420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xE2800420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `SUBS X0, X1, #4095`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_add_i_a1_a_subs_oracle_32_3_62bffc20() {
    // Test SUBS 32-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0x62BFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x62BFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFF001, "W0 should be 0xFFFFF001");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `SUBS X0, X1, #4095`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_add_i_a1_a_subs_oracle_64_3_e2bffc20() {
    // Test SUBS 64-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0xE2BFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xE2BFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `SUBS X0, X1, #4095, LSL #12`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_add_i_a1_a_subs_oracle_32_4_62fffc20() {
    // Test SUBS 32-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0x62FFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x62FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF001000, "W0 should be 0xFF001000");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `SUBS X0, X1, #4095, LSL #12`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_add_i_a1_a_subs_oracle_64_4_e2fffc20() {
    // Test SUBS 64-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0xE2FFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xE2FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max u64 operand (32)
#[test]
fn test_aarch32_add_i_a1_a_subs_oracle_32_5_62800420() {
    // Test SUBS 32-bit: max u64 operand (with oracle verification)
    // Encoding: 0x62800420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x62800420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFE, "W0 should be 0xFFFFFFFE");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max u64 operand (64)
#[test]
fn test_aarch32_add_i_a1_a_subs_oracle_64_5_e2800420() {
    // Test SUBS 64-bit: max u64 operand (with oracle verification)
    // Encoding: 0xE2800420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xE2800420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0xFFFFFFFFFFFFFFFE"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_add_i_a1_a_subs_oracle_32_6_62800420() {
    // Test SUBS 32-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0x62800420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x62800420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "W0 should be 0xFFFFFFFF");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_add_i_a1_a_subs_oracle_64_6_e2800420() {
    // Test SUBS 64-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0xE2800420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xE2800420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_add_i_a1_a_subs_oracle_32_7_62800420() {
    // Test SUBS 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0x62800420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x62800420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFE, "W0 should be 0xFFFFFFFE");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_add_i_a1_a_subs_oracle_64_7_e2800420() {
    // Test SUBS 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0xE2800420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xE2800420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0x7FFFFFFFFFFFFFFE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_add_i_a1_a_subs_oracle_32_8_62800420() {
    // Test SUBS 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0x62800420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x62800420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FFFFFFE, "W0 should be 0x7FFFFFFE");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_add_i_a1_a_subs_oracle_64_8_e2800420() {
    // Test SUBS 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0xE2800420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xE2800420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x7FFFFFFE,
        "X0 should be 0x000000007FFFFFFE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_add_i_a1_a_subs_oracle_32_9_62800420() {
    // Test SUBS 32-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0x62800420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x62800420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFE, "W0 should be 0xFFFFFFFE");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_add_i_a1_a_subs_oracle_64_9_e2800420() {
    // Test SUBS 64-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0xE2800420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xE2800420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0xFFFFFFFFFFFFFFFE"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_add_i_a1_a_subs_oracle_32_10_62800420() {
    // Test SUBS 32-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0x62800420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x62800420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFE, "W0 should be 0xFFFFFFFE");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_add_i_a1_a_subs_oracle_64_10_e2800420() {
    // Test SUBS 64-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0xE2800420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xE2800420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0x00000000FFFFFFFE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `SUBS ZR, X1, #10`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "result discarded, flags set" }
/// ZR destination (32)
#[test]
fn test_aarch32_add_i_a1_a_subs_oracle_32_rd31_zr_6280283f() {
    // Test SUBS 32-bit with Rd=31 (ZR)
    // Encoding: 0x6280283F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x6280283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `SUBS ZR, X1, #10`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "result discarded, flags set" }
/// ZR destination (64)
#[test]
fn test_aarch32_add_i_a1_a_subs_oracle_64_rd31_zr_e280283f() {
    // Test SUBS 64-bit with Rd=31 (ZR)
    // Encoding: 0xE280283F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xE280283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `ADD R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x00000000)
#[test]
fn test_aarch32_add_i_a1_a_a32_add_sub_imm_0_0_0281000a() {
    // Test A32 ADD: small immediate (oracle)
    // Encoding: 0x0281000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x0281000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA, "R0 should be 0x0000000A");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `ADD R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x00000064)
#[test]
fn test_aarch32_add_i_a1_a_a32_add_sub_imm_0_64_0281000a() {
    // Test A32 ADD: small immediate (oracle)
    // Encoding: 0x0281000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x0281000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6E, "R0 should be 0x0000006E");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `ADD R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_add_i_a1_a_a32_add_sub_imm_0_7fffffff_0281000a() {
    // Test A32 ADD: small immediate (oracle)
    // Encoding: 0x0281000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x0281000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000009, "R0 should be 0x80000009");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `ADD R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x80000000)
#[test]
fn test_aarch32_add_i_a1_a_a32_add_sub_imm_0_80000000_0281000a() {
    // Test A32 ADD: small immediate (oracle)
    // Encoding: 0x0281000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0x0281000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x8000000A, "R0 should be 0x8000000A");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `ADD R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_add_i_a1_a_a32_add_sub_imm_0_ffffffff_0281000a() {
    // Test A32 ADD: small immediate (oracle)
    // Encoding: 0x0281000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x0281000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x9, "R0 should be 0x00000009");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `ADD R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x00000000)
#[test]
fn test_aarch32_add_i_a1_a_a32_add_sub_imm_1_0_028100ff() {
    // Test A32 ADD: max imm8 (oracle)
    // Encoding: 0x028100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x028100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `ADD R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x00000064)
#[test]
fn test_aarch32_add_i_a1_a_a32_add_sub_imm_1_64_028100ff() {
    // Test A32 ADD: max imm8 (oracle)
    // Encoding: 0x028100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x028100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x163, "R0 should be 0x00000163");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `ADD R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_add_i_a1_a_a32_add_sub_imm_1_7fffffff_028100ff() {
    // Test A32 ADD: max imm8 (oracle)
    // Encoding: 0x028100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x028100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x800000FE, "R0 should be 0x800000FE");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `ADD R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x80000000)
#[test]
fn test_aarch32_add_i_a1_a_a32_add_sub_imm_1_80000000_028100ff() {
    // Test A32 ADD: max imm8 (oracle)
    // Encoding: 0x028100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0x028100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x800000FF, "R0 should be 0x800000FF");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `ADD R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_add_i_a1_a_a32_add_sub_imm_1_ffffffff_028100ff() {
    // Test A32 ADD: max imm8 (oracle)
    // Encoding: 0x028100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x028100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFE, "R0 should be 0x000000FE");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `ADD R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x00000000)
#[test]
fn test_aarch32_add_i_a1_a_a32_add_sub_imm_2_0_02810180() {
    // Test A32 ADD: rotated by 2 (oracle)
    // Encoding: 0x02810180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x02810180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x20, "R0 should be 0x00000020");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `ADD R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x00000064)
#[test]
fn test_aarch32_add_i_a1_a_a32_add_sub_imm_2_64_02810180() {
    // Test A32 ADD: rotated by 2 (oracle)
    // Encoding: 0x02810180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x02810180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x84, "R0 should be 0x00000084");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `ADD R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_add_i_a1_a_a32_add_sub_imm_2_7fffffff_02810180() {
    // Test A32 ADD: rotated by 2 (oracle)
    // Encoding: 0x02810180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x02810180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x8000001F, "R0 should be 0x8000001F");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `ADD R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x80000000)
#[test]
fn test_aarch32_add_i_a1_a_a32_add_sub_imm_2_80000000_02810180() {
    // Test A32 ADD: rotated by 2 (oracle)
    // Encoding: 0x02810180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0x02810180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000020, "R0 should be 0x80000020");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `ADD R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_add_i_a1_a_a32_add_sub_imm_2_ffffffff_02810180() {
    // Test A32 ADD: rotated by 2 (oracle)
    // Encoding: 0x02810180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x02810180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1F, "R0 should be 0x0000001F");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `ADD R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x00000000)
#[test]
fn test_aarch32_add_i_a1_a_a32_add_sub_imm_3_0_0281040f() {
    // Test A32 ADD: rotated by 8 (oracle)
    // Encoding: 0x0281040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x0281040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xF000000, "R0 should be 0x0F000000");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `ADD R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x00000064)
#[test]
fn test_aarch32_add_i_a1_a_a32_add_sub_imm_3_64_0281040f() {
    // Test A32 ADD: rotated by 8 (oracle)
    // Encoding: 0x0281040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x0281040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xF000064, "R0 should be 0x0F000064");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `ADD R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_add_i_a1_a_a32_add_sub_imm_3_7fffffff_0281040f() {
    // Test A32 ADD: rotated by 8 (oracle)
    // Encoding: 0x0281040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x0281040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x8EFFFFFF, "R0 should be 0x8EFFFFFF");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `ADD R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x80000000)
#[test]
fn test_aarch32_add_i_a1_a_a32_add_sub_imm_3_80000000_0281040f() {
    // Test A32 ADD: rotated by 8 (oracle)
    // Encoding: 0x0281040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0x0281040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x8F000000, "R0 should be 0x8F000000");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `ADD R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_add_i_a1_a_a32_add_sub_imm_3_ffffffff_0281040f() {
    // Test A32 ADD: rotated by 8 (oracle)
    // Encoding: 0x0281040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x0281040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xEFFFFFF, "R0 should be 0x0EFFFFFF");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `ADD R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x00000000)
#[test]
fn test_aarch32_add_i_a1_a_a32_add_sub_imm_4_0_02810000() {
    // Test A32 ADD: zero immediate (oracle)
    // Encoding: 0x02810000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x02810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `ADD R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x00000064)
#[test]
fn test_aarch32_add_i_a1_a_a32_add_sub_imm_4_64_02810000() {
    // Test A32 ADD: zero immediate (oracle)
    // Encoding: 0x02810000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x02810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x64, "R0 should be 0x00000064");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `ADD R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_add_i_a1_a_a32_add_sub_imm_4_7fffffff_02810000() {
    // Test A32 ADD: zero immediate (oracle)
    // Encoding: 0x02810000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x02810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FFFFFFF, "R0 should be 0x7FFFFFFF");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `ADD R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x80000000)
#[test]
fn test_aarch32_add_i_a1_a_a32_add_sub_imm_4_80000000_02810000() {
    // Test A32 ADD: zero immediate (oracle)
    // Encoding: 0x02810000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0x02810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "R0 should be 0x80000000");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `ADD R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_add_i_a1_a_a32_add_sub_imm_4_ffffffff_02810000() {
    // Test A32 ADD: zero immediate (oracle)
    // Encoding: 0x02810000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x02810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "R0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_aarch32_add_i_a1_a_flags_zeroresult_0_02910000() {
    // Test aarch32_ADD_i_A1_A flag computation: ZeroResult
    // Encoding: 0x02910000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x02910000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_aarch32_add_i_a1_a_flags_zeroresult_1_02910000() {
    // Test aarch32_ADD_i_A1_A flag computation: ZeroResult
    // Encoding: 0x02910000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x02910000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_aarch32_add_i_a1_a_flags_negativeresult_2_02910000() {
    // Test aarch32_ADD_i_A1_A flag computation: NegativeResult
    // Encoding: 0x02910000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x02910000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_aarch32_add_i_a1_a_flags_unsignedoverflow_3_02910000() {
    // Test aarch32_ADD_i_A1_A flag computation: UnsignedOverflow
    // Encoding: 0x02910000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x02910000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_aarch32_add_i_a1_a_flags_unsignedoverflow_4_02910000() {
    // Test aarch32_ADD_i_A1_A flag computation: UnsignedOverflow
    // Encoding: 0x02910000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x02910000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_aarch32_add_i_a1_a_flags_signedoverflow_5_02910000() {
    // Test aarch32_ADD_i_A1_A flag computation: SignedOverflow
    // Encoding: 0x02910000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x02910000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_aarch32_add_i_a1_a_flags_signedoverflow_6_02910000() {
    // Test aarch32_ADD_i_A1_A flag computation: SignedOverflow
    // Encoding: 0x02910000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x02910000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_ADD_i_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_aarch32_add_i_a1_a_flags_positiveresult_7_02910000() {
    // Test aarch32_ADD_i_A1_A flag computation: PositiveResult
    // Encoding: 0x02910000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x32);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x02910000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 0 (32)
#[test]
fn test_aarch32_add_i_t1_a_lslv_oracle_32_0_1c020020() {
    // Test LSLV 32-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x12345678, "W0 should be 0x12345678");
}

/// Provenance: aarch32_ADD_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 0 (64)
#[test]
fn test_aarch32_add_i_t1_a_lslv_oracle_64_0_9c020020() {
    // Test LSLV 64-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x12345678,
        "X0 should be 0x0000000012345678"
    );
}

/// Provenance: aarch32_ADD_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4 (32)
#[test]
fn test_aarch32_add_i_t1_a_lslv_oracle_32_1_1c020020() {
    // Test LSLV 32-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x4);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x23456780, "W0 should be 0x23456780");
}

/// Provenance: aarch32_ADD_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 4 (64)
#[test]
fn test_aarch32_add_i_t1_a_lslv_oracle_64_1_9c020020() {
    // Test LSLV 64-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x4);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x23456780,
        "X0 should be 0x0000000123456780"
    );
}

/// Provenance: aarch32_ADD_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 8 (32)
#[test]
fn test_aarch32_add_i_t1_a_lslv_oracle_32_2_1c020020() {
    // Test LSLV 32-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x8);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x34567800, "W0 should be 0x34567800");
}

/// Provenance: aarch32_ADD_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 8 (64)
#[test]
fn test_aarch32_add_i_t1_a_lslv_oracle_64_2_9c020020() {
    // Test LSLV 64-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x8);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x34567800,
        "X0 should be 0x0000001234567800"
    );
}

/// Provenance: aarch32_ADD_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1 (32)
#[test]
fn test_aarch32_add_i_t1_a_lslv_oracle_32_3_1c020020() {
    // Test LSLV 32-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_ADD_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// MSB set, shift 1 (64)
#[test]
fn test_aarch32_add_i_t1_a_lslv_oracle_64_3_9c020020() {
    // Test LSLV 64-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_ADD_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// LSB set, max shift (32)
#[test]
fn test_aarch32_add_i_t1_a_lslv_oracle_32_4_1c020020() {
    // Test LSLV 32-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x3F);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "W0 should be 0x80000000");
}

/// Provenance: aarch32_ADD_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// LSB set, max shift (64)
#[test]
fn test_aarch32_add_i_t1_a_lslv_oracle_64_4_9c020020() {
    // Test LSLV 64-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x3F);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x8000000000000000");
}

/// Provenance: aarch32_ADD_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// all ones, shift 32 (32)
#[test]
fn test_aarch32_add_i_t1_a_lslv_oracle_32_5_1c020020() {
    // Test LSLV 32-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x20);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "W0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_ADD_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// all ones, shift 32 (64)
#[test]
fn test_aarch32_add_i_t1_a_lslv_oracle_64_5_9c020020() {
    // Test LSLV 64-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x20);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0xFFFFFFFF00000000");
}

/// Provenance: aarch32_ADD_i_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// no shift
#[test]
fn test_aarch32_add_i_t1_a_t16_oracle_0_1c080000() {
    // Test T16 LSLS: no shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_ADD_i_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4
#[test]
fn test_aarch32_add_i_t1_a_t16_oracle_1_1c080000() {
    // Test T16 LSLS: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x4);
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF0, "R0 should be 0x00000FF0");
}

/// Provenance: aarch32_ADD_i_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1
#[test]
fn test_aarch32_add_i_t1_a_t16_oracle_2_1c080000() {
    // Test T16 LSLS: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_ADD_i_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift to MSB
#[test]
fn test_aarch32_add_i_t1_a_t16_oracle_3_1c080000() {
    // Test T16 LSLS: shift to MSB (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1F);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "R0 should be 0x80000000");
}

/// Provenance: aarch32_ADD_i_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_aarch32_add_i_t1_a_flags_zeroresult_0_1c080000() {
    // Test aarch32_ADD_i_T1_A flag computation: ZeroResult
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_i_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_aarch32_add_i_t1_a_flags_zeroresult_1_1c080000() {
    // Test aarch32_ADD_i_T1_A flag computation: ZeroResult
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_i_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_aarch32_add_i_t1_a_flags_negativeresult_2_1c080000() {
    // Test aarch32_ADD_i_T1_A flag computation: NegativeResult
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_i_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_aarch32_add_i_t1_a_flags_unsignedoverflow_3_1c080000() {
    // Test aarch32_ADD_i_T1_A flag computation: UnsignedOverflow
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_i_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_aarch32_add_i_t1_a_flags_unsignedoverflow_4_1c080000() {
    // Test aarch32_ADD_i_T1_A flag computation: UnsignedOverflow
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_i_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_aarch32_add_i_t1_a_flags_signedoverflow_5_1c080000() {
    // Test aarch32_ADD_i_T1_A flag computation: SignedOverflow
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_ADD_i_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_aarch32_add_i_t1_a_flags_signedoverflow_6_1c080000() {
    // Test aarch32_ADD_i_T1_A flag computation: SignedOverflow
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_ADD_i_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_aarch32_add_i_t1_a_flags_positiveresult_7_1c080000() {
    // Test aarch32_ADD_i_T1_A flag computation: PositiveResult
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x32);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_i_T2_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 0 (32)
#[test]
fn test_aarch32_add_i_t2_a_lslv_oracle_32_0_30020020() {
    // Test LSLV 32-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x12345678, "W0 should be 0x12345678");
}

/// Provenance: aarch32_ADD_i_T2_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 0 (64)
#[test]
fn test_aarch32_add_i_t2_a_lslv_oracle_64_0_b0020020() {
    // Test LSLV 64-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x12345678,
        "X0 should be 0x0000000012345678"
    );
}

/// Provenance: aarch32_ADD_i_T2_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4 (32)
#[test]
fn test_aarch32_add_i_t2_a_lslv_oracle_32_1_30020020() {
    // Test LSLV 32-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x4);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x23456780, "W0 should be 0x23456780");
}

/// Provenance: aarch32_ADD_i_T2_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 4 (64)
#[test]
fn test_aarch32_add_i_t2_a_lslv_oracle_64_1_b0020020() {
    // Test LSLV 64-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x4);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x23456780,
        "X0 should be 0x0000000123456780"
    );
}

/// Provenance: aarch32_ADD_i_T2_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 8 (32)
#[test]
fn test_aarch32_add_i_t2_a_lslv_oracle_32_2_30020020() {
    // Test LSLV 32-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x8);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x34567800, "W0 should be 0x34567800");
}

/// Provenance: aarch32_ADD_i_T2_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 8 (64)
#[test]
fn test_aarch32_add_i_t2_a_lslv_oracle_64_2_b0020020() {
    // Test LSLV 64-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x8);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x34567800,
        "X0 should be 0x0000001234567800"
    );
}

/// Provenance: aarch32_ADD_i_T2_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1 (32)
#[test]
fn test_aarch32_add_i_t2_a_lslv_oracle_32_3_30020020() {
    // Test LSLV 32-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_ADD_i_T2_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// MSB set, shift 1 (64)
#[test]
fn test_aarch32_add_i_t2_a_lslv_oracle_64_3_b0020020() {
    // Test LSLV 64-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_ADD_i_T2_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// LSB set, max shift (32)
#[test]
fn test_aarch32_add_i_t2_a_lslv_oracle_32_4_30020020() {
    // Test LSLV 32-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3F);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "W0 should be 0x80000000");
}

/// Provenance: aarch32_ADD_i_T2_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// LSB set, max shift (64)
#[test]
fn test_aarch32_add_i_t2_a_lslv_oracle_64_4_b0020020() {
    // Test LSLV 64-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x3F);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x8000000000000000");
}

/// Provenance: aarch32_ADD_i_T2_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// all ones, shift 32 (32)
#[test]
fn test_aarch32_add_i_t2_a_lslv_oracle_32_5_30020020() {
    // Test LSLV 32-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x20);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "W0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_ADD_i_T2_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// all ones, shift 32 (64)
#[test]
fn test_aarch32_add_i_t2_a_lslv_oracle_64_5_b0020020() {
    // Test LSLV 64-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x20);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0xFFFFFFFF00000000");
}

/// Provenance: aarch32_ADD_i_T2_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// no shift
#[test]
fn test_aarch32_add_i_t2_a_t16_oracle_0_30000000() {
    // Test T16 LSLS: no shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_ADD_i_T2_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4
#[test]
fn test_aarch32_add_i_t2_a_t16_oracle_1_30000000() {
    // Test T16 LSLS: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x4);
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF0, "R0 should be 0x00000FF0");
}

/// Provenance: aarch32_ADD_i_T2_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1
#[test]
fn test_aarch32_add_i_t2_a_t16_oracle_2_30000000() {
    // Test T16 LSLS: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_ADD_i_T2_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift to MSB
#[test]
fn test_aarch32_add_i_t2_a_t16_oracle_3_30000000() {
    // Test T16 LSLS: shift to MSB (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1F);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "R0 should be 0x80000000");
}

/// Provenance: aarch32_ADD_i_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_aarch32_add_i_t2_a_flags_zeroresult_0_30000000() {
    // Test aarch32_ADD_i_T2_A flag computation: ZeroResult
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_i_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_aarch32_add_i_t2_a_flags_zeroresult_1_30000000() {
    // Test aarch32_ADD_i_T2_A flag computation: ZeroResult
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_i_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_aarch32_add_i_t2_a_flags_negativeresult_2_30000000() {
    // Test aarch32_ADD_i_T2_A flag computation: NegativeResult
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_i_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_aarch32_add_i_t2_a_flags_unsignedoverflow_3_30000000() {
    // Test aarch32_ADD_i_T2_A flag computation: UnsignedOverflow
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_i_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_aarch32_add_i_t2_a_flags_unsignedoverflow_4_30000000() {
    // Test aarch32_ADD_i_T2_A flag computation: UnsignedOverflow
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_i_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_aarch32_add_i_t2_a_flags_signedoverflow_5_30000000() {
    // Test aarch32_ADD_i_T2_A flag computation: SignedOverflow
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_ADD_i_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_aarch32_add_i_t2_a_flags_signedoverflow_6_30000000() {
    // Test aarch32_ADD_i_T2_A flag computation: SignedOverflow
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_ADD_i_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_aarch32_add_i_t2_a_flags_positiveresult_7_30000000() {
    // Test aarch32_ADD_i_T2_A flag computation: PositiveResult
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x32);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `ADD X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_add_i_t3_a_add_oracle_32_0_f1002820() {
    // Test ADD 32-bit: simple addition/subtraction (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF1002820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x5A, "X0 should be 0x000000000000005A");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `ADD X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_add_i_t3_a_add_oracle_64_0_f1002820() {
    // Test ADD 64-bit: simple addition/subtraction (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF1002820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x5A, "X0 should be 0x000000000000005A");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `ADD X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero operands (32)
#[test]
fn test_aarch32_add_i_t3_a_add_oracle_32_1_f1000020() {
    // Test ADD 32-bit: zero operands (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1000020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `ADD X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero operands (64)
#[test]
fn test_aarch32_add_i_t3_a_add_oracle_64_1_f1000020() {
    // Test ADD 64-bit: zero operands (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1000020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small values (32)
#[test]
fn test_aarch32_add_i_t3_a_add_oracle_32_2_f1000420() {
    // Test ADD 32-bit: small values (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF1000420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// small values (64)
#[test]
fn test_aarch32_add_i_t3_a_add_oracle_64_2_f1000420() {
    // Test ADD 64-bit: small values (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF1000420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `ADD X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_add_i_t3_a_add_oracle_32_3_f13ffc20() {
    // Test ADD 32-bit: max imm12 unshifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF13FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `ADD X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_add_i_t3_a_add_oracle_64_3_f13ffc20() {
    // Test ADD 64-bit: max imm12 unshifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF13FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `ADD X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_add_i_t3_a_add_oracle_32_4_f17ffc20() {
    // Test ADD 32-bit: max imm12 shifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF17FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `ADD X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_add_i_t3_a_add_oracle_64_4_f17ffc20() {
    // Test ADD 64-bit: max imm12 shifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF17FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max u64 operand (32)
#[test]
fn test_aarch32_add_i_t3_a_add_oracle_32_5_f1000420() {
    // Test ADD 32-bit: max u64 operand (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1000420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0x00000000FFFFFFFE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max u64 operand (64)
#[test]
fn test_aarch32_add_i_t3_a_add_oracle_64_5_f1000420() {
    // Test ADD 64-bit: max u64 operand (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1000420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0xFFFFFFFFFFFFFFFE"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_add_i_t3_a_add_oracle_32_6_f1000420() {
    // Test ADD 32-bit: zero result (for sub 1-1) (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1000420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_add_i_t3_a_add_oracle_64_6_f1000420() {
    // Test ADD 64-bit: zero result (for sub 1-1) (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1000420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_add_i_t3_a_add_oracle_32_7_f1000420() {
    // Test ADD 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1000420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0x00000000FFFFFFFE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_add_i_t3_a_add_oracle_64_7_f1000420() {
    // Test ADD 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1000420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0x7FFFFFFFFFFFFFFE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_add_i_t3_a_add_oracle_32_8_f1000420() {
    // Test ADD 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF1000420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x7FFFFFFE,
        "X0 should be 0x000000007FFFFFFE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_add_i_t3_a_add_oracle_64_8_f1000420() {
    // Test ADD 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF1000420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x7FFFFFFE,
        "X0 should be 0x000000007FFFFFFE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_add_i_t3_a_add_oracle_32_9_f1000420() {
    // Test ADD 32-bit: unsigned overflow 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1000420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0x00000000FFFFFFFE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_add_i_t3_a_add_oracle_64_9_f1000420() {
    // Test ADD 64-bit: unsigned overflow 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1000420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0xFFFFFFFFFFFFFFFE"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_add_i_t3_a_add_oracle_32_10_f1000420() {
    // Test ADD 32-bit: unsigned overflow 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1000420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0x00000000FFFFFFFE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_add_i_t3_a_add_oracle_64_10_f1000420() {
    // Test ADD 64-bit: unsigned overflow 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1000420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0x00000000FFFFFFFE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `ADD SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (32)
#[test]
fn test_aarch32_add_i_t3_a_add_oracle_32_rd31_sp_f100283f() {
    // Test ADD 32-bit with Rd=31 (SP)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF100283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `ADD SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (64)
#[test]
fn test_aarch32_add_i_t3_a_add_oracle_64_rd31_sp_f100283f() {
    // Test ADD 64-bit with Rd=31 (SP)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF100283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `ADDS X0, X1, #10`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_add_i_t3_a_adds_oracle_32_0_f1002820() {
    // Test ADDS 32-bit: simple addition/subtraction (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF1002820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x5A, "X0 should be 0x000000000000005A");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `ADDS X0, X1, #10`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_add_i_t3_a_adds_oracle_64_0_f1002820() {
    // Test ADDS 64-bit: simple addition/subtraction (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF1002820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x5A, "X0 should be 0x000000000000005A");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `ADDS X0, X1, #0`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero operands (32)
#[test]
fn test_aarch32_add_i_t3_a_adds_oracle_32_1_f1000020() {
    // Test ADDS 32-bit: zero operands (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1000020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `ADDS X0, X1, #0`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero operands (64)
#[test]
fn test_aarch32_add_i_t3_a_adds_oracle_64_1_f1000020() {
    // Test ADDS 64-bit: zero operands (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1000020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// small values (32)
#[test]
fn test_aarch32_add_i_t3_a_adds_oracle_32_2_f1000420() {
    // Test ADDS 32-bit: small values (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF1000420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// small values (64)
#[test]
fn test_aarch32_add_i_t3_a_adds_oracle_64_2_f1000420() {
    // Test ADDS 64-bit: small values (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF1000420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `ADDS X0, X1, #4095`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_add_i_t3_a_adds_oracle_32_3_f13ffc20() {
    // Test ADDS 32-bit: max imm12 unshifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF13FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `ADDS X0, X1, #4095`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_add_i_t3_a_adds_oracle_64_3_f13ffc20() {
    // Test ADDS 64-bit: max imm12 unshifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF13FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `ADDS X0, X1, #4095, LSL #12`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_add_i_t3_a_adds_oracle_32_4_f17ffc20() {
    // Test ADDS 32-bit: max imm12 shifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF17FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `ADDS X0, X1, #4095, LSL #12`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_add_i_t3_a_adds_oracle_64_4_f17ffc20() {
    // Test ADDS 64-bit: max imm12 shifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF17FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max u64 operand (32)
#[test]
fn test_aarch32_add_i_t3_a_adds_oracle_32_5_f1000420() {
    // Test ADDS 32-bit: max u64 operand (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1000420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0x00000000FFFFFFFE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max u64 operand (64)
#[test]
fn test_aarch32_add_i_t3_a_adds_oracle_64_5_f1000420() {
    // Test ADDS 64-bit: max u64 operand (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1000420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0xFFFFFFFFFFFFFFFE"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_add_i_t3_a_adds_oracle_32_6_f1000420() {
    // Test ADDS 32-bit: zero result (for sub 1-1) (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1000420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_add_i_t3_a_adds_oracle_64_6_f1000420() {
    // Test ADDS 64-bit: zero result (for sub 1-1) (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1000420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_add_i_t3_a_adds_oracle_32_7_f1000420() {
    // Test ADDS 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1000420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0x00000000FFFFFFFE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_add_i_t3_a_adds_oracle_64_7_f1000420() {
    // Test ADDS 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1000420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0x7FFFFFFFFFFFFFFE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_add_i_t3_a_adds_oracle_32_8_f1000420() {
    // Test ADDS 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF1000420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x7FFFFFFE,
        "X0 should be 0x000000007FFFFFFE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_add_i_t3_a_adds_oracle_64_8_f1000420() {
    // Test ADDS 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF1000420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x7FFFFFFE,
        "X0 should be 0x000000007FFFFFFE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_add_i_t3_a_adds_oracle_32_9_f1000420() {
    // Test ADDS 32-bit: unsigned overflow 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1000420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0x00000000FFFFFFFE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_add_i_t3_a_adds_oracle_64_9_f1000420() {
    // Test ADDS 64-bit: unsigned overflow 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1000420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0xFFFFFFFFFFFFFFFE"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_add_i_t3_a_adds_oracle_32_10_f1000420() {
    // Test ADDS 32-bit: unsigned overflow 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1000420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0x00000000FFFFFFFE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_add_i_t3_a_adds_oracle_64_10_f1000420() {
    // Test ADDS 64-bit: unsigned overflow 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1000420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0x00000000FFFFFFFE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `ADDS ZR, X1, #10`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "result discarded, flags set" }
/// ZR destination (32)
#[test]
fn test_aarch32_add_i_t3_a_adds_oracle_32_rd31_zr_f100283f() {
    // Test ADDS 32-bit with Rd=31 (ZR)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF100283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `ADDS ZR, X1, #10`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "result discarded, flags set" }
/// ZR destination (64)
#[test]
fn test_aarch32_add_i_t3_a_adds_oracle_64_rd31_zr_f100283f() {
    // Test ADDS 64-bit with Rd=31 (ZR)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF100283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `SUB X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_add_i_t3_a_sub_oracle_32_0_f1002820() {
    // Test SUB 32-bit: simple addition/subtraction (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF1002820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x5A, "X0 should be 0x000000000000005A");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `SUB X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_add_i_t3_a_sub_oracle_64_0_f1002820() {
    // Test SUB 64-bit: simple addition/subtraction (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF1002820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x5A, "X0 should be 0x000000000000005A");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `SUB X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero operands (32)
#[test]
fn test_aarch32_add_i_t3_a_sub_oracle_32_1_f1000020() {
    // Test SUB 32-bit: zero operands (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1000020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `SUB X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero operands (64)
#[test]
fn test_aarch32_add_i_t3_a_sub_oracle_64_1_f1000020() {
    // Test SUB 64-bit: zero operands (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1000020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small values (32)
#[test]
fn test_aarch32_add_i_t3_a_sub_oracle_32_2_f1000420() {
    // Test SUB 32-bit: small values (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF1000420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// small values (64)
#[test]
fn test_aarch32_add_i_t3_a_sub_oracle_64_2_f1000420() {
    // Test SUB 64-bit: small values (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF1000420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `SUB X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_add_i_t3_a_sub_oracle_32_3_f13ffc20() {
    // Test SUB 32-bit: max imm12 unshifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF13FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `SUB X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_add_i_t3_a_sub_oracle_64_3_f13ffc20() {
    // Test SUB 64-bit: max imm12 unshifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF13FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `SUB X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_add_i_t3_a_sub_oracle_32_4_f17ffc20() {
    // Test SUB 32-bit: max imm12 shifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF17FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `SUB X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_add_i_t3_a_sub_oracle_64_4_f17ffc20() {
    // Test SUB 64-bit: max imm12 shifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF17FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max u64 operand (32)
#[test]
fn test_aarch32_add_i_t3_a_sub_oracle_32_5_f1000420() {
    // Test SUB 32-bit: max u64 operand (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1000420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0x00000000FFFFFFFE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max u64 operand (64)
#[test]
fn test_aarch32_add_i_t3_a_sub_oracle_64_5_f1000420() {
    // Test SUB 64-bit: max u64 operand (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1000420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0xFFFFFFFFFFFFFFFE"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_add_i_t3_a_sub_oracle_32_6_f1000420() {
    // Test SUB 32-bit: zero result (for sub 1-1) (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1000420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_add_i_t3_a_sub_oracle_64_6_f1000420() {
    // Test SUB 64-bit: zero result (for sub 1-1) (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1000420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_add_i_t3_a_sub_oracle_32_7_f1000420() {
    // Test SUB 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1000420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0x00000000FFFFFFFE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_add_i_t3_a_sub_oracle_64_7_f1000420() {
    // Test SUB 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1000420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0x7FFFFFFFFFFFFFFE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_add_i_t3_a_sub_oracle_32_8_f1000420() {
    // Test SUB 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF1000420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x7FFFFFFE,
        "X0 should be 0x000000007FFFFFFE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_add_i_t3_a_sub_oracle_64_8_f1000420() {
    // Test SUB 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF1000420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x7FFFFFFE,
        "X0 should be 0x000000007FFFFFFE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_add_i_t3_a_sub_oracle_32_9_f1000420() {
    // Test SUB 32-bit: unsigned overflow 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1000420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0x00000000FFFFFFFE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_add_i_t3_a_sub_oracle_64_9_f1000420() {
    // Test SUB 64-bit: unsigned overflow 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1000420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0xFFFFFFFFFFFFFFFE"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_add_i_t3_a_sub_oracle_32_10_f1000420() {
    // Test SUB 32-bit: unsigned overflow 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1000420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0x00000000FFFFFFFE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_add_i_t3_a_sub_oracle_64_10_f1000420() {
    // Test SUB 64-bit: unsigned overflow 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1000420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0x00000000FFFFFFFE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `SUB SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (32)
#[test]
fn test_aarch32_add_i_t3_a_sub_oracle_32_rd31_sp_f100283f() {
    // Test SUB 32-bit with Rd=31 (SP)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF100283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `SUB SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (64)
#[test]
fn test_aarch32_add_i_t3_a_sub_oracle_64_rd31_sp_f100283f() {
    // Test SUB 64-bit with Rd=31 (SP)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF100283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `SUBS X0, X1, #10`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_add_i_t3_a_subs_oracle_32_0_f1002820() {
    // Test SUBS 32-bit: simple addition/subtraction (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF1002820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x5A, "X0 should be 0x000000000000005A");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `SUBS X0, X1, #10`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_add_i_t3_a_subs_oracle_64_0_f1002820() {
    // Test SUBS 64-bit: simple addition/subtraction (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF1002820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x5A, "X0 should be 0x000000000000005A");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `SUBS X0, X1, #0`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero operands (32)
#[test]
fn test_aarch32_add_i_t3_a_subs_oracle_32_1_f1000020() {
    // Test SUBS 32-bit: zero operands (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1000020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `SUBS X0, X1, #0`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero operands (64)
#[test]
fn test_aarch32_add_i_t3_a_subs_oracle_64_1_f1000020() {
    // Test SUBS 64-bit: zero operands (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1000020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// small values (32)
#[test]
fn test_aarch32_add_i_t3_a_subs_oracle_32_2_f1000420() {
    // Test SUBS 32-bit: small values (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF1000420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// small values (64)
#[test]
fn test_aarch32_add_i_t3_a_subs_oracle_64_2_f1000420() {
    // Test SUBS 64-bit: small values (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF1000420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `SUBS X0, X1, #4095`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_add_i_t3_a_subs_oracle_32_3_f13ffc20() {
    // Test SUBS 32-bit: max imm12 unshifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF13FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `SUBS X0, X1, #4095`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_add_i_t3_a_subs_oracle_64_3_f13ffc20() {
    // Test SUBS 64-bit: max imm12 unshifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF13FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `SUBS X0, X1, #4095, LSL #12`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_add_i_t3_a_subs_oracle_32_4_f17ffc20() {
    // Test SUBS 32-bit: max imm12 shifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF17FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `SUBS X0, X1, #4095, LSL #12`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_add_i_t3_a_subs_oracle_64_4_f17ffc20() {
    // Test SUBS 64-bit: max imm12 shifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF17FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max u64 operand (32)
#[test]
fn test_aarch32_add_i_t3_a_subs_oracle_32_5_f1000420() {
    // Test SUBS 32-bit: max u64 operand (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1000420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0x00000000FFFFFFFE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max u64 operand (64)
#[test]
fn test_aarch32_add_i_t3_a_subs_oracle_64_5_f1000420() {
    // Test SUBS 64-bit: max u64 operand (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1000420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0xFFFFFFFFFFFFFFFE"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_add_i_t3_a_subs_oracle_32_6_f1000420() {
    // Test SUBS 32-bit: zero result (for sub 1-1) (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1000420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_add_i_t3_a_subs_oracle_64_6_f1000420() {
    // Test SUBS 64-bit: zero result (for sub 1-1) (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1000420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_add_i_t3_a_subs_oracle_32_7_f1000420() {
    // Test SUBS 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1000420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0x00000000FFFFFFFE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_add_i_t3_a_subs_oracle_64_7_f1000420() {
    // Test SUBS 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1000420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0x7FFFFFFFFFFFFFFE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_add_i_t3_a_subs_oracle_32_8_f1000420() {
    // Test SUBS 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF1000420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x7FFFFFFE,
        "X0 should be 0x000000007FFFFFFE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_add_i_t3_a_subs_oracle_64_8_f1000420() {
    // Test SUBS 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF1000420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x7FFFFFFE,
        "X0 should be 0x000000007FFFFFFE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_add_i_t3_a_subs_oracle_32_9_f1000420() {
    // Test SUBS 32-bit: unsigned overflow 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1000420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0x00000000FFFFFFFE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_add_i_t3_a_subs_oracle_64_9_f1000420() {
    // Test SUBS 64-bit: unsigned overflow 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1000420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0xFFFFFFFFFFFFFFFE"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_add_i_t3_a_subs_oracle_32_10_f1000420() {
    // Test SUBS 32-bit: unsigned overflow 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1000420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0x00000000FFFFFFFE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_add_i_t3_a_subs_oracle_64_10_f1000420() {
    // Test SUBS 64-bit: unsigned overflow 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1000420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0x00000000FFFFFFFE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `SUBS ZR, X1, #10`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "result discarded, flags set" }
/// ZR destination (32)
#[test]
fn test_aarch32_add_i_t3_a_subs_oracle_32_rd31_zr_f100283f() {
    // Test SUBS 32-bit with Rd=31 (ZR)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF100283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `SUBS ZR, X1, #10`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "result discarded, flags set" }
/// ZR destination (64)
#[test]
fn test_aarch32_add_i_t3_a_subs_oracle_64_rd31_zr_f100283f() {
    // Test SUBS 64-bit with Rd=31 (ZR)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF100283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `ADD.W R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple values
#[test]
fn test_aarch32_add_i_t3_a_t32_oracle_0_f1010000() {
    // Test T32 ADD: simple values (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x32);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF1010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x96, "R0 should be 0x00000096");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `ADD.W R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero values
#[test]
fn test_aarch32_add_i_t3_a_t32_oracle_1_f1010000() {
    // Test T32 ADD: zero values (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `ADD.W R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max value
#[test]
fn test_aarch32_add_i_t3_a_t32_oracle_2_f1010000() {
    // Test T32 ADD: max value (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0xF1010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `ADD.W R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// mixed pattern
#[test]
fn test_aarch32_add_i_t3_a_t32_oracle_3_f1010000() {
    // Test T32 ADD: mixed pattern (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xABCDEF01);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u32 = 0xF1010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xBE024579, "R0 should be 0xBE024579");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_aarch32_add_i_t3_a_flags_zeroresult_0_f1110000() {
    // Test aarch32_ADD_i_T3_A flag computation: ZeroResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xF1110000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_aarch32_add_i_t3_a_flags_zeroresult_1_f1110000() {
    // Test aarch32_ADD_i_T3_A flag computation: ZeroResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF1110000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_aarch32_add_i_t3_a_flags_negativeresult_2_f1110000() {
    // Test aarch32_ADD_i_T3_A flag computation: NegativeResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xF1110000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_aarch32_add_i_t3_a_flags_unsignedoverflow_3_f1110000() {
    // Test aarch32_ADD_i_T3_A flag computation: UnsignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1110000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_aarch32_add_i_t3_a_flags_unsignedoverflow_4_f1110000() {
    // Test aarch32_ADD_i_T3_A flag computation: UnsignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0xF1110000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_aarch32_add_i_t3_a_flags_signedoverflow_5_f1110000() {
    // Test aarch32_ADD_i_T3_A flag computation: SignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1110000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_aarch32_add_i_t3_a_flags_signedoverflow_6_f1110000() {
    // Test aarch32_ADD_i_T3_A flag computation: SignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0xF1110000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_ADD_i_T3_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_aarch32_add_i_t3_a_flags_positiveresult_7_f1110000() {
    // Test aarch32_ADD_i_T3_A flag computation: PositiveResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x32);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF1110000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_i_T4_A
/// ASL: `AND X0, X1, #0xFF`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// mask lower 8 bits (64)
#[test]
fn test_aarch32_add_i_t4_a_and_oracle_64_0_92401c20() {
    // Test AND 64-bit: mask lower 8 bits (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x92401C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "X0 should be 0x00000000000000FF");
}

/// Provenance: aarch32_ADD_i_T4_A
/// ASL: `AND X0, X1, #0xFFFF`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// mask lower 16 bits (64)
#[test]
fn test_aarch32_add_i_t4_a_and_oracle_64_1_92403c20() {
    // Test AND 64-bit: mask lower 16 bits (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x92403C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFF, "X0 should be 0x000000000000FFFF");
}

/// Provenance: aarch32_ADD_i_T4_A
/// ASL: `AND X0, X1, #0xFFFFFFFF`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// mask lower 32 bits (64)
#[test]
fn test_aarch32_add_i_t4_a_and_oracle_64_2_92407c20() {
    // Test AND 64-bit: mask lower 32 bits (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x92407C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0x00000000FFFFFFFF"
    );
}

/// Provenance: aarch32_ADD_i_T4_A
/// ASL: `AND X0, X1, #0x1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// single bit mask (64)
#[test]
fn test_aarch32_add_i_t4_a_and_oracle_64_3_92400020() {
    // Test AND 64-bit: single bit mask (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xCAFEBABE);
    let encoding: u32 = 0x92400020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_ADD_i_T4_A
/// ASL: `AND X0, X1, #0x7FFFFFFFFFFFFFFF`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// all but MSB (64)
#[test]
fn test_aarch32_add_i_t4_a_and_oracle_64_4_9240f820() {
    // Test AND 64-bit: all but MSB (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    let encoding: u32 = 0x9240F820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xAAAAAAAA,
        "X0 should be 0x2AAAAAAAAAAAAAAA"
    );
}

/// Provenance: aarch32_ADD_i_T4_A
/// ASL: `AND W0, W1, #0xFF`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// mask lower 8 bits (32)
#[test]
fn test_aarch32_add_i_t4_a_and_oracle_32_0_12001c20() {
    // Test AND 32-bit: mask lower 8 bits (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x12001C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "W0 should be 0x000000FF");
}

/// Provenance: aarch32_ADD_i_T4_A
/// ASL: `AND W0, W1, #0xFFFF`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// mask lower 16 bits (32)
#[test]
fn test_aarch32_add_i_t4_a_and_oracle_32_1_12003c20() {
    // Test AND 32-bit: mask lower 16 bits (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x12003C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFF, "W0 should be 0x0000FFFF");
}

/// Provenance: aarch32_ADD_i_T4_A
/// ASL: `AND W0, W1, #0x1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// single bit mask (32)
#[test]
fn test_aarch32_add_i_t4_a_and_oracle_32_2_12000020() {
    // Test AND 32-bit: single bit mask (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xDEADBEEF);
    let encoding: u32 = 0x12000020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_ADD_i_T4_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_aarch32_add_i_t4_a_flags_zeroresult_0_f2010000() {
    // Test aarch32_ADD_i_T4_A flag computation: ZeroResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xF2010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_i_T4_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_aarch32_add_i_t4_a_flags_zeroresult_1_f2010000() {
    // Test aarch32_ADD_i_T4_A flag computation: ZeroResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0xF2010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_i_T4_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_aarch32_add_i_t4_a_flags_negativeresult_2_f2010000() {
    // Test aarch32_ADD_i_T4_A flag computation: NegativeResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xF2010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_i_T4_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_aarch32_add_i_t4_a_flags_unsignedoverflow_3_f2010000() {
    // Test aarch32_ADD_i_T4_A flag computation: UnsignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0xF2010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_i_T4_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_aarch32_add_i_t4_a_flags_unsignedoverflow_4_f2010000() {
    // Test aarch32_ADD_i_T4_A flag computation: UnsignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_i_T4_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_aarch32_add_i_t4_a_flags_signedoverflow_5_f2010000() {
    // Test aarch32_ADD_i_T4_A flag computation: SignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0xF2010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_ADD_i_T4_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_aarch32_add_i_t4_a_flags_signedoverflow_6_f2010000() {
    // Test aarch32_ADD_i_T4_A flag computation: SignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0xF2010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_ADD_i_T4_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_aarch32_add_i_t4_a_flags_positiveresult_7_f2010000() {
    // Test aarch32_ADD_i_T4_A flag computation: PositiveResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x32);
    let encoding: u32 = 0xF2010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

// ============================================================================
// aarch32_ADD_r_A Tests
// ============================================================================

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_add_r_a1_a_field_cond_0_min_0_00800000() {
    // Encoding: 0x00800000
    // Test aarch32_ADD_r_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rd=0, Rm=0, Rn=0, S=0, imm5=0, type1=0
    let encoding: u32 = 0x00800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_add_r_a1_a_field_cond_1_poweroftwo_0_10800000() {
    // Encoding: 0x10800000
    // Test aarch32_ADD_r_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: imm5=0, Rn=0, type1=0, S=0, Rm=0, cond=1, Rd=0
    let encoding: u32 = 0x10800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_add_r_a1_a_field_cond_2_poweroftwo_0_20800000() {
    // Encoding: 0x20800000
    // Test aarch32_ADD_r_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=2, Rm=0, type1=0, Rn=0, Rd=0, imm5=0, S=0
    let encoding: u32 = 0x20800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_add_r_a1_a_field_cond_3_poweroftwo_0_30800000() {
    // Encoding: 0x30800000
    // Test aarch32_ADD_r_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, Rd=0, Rn=0, imm5=0, Rm=0, cond=3, type1=0
    let encoding: u32 = 0x30800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_add_r_a1_a_field_cond_4_poweroftwo_0_40800000() {
    // Encoding: 0x40800000
    // Test aarch32_ADD_r_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, S=0, Rn=0, Rd=0, imm5=0, type1=0, cond=4
    let encoding: u32 = 0x40800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_add_r_a1_a_field_cond_5_poweroftwo_0_50800000() {
    // Encoding: 0x50800000
    // Test aarch32_ADD_r_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: imm5=0, type1=0, Rn=0, cond=5, Rm=0, S=0, Rd=0
    let encoding: u32 = 0x50800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_add_r_a1_a_field_cond_6_poweroftwo_0_60800000() {
    // Encoding: 0x60800000
    // Test aarch32_ADD_r_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, cond=6, imm5=0, Rm=0, Rn=0, Rd=0, type1=0
    let encoding: u32 = 0x60800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_add_r_a1_a_field_cond_7_poweroftwo_0_70800000() {
    // Encoding: 0x70800000
    // Test aarch32_ADD_r_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: imm5=0, S=0, Rm=0, cond=7, type1=0, Rn=0, Rd=0
    let encoding: u32 = 0x70800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_add_r_a1_a_field_cond_8_poweroftwo_0_80800000() {
    // Encoding: 0x80800000
    // Test aarch32_ADD_r_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, imm5=0, type1=0, Rm=0, cond=8, Rd=0, Rn=0
    let encoding: u32 = 0x80800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_add_r_a1_a_field_cond_9_poweroftwo_0_90800000() {
    // Encoding: 0x90800000
    // Test aarch32_ADD_r_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, Rn=0, cond=9, Rd=0, imm5=0, type1=0, Rm=0
    let encoding: u32 = 0x90800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_add_r_a1_a_field_cond_10_poweroftwo_0_a0800000() {
    // Encoding: 0xA0800000
    // Test aarch32_ADD_r_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=10, Rm=0, S=0, Rn=0, Rd=0, imm5=0, type1=0
    let encoding: u32 = 0xA0800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_add_r_a1_a_field_cond_11_poweroftwo_0_b0800000() {
    // Encoding: 0xB0800000
    // Test aarch32_ADD_r_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: type1=0, Rm=0, Rn=0, imm5=0, cond=11, S=0, Rd=0
    let encoding: u32 = 0xB0800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_add_r_a1_a_field_cond_12_poweroftwo_0_c0800000() {
    // Encoding: 0xC0800000
    // Test aarch32_ADD_r_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=12, type1=0, Rm=0, S=0, Rn=0, imm5=0, Rd=0
    let encoding: u32 = 0xC0800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_add_r_a1_a_field_cond_13_poweroftwo_0_d0800000() {
    // Encoding: 0xD0800000
    // Test aarch32_ADD_r_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, cond=13, Rn=0, type1=0, Rm=0, S=0, imm5=0
    let encoding: u32 = 0xD0800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_add_r_a1_a_field_cond_14_poweroftwo_0_e0800000() {
    // Encoding: 0xE0800000
    // Test aarch32_ADD_r_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rn=0, S=0, imm5=0, cond=14, type1=0, Rm=0
    let encoding: u32 = 0xE0800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_add_r_a1_a_field_cond_15_max_0_f0800000() {
    // Encoding: 0xF0800000
    // Test aarch32_ADD_r_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: imm5=0, Rm=0, Rn=0, S=0, type1=0, cond=15, Rd=0
    let encoding: u32 = 0xF0800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_add_r_a1_a_field_s_0_min_0_00800000() {
    // Encoding: 0x00800000
    // Test aarch32_ADD_r_A1_A field S = 0 (Min)
    // ISET: A32
    // Fields: S=0, Rm=0, Rd=0, cond=0, Rn=0, type1=0, imm5=0
    let encoding: u32 = 0x00800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_add_r_a1_a_field_s_1_max_0_00900000() {
    // Encoding: 0x00900000
    // Test aarch32_ADD_r_A1_A field S = 1 (Max)
    // ISET: A32
    // Fields: Rm=0, S=1, imm5=0, type1=0, Rd=0, Rn=0, cond=0
    let encoding: u32 = 0x00900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_add_r_a1_a_field_rn_0_min_0_00800000() {
    // Encoding: 0x00800000
    // Test aarch32_ADD_r_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, Rd=0, type1=0, S=0, Rn=0, cond=0, imm5=0
    let encoding: u32 = 0x00800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_add_r_a1_a_field_rn_1_poweroftwo_0_00810000() {
    // Encoding: 0x00810000
    // Test aarch32_ADD_r_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: imm5=0, cond=0, Rn=1, Rd=0, type1=0, Rm=0, S=0
    let encoding: u32 = 0x00810000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_add_r_a1_a_field_rd_0_min_0_00800000() {
    // Encoding: 0x00800000
    // Test aarch32_ADD_r_A1_A field Rd = 0 (Min)
    // ISET: A32
    // Fields: type1=0, Rd=0, Rn=0, cond=0, S=0, imm5=0, Rm=0
    let encoding: u32 = 0x00800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_add_r_a1_a_field_rd_1_poweroftwo_0_00801000() {
    // Encoding: 0x00801000
    // Test aarch32_ADD_r_A1_A field Rd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Rd=1, type1=0, imm5=0, Rm=0, S=0, Rn=0
    let encoding: u32 = 0x00801000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_add_r_a1_a_field_imm5_0_zero_0_00800000() {
    // Encoding: 0x00800000
    // Test aarch32_ADD_r_A1_A field imm5 = 0 (Zero)
    // ISET: A32
    // Fields: Rm=0, type1=0, S=0, Rn=0, cond=0, imm5=0, Rd=0
    let encoding: u32 = 0x00800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_add_r_a1_a_field_imm5_1_poweroftwo_0_00800080() {
    // Encoding: 0x00800080
    // Test aarch32_ADD_r_A1_A field imm5 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, Rd=0, cond=0, type1=0, Rn=0, imm5=1, Rm=0
    let encoding: u32 = 0x00800080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_add_r_a1_a_field_imm5_3_poweroftwominusone_0_00800180() {
    // Encoding: 0x00800180
    // Test aarch32_ADD_r_A1_A field imm5 = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rd=0, Rm=0, type1=0, imm5=3, cond=0, Rn=0, S=0
    let encoding: u32 = 0x00800180;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_add_r_a1_a_field_imm5_4_poweroftwo_0_00800200() {
    // Encoding: 0x00800200
    // Test aarch32_ADD_r_A1_A field imm5 = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, type1=0, cond=0, Rd=0, imm5=4, Rn=0, Rm=0
    let encoding: u32 = 0x00800200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_add_r_a1_a_field_imm5_7_poweroftwominusone_0_00800380() {
    // Encoding: 0x00800380
    // Test aarch32_ADD_r_A1_A field imm5 = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rn=0, imm5=7, S=0, type1=0, Rm=0, cond=0, Rd=0
    let encoding: u32 = 0x00800380;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_add_r_a1_a_field_imm5_8_poweroftwo_0_00800400() {
    // Encoding: 0x00800400
    // Test aarch32_ADD_r_A1_A field imm5 = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rm=0, type1=0, cond=0, S=0, Rd=0, imm5=8
    let encoding: u32 = 0x00800400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 15, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (15)
#[test]
fn test_aarch32_add_r_a1_a_field_imm5_15_poweroftwominusone_0_00800780() {
    // Encoding: 0x00800780
    // Test aarch32_ADD_r_A1_A field imm5 = 15 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rd=0, S=0, cond=0, type1=0, Rm=0, Rn=0, imm5=15
    let encoding: u32 = 0x00800780;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_add_r_a1_a_field_imm5_16_poweroftwo_0_00800800() {
    // Encoding: 0x00800800
    // Test aarch32_ADD_r_A1_A field imm5 = 16 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, Rn=0, Rm=0, cond=0, imm5=16, Rd=0, type1=0
    let encoding: u32 = 0x00800800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 31, boundary: Max }
/// maximum immediate (31)
#[test]
fn test_aarch32_add_r_a1_a_field_imm5_31_max_0_00800f80() {
    // Encoding: 0x00800F80
    // Test aarch32_ADD_r_A1_A field imm5 = 31 (Max)
    // ISET: A32
    // Fields: Rm=0, Rd=0, cond=0, imm5=31, S=0, type1=0, Rn=0
    let encoding: u32 = 0x00800F80;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `field type1 5 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_add_r_a1_a_field_type1_0_min_0_00800000() {
    // Encoding: 0x00800000
    // Test aarch32_ADD_r_A1_A field type1 = 0 (Min)
    // ISET: A32
    // Fields: imm5=0, type1=0, Rd=0, cond=0, Rm=0, S=0, Rn=0
    let encoding: u32 = 0x00800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `field type1 5 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_add_r_a1_a_field_type1_1_poweroftwo_0_00800020() {
    // Encoding: 0x00800020
    // Test aarch32_ADD_r_A1_A field type1 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, type1=1, cond=0, Rm=0, Rd=0, Rn=0, imm5=0
    let encoding: u32 = 0x00800020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `field type1 5 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_aarch32_add_r_a1_a_field_type1_3_max_0_00800060() {
    // Encoding: 0x00800060
    // Test aarch32_ADD_r_A1_A field type1 = 3 (Max)
    // ISET: A32
    // Fields: type1=3, Rm=0, imm5=0, cond=0, S=0, Rd=0, Rn=0
    let encoding: u32 = 0x00800060;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_add_r_a1_a_field_rm_0_min_0_00800000() {
    // Encoding: 0x00800000
    // Test aarch32_ADD_r_A1_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: imm5=0, Rm=0, cond=0, S=0, type1=0, Rn=0, Rd=0
    let encoding: u32 = 0x00800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_add_r_a1_a_field_rm_1_poweroftwo_0_00800001() {
    // Encoding: 0x00800001
    // Test aarch32_ADD_r_A1_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Rd=0, Rm=1, Rn=0, S=0, type1=0, imm5=0
    let encoding: u32 = 0x00800001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_add_r_a1_a_combo_0_0_00800000() {
    // Encoding: 0x00800000
    // Test aarch32_ADD_r_A1_A field combination: cond=0, S=0, Rn=0, Rd=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: cond=0, Rd=0, Rm=0, type1=0, S=0, imm5=0, Rn=0
    let encoding: u32 = 0x00800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_add_r_a1_a_special_cond_0_condition_eq_0_00800000() {
    // Encoding: 0x00800000
    // Test aarch32_ADD_r_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: S=0, Rd=0, imm5=0, Rn=0, cond=0, type1=0, Rm=0
    let encoding: u32 = 0x00800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_add_r_a1_a_special_cond_1_condition_ne_0_10800000() {
    // Encoding: 0x10800000
    // Test aarch32_ADD_r_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: cond=1, type1=0, S=0, Rd=0, Rm=0, imm5=0, Rn=0
    let encoding: u32 = 0x10800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_add_r_a1_a_special_cond_2_condition_cs_hs_0_20800000() {
    // Encoding: 0x20800000
    // Test aarch32_ADD_r_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: Rm=0, Rd=0, cond=2, Rn=0, imm5=0, S=0, type1=0
    let encoding: u32 = 0x20800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_add_r_a1_a_special_cond_3_condition_cc_lo_0_30800000() {
    // Encoding: 0x30800000
    // Test aarch32_ADD_r_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: Rn=0, cond=3, Rd=0, type1=0, imm5=0, Rm=0, S=0
    let encoding: u32 = 0x30800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_add_r_a1_a_special_cond_4_condition_mi_0_40800000() {
    // Encoding: 0x40800000
    // Test aarch32_ADD_r_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: S=0, type1=0, Rd=0, imm5=0, Rm=0, Rn=0, cond=4
    let encoding: u32 = 0x40800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_add_r_a1_a_special_cond_5_condition_pl_0_50800000() {
    // Encoding: 0x50800000
    // Test aarch32_ADD_r_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: cond=5, S=0, type1=0, Rm=0, Rd=0, Rn=0, imm5=0
    let encoding: u32 = 0x50800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_add_r_a1_a_special_cond_6_condition_vs_0_60800000() {
    // Encoding: 0x60800000
    // Test aarch32_ADD_r_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: cond=6, Rd=0, imm5=0, type1=0, Rm=0, S=0, Rn=0
    let encoding: u32 = 0x60800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_add_r_a1_a_special_cond_7_condition_vc_0_70800000() {
    // Encoding: 0x70800000
    // Test aarch32_ADD_r_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: type1=0, S=0, cond=7, Rn=0, imm5=0, Rd=0, Rm=0
    let encoding: u32 = 0x70800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_add_r_a1_a_special_cond_8_condition_hi_0_80800000() {
    // Encoding: 0x80800000
    // Test aarch32_ADD_r_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: S=0, Rn=0, Rd=0, imm5=0, cond=8, type1=0, Rm=0
    let encoding: u32 = 0x80800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_add_r_a1_a_special_cond_9_condition_ls_0_90800000() {
    // Encoding: 0x90800000
    // Test aarch32_ADD_r_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: S=0, Rd=0, imm5=0, cond=9, type1=0, Rm=0, Rn=0
    let encoding: u32 = 0x90800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_add_r_a1_a_special_cond_10_condition_ge_0_a0800000() {
    // Encoding: 0xA0800000
    // Test aarch32_ADD_r_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: cond=10, Rd=0, type1=0, Rm=0, Rn=0, S=0, imm5=0
    let encoding: u32 = 0xA0800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_add_r_a1_a_special_cond_11_condition_lt_0_b0800000() {
    // Encoding: 0xB0800000
    // Test aarch32_ADD_r_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: cond=11, Rd=0, S=0, type1=0, Rn=0, imm5=0, Rm=0
    let encoding: u32 = 0xB0800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_add_r_a1_a_special_cond_12_condition_gt_0_c0800000() {
    // Encoding: 0xC0800000
    // Test aarch32_ADD_r_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: type1=0, imm5=0, Rn=0, Rm=0, Rd=0, cond=12, S=0
    let encoding: u32 = 0xC0800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_add_r_a1_a_special_cond_13_condition_le_0_d0800000() {
    // Encoding: 0xD0800000
    // Test aarch32_ADD_r_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: cond=13, Rd=0, Rm=0, S=0, Rn=0, imm5=0, type1=0
    let encoding: u32 = 0xD0800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_add_r_a1_a_special_cond_14_condition_al_0_e0800000() {
    // Encoding: 0xE0800000
    // Test aarch32_ADD_r_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: type1=0, Rn=0, cond=14, Rd=0, imm5=0, Rm=0, S=0
    let encoding: u32 = 0xE0800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_add_r_a1_a_special_cond_15_condition_nv_0_f0800000() {
    // Encoding: 0xF0800000
    // Test aarch32_ADD_r_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: type1=0, Rm=0, imm5=0, S=0, Rn=0, Rd=0, cond=15
    let encoding: u32 = 0xF0800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `field S = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "S", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_add_r_a1_a_special_s_0_size_variant_0_0_00800000() {
    // Encoding: 0x00800000
    // Test aarch32_ADD_r_A1_A special value S = 0 (Size variant 0)
    // ISET: A32
    // Fields: imm5=0, Rd=0, type1=0, Rm=0, cond=0, Rn=0, S=0
    let encoding: u32 = 0x00800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `field S = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "S", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_add_r_a1_a_special_s_1_size_variant_1_0_00900000() {
    // Encoding: 0x00900000
    // Test aarch32_ADD_r_A1_A special value S = 1 (Size variant 1)
    // ISET: A32
    // Fields: Rm=0, Rn=0, Rd=0, cond=0, S=1, imm5=0, type1=0
    let encoding: u32 = 0x00900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_r_T1_A
/// ASL: `field Rm 22 +: 3`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_add_r_t1_a_field_rm_0_min_0_18000000() {
    // Thumb encoding (32): 0x18000000
    // Test aarch32_ADD_r_T1_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: Rm=0, Rn=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x18000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_r_T1_A
/// ASL: `field Rm 22 +: 3`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_add_r_t1_a_field_rm_1_poweroftwo_0_18400000() {
    // Thumb encoding (32): 0x18400000
    // Test aarch32_ADD_r_T1_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=1, Rn=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x18400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_r_T1_A
/// ASL: `field Rn 19 +: 3`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_add_r_t1_a_field_rn_0_min_0_18000000() {
    // Thumb encoding (32): 0x18000000
    // Test aarch32_ADD_r_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rm=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x18000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_r_T1_A
/// ASL: `field Rn 19 +: 3`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_add_r_t1_a_field_rn_1_poweroftwo_0_18080000() {
    // Thumb encoding (32): 0x18080000
    // Test aarch32_ADD_r_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=0, Rn=1, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x18080000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_r_T1_A
/// ASL: `field Rd 16 +: 3`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_add_r_t1_a_field_rd_0_min_0_18000000() {
    // Thumb encoding (32): 0x18000000
    // Test aarch32_ADD_r_T1_A field Rd = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rd=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x18000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_r_T1_A
/// ASL: `field Rd 16 +: 3`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_add_r_t1_a_field_rd_1_poweroftwo_0_18010000() {
    // Thumb encoding (32): 0x18010000
    // Test aarch32_ADD_r_T1_A field Rd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Rd=1, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x18010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_r_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch32_add_r_t1_a_combo_0_0_18000000() {
    // Thumb encoding (32): 0x18000000
    // Test aarch32_ADD_r_T1_A field combination: Rm=0, Rn=0, Rd=0
    // ISET: T32
    // Fields: Rm=0, Rn=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x18000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_r_T2_A
/// ASL: `field DN 23 +: 1`
/// Requirement: FieldBoundary { field: "DN", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_add_r_t2_a_field_dn_0_min_0_44000000() {
    // Thumb encoding (32): 0x44000000
    // Test aarch32_ADD_r_T2_A field DN = 0 (Min)
    // ISET: T32
    // Fields: DN=0, Rm=0, Rdn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x44000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_r_T2_A
/// ASL: `field DN 23 +: 1`
/// Requirement: FieldBoundary { field: "DN", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_add_r_t2_a_field_dn_1_max_0_44800000() {
    // Thumb encoding (32): 0x44800000
    // Test aarch32_ADD_r_T2_A field DN = 1 (Max)
    // ISET: T32
    // Fields: Rdn=0, DN=1, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x44800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_r_T2_A
/// ASL: `field Rm 19 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_add_r_t2_a_field_rm_0_min_0_44000000() {
    // Thumb encoding (32): 0x44000000
    // Test aarch32_ADD_r_T2_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: DN=0, Rdn=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x44000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_r_T2_A
/// ASL: `field Rm 19 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_add_r_t2_a_field_rm_1_poweroftwo_0_44080000() {
    // Thumb encoding (32): 0x44080000
    // Test aarch32_ADD_r_T2_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: DN=0, Rm=1, Rdn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x44080000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_r_T2_A
/// ASL: `field Rdn 16 +: 3`
/// Requirement: FieldBoundary { field: "Rdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_add_r_t2_a_field_rdn_0_min_0_44000000() {
    // Thumb encoding (32): 0x44000000
    // Test aarch32_ADD_r_T2_A field Rdn = 0 (Min)
    // ISET: T32
    // Fields: Rdn=0, Rm=0, DN=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x44000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_r_T2_A
/// ASL: `field Rdn 16 +: 3`
/// Requirement: FieldBoundary { field: "Rdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_add_r_t2_a_field_rdn_1_poweroftwo_0_44010000() {
    // Thumb encoding (32): 0x44010000
    // Test aarch32_ADD_r_T2_A field Rdn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: DN=0, Rm=0, Rdn=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x44010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_r_T2_A
/// ASL: `field Rdn 16 +: 3`
/// Requirement: FieldBoundary { field: "Rdn", value: 7, boundary: Max }
/// maximum value (7)
#[test]
fn test_aarch32_add_r_t2_a_field_rdn_7_max_0_44070000() {
    // Thumb encoding (32): 0x44070000
    // Test aarch32_ADD_r_T2_A field Rdn = 7 (Max)
    // ISET: T32
    // Fields: DN=0, Rm=0, Rdn=7
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x44070000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_r_T2_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// DN=0 (minimum value)
#[test]
fn test_aarch32_add_r_t2_a_combo_0_0_44000000() {
    // Thumb encoding (32): 0x44000000
    // Test aarch32_ADD_r_T2_A field combination: DN=0, Rm=0, Rdn=0
    // ISET: T32
    // Fields: DN=0, Rm=0, Rdn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x44000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_r_T2_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: And, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Binary { op: And, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_add_r_t2_a_invalid_0_0_44000000() {
    // Thumb encoding (32): 0x44000000
    // Test aarch32_ADD_r_T2_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Binary { op: And, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }
    // ISET: T32
    // Fields: DN=0, Rdn=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x44000000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_ADD_r_T2_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_add_r_t2_a_invalid_1_0_44000000() {
    // Thumb encoding (32): 0x44000000
    // Test aarch32_ADD_r_T2_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rm=0, Rdn=0, DN=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x44000000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_ADD_r_T2_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: And, lhs: Binary { op: And, lhs: LitInt(15), rhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] } }, rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "LastInITBlock" }, args: [] } } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: And, lhs: Binary { op: And, lhs: LitInt(15), rhs: Call { name: QualifiedIdentifier { qualifier: Any, name: \"InITBlock\" }, args: [] } }, rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"LastInITBlock\" }, args: [] } } } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_add_r_t2_a_invalid_2_0_44000000() {
    // Thumb encoding (32): 0x44000000
    // Test aarch32_ADD_r_T2_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: And, lhs: Binary { op: And, lhs: LitInt(15), rhs: Call { name: QualifiedIdentifier { qualifier: Any, name: "InITBlock" }, args: [] } }, rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "LastInITBlock" }, args: [] } } } }
    // ISET: T32
    // Fields: DN=0, Rm=0, Rdn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x44000000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_ADD_r_T2_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_add_r_t2_a_invalid_3_0_44000000() {
    // Thumb encoding (32): 0x44000000
    // Test aarch32_ADD_r_T2_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: DN=0, Rm=0, Rdn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x44000000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_ADD_r_T3_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_add_r_t3_a_field_s_0_min_0_eb000000() {
    // Thumb encoding (32): 0xEB000000
    // Test aarch32_ADD_r_T3_A field S = 0 (Min)
    // ISET: T32
    // Fields: Rm=0, Rn=0, Rd=0, type1=0, S=0, imm3=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEB000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_r_T3_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_add_r_t3_a_field_s_1_max_0_eb100000() {
    // Thumb encoding (32): 0xEB100000
    // Test aarch32_ADD_r_T3_A field S = 1 (Max)
    // ISET: T32
    // Fields: imm3=0, imm2=0, type1=0, S=1, Rm=0, Rd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEB100000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_r_T3_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_add_r_t3_a_field_rn_0_min_0_eb000000() {
    // Thumb encoding (32): 0xEB000000
    // Test aarch32_ADD_r_T3_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rm=0, Rd=0, imm3=0, Rn=0, S=0, imm2=0, type1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEB000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_r_T3_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_add_r_t3_a_field_rn_1_poweroftwo_0_eb010000() {
    // Thumb encoding (32): 0xEB010000
    // Test aarch32_ADD_r_T3_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: type1=0, imm3=0, S=0, Rd=0, Rn=1, imm2=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEB010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_r_T3_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_add_r_t3_a_field_imm3_0_zero_0_eb000000() {
    // Thumb encoding (32): 0xEB000000
    // Test aarch32_ADD_r_T3_A field imm3 = 0 (Zero)
    // ISET: T32
    // Fields: Rn=0, Rd=0, imm2=0, Rm=0, imm3=0, type1=0, S=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEB000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_r_T3_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_add_r_t3_a_field_imm3_1_poweroftwo_0_eb001000() {
    // Thumb encoding (32): 0xEB001000
    // Test aarch32_ADD_r_T3_A field imm3 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: S=0, Rn=0, Rd=0, imm2=0, imm3=1, type1=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEB001000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_r_T3_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 3, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (3)
#[test]
fn test_aarch32_add_r_t3_a_field_imm3_3_poweroftwominusone_0_eb003000() {
    // Thumb encoding (32): 0xEB003000
    // Test aarch32_ADD_r_T3_A field imm3 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rd=0, S=0, imm2=0, Rm=0, Rn=0, imm3=3, type1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEB003000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_r_T3_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 7, boundary: Max }
/// maximum immediate (7)
#[test]
fn test_aarch32_add_r_t3_a_field_imm3_7_max_0_eb007000() {
    // Thumb encoding (32): 0xEB007000
    // Test aarch32_ADD_r_T3_A field imm3 = 7 (Max)
    // ISET: T32
    // Fields: Rm=0, S=0, Rn=0, type1=0, imm3=7, Rd=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEB007000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_r_T3_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_add_r_t3_a_field_rd_0_min_0_eb000000() {
    // Thumb encoding (32): 0xEB000000
    // Test aarch32_ADD_r_T3_A field Rd = 0 (Min)
    // ISET: T32
    // Fields: type1=0, imm3=0, imm2=0, Rd=0, S=0, Rn=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEB000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_r_T3_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_add_r_t3_a_field_rd_1_poweroftwo_0_eb000100() {
    // Thumb encoding (32): 0xEB000100
    // Test aarch32_ADD_r_T3_A field Rd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm2=0, Rm=0, Rd=1, Rn=0, imm3=0, S=0, type1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEB000100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_r_T3_A
/// ASL: `field imm2 6 +: 2`
/// Requirement: FieldBoundary { field: "imm2", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_add_r_t3_a_field_imm2_0_zero_0_eb000000() {
    // Thumb encoding (32): 0xEB000000
    // Test aarch32_ADD_r_T3_A field imm2 = 0 (Zero)
    // ISET: T32
    // Fields: type1=0, S=0, Rn=0, Rd=0, imm2=0, Rm=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEB000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_r_T3_A
/// ASL: `field imm2 6 +: 2`
/// Requirement: FieldBoundary { field: "imm2", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_add_r_t3_a_field_imm2_1_poweroftwo_0_eb000040() {
    // Thumb encoding (32): 0xEB000040
    // Test aarch32_ADD_r_T3_A field imm2 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, imm2=1, Rm=0, S=0, type1=0, imm3=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEB000040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_r_T3_A
/// ASL: `field imm2 6 +: 2`
/// Requirement: FieldBoundary { field: "imm2", value: 3, boundary: Max }
/// maximum immediate (3)
#[test]
fn test_aarch32_add_r_t3_a_field_imm2_3_max_0_eb0000c0() {
    // Thumb encoding (32): 0xEB0000C0
    // Test aarch32_ADD_r_T3_A field imm2 = 3 (Max)
    // ISET: T32
    // Fields: imm2=3, Rn=0, imm3=0, type1=0, Rd=0, S=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEB0000C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_r_T3_A
/// ASL: `field type1 4 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_add_r_t3_a_field_type1_0_min_0_eb000000() {
    // Thumb encoding (32): 0xEB000000
    // Test aarch32_ADD_r_T3_A field type1 = 0 (Min)
    // ISET: T32
    // Fields: Rm=0, Rn=0, Rd=0, S=0, imm2=0, type1=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEB000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_r_T3_A
/// ASL: `field type1 4 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_add_r_t3_a_field_type1_1_poweroftwo_0_eb000010() {
    // Thumb encoding (32): 0xEB000010
    // Test aarch32_ADD_r_T3_A field type1 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: S=0, imm3=0, Rd=0, imm2=0, type1=1, Rn=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEB000010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_r_T3_A
/// ASL: `field type1 4 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_aarch32_add_r_t3_a_field_type1_3_max_0_eb000030() {
    // Thumb encoding (32): 0xEB000030
    // Test aarch32_ADD_r_T3_A field type1 = 3 (Max)
    // ISET: T32
    // Fields: S=0, Rd=0, imm3=0, imm2=0, type1=3, Rm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEB000030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_r_T3_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_add_r_t3_a_field_rm_0_min_0_eb000000() {
    // Thumb encoding (32): 0xEB000000
    // Test aarch32_ADD_r_T3_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, type1=0, imm3=0, S=0, Rd=0, imm2=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEB000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_r_T3_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_add_r_t3_a_field_rm_1_poweroftwo_0_eb000001() {
    // Thumb encoding (32): 0xEB000001
    // Test aarch32_ADD_r_T3_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, imm3=0, S=0, Rd=0, imm2=0, type1=0, Rm=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEB000001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_r_T3_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// S=0 (8-bit / byte size)
#[test]
fn test_aarch32_add_r_t3_a_combo_0_0_eb000000() {
    // Thumb encoding (32): 0xEB000000
    // Test aarch32_ADD_r_T3_A field combination: S=0, Rn=0, imm3=0, Rd=0, imm2=0, type1=0, Rm=0
    // ISET: T32
    // Fields: Rd=0, imm2=0, S=0, type1=0, Rn=0, Rm=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEB000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_r_T3_A
/// ASL: `field S = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "S", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_add_r_t3_a_special_s_0_size_variant_0_0_eb000000() {
    // Thumb encoding (32): 0xEB000000
    // Test aarch32_ADD_r_T3_A special value S = 0 (Size variant 0)
    // ISET: T32
    // Fields: Rm=0, type1=0, Rd=0, S=0, imm3=0, Rn=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEB000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_r_T3_A
/// ASL: `field S = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "S", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_add_r_t3_a_special_s_1_size_variant_1_0_eb100000() {
    // Thumb encoding (32): 0xEB100000
    // Test aarch32_ADD_r_T3_A special value S = 1 (Size variant 1)
    // ISET: T32
    // Fields: imm3=0, S=1, type1=0, Rd=0, Rm=0, imm2=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEB100000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_r_T3_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Or, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: And, lhs: LitInt(15), rhs: Unary { op: Not, operand: Var(QualifiedIdentifier { qualifier: Any, name: "setflags" }) } } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Or, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: And, lhs: LitInt(15), rhs: Unary { op: Not, operand: Var(QualifiedIdentifier { qualifier: Any, name: \"setflags\" }) } } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_add_r_t3_a_invalid_0_0_eb000000() {
    // Thumb encoding (32): 0xEB000000
    // Test aarch32_ADD_r_T3_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Or, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: And, lhs: LitInt(15), rhs: Unary { op: Not, operand: Var(QualifiedIdentifier { qualifier: Any, name: "setflags" }) } } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }
    // ISET: T32
    // Fields: Rn=0, Rd=0, Rm=0, imm2=0, type1=0, S=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEB000000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_ADD_r_T3_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_add_r_t3_a_invalid_1_0_eb000000() {
    // Thumb encoding (32): 0xEB000000
    // Test aarch32_ADD_r_T3_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: imm3=0, imm2=0, type1=0, Rm=0, S=0, Rd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEB000000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `ADD X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// no shift (32)
#[test]
fn test_aarch32_add_r_a1_a_add_shifted_oracle_32_0_00820020() {
    // Test ADD shifted 32-bit: no shift (oracle)
    // Encoding: 0x00820020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0xA);
    let encoding: u32 = 0x00820020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6E, "W0 should be 0x0000006E");
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `ADD X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// no shift (64)
#[test]
fn test_aarch32_add_r_a1_a_add_shifted_oracle_64_0_80820020() {
    // Test ADD shifted 64-bit: no shift (oracle)
    // Encoding: 0x80820020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xA);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x80820020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6E, "X0 should be 0x000000000000006E");
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `ADD X0, X1, X2, shift #3`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// LSL #3 (multiply by 8) (32)
#[test]
fn test_aarch32_add_r_a1_a_add_shifted_oracle_32_1_00820c20() {
    // Test ADD shifted 32-bit: LSL #3 (multiply by 8) (oracle)
    // Encoding: 0x00820C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x00820C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6C, "W0 should be 0x0000006C");
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `ADD X0, X1, X2, shift #3`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// LSL #3 (multiply by 8) (64)
#[test]
fn test_aarch32_add_r_a1_a_add_shifted_oracle_64_1_80820c20() {
    // Test ADD shifted 64-bit: LSL #3 (multiply by 8) (oracle)
    // Encoding: 0x80820C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x80820C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6C, "X0 should be 0x000000000000006C");
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `ADD X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// overflow test (32)
#[test]
fn test_aarch32_add_r_a1_a_add_shifted_oracle_32_2_00820020() {
    // Test ADD shifted 32-bit: overflow test (oracle)
    // Encoding: 0x00820020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x00820020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `ADD X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// overflow test (64)
#[test]
fn test_aarch32_add_r_a1_a_add_shifted_oracle_64_2_80820020() {
    // Test ADD shifted 64-bit: overflow test (oracle)
    // Encoding: 0x80820020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x80820020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `ADD X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// subtract from zero (32)
#[test]
fn test_aarch32_add_r_a1_a_add_shifted_oracle_32_3_00820020() {
    // Test ADD shifted 32-bit: subtract from zero (oracle)
    // Encoding: 0x00820020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x00820020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "W0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `ADD X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// subtract from zero (64)
#[test]
fn test_aarch32_add_r_a1_a_add_shifted_oracle_64_3_80820020() {
    // Test ADD shifted 64-bit: subtract from zero (oracle)
    // Encoding: 0x80820020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x80820020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `ADDS X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// no shift (32)
#[test]
fn test_aarch32_add_r_a1_a_adds_shifted_oracle_32_0_20820020() {
    // Test ADDS shifted 32-bit: no shift (oracle)
    // Encoding: 0x20820020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xA);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x20820020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6E, "W0 should be 0x0000006E");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `ADDS X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// no shift (64)
#[test]
fn test_aarch32_add_r_a1_a_adds_shifted_oracle_64_0_a0820020() {
    // Test ADDS shifted 64-bit: no shift (oracle)
    // Encoding: 0xA0820020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xA);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xA0820020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6E, "X0 should be 0x000000000000006E");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `ADDS X0, X1, X2, shift #3`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// LSL #3 (multiply by 8) (32)
#[test]
fn test_aarch32_add_r_a1_a_adds_shifted_oracle_32_1_20820c20() {
    // Test ADDS shifted 32-bit: LSL #3 (multiply by 8) (oracle)
    // Encoding: 0x20820C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x20820C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6C, "W0 should be 0x0000006C");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `ADDS X0, X1, X2, shift #3`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// LSL #3 (multiply by 8) (64)
#[test]
fn test_aarch32_add_r_a1_a_adds_shifted_oracle_64_1_a0820c20() {
    // Test ADDS shifted 64-bit: LSL #3 (multiply by 8) (oracle)
    // Encoding: 0xA0820C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xA0820C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6C, "X0 should be 0x000000000000006C");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `ADDS X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// overflow test (32)
#[test]
fn test_aarch32_add_r_a1_a_adds_shifted_oracle_32_2_20820020() {
    // Test ADDS shifted 32-bit: overflow test (oracle)
    // Encoding: 0x20820020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x20820020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `ADDS X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// overflow test (64)
#[test]
fn test_aarch32_add_r_a1_a_adds_shifted_oracle_64_2_a0820020() {
    // Test ADDS shifted 64-bit: overflow test (oracle)
    // Encoding: 0xA0820020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xA0820020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, true, "V flag should be true");
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `ADDS X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// subtract from zero (32)
#[test]
fn test_aarch32_add_r_a1_a_adds_shifted_oracle_32_3_20820020() {
    // Test ADDS shifted 32-bit: subtract from zero (oracle)
    // Encoding: 0x20820020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x20820020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "W0 should be 0xFFFFFFFF");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `ADDS X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// subtract from zero (64)
#[test]
fn test_aarch32_add_r_a1_a_adds_shifted_oracle_64_3_a0820020() {
    // Test ADDS shifted 64-bit: subtract from zero (oracle)
    // Encoding: 0xA0820020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xA0820020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `SUB X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// no shift (32)
#[test]
fn test_aarch32_add_r_a1_a_sub_shifted_oracle_32_0_40820020() {
    // Test SUB shifted 32-bit: no shift (oracle)
    // Encoding: 0x40820020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0xA);
    let encoding: u32 = 0x40820020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x5A, "W0 should be 0x0000005A");
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `SUB X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// no shift (64)
#[test]
fn test_aarch32_add_r_a1_a_sub_shifted_oracle_64_0_c0820020() {
    // Test SUB shifted 64-bit: no shift (oracle)
    // Encoding: 0xC0820020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xA);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xC0820020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x5A, "X0 should be 0x000000000000005A");
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `SUB X0, X1, X2, shift #3`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// LSL #3 (multiply by 8) (32)
#[test]
fn test_aarch32_add_r_a1_a_sub_shifted_oracle_32_1_40820c20() {
    // Test SUB shifted 32-bit: LSL #3 (multiply by 8) (oracle)
    // Encoding: 0x40820C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x40820C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x5C, "W0 should be 0x0000005C");
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `SUB X0, X1, X2, shift #3`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// LSL #3 (multiply by 8) (64)
#[test]
fn test_aarch32_add_r_a1_a_sub_shifted_oracle_64_1_c0820c20() {
    // Test SUB shifted 64-bit: LSL #3 (multiply by 8) (oracle)
    // Encoding: 0xC0820C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0xC0820C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x5C, "X0 should be 0x000000000000005C");
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `SUB X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// overflow test (32)
#[test]
fn test_aarch32_add_r_a1_a_sub_shifted_oracle_32_2_40820020() {
    // Test SUB shifted 32-bit: overflow test (oracle)
    // Encoding: 0x40820020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x40820020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `SUB X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// overflow test (64)
#[test]
fn test_aarch32_add_r_a1_a_sub_shifted_oracle_64_2_c0820020() {
    // Test SUB shifted 64-bit: overflow test (oracle)
    // Encoding: 0xC0820020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xC0820020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `SUB X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// subtract from zero (32)
#[test]
fn test_aarch32_add_r_a1_a_sub_shifted_oracle_32_3_40820020() {
    // Test SUB shifted 32-bit: subtract from zero (oracle)
    // Encoding: 0x40820020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x40820020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `SUB X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// subtract from zero (64)
#[test]
fn test_aarch32_add_r_a1_a_sub_shifted_oracle_64_3_c0820020() {
    // Test SUB shifted 64-bit: subtract from zero (oracle)
    // Encoding: 0xC0820020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0xC0820020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x0000000000000001");
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `SUBS X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// no shift (32)
#[test]
fn test_aarch32_add_r_a1_a_subs_shifted_oracle_32_0_60820020() {
    // Test SUBS shifted 32-bit: no shift (oracle)
    // Encoding: 0x60820020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0xA);
    let encoding: u32 = 0x60820020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x5A, "W0 should be 0x0000005A");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `SUBS X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// no shift (64)
#[test]
fn test_aarch32_add_r_a1_a_subs_shifted_oracle_64_0_e0820020() {
    // Test SUBS shifted 64-bit: no shift (oracle)
    // Encoding: 0xE0820020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0xA);
    let encoding: u32 = 0xE0820020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x5A, "X0 should be 0x000000000000005A");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `SUBS X0, X1, X2, shift #3`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// LSL #3 (multiply by 8) (32)
#[test]
fn test_aarch32_add_r_a1_a_subs_shifted_oracle_32_1_60820c20() {
    // Test SUBS shifted 32-bit: LSL #3 (multiply by 8) (oracle)
    // Encoding: 0x60820C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x60820C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x5C, "W0 should be 0x0000005C");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `SUBS X0, X1, X2, shift #3`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// LSL #3 (multiply by 8) (64)
#[test]
fn test_aarch32_add_r_a1_a_subs_shifted_oracle_64_1_e0820c20() {
    // Test SUBS shifted 64-bit: LSL #3 (multiply by 8) (oracle)
    // Encoding: 0xE0820C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xE0820C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x5C, "X0 should be 0x000000000000005C");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `SUBS X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// overflow test (32)
#[test]
fn test_aarch32_add_r_a1_a_subs_shifted_oracle_32_2_60820020() {
    // Test SUBS shifted 32-bit: overflow test (oracle)
    // Encoding: 0x60820020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x60820020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `SUBS X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// overflow test (64)
#[test]
fn test_aarch32_add_r_a1_a_subs_shifted_oracle_64_2_e0820020() {
    // Test SUBS shifted 64-bit: overflow test (oracle)
    // Encoding: 0xE0820020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xE0820020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `SUBS X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// subtract from zero (32)
#[test]
fn test_aarch32_add_r_a1_a_subs_shifted_oracle_32_3_60820020() {
    // Test SUBS shifted 32-bit: subtract from zero (oracle)
    // Encoding: 0x60820020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x60820020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `SUBS X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// subtract from zero (64)
#[test]
fn test_aarch32_add_r_a1_a_subs_shifted_oracle_64_3_e0820020() {
    // Test SUBS shifted 64-bit: subtract from zero (oracle)
    // Encoding: 0xE0820020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xE0820020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x0000000000000001");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `ADD R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple values
#[test]
fn test_aarch32_add_r_a1_a_a32_add_sub_reg_0_00810002() {
    // Test A32 ADD: simple values (oracle)
    // Encoding: 0x00810002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x32);
    let encoding: u32 = 0x00810002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x96, "R0 should be 0x00000096");
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `ADD R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero values
#[test]
fn test_aarch32_add_r_a1_a_a32_add_sub_reg_1_00810002() {
    // Test A32 ADD: zero values (oracle)
    // Encoding: 0x00810002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x00810002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `ADD R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max value
#[test]
fn test_aarch32_add_r_a1_a_a32_add_sub_reg_2_00810002() {
    // Test A32 ADD: max value (oracle)
    // Encoding: 0x00810002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x00810002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `ADD R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set
#[test]
fn test_aarch32_add_r_a1_a_a32_add_sub_reg_3_00810002() {
    // Test A32 ADD: MSB set (oracle)
    // Encoding: 0x00810002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x80000000);
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0x00810002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `ADD R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// mixed pattern
#[test]
fn test_aarch32_add_r_a1_a_a32_add_sub_reg_4_00810002() {
    // Test A32 ADD: mixed pattern (oracle)
    // Encoding: 0x00810002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x9ABCDEF0);
    let encoding: u32 = 0x00810002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xACF13568, "R0 should be 0xACF13568");
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_aarch32_add_r_a1_a_flags_zeroresult_0_00910002() {
    // Test aarch32_ADD_r_A1_A flag computation: ZeroResult
    // Encoding: 0x00910002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x00910002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_aarch32_add_r_a1_a_flags_zeroresult_1_00910002() {
    // Test aarch32_ADD_r_A1_A flag computation: ZeroResult
    // Encoding: 0x00910002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x00910002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_aarch32_add_r_a1_a_flags_negativeresult_2_00910002() {
    // Test aarch32_ADD_r_A1_A flag computation: NegativeResult
    // Encoding: 0x00910002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x00910002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_aarch32_add_r_a1_a_flags_unsignedoverflow_3_00910002() {
    // Test aarch32_ADD_r_A1_A flag computation: UnsignedOverflow
    // Encoding: 0x00910002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x00910002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_aarch32_add_r_a1_a_flags_unsignedoverflow_4_00910002() {
    // Test aarch32_ADD_r_A1_A flag computation: UnsignedOverflow
    // Encoding: 0x00910002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x00910002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_aarch32_add_r_a1_a_flags_signedoverflow_5_00910002() {
    // Test aarch32_ADD_r_A1_A flag computation: SignedOverflow
    // Encoding: 0x00910002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x00910002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_aarch32_add_r_a1_a_flags_signedoverflow_6_00910002() {
    // Test aarch32_ADD_r_A1_A flag computation: SignedOverflow
    // Encoding: 0x00910002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x00910002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_ADD_r_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_aarch32_add_r_a1_a_flags_positiveresult_7_00910002() {
    // Test aarch32_ADD_r_A1_A flag computation: PositiveResult
    // Encoding: 0x00910002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x32);
    let encoding: u32 = 0x00910002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 0 (32)
#[test]
fn test_aarch32_add_r_t1_a_lslv_oracle_32_0_18020020() {
    // Test LSLV 32-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x12345678, "W0 should be 0x12345678");
}

/// Provenance: aarch32_ADD_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 0 (64)
#[test]
fn test_aarch32_add_r_t1_a_lslv_oracle_64_0_98020020() {
    // Test LSLV 64-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x12345678,
        "X0 should be 0x0000000012345678"
    );
}

/// Provenance: aarch32_ADD_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4 (32)
#[test]
fn test_aarch32_add_r_t1_a_lslv_oracle_32_1_18020020() {
    // Test LSLV 32-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x4);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x23456780, "W0 should be 0x23456780");
}

/// Provenance: aarch32_ADD_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 4 (64)
#[test]
fn test_aarch32_add_r_t1_a_lslv_oracle_64_1_98020020() {
    // Test LSLV 64-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x4);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x23456780,
        "X0 should be 0x0000000123456780"
    );
}

/// Provenance: aarch32_ADD_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 8 (32)
#[test]
fn test_aarch32_add_r_t1_a_lslv_oracle_32_2_18020020() {
    // Test LSLV 32-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x8);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x34567800, "W0 should be 0x34567800");
}

/// Provenance: aarch32_ADD_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 8 (64)
#[test]
fn test_aarch32_add_r_t1_a_lslv_oracle_64_2_98020020() {
    // Test LSLV 64-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x8);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x34567800,
        "X0 should be 0x0000001234567800"
    );
}

/// Provenance: aarch32_ADD_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1 (32)
#[test]
fn test_aarch32_add_r_t1_a_lslv_oracle_32_3_18020020() {
    // Test LSLV 32-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_ADD_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// MSB set, shift 1 (64)
#[test]
fn test_aarch32_add_r_t1_a_lslv_oracle_64_3_98020020() {
    // Test LSLV 64-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_ADD_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// LSB set, max shift (32)
#[test]
fn test_aarch32_add_r_t1_a_lslv_oracle_32_4_18020020() {
    // Test LSLV 32-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x3F);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "W0 should be 0x80000000");
}

/// Provenance: aarch32_ADD_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// LSB set, max shift (64)
#[test]
fn test_aarch32_add_r_t1_a_lslv_oracle_64_4_98020020() {
    // Test LSLV 64-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3F);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x8000000000000000");
}

/// Provenance: aarch32_ADD_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// all ones, shift 32 (32)
#[test]
fn test_aarch32_add_r_t1_a_lslv_oracle_32_5_18020020() {
    // Test LSLV 32-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x20);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "W0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_ADD_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// all ones, shift 32 (64)
#[test]
fn test_aarch32_add_r_t1_a_lslv_oracle_64_5_98020020() {
    // Test LSLV 64-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x20);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0xFFFFFFFF00000000");
}

/// Provenance: aarch32_ADD_r_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// no shift
#[test]
fn test_aarch32_add_r_t1_a_t16_oracle_0_18880000() {
    // Test T16 LSLS: no shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_ADD_r_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4
#[test]
fn test_aarch32_add_r_t1_a_t16_oracle_1_18880000() {
    // Test T16 LSLS: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    set_w(&mut cpu, 2, 0x4);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF0, "R0 should be 0x00000FF0");
}

/// Provenance: aarch32_ADD_r_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1
#[test]
fn test_aarch32_add_r_t1_a_t16_oracle_2_18880000() {
    // Test T16 LSLS: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_ADD_r_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift to MSB
#[test]
fn test_aarch32_add_r_t1_a_t16_oracle_3_18880000() {
    // Test T16 LSLS: shift to MSB (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x1F);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "R0 should be 0x80000000");
}

/// Provenance: aarch32_ADD_r_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_aarch32_add_r_t1_a_flags_zeroresult_0_18880000() {
    // Test aarch32_ADD_r_T1_A flag computation: ZeroResult
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_r_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_aarch32_add_r_t1_a_flags_zeroresult_1_18880000() {
    // Test aarch32_ADD_r_T1_A flag computation: ZeroResult
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_r_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_aarch32_add_r_t1_a_flags_negativeresult_2_18880000() {
    // Test aarch32_ADD_r_T1_A flag computation: NegativeResult
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_r_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_aarch32_add_r_t1_a_flags_unsignedoverflow_3_18880000() {
    // Test aarch32_ADD_r_T1_A flag computation: UnsignedOverflow
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_r_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_aarch32_add_r_t1_a_flags_unsignedoverflow_4_18880000() {
    // Test aarch32_ADD_r_T1_A flag computation: UnsignedOverflow
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_r_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_aarch32_add_r_t1_a_flags_signedoverflow_5_18880000() {
    // Test aarch32_ADD_r_T1_A flag computation: SignedOverflow
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_ADD_r_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_aarch32_add_r_t1_a_flags_signedoverflow_6_18880000() {
    // Test aarch32_ADD_r_T1_A flag computation: SignedOverflow
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_ADD_r_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_aarch32_add_r_t1_a_flags_positiveresult_7_18880000() {
    // Test aarch32_ADD_r_T1_A flag computation: PositiveResult
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x32);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_r_T2_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 0 (32)
#[test]
fn test_aarch32_add_r_t2_a_lslv_oracle_32_0_44020020() {
    // Test LSLV 32-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x12345678, "W0 should be 0x12345678");
}

/// Provenance: aarch32_ADD_r_T2_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 0 (64)
#[test]
fn test_aarch32_add_r_t2_a_lslv_oracle_64_0_c4020020() {
    // Test LSLV 64-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x12345678,
        "X0 should be 0x0000000012345678"
    );
}

/// Provenance: aarch32_ADD_r_T2_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4 (32)
#[test]
fn test_aarch32_add_r_t2_a_lslv_oracle_32_1_44020020() {
    // Test LSLV 32-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x4);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x23456780, "W0 should be 0x23456780");
}

/// Provenance: aarch32_ADD_r_T2_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 4 (64)
#[test]
fn test_aarch32_add_r_t2_a_lslv_oracle_64_1_c4020020() {
    // Test LSLV 64-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x4);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x23456780,
        "X0 should be 0x0000000123456780"
    );
}

/// Provenance: aarch32_ADD_r_T2_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 8 (32)
#[test]
fn test_aarch32_add_r_t2_a_lslv_oracle_32_2_44020020() {
    // Test LSLV 32-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x8);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x34567800, "W0 should be 0x34567800");
}

/// Provenance: aarch32_ADD_r_T2_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 8 (64)
#[test]
fn test_aarch32_add_r_t2_a_lslv_oracle_64_2_c4020020() {
    // Test LSLV 64-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x8);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x34567800,
        "X0 should be 0x0000001234567800"
    );
}

/// Provenance: aarch32_ADD_r_T2_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1 (32)
#[test]
fn test_aarch32_add_r_t2_a_lslv_oracle_32_3_44020020() {
    // Test LSLV 32-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_ADD_r_T2_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// MSB set, shift 1 (64)
#[test]
fn test_aarch32_add_r_t2_a_lslv_oracle_64_3_c4020020() {
    // Test LSLV 64-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_ADD_r_T2_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// LSB set, max shift (32)
#[test]
fn test_aarch32_add_r_t2_a_lslv_oracle_32_4_44020020() {
    // Test LSLV 32-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x3F);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "W0 should be 0x80000000");
}

/// Provenance: aarch32_ADD_r_T2_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// LSB set, max shift (64)
#[test]
fn test_aarch32_add_r_t2_a_lslv_oracle_64_4_c4020020() {
    // Test LSLV 64-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x3F);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x8000000000000000");
}

/// Provenance: aarch32_ADD_r_T2_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// all ones, shift 32 (32)
#[test]
fn test_aarch32_add_r_t2_a_lslv_oracle_32_5_44020020() {
    // Test LSLV 32-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x20);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "W0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_ADD_r_T2_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// all ones, shift 32 (64)
#[test]
fn test_aarch32_add_r_t2_a_lslv_oracle_64_5_c4020020() {
    // Test LSLV 64-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x20);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0xFFFFFFFF00000000");
}

/// Provenance: aarch32_ADD_r_T2_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// no shift
#[test]
fn test_aarch32_add_r_t2_a_t16_oracle_0_44100000() {
    // Test T16 LSLS: no shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_ADD_r_T2_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4
#[test]
fn test_aarch32_add_r_t2_a_t16_oracle_1_44100000() {
    // Test T16 LSLS: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x4);
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF0, "R0 should be 0x00000FF0");
}

/// Provenance: aarch32_ADD_r_T2_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1
#[test]
fn test_aarch32_add_r_t2_a_t16_oracle_2_44100000() {
    // Test T16 LSLS: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_ADD_r_T2_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift to MSB
#[test]
fn test_aarch32_add_r_t2_a_t16_oracle_3_44100000() {
    // Test T16 LSLS: shift to MSB (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1F);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "R0 should be 0x80000000");
}

/// Provenance: aarch32_ADD_r_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_aarch32_add_r_t2_a_flags_zeroresult_0_44100000() {
    // Test aarch32_ADD_r_T2_A flag computation: ZeroResult
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_r_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_aarch32_add_r_t2_a_flags_zeroresult_1_44100000() {
    // Test aarch32_ADD_r_T2_A flag computation: ZeroResult
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_r_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_aarch32_add_r_t2_a_flags_negativeresult_2_44100000() {
    // Test aarch32_ADD_r_T2_A flag computation: NegativeResult
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_r_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_aarch32_add_r_t2_a_flags_unsignedoverflow_3_44100000() {
    // Test aarch32_ADD_r_T2_A flag computation: UnsignedOverflow
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_r_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_aarch32_add_r_t2_a_flags_unsignedoverflow_4_44100000() {
    // Test aarch32_ADD_r_T2_A flag computation: UnsignedOverflow
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_r_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_aarch32_add_r_t2_a_flags_signedoverflow_5_44100000() {
    // Test aarch32_ADD_r_T2_A flag computation: SignedOverflow
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_ADD_r_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_aarch32_add_r_t2_a_flags_signedoverflow_6_44100000() {
    // Test aarch32_ADD_r_T2_A flag computation: SignedOverflow
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_ADD_r_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_aarch32_add_r_t2_a_flags_positiveresult_7_44100000() {
    // Test aarch32_ADD_r_T2_A flag computation: PositiveResult
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x32);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_r_T3_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_aarch32_add_r_t3_a_flags_zeroresult_0_eb110002() {
    // Test aarch32_ADD_r_T3_A flag computation: ZeroResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xEB110002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_r_T3_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_aarch32_add_r_t3_a_flags_zeroresult_1_eb110002() {
    // Test aarch32_ADD_r_T3_A flag computation: ZeroResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xEB110002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_r_T3_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_aarch32_add_r_t3_a_flags_negativeresult_2_eb110002() {
    // Test aarch32_ADD_r_T3_A flag computation: NegativeResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xEB110002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_r_T3_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_aarch32_add_r_t3_a_flags_unsignedoverflow_3_eb110002() {
    // Test aarch32_ADD_r_T3_A flag computation: UnsignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0xEB110002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_r_T3_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_aarch32_add_r_t3_a_flags_unsignedoverflow_4_eb110002() {
    // Test aarch32_ADD_r_T3_A flag computation: UnsignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0xEB110002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_r_T3_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_aarch32_add_r_t3_a_flags_signedoverflow_5_eb110002() {
    // Test aarch32_ADD_r_T3_A flag computation: SignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0xEB110002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_ADD_r_T3_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_aarch32_add_r_t3_a_flags_signedoverflow_6_eb110002() {
    // Test aarch32_ADD_r_T3_A flag computation: SignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0xEB110002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_ADD_r_T3_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_aarch32_add_r_t3_a_flags_positiveresult_7_eb110002() {
    // Test aarch32_ADD_r_T3_A flag computation: PositiveResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x32);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xEB110002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

// ============================================================================
// aarch32_RSB_r_A Tests
// ============================================================================

/// Provenance: aarch32_RSB_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_rsb_r_a1_a_field_cond_0_min_0_00600000() {
    // Encoding: 0x00600000
    // Test aarch32_RSB_r_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: Rd=0, Rn=0, imm5=0, type1=0, Rm=0, cond=0, S=0
    let encoding: u32 = 0x00600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_rsb_r_a1_a_field_cond_1_poweroftwo_0_10600000() {
    // Encoding: 0x10600000
    // Test aarch32_RSB_r_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, cond=1, Rn=0, Rd=0, S=0, imm5=0, type1=0
    let encoding: u32 = 0x10600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_rsb_r_a1_a_field_cond_2_poweroftwo_0_20600000() {
    // Encoding: 0x20600000
    // Test aarch32_RSB_r_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, S=0, cond=2, Rn=0, imm5=0, type1=0, Rd=0
    let encoding: u32 = 0x20600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_rsb_r_a1_a_field_cond_3_poweroftwo_0_30600000() {
    // Encoding: 0x30600000
    // Test aarch32_RSB_r_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rd=0, type1=0, cond=3, S=0, imm5=0, Rm=0
    let encoding: u32 = 0x30600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_rsb_r_a1_a_field_cond_4_poweroftwo_0_40600000() {
    // Encoding: 0x40600000
    // Test aarch32_RSB_r_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=4, Rd=0, imm5=0, type1=0, S=0, Rm=0, Rn=0
    let encoding: u32 = 0x40600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_rsb_r_a1_a_field_cond_5_poweroftwo_0_50600000() {
    // Encoding: 0x50600000
    // Test aarch32_RSB_r_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=5, imm5=0, Rm=0, type1=0, Rn=0, S=0, Rd=0
    let encoding: u32 = 0x50600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_rsb_r_a1_a_field_cond_6_poweroftwo_0_60600000() {
    // Encoding: 0x60600000
    // Test aarch32_RSB_r_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, cond=6, Rn=0, type1=0, Rm=0, Rd=0, imm5=0
    let encoding: u32 = 0x60600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_rsb_r_a1_a_field_cond_7_poweroftwo_0_70600000() {
    // Encoding: 0x70600000
    // Test aarch32_RSB_r_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: type1=0, Rm=0, imm5=0, Rd=0, cond=7, S=0, Rn=0
    let encoding: u32 = 0x70600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_rsb_r_a1_a_field_cond_8_poweroftwo_0_80600000() {
    // Encoding: 0x80600000
    // Test aarch32_RSB_r_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, S=0, Rd=0, type1=0, cond=8, imm5=0, Rm=0
    let encoding: u32 = 0x80600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_rsb_r_a1_a_field_cond_9_poweroftwo_0_90600000() {
    // Encoding: 0x90600000
    // Test aarch32_RSB_r_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rd=0, S=0, type1=0, imm5=0, cond=9, Rm=0
    let encoding: u32 = 0x90600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_rsb_r_a1_a_field_cond_10_poweroftwo_0_a0600000() {
    // Encoding: 0xA0600000
    // Test aarch32_RSB_r_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, Rd=0, Rn=0, imm5=0, type1=0, Rm=0, cond=10
    let encoding: u32 = 0xA0600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_rsb_r_a1_a_field_cond_11_poweroftwo_0_b0600000() {
    // Encoding: 0xB0600000
    // Test aarch32_RSB_r_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: imm5=0, Rn=0, S=0, cond=11, type1=0, Rd=0, Rm=0
    let encoding: u32 = 0xB0600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_rsb_r_a1_a_field_cond_12_poweroftwo_0_c0600000() {
    // Encoding: 0xC0600000
    // Test aarch32_RSB_r_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: type1=0, Rm=0, Rn=0, S=0, cond=12, Rd=0, imm5=0
    let encoding: u32 = 0xC0600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_rsb_r_a1_a_field_cond_13_poweroftwo_0_d0600000() {
    // Encoding: 0xD0600000
    // Test aarch32_RSB_r_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=13, type1=0, Rm=0, Rd=0, Rn=0, imm5=0, S=0
    let encoding: u32 = 0xD0600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_rsb_r_a1_a_field_cond_14_poweroftwo_0_e0600000() {
    // Encoding: 0xE0600000
    // Test aarch32_RSB_r_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, Rd=0, type1=0, Rm=0, Rn=0, cond=14, imm5=0
    let encoding: u32 = 0xE0600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_rsb_r_a1_a_field_cond_15_max_0_f0600000() {
    // Encoding: 0xF0600000
    // Test aarch32_RSB_r_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: cond=15, type1=0, imm5=0, S=0, Rd=0, Rm=0, Rn=0
    let encoding: u32 = 0xF0600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_r_A1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_rsb_r_a1_a_field_s_0_min_0_00600000() {
    // Encoding: 0x00600000
    // Test aarch32_RSB_r_A1_A field S = 0 (Min)
    // ISET: A32
    // Fields: type1=0, Rm=0, S=0, cond=0, Rn=0, imm5=0, Rd=0
    let encoding: u32 = 0x00600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_r_A1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_rsb_r_a1_a_field_s_1_max_0_00700000() {
    // Encoding: 0x00700000
    // Test aarch32_RSB_r_A1_A field S = 1 (Max)
    // ISET: A32
    // Fields: cond=0, S=1, Rn=0, Rd=0, Rm=0, type1=0, imm5=0
    let encoding: u32 = 0x00700000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_r_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_rsb_r_a1_a_field_rn_0_min_0_00600000() {
    // Encoding: 0x00600000
    // Test aarch32_RSB_r_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: imm5=0, Rm=0, S=0, Rn=0, Rd=0, type1=0, cond=0
    let encoding: u32 = 0x00600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_r_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_rsb_r_a1_a_field_rn_1_poweroftwo_0_00610000() {
    // Encoding: 0x00610000
    // Test aarch32_RSB_r_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, type1=0, imm5=0, Rn=1, Rd=0, Rm=0, cond=0
    let encoding: u32 = 0x00610000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_r_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_rsb_r_a1_a_field_rd_0_min_0_00600000() {
    // Encoding: 0x00600000
    // Test aarch32_RSB_r_A1_A field Rd = 0 (Min)
    // ISET: A32
    // Fields: imm5=0, type1=0, cond=0, Rn=0, Rm=0, Rd=0, S=0
    let encoding: u32 = 0x00600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_r_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_rsb_r_a1_a_field_rd_1_poweroftwo_0_00601000() {
    // Encoding: 0x00601000
    // Test aarch32_RSB_r_A1_A field Rd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rd=1, cond=0, S=0, imm5=0, type1=0, Rm=0
    let encoding: u32 = 0x00601000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_rsb_r_a1_a_field_imm5_0_zero_0_00600000() {
    // Encoding: 0x00600000
    // Test aarch32_RSB_r_A1_A field imm5 = 0 (Zero)
    // ISET: A32
    // Fields: cond=0, Rn=0, imm5=0, Rm=0, type1=0, Rd=0, S=0
    let encoding: u32 = 0x00600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_rsb_r_a1_a_field_imm5_1_poweroftwo_0_00600080() {
    // Encoding: 0x00600080
    // Test aarch32_RSB_r_A1_A field imm5 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, S=0, Rn=0, cond=0, Rm=0, imm5=1, type1=0
    let encoding: u32 = 0x00600080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_rsb_r_a1_a_field_imm5_3_poweroftwominusone_0_00600180() {
    // Encoding: 0x00600180
    // Test aarch32_RSB_r_A1_A field imm5 = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: type1=0, Rn=0, imm5=3, cond=0, Rm=0, Rd=0, S=0
    let encoding: u32 = 0x00600180;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_rsb_r_a1_a_field_imm5_4_poweroftwo_0_00600200() {
    // Encoding: 0x00600200
    // Test aarch32_RSB_r_A1_A field imm5 = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, imm5=4, S=0, Rm=0, Rn=0, cond=0, type1=0
    let encoding: u32 = 0x00600200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_rsb_r_a1_a_field_imm5_7_poweroftwominusone_0_00600380() {
    // Encoding: 0x00600380
    // Test aarch32_RSB_r_A1_A field imm5 = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: type1=0, Rn=0, cond=0, S=0, Rd=0, Rm=0, imm5=7
    let encoding: u32 = 0x00600380;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_rsb_r_a1_a_field_imm5_8_poweroftwo_0_00600400() {
    // Encoding: 0x00600400
    // Test aarch32_RSB_r_A1_A field imm5 = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: type1=0, S=0, Rn=0, Rd=0, imm5=8, Rm=0, cond=0
    let encoding: u32 = 0x00600400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 15, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (15)
#[test]
fn test_aarch32_rsb_r_a1_a_field_imm5_15_poweroftwominusone_0_00600780() {
    // Encoding: 0x00600780
    // Test aarch32_RSB_r_A1_A field imm5 = 15 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, Rn=0, Rd=0, imm5=15, type1=0, Rm=0, S=0
    let encoding: u32 = 0x00600780;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_rsb_r_a1_a_field_imm5_16_poweroftwo_0_00600800() {
    // Encoding: 0x00600800
    // Test aarch32_RSB_r_A1_A field imm5 = 16 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Rn=0, S=0, cond=0, Rd=0, imm5=16, type1=0
    let encoding: u32 = 0x00600800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 31, boundary: Max }
/// maximum immediate (31)
#[test]
fn test_aarch32_rsb_r_a1_a_field_imm5_31_max_0_00600f80() {
    // Encoding: 0x00600F80
    // Test aarch32_RSB_r_A1_A field imm5 = 31 (Max)
    // ISET: A32
    // Fields: type1=0, imm5=31, cond=0, Rn=0, Rm=0, S=0, Rd=0
    let encoding: u32 = 0x00600F80;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_r_A1_A
/// ASL: `field type1 5 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_rsb_r_a1_a_field_type1_0_min_0_00600000() {
    // Encoding: 0x00600000
    // Test aarch32_RSB_r_A1_A field type1 = 0 (Min)
    // ISET: A32
    // Fields: S=0, cond=0, Rd=0, Rn=0, type1=0, imm5=0, Rm=0
    let encoding: u32 = 0x00600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_r_A1_A
/// ASL: `field type1 5 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_rsb_r_a1_a_field_type1_1_poweroftwo_0_00600020() {
    // Encoding: 0x00600020
    // Test aarch32_RSB_r_A1_A field type1 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, type1=1, cond=0, Rd=0, S=0, Rm=0, imm5=0
    let encoding: u32 = 0x00600020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_r_A1_A
/// ASL: `field type1 5 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_aarch32_rsb_r_a1_a_field_type1_3_max_0_00600060() {
    // Encoding: 0x00600060
    // Test aarch32_RSB_r_A1_A field type1 = 3 (Max)
    // ISET: A32
    // Fields: Rd=0, type1=3, Rm=0, S=0, imm5=0, cond=0, Rn=0
    let encoding: u32 = 0x00600060;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_r_A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_rsb_r_a1_a_field_rm_0_min_0_00600000() {
    // Encoding: 0x00600000
    // Test aarch32_RSB_r_A1_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: imm5=0, type1=0, Rm=0, Rn=0, cond=0, S=0, Rd=0
    let encoding: u32 = 0x00600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_r_A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_rsb_r_a1_a_field_rm_1_poweroftwo_0_00600001() {
    // Encoding: 0x00600001
    // Test aarch32_RSB_r_A1_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: imm5=0, Rn=0, S=0, cond=0, type1=0, Rd=0, Rm=1
    let encoding: u32 = 0x00600001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_r_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_rsb_r_a1_a_combo_0_0_00600000() {
    // Encoding: 0x00600000
    // Test aarch32_RSB_r_A1_A field combination: cond=0, S=0, Rn=0, Rd=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: Rd=0, Rm=0, cond=0, Rn=0, imm5=0, S=0, type1=0
    let encoding: u32 = 0x00600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_r_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_rsb_r_a1_a_special_cond_0_condition_eq_0_00600000() {
    // Encoding: 0x00600000
    // Test aarch32_RSB_r_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: type1=0, Rm=0, Rd=0, imm5=0, S=0, cond=0, Rn=0
    let encoding: u32 = 0x00600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_r_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_rsb_r_a1_a_special_cond_1_condition_ne_0_10600000() {
    // Encoding: 0x10600000
    // Test aarch32_RSB_r_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: cond=1, Rn=0, S=0, imm5=0, Rd=0, type1=0, Rm=0
    let encoding: u32 = 0x10600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_r_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_rsb_r_a1_a_special_cond_2_condition_cs_hs_0_20600000() {
    // Encoding: 0x20600000
    // Test aarch32_RSB_r_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: Rm=0, imm5=0, Rn=0, S=0, cond=2, Rd=0, type1=0
    let encoding: u32 = 0x20600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_r_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_rsb_r_a1_a_special_cond_3_condition_cc_lo_0_30600000() {
    // Encoding: 0x30600000
    // Test aarch32_RSB_r_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: imm5=0, cond=3, Rn=0, Rm=0, S=0, type1=0, Rd=0
    let encoding: u32 = 0x30600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_r_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_rsb_r_a1_a_special_cond_4_condition_mi_0_40600000() {
    // Encoding: 0x40600000
    // Test aarch32_RSB_r_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: imm5=0, Rn=0, cond=4, S=0, type1=0, Rm=0, Rd=0
    let encoding: u32 = 0x40600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_r_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_rsb_r_a1_a_special_cond_5_condition_pl_0_50600000() {
    // Encoding: 0x50600000
    // Test aarch32_RSB_r_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: Rm=0, S=0, type1=0, Rd=0, imm5=0, Rn=0, cond=5
    let encoding: u32 = 0x50600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_r_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_rsb_r_a1_a_special_cond_6_condition_vs_0_60600000() {
    // Encoding: 0x60600000
    // Test aarch32_RSB_r_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: cond=6, S=0, Rm=0, imm5=0, Rn=0, type1=0, Rd=0
    let encoding: u32 = 0x60600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_r_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_rsb_r_a1_a_special_cond_7_condition_vc_0_70600000() {
    // Encoding: 0x70600000
    // Test aarch32_RSB_r_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: cond=7, imm5=0, type1=0, Rm=0, S=0, Rn=0, Rd=0
    let encoding: u32 = 0x70600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_r_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_rsb_r_a1_a_special_cond_8_condition_hi_0_80600000() {
    // Encoding: 0x80600000
    // Test aarch32_RSB_r_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: cond=8, imm5=0, type1=0, Rn=0, Rd=0, S=0, Rm=0
    let encoding: u32 = 0x80600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_r_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_rsb_r_a1_a_special_cond_9_condition_ls_0_90600000() {
    // Encoding: 0x90600000
    // Test aarch32_RSB_r_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: Rd=0, Rm=0, cond=9, type1=0, imm5=0, Rn=0, S=0
    let encoding: u32 = 0x90600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_r_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_rsb_r_a1_a_special_cond_10_condition_ge_0_a0600000() {
    // Encoding: 0xA0600000
    // Test aarch32_RSB_r_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: imm5=0, Rd=0, cond=10, type1=0, Rm=0, Rn=0, S=0
    let encoding: u32 = 0xA0600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_r_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_rsb_r_a1_a_special_cond_11_condition_lt_0_b0600000() {
    // Encoding: 0xB0600000
    // Test aarch32_RSB_r_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: imm5=0, Rn=0, Rd=0, type1=0, S=0, Rm=0, cond=11
    let encoding: u32 = 0xB0600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_r_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_rsb_r_a1_a_special_cond_12_condition_gt_0_c0600000() {
    // Encoding: 0xC0600000
    // Test aarch32_RSB_r_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: type1=0, Rd=0, S=0, Rm=0, imm5=0, Rn=0, cond=12
    let encoding: u32 = 0xC0600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_r_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_rsb_r_a1_a_special_cond_13_condition_le_0_d0600000() {
    // Encoding: 0xD0600000
    // Test aarch32_RSB_r_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: Rd=0, cond=13, Rn=0, S=0, imm5=0, type1=0, Rm=0
    let encoding: u32 = 0xD0600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_r_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_rsb_r_a1_a_special_cond_14_condition_al_0_e0600000() {
    // Encoding: 0xE0600000
    // Test aarch32_RSB_r_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: cond=14, type1=0, Rd=0, Rn=0, imm5=0, S=0, Rm=0
    let encoding: u32 = 0xE0600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_r_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_rsb_r_a1_a_special_cond_15_condition_nv_0_f0600000() {
    // Encoding: 0xF0600000
    // Test aarch32_RSB_r_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: type1=0, Rm=0, S=0, cond=15, Rn=0, Rd=0, imm5=0
    let encoding: u32 = 0xF0600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_r_A1_A
/// ASL: `field S = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "S", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_rsb_r_a1_a_special_s_0_size_variant_0_0_00600000() {
    // Encoding: 0x00600000
    // Test aarch32_RSB_r_A1_A special value S = 0 (Size variant 0)
    // ISET: A32
    // Fields: imm5=0, Rn=0, type1=0, Rm=0, S=0, cond=0, Rd=0
    let encoding: u32 = 0x00600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_r_A1_A
/// ASL: `field S = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "S", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_rsb_r_a1_a_special_s_1_size_variant_1_0_00700000() {
    // Encoding: 0x00700000
    // Test aarch32_RSB_r_A1_A special value S = 1 (Size variant 1)
    // ISET: A32
    // Fields: Rd=0, S=1, Rn=0, imm5=0, type1=0, Rm=0, cond=0
    let encoding: u32 = 0x00700000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSB_r_T1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_rsb_r_t1_a_field_s_0_min_0_ebc00000() {
    // Thumb encoding (32): 0xEBC00000
    // Test aarch32_RSB_r_T1_A field S = 0 (Min)
    // ISET: T32
    // Fields: S=0, Rn=0, Rd=0, imm3=0, type1=0, Rm=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEBC00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_RSB_r_T1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_rsb_r_t1_a_field_s_1_max_0_ebd00000() {
    // Thumb encoding (32): 0xEBD00000
    // Test aarch32_RSB_r_T1_A field S = 1 (Max)
    // ISET: T32
    // Fields: Rm=0, Rn=0, S=1, imm2=0, imm3=0, Rd=0, type1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEBD00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_RSB_r_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_rsb_r_t1_a_field_rn_0_min_0_ebc00000() {
    // Thumb encoding (32): 0xEBC00000
    // Test aarch32_RSB_r_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: S=0, imm3=0, Rn=0, Rd=0, imm2=0, type1=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEBC00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_RSB_r_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_rsb_r_t1_a_field_rn_1_poweroftwo_0_ebc10000() {
    // Thumb encoding (32): 0xEBC10000
    // Test aarch32_RSB_r_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm2=0, Rn=1, type1=0, Rm=0, S=0, imm3=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEBC10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_RSB_r_T1_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_rsb_r_t1_a_field_imm3_0_zero_0_ebc00000() {
    // Thumb encoding (32): 0xEBC00000
    // Test aarch32_RSB_r_T1_A field imm3 = 0 (Zero)
    // ISET: T32
    // Fields: imm3=0, Rm=0, S=0, Rd=0, imm2=0, type1=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEBC00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_RSB_r_T1_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_rsb_r_t1_a_field_imm3_1_poweroftwo_0_ebc01000() {
    // Thumb encoding (32): 0xEBC01000
    // Test aarch32_RSB_r_T1_A field imm3 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, imm2=0, imm3=1, S=0, Rm=0, type1=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEBC01000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_RSB_r_T1_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 3, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (3)
#[test]
fn test_aarch32_rsb_r_t1_a_field_imm3_3_poweroftwominusone_0_ebc03000() {
    // Thumb encoding (32): 0xEBC03000
    // Test aarch32_RSB_r_T1_A field imm3 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm2=0, S=0, Rn=0, type1=0, imm3=3, Rm=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEBC03000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_RSB_r_T1_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 7, boundary: Max }
/// maximum immediate (7)
#[test]
fn test_aarch32_rsb_r_t1_a_field_imm3_7_max_0_ebc07000() {
    // Thumb encoding (32): 0xEBC07000
    // Test aarch32_RSB_r_T1_A field imm3 = 7 (Max)
    // ISET: T32
    // Fields: Rn=0, Rm=0, Rd=0, type1=0, S=0, imm3=7, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEBC07000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_RSB_r_T1_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_rsb_r_t1_a_field_rd_0_min_0_ebc00000() {
    // Thumb encoding (32): 0xEBC00000
    // Test aarch32_RSB_r_T1_A field Rd = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, imm2=0, type1=0, Rd=0, Rm=0, S=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEBC00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_RSB_r_T1_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_rsb_r_t1_a_field_rd_1_poweroftwo_0_ebc00100() {
    // Thumb encoding (32): 0xEBC00100
    // Test aarch32_RSB_r_T1_A field Rd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm2=0, type1=0, Rm=0, S=0, Rn=0, imm3=0, Rd=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEBC00100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_RSB_r_T1_A
/// ASL: `field imm2 6 +: 2`
/// Requirement: FieldBoundary { field: "imm2", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_rsb_r_t1_a_field_imm2_0_zero_0_ebc00000() {
    // Thumb encoding (32): 0xEBC00000
    // Test aarch32_RSB_r_T1_A field imm2 = 0 (Zero)
    // ISET: T32
    // Fields: S=0, type1=0, Rm=0, imm3=0, imm2=0, Rn=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEBC00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_RSB_r_T1_A
/// ASL: `field imm2 6 +: 2`
/// Requirement: FieldBoundary { field: "imm2", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_rsb_r_t1_a_field_imm2_1_poweroftwo_0_ebc00040() {
    // Thumb encoding (32): 0xEBC00040
    // Test aarch32_RSB_r_T1_A field imm2 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=0, Rn=0, Rd=0, imm3=0, S=0, imm2=1, type1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEBC00040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_RSB_r_T1_A
/// ASL: `field imm2 6 +: 2`
/// Requirement: FieldBoundary { field: "imm2", value: 3, boundary: Max }
/// maximum immediate (3)
#[test]
fn test_aarch32_rsb_r_t1_a_field_imm2_3_max_0_ebc000c0() {
    // Thumb encoding (32): 0xEBC000C0
    // Test aarch32_RSB_r_T1_A field imm2 = 3 (Max)
    // ISET: T32
    // Fields: S=0, Rd=0, type1=0, Rm=0, imm3=0, imm2=3, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEBC000C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_RSB_r_T1_A
/// ASL: `field type1 4 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_rsb_r_t1_a_field_type1_0_min_0_ebc00000() {
    // Thumb encoding (32): 0xEBC00000
    // Test aarch32_RSB_r_T1_A field type1 = 0 (Min)
    // ISET: T32
    // Fields: imm3=0, imm2=0, type1=0, Rm=0, Rn=0, Rd=0, S=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEBC00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_RSB_r_T1_A
/// ASL: `field type1 4 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_rsb_r_t1_a_field_type1_1_poweroftwo_0_ebc00010() {
    // Thumb encoding (32): 0xEBC00010
    // Test aarch32_RSB_r_T1_A field type1 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm3=0, type1=1, S=0, Rd=0, imm2=0, Rn=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEBC00010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_RSB_r_T1_A
/// ASL: `field type1 4 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_aarch32_rsb_r_t1_a_field_type1_3_max_0_ebc00030() {
    // Thumb encoding (32): 0xEBC00030
    // Test aarch32_RSB_r_T1_A field type1 = 3 (Max)
    // ISET: T32
    // Fields: imm3=0, Rn=0, S=0, imm2=0, Rm=0, Rd=0, type1=3
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEBC00030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_RSB_r_T1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_rsb_r_t1_a_field_rm_0_min_0_ebc00000() {
    // Thumb encoding (32): 0xEBC00000
    // Test aarch32_RSB_r_T1_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: imm2=0, S=0, type1=0, Rm=0, Rn=0, Rd=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEBC00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_RSB_r_T1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_rsb_r_t1_a_field_rm_1_poweroftwo_0_ebc00001() {
    // Thumb encoding (32): 0xEBC00001
    // Test aarch32_RSB_r_T1_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rd=0, imm2=0, type1=0, Rn=0, Rm=1, imm3=0, S=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEBC00001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_RSB_r_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// S=0 (8-bit / byte size)
#[test]
fn test_aarch32_rsb_r_t1_a_combo_0_0_ebc00000() {
    // Thumb encoding (32): 0xEBC00000
    // Test aarch32_RSB_r_T1_A field combination: S=0, Rn=0, imm3=0, Rd=0, imm2=0, type1=0, Rm=0
    // ISET: T32
    // Fields: S=0, imm2=0, type1=0, Rm=0, Rn=0, imm3=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEBC00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_RSB_r_T1_A
/// ASL: `field S = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "S", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_rsb_r_t1_a_special_s_0_size_variant_0_0_ebc00000() {
    // Thumb encoding (32): 0xEBC00000
    // Test aarch32_RSB_r_T1_A special value S = 0 (Size variant 0)
    // ISET: T32
    // Fields: Rd=0, Rm=0, imm2=0, type1=0, imm3=0, S=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEBC00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_RSB_r_T1_A
/// ASL: `field S = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "S", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_rsb_r_t1_a_special_s_1_size_variant_1_0_ebd00000() {
    // Thumb encoding (32): 0xEBD00000
    // Test aarch32_RSB_r_T1_A special value S = 1 (Size variant 1)
    // ISET: T32
    // Fields: imm2=0, S=1, type1=0, Rm=0, Rn=0, imm3=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEBD00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_RSB_r_T1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_rsb_r_t1_a_invalid_0_0_ebc00000() {
    // Thumb encoding (32): 0xEBC00000
    // Test aarch32_RSB_r_T1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }
    // ISET: T32
    // Fields: Rn=0, type1=0, imm3=0, S=0, Rm=0, Rd=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEBC00000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_RSB_r_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_rsb_r_t1_a_invalid_1_0_ebc00000() {
    // Thumb encoding (32): 0xEBC00000
    // Test aarch32_RSB_r_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: imm3=0, Rn=0, Rd=0, S=0, type1=0, imm2=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEBC00000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_RSB_r_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_aarch32_rsb_r_a1_a_flags_zeroresult_0_00710002() {
    // Test aarch32_RSB_r_A1_A flag computation: ZeroResult
    // Encoding: 0x00710002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x00710002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_RSB_r_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_aarch32_rsb_r_a1_a_flags_zeroresult_1_00710002() {
    // Test aarch32_RSB_r_A1_A flag computation: ZeroResult
    // Encoding: 0x00710002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x00710002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_RSB_r_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_aarch32_rsb_r_a1_a_flags_negativeresult_2_00710002() {
    // Test aarch32_RSB_r_A1_A flag computation: NegativeResult
    // Encoding: 0x00710002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x00710002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_RSB_r_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_aarch32_rsb_r_a1_a_flags_unsignedoverflow_3_00710002() {
    // Test aarch32_RSB_r_A1_A flag computation: UnsignedOverflow
    // Encoding: 0x00710002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x00710002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_RSB_r_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_aarch32_rsb_r_a1_a_flags_unsignedoverflow_4_00710002() {
    // Test aarch32_RSB_r_A1_A flag computation: UnsignedOverflow
    // Encoding: 0x00710002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x00710002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_RSB_r_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_aarch32_rsb_r_a1_a_flags_signedoverflow_5_00710002() {
    // Test aarch32_RSB_r_A1_A flag computation: SignedOverflow
    // Encoding: 0x00710002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x00710002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_RSB_r_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_aarch32_rsb_r_a1_a_flags_signedoverflow_6_00710002() {
    // Test aarch32_RSB_r_A1_A flag computation: SignedOverflow
    // Encoding: 0x00710002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x00710002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_RSB_r_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_aarch32_rsb_r_a1_a_flags_positiveresult_7_00710002() {
    // Test aarch32_RSB_r_A1_A flag computation: PositiveResult
    // Encoding: 0x00710002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x32);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x00710002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_RSB_r_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_aarch32_rsb_r_t1_a_flags_zeroresult_0_ebd10002() {
    // Test aarch32_RSB_r_T1_A flag computation: ZeroResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xEBD10002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_RSB_r_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_aarch32_rsb_r_t1_a_flags_zeroresult_1_ebd10002() {
    // Test aarch32_RSB_r_T1_A flag computation: ZeroResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0xEBD10002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_RSB_r_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_aarch32_rsb_r_t1_a_flags_negativeresult_2_ebd10002() {
    // Test aarch32_RSB_r_T1_A flag computation: NegativeResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xEBD10002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_RSB_r_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_aarch32_rsb_r_t1_a_flags_unsignedoverflow_3_ebd10002() {
    // Test aarch32_RSB_r_T1_A flag computation: UnsignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0xEBD10002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_RSB_r_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_aarch32_rsb_r_t1_a_flags_unsignedoverflow_4_ebd10002() {
    // Test aarch32_RSB_r_T1_A flag computation: UnsignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xEBD10002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_RSB_r_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_aarch32_rsb_r_t1_a_flags_signedoverflow_5_ebd10002() {
    // Test aarch32_RSB_r_T1_A flag computation: SignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0xEBD10002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_RSB_r_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_aarch32_rsb_r_t1_a_flags_signedoverflow_6_ebd10002() {
    // Test aarch32_RSB_r_T1_A flag computation: SignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0xEBD10002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_RSB_r_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_aarch32_rsb_r_t1_a_flags_positiveresult_7_ebd10002() {
    // Test aarch32_RSB_r_T1_A flag computation: PositiveResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x32);
    let encoding: u32 = 0xEBD10002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

// ============================================================================
// aarch32_SUB_SP_i_A Tests
// ============================================================================

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_sub_sp_i_a1_a_field_cond_0_min_0_024d0000() {
    // Encoding: 0x024D0000
    // Test aarch32_SUB_SP_i_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: imm12=0, cond=0, Rd=0, S=0
    let encoding: u32 = 0x024D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_sub_sp_i_a1_a_field_cond_1_poweroftwo_0_124d0000() {
    // Encoding: 0x124D0000
    // Test aarch32_SUB_SP_i_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=1, Rd=0, S=0, imm12=0
    let encoding: u32 = 0x124D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_sub_sp_i_a1_a_field_cond_2_poweroftwo_0_224d0000() {
    // Encoding: 0x224D0000
    // Test aarch32_SUB_SP_i_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=0, S=0, cond=2, Rd=0
    let encoding: u32 = 0x224D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_sub_sp_i_a1_a_field_cond_3_poweroftwo_0_324d0000() {
    // Encoding: 0x324D0000
    // Test aarch32_SUB_SP_i_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=0, S=0, cond=3, Rd=0
    let encoding: u32 = 0x324D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_sub_sp_i_a1_a_field_cond_4_poweroftwo_0_424d0000() {
    // Encoding: 0x424D0000
    // Test aarch32_SUB_SP_i_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=0, Rd=0, S=0, cond=4
    let encoding: u32 = 0x424D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_sub_sp_i_a1_a_field_cond_5_poweroftwo_0_524d0000() {
    // Encoding: 0x524D0000
    // Test aarch32_SUB_SP_i_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, Rd=0, cond=5, imm12=0
    let encoding: u32 = 0x524D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_sub_sp_i_a1_a_field_cond_6_poweroftwo_0_624d0000() {
    // Encoding: 0x624D0000
    // Test aarch32_SUB_SP_i_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, cond=6, imm12=0, S=0
    let encoding: u32 = 0x624D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_sub_sp_i_a1_a_field_cond_7_poweroftwo_0_724d0000() {
    // Encoding: 0x724D0000
    // Test aarch32_SUB_SP_i_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, cond=7, Rd=0, imm12=0
    let encoding: u32 = 0x724D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_sub_sp_i_a1_a_field_cond_8_poweroftwo_0_824d0000() {
    // Encoding: 0x824D0000
    // Test aarch32_SUB_SP_i_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=0, S=0, Rd=0, cond=8
    let encoding: u32 = 0x824D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_sub_sp_i_a1_a_field_cond_9_poweroftwo_0_924d0000() {
    // Encoding: 0x924D0000
    // Test aarch32_SUB_SP_i_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, cond=9, imm12=0, Rd=0
    let encoding: u32 = 0x924D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_sub_sp_i_a1_a_field_cond_10_poweroftwo_0_a24d0000() {
    // Encoding: 0xA24D0000
    // Test aarch32_SUB_SP_i_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=10, Rd=0, S=0, imm12=0
    let encoding: u32 = 0xA24D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_sub_sp_i_a1_a_field_cond_11_poweroftwo_0_b24d0000() {
    // Encoding: 0xB24D0000
    // Test aarch32_SUB_SP_i_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=11, Rd=0, S=0, imm12=0
    let encoding: u32 = 0xB24D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_sub_sp_i_a1_a_field_cond_12_poweroftwo_0_c24d0000() {
    // Encoding: 0xC24D0000
    // Test aarch32_SUB_SP_i_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=0, cond=12, S=0, Rd=0
    let encoding: u32 = 0xC24D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_sub_sp_i_a1_a_field_cond_13_poweroftwo_0_d24d0000() {
    // Encoding: 0xD24D0000
    // Test aarch32_SUB_SP_i_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, Rd=0, imm12=0, cond=13
    let encoding: u32 = 0xD24D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_sub_sp_i_a1_a_field_cond_14_poweroftwo_0_e24d0000() {
    // Encoding: 0xE24D0000
    // Test aarch32_SUB_SP_i_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, imm12=0, Rd=0, cond=14
    let encoding: u32 = 0xE24D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_sub_sp_i_a1_a_field_cond_15_max_0_f24d0000() {
    // Encoding: 0xF24D0000
    // Test aarch32_SUB_SP_i_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: Rd=0, S=0, imm12=0, cond=15
    let encoding: u32 = 0xF24D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_sub_sp_i_a1_a_field_s_0_min_0_024d0000() {
    // Encoding: 0x024D0000
    // Test aarch32_SUB_SP_i_A1_A field S = 0 (Min)
    // ISET: A32
    // Fields: imm12=0, S=0, cond=0, Rd=0
    let encoding: u32 = 0x024D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_sub_sp_i_a1_a_field_s_1_max_0_025d0000() {
    // Encoding: 0x025D0000
    // Test aarch32_SUB_SP_i_A1_A field S = 1 (Max)
    // ISET: A32
    // Fields: cond=0, Rd=0, imm12=0, S=1
    let encoding: u32 = 0x025D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_sub_sp_i_a1_a_field_rd_0_min_0_024d0000() {
    // Encoding: 0x024D0000
    // Test aarch32_SUB_SP_i_A1_A field Rd = 0 (Min)
    // ISET: A32
    // Fields: S=0, Rd=0, imm12=0, cond=0
    let encoding: u32 = 0x024D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_sub_sp_i_a1_a_field_rd_1_poweroftwo_0_024d1000() {
    // Encoding: 0x024D1000
    // Test aarch32_SUB_SP_i_A1_A field Rd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, S=0, imm12=0, Rd=1
    let encoding: u32 = 0x024D1000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_sub_sp_i_a1_a_field_imm12_0_zero_0_024d0000() {
    // Encoding: 0x024D0000
    // Test aarch32_SUB_SP_i_A1_A field imm12 = 0 (Zero)
    // ISET: A32
    // Fields: S=0, Rd=0, cond=0, imm12=0
    let encoding: u32 = 0x024D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_sub_sp_i_a1_a_field_imm12_1_poweroftwo_0_024d0001() {
    // Encoding: 0x024D0001
    // Test aarch32_SUB_SP_i_A1_A field imm12 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, Rd=0, imm12=1, cond=0
    let encoding: u32 = 0x024D0001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_sub_sp_i_a1_a_field_imm12_3_poweroftwominusone_0_024d0003() {
    // Encoding: 0x024D0003
    // Test aarch32_SUB_SP_i_A1_A field imm12 = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rd=0, imm12=3, cond=0, S=0
    let encoding: u32 = 0x024D0003;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_sub_sp_i_a1_a_field_imm12_4_poweroftwo_0_024d0004() {
    // Encoding: 0x024D0004
    // Test aarch32_SUB_SP_i_A1_A field imm12 = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, Rd=0, cond=0, imm12=4
    let encoding: u32 = 0x024D0004;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_sub_sp_i_a1_a_field_imm12_7_poweroftwominusone_0_024d0007() {
    // Encoding: 0x024D0007
    // Test aarch32_SUB_SP_i_A1_A field imm12 = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm12=7, cond=0, S=0, Rd=0
    let encoding: u32 = 0x024D0007;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_sub_sp_i_a1_a_field_imm12_8_poweroftwo_0_024d0008() {
    // Encoding: 0x024D0008
    // Test aarch32_SUB_SP_i_A1_A field imm12 = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, Rd=0, cond=0, imm12=8
    let encoding: u32 = 0x024D0008;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_sub_sp_i_a1_a_field_imm12_15_poweroftwominusone_0_024d000f() {
    // Encoding: 0x024D000F
    // Test aarch32_SUB_SP_i_A1_A field imm12 = 15 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, imm12=15, Rd=0, S=0
    let encoding: u32 = 0x024D000F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_sub_sp_i_a1_a_field_imm12_16_poweroftwo_0_024d0010() {
    // Encoding: 0x024D0010
    // Test aarch32_SUB_SP_i_A1_A field imm12 = 16 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, Rd=0, cond=0, imm12=16
    let encoding: u32 = 0x024D0010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_sub_sp_i_a1_a_field_imm12_31_poweroftwominusone_0_024d001f() {
    // Encoding: 0x024D001F
    // Test aarch32_SUB_SP_i_A1_A field imm12 = 31 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm12=31, Rd=0, cond=0, S=0
    let encoding: u32 = 0x024D001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_sub_sp_i_a1_a_field_imm12_32_poweroftwo_0_024d0020() {
    // Encoding: 0x024D0020
    // Test aarch32_SUB_SP_i_A1_A field imm12 = 32 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, cond=0, Rd=0, imm12=32
    let encoding: u32 = 0x024D0020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_sub_sp_i_a1_a_field_imm12_63_poweroftwominusone_0_024d003f() {
    // Encoding: 0x024D003F
    // Test aarch32_SUB_SP_i_A1_A field imm12 = 63 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: S=0, cond=0, Rd=0, imm12=63
    let encoding: u32 = 0x024D003F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_sub_sp_i_a1_a_field_imm12_64_poweroftwo_0_024d0040() {
    // Encoding: 0x024D0040
    // Test aarch32_SUB_SP_i_A1_A field imm12 = 64 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=64, cond=0, S=0, Rd=0
    let encoding: u32 = 0x024D0040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 127, boundary: PowerOfTwoMinusOne }
/// 2^7 - 1 = 127
#[test]
fn test_aarch32_sub_sp_i_a1_a_field_imm12_127_poweroftwominusone_0_024d007f() {
    // Encoding: 0x024D007F
    // Test aarch32_SUB_SP_i_A1_A field imm12 = 127 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, S=0, imm12=127, Rd=0
    let encoding: u32 = 0x024D007F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_sub_sp_i_a1_a_field_imm12_128_poweroftwo_0_024d0080() {
    // Encoding: 0x024D0080
    // Test aarch32_SUB_SP_i_A1_A field imm12 = 128 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, S=0, Rd=0, imm12=128
    let encoding: u32 = 0x024D0080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 255, boundary: PowerOfTwoMinusOne }
/// 2^8 - 1 = 255
#[test]
fn test_aarch32_sub_sp_i_a1_a_field_imm12_255_poweroftwominusone_0_024d00ff() {
    // Encoding: 0x024D00FF
    // Test aarch32_SUB_SP_i_A1_A field imm12 = 255 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, Rd=0, imm12=255, S=0
    let encoding: u32 = 0x024D00FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 256, boundary: PowerOfTwo }
/// power of 2 (2^8 = 256)
#[test]
fn test_aarch32_sub_sp_i_a1_a_field_imm12_256_poweroftwo_0_024d0100() {
    // Encoding: 0x024D0100
    // Test aarch32_SUB_SP_i_A1_A field imm12 = 256 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=256, cond=0, S=0, Rd=0
    let encoding: u32 = 0x024D0100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 511, boundary: PowerOfTwoMinusOne }
/// 2^9 - 1 = 511
#[test]
fn test_aarch32_sub_sp_i_a1_a_field_imm12_511_poweroftwominusone_0_024d01ff() {
    // Encoding: 0x024D01FF
    // Test aarch32_SUB_SP_i_A1_A field imm12 = 511 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm12=511, Rd=0, cond=0, S=0
    let encoding: u32 = 0x024D01FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 512, boundary: PowerOfTwo }
/// power of 2 (2^9 = 512)
#[test]
fn test_aarch32_sub_sp_i_a1_a_field_imm12_512_poweroftwo_0_024d0200() {
    // Encoding: 0x024D0200
    // Test aarch32_SUB_SP_i_A1_A field imm12 = 512 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=512, cond=0, S=0, Rd=0
    let encoding: u32 = 0x024D0200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1023, boundary: PowerOfTwoMinusOne }
/// 2^10 - 1 = 1023
#[test]
fn test_aarch32_sub_sp_i_a1_a_field_imm12_1023_poweroftwominusone_0_024d03ff() {
    // Encoding: 0x024D03FF
    // Test aarch32_SUB_SP_i_A1_A field imm12 = 1023 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, S=0, Rd=0, imm12=1023
    let encoding: u32 = 0x024D03FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1024, boundary: PowerOfTwo }
/// power of 2 (2^10 = 1024)
#[test]
fn test_aarch32_sub_sp_i_a1_a_field_imm12_1024_poweroftwo_0_024d0400() {
    // Encoding: 0x024D0400
    // Test aarch32_SUB_SP_i_A1_A field imm12 = 1024 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, cond=0, Rd=0, imm12=1024
    let encoding: u32 = 0x024D0400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2047, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (2047)
#[test]
fn test_aarch32_sub_sp_i_a1_a_field_imm12_2047_poweroftwominusone_0_024d07ff() {
    // Encoding: 0x024D07FF
    // Test aarch32_SUB_SP_i_A1_A field imm12 = 2047 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rd=0, S=0, cond=0, imm12=2047
    let encoding: u32 = 0x024D07FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2048, boundary: PowerOfTwo }
/// power of 2 (2^11 = 2048)
#[test]
fn test_aarch32_sub_sp_i_a1_a_field_imm12_2048_poweroftwo_0_024d0800() {
    // Encoding: 0x024D0800
    // Test aarch32_SUB_SP_i_A1_A field imm12 = 2048 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, S=0, imm12=2048, Rd=0
    let encoding: u32 = 0x024D0800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4095, boundary: Max }
/// maximum immediate (4095)
#[test]
fn test_aarch32_sub_sp_i_a1_a_field_imm12_4095_max_0_024d0fff() {
    // Encoding: 0x024D0FFF
    // Test aarch32_SUB_SP_i_A1_A field imm12 = 4095 (Max)
    // ISET: A32
    // Fields: cond=0, imm12=4095, S=0, Rd=0
    let encoding: u32 = 0x024D0FFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_sub_sp_i_a1_a_combo_0_0_024d0000() {
    // Encoding: 0x024D0000
    // Test aarch32_SUB_SP_i_A1_A field combination: cond=0, S=0, Rd=0, imm12=0
    // ISET: A32
    // Fields: Rd=0, S=0, cond=0, imm12=0
    let encoding: u32 = 0x024D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_sub_sp_i_a1_a_special_cond_0_condition_eq_0_024d0000() {
    // Encoding: 0x024D0000
    // Test aarch32_SUB_SP_i_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: cond=0, Rd=0, imm12=0, S=0
    let encoding: u32 = 0x024D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_sub_sp_i_a1_a_special_cond_1_condition_ne_0_124d0000() {
    // Encoding: 0x124D0000
    // Test aarch32_SUB_SP_i_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: imm12=0, Rd=0, cond=1, S=0
    let encoding: u32 = 0x124D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_sub_sp_i_a1_a_special_cond_2_condition_cs_hs_0_224d0000() {
    // Encoding: 0x224D0000
    // Test aarch32_SUB_SP_i_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: cond=2, imm12=0, Rd=0, S=0
    let encoding: u32 = 0x224D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_sub_sp_i_a1_a_special_cond_3_condition_cc_lo_0_324d0000() {
    // Encoding: 0x324D0000
    // Test aarch32_SUB_SP_i_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: cond=3, S=0, imm12=0, Rd=0
    let encoding: u32 = 0x324D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_sub_sp_i_a1_a_special_cond_4_condition_mi_0_424d0000() {
    // Encoding: 0x424D0000
    // Test aarch32_SUB_SP_i_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: S=0, Rd=0, cond=4, imm12=0
    let encoding: u32 = 0x424D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_sub_sp_i_a1_a_special_cond_5_condition_pl_0_524d0000() {
    // Encoding: 0x524D0000
    // Test aarch32_SUB_SP_i_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: imm12=0, cond=5, Rd=0, S=0
    let encoding: u32 = 0x524D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_sub_sp_i_a1_a_special_cond_6_condition_vs_0_624d0000() {
    // Encoding: 0x624D0000
    // Test aarch32_SUB_SP_i_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: imm12=0, cond=6, Rd=0, S=0
    let encoding: u32 = 0x624D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_sub_sp_i_a1_a_special_cond_7_condition_vc_0_724d0000() {
    // Encoding: 0x724D0000
    // Test aarch32_SUB_SP_i_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: Rd=0, S=0, cond=7, imm12=0
    let encoding: u32 = 0x724D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_sub_sp_i_a1_a_special_cond_8_condition_hi_0_824d0000() {
    // Encoding: 0x824D0000
    // Test aarch32_SUB_SP_i_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: cond=8, S=0, Rd=0, imm12=0
    let encoding: u32 = 0x824D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_sub_sp_i_a1_a_special_cond_9_condition_ls_0_924d0000() {
    // Encoding: 0x924D0000
    // Test aarch32_SUB_SP_i_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: Rd=0, S=0, cond=9, imm12=0
    let encoding: u32 = 0x924D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_sub_sp_i_a1_a_special_cond_10_condition_ge_0_a24d0000() {
    // Encoding: 0xA24D0000
    // Test aarch32_SUB_SP_i_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: S=0, Rd=0, cond=10, imm12=0
    let encoding: u32 = 0xA24D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_sub_sp_i_a1_a_special_cond_11_condition_lt_0_b24d0000() {
    // Encoding: 0xB24D0000
    // Test aarch32_SUB_SP_i_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: S=0, Rd=0, imm12=0, cond=11
    let encoding: u32 = 0xB24D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_sub_sp_i_a1_a_special_cond_12_condition_gt_0_c24d0000() {
    // Encoding: 0xC24D0000
    // Test aarch32_SUB_SP_i_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: S=0, cond=12, Rd=0, imm12=0
    let encoding: u32 = 0xC24D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_sub_sp_i_a1_a_special_cond_13_condition_le_0_d24d0000() {
    // Encoding: 0xD24D0000
    // Test aarch32_SUB_SP_i_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: S=0, imm12=0, cond=13, Rd=0
    let encoding: u32 = 0xD24D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_sub_sp_i_a1_a_special_cond_14_condition_al_0_e24d0000() {
    // Encoding: 0xE24D0000
    // Test aarch32_SUB_SP_i_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: Rd=0, cond=14, S=0, imm12=0
    let encoding: u32 = 0xE24D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_sub_sp_i_a1_a_special_cond_15_condition_nv_0_f24d0000() {
    // Encoding: 0xF24D0000
    // Test aarch32_SUB_SP_i_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: cond=15, Rd=0, imm12=0, S=0
    let encoding: u32 = 0xF24D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `field S = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "S", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_sub_sp_i_a1_a_special_s_0_size_variant_0_0_024d0000() {
    // Encoding: 0x024D0000
    // Test aarch32_SUB_SP_i_A1_A special value S = 0 (Size variant 0)
    // ISET: A32
    // Fields: Rd=0, cond=0, imm12=0, S=0
    let encoding: u32 = 0x024D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `field S = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "S", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_sub_sp_i_a1_a_special_s_1_size_variant_1_0_025d0000() {
    // Encoding: 0x025D0000
    // Test aarch32_SUB_SP_i_A1_A special value S = 1 (Size variant 1)
    // ISET: A32
    // Fields: cond=0, imm12=0, S=1, Rd=0
    let encoding: u32 = 0x025D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_SP_i_T1_A
/// ASL: `field imm7 16 +: 7`
/// Requirement: FieldBoundary { field: "imm7", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_sub_sp_i_t1_a_field_imm7_0_zero_0_b0800000() {
    // Thumb encoding (32): 0xB0800000
    // Test aarch32_SUB_SP_i_T1_A field imm7 = 0 (Zero)
    // ISET: T32
    // Fields: imm7=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xB0800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_SP_i_T1_A
/// ASL: `field imm7 16 +: 7`
/// Requirement: FieldBoundary { field: "imm7", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_sub_sp_i_t1_a_field_imm7_1_poweroftwo_0_b0810000() {
    // Thumb encoding (32): 0xB0810000
    // Test aarch32_SUB_SP_i_T1_A field imm7 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm7=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xB0810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_SP_i_T1_A
/// ASL: `field imm7 16 +: 7`
/// Requirement: FieldBoundary { field: "imm7", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_sub_sp_i_t1_a_field_imm7_3_poweroftwominusone_0_b0830000() {
    // Thumb encoding (32): 0xB0830000
    // Test aarch32_SUB_SP_i_T1_A field imm7 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm7=3
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xB0830000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_SP_i_T1_A
/// ASL: `field imm7 16 +: 7`
/// Requirement: FieldBoundary { field: "imm7", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_sub_sp_i_t1_a_field_imm7_4_poweroftwo_0_b0840000() {
    // Thumb encoding (32): 0xB0840000
    // Test aarch32_SUB_SP_i_T1_A field imm7 = 4 (PowerOfTwo)
    // ISET: T32
    // Fields: imm7=4
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xB0840000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_SP_i_T1_A
/// ASL: `field imm7 16 +: 7`
/// Requirement: FieldBoundary { field: "imm7", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_sub_sp_i_t1_a_field_imm7_7_poweroftwominusone_0_b0870000() {
    // Thumb encoding (32): 0xB0870000
    // Test aarch32_SUB_SP_i_T1_A field imm7 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm7=7
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xB0870000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_SP_i_T1_A
/// ASL: `field imm7 16 +: 7`
/// Requirement: FieldBoundary { field: "imm7", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_sub_sp_i_t1_a_field_imm7_8_poweroftwo_0_b0880000() {
    // Thumb encoding (32): 0xB0880000
    // Test aarch32_SUB_SP_i_T1_A field imm7 = 8 (PowerOfTwo)
    // ISET: T32
    // Fields: imm7=8
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xB0880000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_SP_i_T1_A
/// ASL: `field imm7 16 +: 7`
/// Requirement: FieldBoundary { field: "imm7", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_sub_sp_i_t1_a_field_imm7_15_poweroftwominusone_0_b08f0000() {
    // Thumb encoding (32): 0xB08F0000
    // Test aarch32_SUB_SP_i_T1_A field imm7 = 15 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm7=15
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xB08F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_SP_i_T1_A
/// ASL: `field imm7 16 +: 7`
/// Requirement: FieldBoundary { field: "imm7", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_sub_sp_i_t1_a_field_imm7_16_poweroftwo_0_b0900000() {
    // Thumb encoding (32): 0xB0900000
    // Test aarch32_SUB_SP_i_T1_A field imm7 = 16 (PowerOfTwo)
    // ISET: T32
    // Fields: imm7=16
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xB0900000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_SP_i_T1_A
/// ASL: `field imm7 16 +: 7`
/// Requirement: FieldBoundary { field: "imm7", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_sub_sp_i_t1_a_field_imm7_31_poweroftwominusone_0_b09f0000() {
    // Thumb encoding (32): 0xB09F0000
    // Test aarch32_SUB_SP_i_T1_A field imm7 = 31 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm7=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xB09F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_SP_i_T1_A
/// ASL: `field imm7 16 +: 7`
/// Requirement: FieldBoundary { field: "imm7", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_sub_sp_i_t1_a_field_imm7_32_poweroftwo_0_b0a00000() {
    // Thumb encoding (32): 0xB0A00000
    // Test aarch32_SUB_SP_i_T1_A field imm7 = 32 (PowerOfTwo)
    // ISET: T32
    // Fields: imm7=32
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xB0A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_SP_i_T1_A
/// ASL: `field imm7 16 +: 7`
/// Requirement: FieldBoundary { field: "imm7", value: 63, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (63)
#[test]
fn test_aarch32_sub_sp_i_t1_a_field_imm7_63_poweroftwominusone_0_b0bf0000() {
    // Thumb encoding (32): 0xB0BF0000
    // Test aarch32_SUB_SP_i_T1_A field imm7 = 63 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm7=63
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xB0BF0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_SP_i_T1_A
/// ASL: `field imm7 16 +: 7`
/// Requirement: FieldBoundary { field: "imm7", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_sub_sp_i_t1_a_field_imm7_64_poweroftwo_0_b0c00000() {
    // Thumb encoding (32): 0xB0C00000
    // Test aarch32_SUB_SP_i_T1_A field imm7 = 64 (PowerOfTwo)
    // ISET: T32
    // Fields: imm7=64
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xB0C00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_SP_i_T1_A
/// ASL: `field imm7 16 +: 7`
/// Requirement: FieldBoundary { field: "imm7", value: 127, boundary: Max }
/// maximum immediate (127)
#[test]
fn test_aarch32_sub_sp_i_t1_a_field_imm7_127_max_0_b0ff0000() {
    // Thumb encoding (32): 0xB0FF0000
    // Test aarch32_SUB_SP_i_T1_A field imm7 = 127 (Max)
    // ISET: T32
    // Fields: imm7=127
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xB0FF0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_SP_i_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm7=0 (immediate value 0)
#[test]
fn test_aarch32_sub_sp_i_t1_a_combo_0_0_b0800000() {
    // Thumb encoding (32): 0xB0800000
    // Test aarch32_SUB_SP_i_T1_A field combination: imm7=0
    // ISET: T32
    // Fields: imm7=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xB0800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `field i 26 +: 1`
/// Requirement: FieldBoundary { field: "i", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_sub_sp_i_t2_a_field_i_0_min_0_f1ad0000() {
    // Thumb encoding (32): 0xF1AD0000
    // Test aarch32_SUB_SP_i_T2_A field i = 0 (Min)
    // ISET: T32
    // Fields: i=0, S=0, imm3=0, Rd=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1AD0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `field i 26 +: 1`
/// Requirement: FieldBoundary { field: "i", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_sub_sp_i_t2_a_field_i_1_max_0_f5ad0000() {
    // Thumb encoding (32): 0xF5AD0000
    // Test aarch32_SUB_SP_i_T2_A field i = 1 (Max)
    // ISET: T32
    // Fields: Rd=0, i=1, imm3=0, imm8=0, S=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF5AD0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_sub_sp_i_t2_a_field_s_0_min_0_f1ad0000() {
    // Thumb encoding (32): 0xF1AD0000
    // Test aarch32_SUB_SP_i_T2_A field S = 0 (Min)
    // ISET: T32
    // Fields: imm8=0, i=0, imm3=0, S=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1AD0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_sub_sp_i_t2_a_field_s_1_max_0_f1bd0000() {
    // Thumb encoding (32): 0xF1BD0000
    // Test aarch32_SUB_SP_i_T2_A field S = 1 (Max)
    // ISET: T32
    // Fields: Rd=0, S=1, i=0, imm3=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1BD0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_sub_sp_i_t2_a_field_imm3_0_zero_0_f1ad0000() {
    // Thumb encoding (32): 0xF1AD0000
    // Test aarch32_SUB_SP_i_T2_A field imm3 = 0 (Zero)
    // ISET: T32
    // Fields: imm8=0, Rd=0, i=0, S=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1AD0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_sub_sp_i_t2_a_field_imm3_1_poweroftwo_0_f1ad1000() {
    // Thumb encoding (32): 0xF1AD1000
    // Test aarch32_SUB_SP_i_T2_A field imm3 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm3=1, S=0, Rd=0, imm8=0, i=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1AD1000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 3, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (3)
#[test]
fn test_aarch32_sub_sp_i_t2_a_field_imm3_3_poweroftwominusone_0_f1ad3000() {
    // Thumb encoding (32): 0xF1AD3000
    // Test aarch32_SUB_SP_i_T2_A field imm3 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm8=0, imm3=3, i=0, Rd=0, S=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1AD3000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 7, boundary: Max }
/// maximum immediate (7)
#[test]
fn test_aarch32_sub_sp_i_t2_a_field_imm3_7_max_0_f1ad7000() {
    // Thumb encoding (32): 0xF1AD7000
    // Test aarch32_SUB_SP_i_T2_A field imm3 = 7 (Max)
    // ISET: T32
    // Fields: i=0, imm3=7, imm8=0, S=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1AD7000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_sub_sp_i_t2_a_field_rd_0_min_0_f1ad0000() {
    // Thumb encoding (32): 0xF1AD0000
    // Test aarch32_SUB_SP_i_T2_A field Rd = 0 (Min)
    // ISET: T32
    // Fields: S=0, imm8=0, i=0, imm3=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1AD0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_sub_sp_i_t2_a_field_rd_1_poweroftwo_0_f1ad0100() {
    // Thumb encoding (32): 0xF1AD0100
    // Test aarch32_SUB_SP_i_T2_A field Rd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: S=0, imm3=0, Rd=1, i=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1AD0100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_sub_sp_i_t2_a_field_imm8_0_zero_0_f1ad0000() {
    // Thumb encoding (32): 0xF1AD0000
    // Test aarch32_SUB_SP_i_T2_A field imm8 = 0 (Zero)
    // ISET: T32
    // Fields: S=0, imm8=0, imm3=0, Rd=0, i=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1AD0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_sub_sp_i_t2_a_field_imm8_1_poweroftwo_0_f1ad0001() {
    // Thumb encoding (32): 0xF1AD0001
    // Test aarch32_SUB_SP_i_T2_A field imm8 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: S=0, i=0, imm3=0, Rd=0, imm8=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1AD0001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_sub_sp_i_t2_a_field_imm8_3_poweroftwominusone_0_f1ad0003() {
    // Thumb encoding (32): 0xF1AD0003
    // Test aarch32_SUB_SP_i_T2_A field imm8 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: i=0, S=0, Rd=0, imm3=0, imm8=3
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1AD0003;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_sub_sp_i_t2_a_field_imm8_4_poweroftwo_0_f1ad0004() {
    // Thumb encoding (32): 0xF1AD0004
    // Test aarch32_SUB_SP_i_T2_A field imm8 = 4 (PowerOfTwo)
    // ISET: T32
    // Fields: i=0, imm8=4, S=0, imm3=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1AD0004;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_sub_sp_i_t2_a_field_imm8_7_poweroftwominusone_0_f1ad0007() {
    // Thumb encoding (32): 0xF1AD0007
    // Test aarch32_SUB_SP_i_T2_A field imm8 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm3=0, S=0, Rd=0, i=0, imm8=7
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1AD0007;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_sub_sp_i_t2_a_field_imm8_8_poweroftwo_0_f1ad0008() {
    // Thumb encoding (32): 0xF1AD0008
    // Test aarch32_SUB_SP_i_T2_A field imm8 = 8 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=8, i=0, Rd=0, S=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1AD0008;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_sub_sp_i_t2_a_field_imm8_15_poweroftwominusone_0_f1ad000f() {
    // Thumb encoding (32): 0xF1AD000F
    // Test aarch32_SUB_SP_i_T2_A field imm8 = 15 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm8=15, imm3=0, i=0, Rd=0, S=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1AD000F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_sub_sp_i_t2_a_field_imm8_16_poweroftwo_0_f1ad0010() {
    // Thumb encoding (32): 0xF1AD0010
    // Test aarch32_SUB_SP_i_T2_A field imm8 = 16 (PowerOfTwo)
    // ISET: T32
    // Fields: i=0, imm3=0, imm8=16, S=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1AD0010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_sub_sp_i_t2_a_field_imm8_31_poweroftwominusone_0_f1ad001f() {
    // Thumb encoding (32): 0xF1AD001F
    // Test aarch32_SUB_SP_i_T2_A field imm8 = 31 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: i=0, Rd=0, imm8=31, S=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1AD001F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_sub_sp_i_t2_a_field_imm8_32_poweroftwo_0_f1ad0020() {
    // Thumb encoding (32): 0xF1AD0020
    // Test aarch32_SUB_SP_i_T2_A field imm8 = 32 (PowerOfTwo)
    // ISET: T32
    // Fields: S=0, imm8=32, i=0, imm3=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1AD0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_sub_sp_i_t2_a_field_imm8_63_poweroftwominusone_0_f1ad003f() {
    // Thumb encoding (32): 0xF1AD003F
    // Test aarch32_SUB_SP_i_T2_A field imm8 = 63 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: S=0, i=0, Rd=0, imm3=0, imm8=63
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1AD003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_sub_sp_i_t2_a_field_imm8_64_poweroftwo_0_f1ad0040() {
    // Thumb encoding (32): 0xF1AD0040
    // Test aarch32_SUB_SP_i_T2_A field imm8 = 64 (PowerOfTwo)
    // ISET: T32
    // Fields: Rd=0, i=0, imm3=0, S=0, imm8=64
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1AD0040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 127, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (127)
#[test]
fn test_aarch32_sub_sp_i_t2_a_field_imm8_127_poweroftwominusone_0_f1ad007f() {
    // Thumb encoding (32): 0xF1AD007F
    // Test aarch32_SUB_SP_i_T2_A field imm8 = 127 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm3=0, Rd=0, S=0, imm8=127, i=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1AD007F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_sub_sp_i_t2_a_field_imm8_128_poweroftwo_0_f1ad0080() {
    // Thumb encoding (32): 0xF1AD0080
    // Test aarch32_SUB_SP_i_T2_A field imm8 = 128 (PowerOfTwo)
    // ISET: T32
    // Fields: i=0, imm3=0, Rd=0, imm8=128, S=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1AD0080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 255, boundary: Max }
/// maximum immediate (255)
#[test]
fn test_aarch32_sub_sp_i_t2_a_field_imm8_255_max_0_f1ad00ff() {
    // Thumb encoding (32): 0xF1AD00FF
    // Test aarch32_SUB_SP_i_T2_A field imm8 = 255 (Max)
    // ISET: T32
    // Fields: S=0, i=0, Rd=0, imm8=255, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1AD00FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// i=0 (minimum value)
#[test]
fn test_aarch32_sub_sp_i_t2_a_combo_0_0_f1ad0000() {
    // Thumb encoding (32): 0xF1AD0000
    // Test aarch32_SUB_SP_i_T2_A field combination: i=0, S=0, imm3=0, Rd=0, imm8=0
    // ISET: T32
    // Fields: i=0, imm8=0, Rd=0, S=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1AD0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `field S = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "S", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_sub_sp_i_t2_a_special_s_0_size_variant_0_0_f1ad0000() {
    // Thumb encoding (32): 0xF1AD0000
    // Test aarch32_SUB_SP_i_T2_A special value S = 0 (Size variant 0)
    // ISET: T32
    // Fields: Rd=0, imm3=0, imm8=0, i=0, S=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1AD0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `field S = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "S", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_sub_sp_i_t2_a_special_s_1_size_variant_1_0_f1bd0000() {
    // Thumb encoding (32): 0xF1BD0000
    // Test aarch32_SUB_SP_i_T2_A special value S = 1 (Size variant 1)
    // ISET: T32
    // Fields: imm3=0, Rd=0, i=0, S=1, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1BD0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: And, lhs: LitInt(15), rhs: Unary { op: Not, operand: Var(QualifiedIdentifier { qualifier: Any, name: "setflags" }) } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: And, lhs: LitInt(15), rhs: Unary { op: Not, operand: Var(QualifiedIdentifier { qualifier: Any, name: \"setflags\" }) } } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_sub_sp_i_t2_a_invalid_0_0_f1ad0000() {
    // Thumb encoding (32): 0xF1AD0000
    // Test aarch32_SUB_SP_i_T2_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: And, lhs: LitInt(15), rhs: Unary { op: Not, operand: Var(QualifiedIdentifier { qualifier: Any, name: "setflags" }) } } }
    // ISET: T32
    // Fields: i=0, Rd=0, S=0, imm3=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1AD0000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_sub_sp_i_t2_a_invalid_1_0_f1ad0000() {
    // Thumb encoding (32): 0xF1AD0000
    // Test aarch32_SUB_SP_i_T2_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: imm3=0, Rd=0, imm8=0, i=0, S=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1AD0000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_SUB_SP_i_T3_A
/// ASL: `field i 26 +: 1`
/// Requirement: FieldBoundary { field: "i", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_sub_sp_i_t3_a_field_i_0_min_0_f2ad0000() {
    // Thumb encoding (32): 0xF2AD0000
    // Test aarch32_SUB_SP_i_T3_A field i = 0 (Min)
    // ISET: T32
    // Fields: Rd=0, i=0, imm8=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2AD0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_SP_i_T3_A
/// ASL: `field i 26 +: 1`
/// Requirement: FieldBoundary { field: "i", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_sub_sp_i_t3_a_field_i_1_max_0_f6ad0000() {
    // Thumb encoding (32): 0xF6AD0000
    // Test aarch32_SUB_SP_i_T3_A field i = 1 (Max)
    // ISET: T32
    // Fields: i=1, Rd=0, imm8=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF6AD0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_SP_i_T3_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_sub_sp_i_t3_a_field_imm3_0_zero_0_f2ad0000() {
    // Thumb encoding (32): 0xF2AD0000
    // Test aarch32_SUB_SP_i_T3_A field imm3 = 0 (Zero)
    // ISET: T32
    // Fields: imm8=0, i=0, Rd=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2AD0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_SP_i_T3_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_sub_sp_i_t3_a_field_imm3_1_poweroftwo_0_f2ad1000() {
    // Thumb encoding (32): 0xF2AD1000
    // Test aarch32_SUB_SP_i_T3_A field imm3 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: i=0, imm3=1, imm8=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2AD1000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_SP_i_T3_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 3, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (3)
#[test]
fn test_aarch32_sub_sp_i_t3_a_field_imm3_3_poweroftwominusone_0_f2ad3000() {
    // Thumb encoding (32): 0xF2AD3000
    // Test aarch32_SUB_SP_i_T3_A field imm3 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm3=3, i=0, Rd=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2AD3000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_SP_i_T3_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 7, boundary: Max }
/// maximum immediate (7)
#[test]
fn test_aarch32_sub_sp_i_t3_a_field_imm3_7_max_0_f2ad7000() {
    // Thumb encoding (32): 0xF2AD7000
    // Test aarch32_SUB_SP_i_T3_A field imm3 = 7 (Max)
    // ISET: T32
    // Fields: i=0, imm3=7, imm8=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2AD7000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_SP_i_T3_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_sub_sp_i_t3_a_field_rd_0_min_0_f2ad0000() {
    // Thumb encoding (32): 0xF2AD0000
    // Test aarch32_SUB_SP_i_T3_A field Rd = 0 (Min)
    // ISET: T32
    // Fields: i=0, imm8=0, Rd=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2AD0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_SP_i_T3_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_sub_sp_i_t3_a_field_rd_1_poweroftwo_0_f2ad0100() {
    // Thumb encoding (32): 0xF2AD0100
    // Test aarch32_SUB_SP_i_T3_A field Rd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: i=0, imm8=0, Rd=1, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2AD0100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_SP_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_sub_sp_i_t3_a_field_imm8_0_zero_0_f2ad0000() {
    // Thumb encoding (32): 0xF2AD0000
    // Test aarch32_SUB_SP_i_T3_A field imm8 = 0 (Zero)
    // ISET: T32
    // Fields: imm8=0, imm3=0, i=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2AD0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_SP_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_sub_sp_i_t3_a_field_imm8_1_poweroftwo_0_f2ad0001() {
    // Thumb encoding (32): 0xF2AD0001
    // Test aarch32_SUB_SP_i_T3_A field imm8 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=1, Rd=0, i=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2AD0001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_SP_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_sub_sp_i_t3_a_field_imm8_3_poweroftwominusone_0_f2ad0003() {
    // Thumb encoding (32): 0xF2AD0003
    // Test aarch32_SUB_SP_i_T3_A field imm8 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm3=0, Rd=0, i=0, imm8=3
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2AD0003;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_SP_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_sub_sp_i_t3_a_field_imm8_4_poweroftwo_0_f2ad0004() {
    // Thumb encoding (32): 0xF2AD0004
    // Test aarch32_SUB_SP_i_T3_A field imm8 = 4 (PowerOfTwo)
    // ISET: T32
    // Fields: Rd=0, i=0, imm8=4, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2AD0004;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_SP_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_sub_sp_i_t3_a_field_imm8_7_poweroftwominusone_0_f2ad0007() {
    // Thumb encoding (32): 0xF2AD0007
    // Test aarch32_SUB_SP_i_T3_A field imm8 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rd=0, i=0, imm8=7, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2AD0007;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_SP_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_sub_sp_i_t3_a_field_imm8_8_poweroftwo_0_f2ad0008() {
    // Thumb encoding (32): 0xF2AD0008
    // Test aarch32_SUB_SP_i_T3_A field imm8 = 8 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=8, i=0, imm3=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2AD0008;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_SP_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_sub_sp_i_t3_a_field_imm8_15_poweroftwominusone_0_f2ad000f() {
    // Thumb encoding (32): 0xF2AD000F
    // Test aarch32_SUB_SP_i_T3_A field imm8 = 15 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: i=0, imm3=0, imm8=15, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2AD000F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_SP_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_sub_sp_i_t3_a_field_imm8_16_poweroftwo_0_f2ad0010() {
    // Thumb encoding (32): 0xF2AD0010
    // Test aarch32_SUB_SP_i_T3_A field imm8 = 16 (PowerOfTwo)
    // ISET: T32
    // Fields: i=0, Rd=0, imm8=16, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2AD0010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_SP_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_sub_sp_i_t3_a_field_imm8_31_poweroftwominusone_0_f2ad001f() {
    // Thumb encoding (32): 0xF2AD001F
    // Test aarch32_SUB_SP_i_T3_A field imm8 = 31 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rd=0, imm3=0, imm8=31, i=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2AD001F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_SP_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_sub_sp_i_t3_a_field_imm8_32_poweroftwo_0_f2ad0020() {
    // Thumb encoding (32): 0xF2AD0020
    // Test aarch32_SUB_SP_i_T3_A field imm8 = 32 (PowerOfTwo)
    // ISET: T32
    // Fields: i=0, imm3=0, Rd=0, imm8=32
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2AD0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_SP_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_sub_sp_i_t3_a_field_imm8_63_poweroftwominusone_0_f2ad003f() {
    // Thumb encoding (32): 0xF2AD003F
    // Test aarch32_SUB_SP_i_T3_A field imm8 = 63 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm8=63, imm3=0, Rd=0, i=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2AD003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_SP_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_sub_sp_i_t3_a_field_imm8_64_poweroftwo_0_f2ad0040() {
    // Thumb encoding (32): 0xF2AD0040
    // Test aarch32_SUB_SP_i_T3_A field imm8 = 64 (PowerOfTwo)
    // ISET: T32
    // Fields: i=0, Rd=0, imm8=64, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2AD0040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_SP_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 127, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (127)
#[test]
fn test_aarch32_sub_sp_i_t3_a_field_imm8_127_poweroftwominusone_0_f2ad007f() {
    // Thumb encoding (32): 0xF2AD007F
    // Test aarch32_SUB_SP_i_T3_A field imm8 = 127 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: i=0, imm3=0, Rd=0, imm8=127
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2AD007F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_SP_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_sub_sp_i_t3_a_field_imm8_128_poweroftwo_0_f2ad0080() {
    // Thumb encoding (32): 0xF2AD0080
    // Test aarch32_SUB_SP_i_T3_A field imm8 = 128 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=128, Rd=0, imm3=0, i=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2AD0080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_SP_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 255, boundary: Max }
/// maximum immediate (255)
#[test]
fn test_aarch32_sub_sp_i_t3_a_field_imm8_255_max_0_f2ad00ff() {
    // Thumb encoding (32): 0xF2AD00FF
    // Test aarch32_SUB_SP_i_T3_A field imm8 = 255 (Max)
    // ISET: T32
    // Fields: i=0, imm3=0, imm8=255, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2AD00FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_SP_i_T3_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// i=0 (minimum value)
#[test]
fn test_aarch32_sub_sp_i_t3_a_combo_0_0_f2ad0000() {
    // Thumb encoding (32): 0xF2AD0000
    // Test aarch32_SUB_SP_i_T3_A field combination: i=0, imm3=0, Rd=0, imm8=0
    // ISET: T32
    // Fields: Rd=0, i=0, imm8=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2AD0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_SP_i_T3_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_sub_sp_i_t3_a_invalid_0_0_f2ad0000() {
    // Thumb encoding (32): 0xF2AD0000
    // Test aarch32_SUB_SP_i_T3_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: LitInt(15) }
    // ISET: T32
    // Fields: i=0, Rd=0, imm3=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2AD0000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_SUB_SP_i_T3_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_sub_sp_i_t3_a_invalid_1_0_f2ad0000() {
    // Thumb encoding (32): 0xF2AD0000
    // Test aarch32_SUB_SP_i_T3_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: imm3=0, imm8=0, i=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF2AD0000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `ADD X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_sub_sp_i_a1_a_add_oracle_32_0_024d2820() {
    // Test ADD 32-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0x024D2820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x024D2820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x34A064, "W0 should be 0x34A064");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `ADD X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_sub_sp_i_a1_a_add_oracle_64_0_824d2820() {
    // Test ADD 64-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0x824D2820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x824D2820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x34A064, "X0 should be 0x000000000034A064");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `ADD X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero operands (32)
#[test]
fn test_aarch32_sub_sp_i_a1_a_add_oracle_32_1_024d0020() {
    // Test ADD 32-bit: zero operands (with oracle verification)
    // Encoding: 0x024D0020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x024D0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x340000, "W0 should be 0x340000");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `ADD X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero operands (64)
#[test]
fn test_aarch32_sub_sp_i_a1_a_add_oracle_64_1_824d0020() {
    // Test ADD 64-bit: zero operands (with oracle verification)
    // Encoding: 0x824D0020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x824D0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x340000, "X0 should be 0x0000000000340000");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small values (32)
#[test]
fn test_aarch32_sub_sp_i_a1_a_add_oracle_32_2_024d0420() {
    // Test ADD 32-bit: small values (with oracle verification)
    // Encoding: 0x024D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x024D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x341001, "W0 should be 0x341001");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// small values (64)
#[test]
fn test_aarch32_sub_sp_i_a1_a_add_oracle_64_2_824d0420() {
    // Test ADD 64-bit: small values (with oracle verification)
    // Encoding: 0x824D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x824D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x341001, "X0 should be 0x0000000000341001");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `ADD X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_sub_sp_i_a1_a_add_oracle_32_3_027ffc20() {
    // Test ADD 32-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0x027FFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x027FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF000, "W0 should be 0xFFF000");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `ADD X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_sub_sp_i_a1_a_add_oracle_64_3_827ffc20() {
    // Test ADD 64-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0x827FFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x827FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF000, "X0 should be 0x0000000000FFF000");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `ADD X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_sub_sp_i_a1_a_add_oracle_32_4_027ffc20() {
    // Test ADD 32-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0x027FFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x027FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF000, "W0 should be 0xFFF000");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `ADD X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_sub_sp_i_a1_a_add_oracle_64_4_827ffc20() {
    // Test ADD 64-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0x827FFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x827FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF000, "X0 should be 0x0000000000FFF000");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max u64 operand (32)
#[test]
fn test_aarch32_sub_sp_i_a1_a_add_oracle_32_5_024d0420() {
    // Test ADD 32-bit: max u64 operand (with oracle verification)
    // Encoding: 0x024D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x024D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x340FFF, "W0 should be 0x340FFF");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max u64 operand (64)
#[test]
fn test_aarch32_sub_sp_i_a1_a_add_oracle_64_5_824d0420() {
    // Test ADD 64-bit: max u64 operand (with oracle verification)
    // Encoding: 0x824D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x824D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x340FFF, "X0 should be 0x0000000000340FFF");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_sub_sp_i_a1_a_add_oracle_32_6_024d0420() {
    // Test ADD 32-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0x024D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x024D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x341000, "W0 should be 0x341000");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_sub_sp_i_a1_a_add_oracle_64_6_824d0420() {
    // Test ADD 64-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0x824D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x824D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x341000, "X0 should be 0x0000000000341000");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_sub_sp_i_a1_a_add_oracle_32_7_024d0420() {
    // Test ADD 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0x024D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x024D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x340FFF, "W0 should be 0x340FFF");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_sub_sp_i_a1_a_add_oracle_64_7_824d0420() {
    // Test ADD 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0x824D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x824D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x340FFF, "X0 should be 0x8000000000340FFF");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_sub_sp_i_a1_a_add_oracle_32_8_024d0420() {
    // Test ADD 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0x024D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x024D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80340FFF, "W0 should be 0x80340FFF");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_sub_sp_i_a1_a_add_oracle_64_8_824d0420() {
    // Test ADD 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0x824D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x824D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x80340FFF,
        "X0 should be 0x0000000080340FFF"
    );
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_sub_sp_i_a1_a_add_oracle_32_9_024d0420() {
    // Test ADD 32-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0x024D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x024D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x340FFF, "W0 should be 0x340FFF");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_sub_sp_i_a1_a_add_oracle_64_9_824d0420() {
    // Test ADD 64-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0x824D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x824D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x340FFF, "X0 should be 0x0000000000340FFF");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_sub_sp_i_a1_a_add_oracle_32_10_024d0420() {
    // Test ADD 32-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0x024D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x024D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x340FFF, "W0 should be 0x340FFF");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_sub_sp_i_a1_a_add_oracle_64_10_824d0420() {
    // Test ADD 64-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0x824D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x824D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x340FFF, "X0 should be 0x0000000100340FFF");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `ADD SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (32)
#[test]
fn test_aarch32_sub_sp_i_a1_a_add_oracle_32_rd31_sp_024d283f() {
    // Test ADD 32-bit with Rd=31 (SP)
    // Encoding: 0x024D283F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x024D283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    // TODO: assertion - TestAssertion { check: Sp, expected: U64(3448932), message: "SP should be 0x34A064" }
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `ADD SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (64)
#[test]
fn test_aarch32_sub_sp_i_a1_a_add_oracle_64_rd31_sp_824d283f() {
    // Test ADD 64-bit with Rd=31 (SP)
    // Encoding: 0x824D283F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x824D283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    // TODO: assertion - TestAssertion { check: Sp, expected: U64(3448932), message: "SP should be 0x34A064" }
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `ADDS X0, X1, #10`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_sub_sp_i_a1_a_adds_oracle_32_0_224d2820() {
    // Test ADDS 32-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0x224D2820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x224D2820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x34A064, "W0 should be 0x34A064");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `ADDS X0, X1, #10`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_sub_sp_i_a1_a_adds_oracle_64_0_a24d2820() {
    // Test ADDS 64-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0xA24D2820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xA24D2820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x34A064, "X0 should be 0x000000000034A064");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `ADDS X0, X1, #0`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero operands (32)
#[test]
fn test_aarch32_sub_sp_i_a1_a_adds_oracle_32_1_224d0020() {
    // Test ADDS 32-bit: zero operands (with oracle verification)
    // Encoding: 0x224D0020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x224D0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x340000, "W0 should be 0x340000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `ADDS X0, X1, #0`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero operands (64)
#[test]
fn test_aarch32_sub_sp_i_a1_a_adds_oracle_64_1_a24d0020() {
    // Test ADDS 64-bit: zero operands (with oracle verification)
    // Encoding: 0xA24D0020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xA24D0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x340000, "X0 should be 0x0000000000340000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// small values (32)
#[test]
fn test_aarch32_sub_sp_i_a1_a_adds_oracle_32_2_224d0420() {
    // Test ADDS 32-bit: small values (with oracle verification)
    // Encoding: 0x224D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x224D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x341001, "W0 should be 0x341001");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// small values (64)
#[test]
fn test_aarch32_sub_sp_i_a1_a_adds_oracle_64_2_a24d0420() {
    // Test ADDS 64-bit: small values (with oracle verification)
    // Encoding: 0xA24D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xA24D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x341001, "X0 should be 0x0000000000341001");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `ADDS X0, X1, #4095`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_sub_sp_i_a1_a_adds_oracle_32_3_227ffc20() {
    // Test ADDS 32-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0x227FFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x227FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF000, "W0 should be 0xFFF000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `ADDS X0, X1, #4095`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_sub_sp_i_a1_a_adds_oracle_64_3_a27ffc20() {
    // Test ADDS 64-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0xA27FFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xA27FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF000, "X0 should be 0x0000000000FFF000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `ADDS X0, X1, #4095, LSL #12`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_sub_sp_i_a1_a_adds_oracle_32_4_227ffc20() {
    // Test ADDS 32-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0x227FFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x227FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF000, "W0 should be 0xFFF000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `ADDS X0, X1, #4095, LSL #12`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_sub_sp_i_a1_a_adds_oracle_64_4_a27ffc20() {
    // Test ADDS 64-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0xA27FFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xA27FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF000, "X0 should be 0x0000000000FFF000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max u64 operand (32)
#[test]
fn test_aarch32_sub_sp_i_a1_a_adds_oracle_32_5_224d0420() {
    // Test ADDS 32-bit: max u64 operand (with oracle verification)
    // Encoding: 0x224D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x224D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x340FFF, "W0 should be 0x340FFF");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max u64 operand (64)
#[test]
fn test_aarch32_sub_sp_i_a1_a_adds_oracle_64_5_a24d0420() {
    // Test ADDS 64-bit: max u64 operand (with oracle verification)
    // Encoding: 0xA24D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xA24D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x340FFF, "X0 should be 0x0000000000340FFF");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_sub_sp_i_a1_a_adds_oracle_32_6_224d0420() {
    // Test ADDS 32-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0x224D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x224D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x341000, "W0 should be 0x341000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_sub_sp_i_a1_a_adds_oracle_64_6_a24d0420() {
    // Test ADDS 64-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0xA24D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xA24D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x341000, "X0 should be 0x0000000000341000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_sub_sp_i_a1_a_adds_oracle_32_7_224d0420() {
    // Test ADDS 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0x224D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x224D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x340FFF, "W0 should be 0x340FFF");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_sub_sp_i_a1_a_adds_oracle_64_7_a24d0420() {
    // Test ADDS 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0xA24D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xA24D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x340FFF, "X0 should be 0x8000000000340FFF");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, true, "V flag should be true");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_sub_sp_i_a1_a_adds_oracle_32_8_224d0420() {
    // Test ADDS 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0x224D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x224D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80340FFF, "W0 should be 0x80340FFF");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, true, "V flag should be true");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_sub_sp_i_a1_a_adds_oracle_64_8_a24d0420() {
    // Test ADDS 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0xA24D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xA24D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x80340FFF,
        "X0 should be 0x0000000080340FFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_sub_sp_i_a1_a_adds_oracle_32_9_224d0420() {
    // Test ADDS 32-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0x224D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x224D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x340FFF, "W0 should be 0x340FFF");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_sub_sp_i_a1_a_adds_oracle_64_9_a24d0420() {
    // Test ADDS 64-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0xA24D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xA24D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x340FFF, "X0 should be 0x0000000000340FFF");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_sub_sp_i_a1_a_adds_oracle_32_10_224d0420() {
    // Test ADDS 32-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0x224D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x224D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x340FFF, "W0 should be 0x340FFF");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_sub_sp_i_a1_a_adds_oracle_64_10_a24d0420() {
    // Test ADDS 64-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0xA24D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xA24D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x340FFF, "X0 should be 0x0000000100340FFF");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `ADDS ZR, X1, #10`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "result discarded, flags set" }
/// ZR destination (32)
#[test]
fn test_aarch32_sub_sp_i_a1_a_adds_oracle_32_rd31_zr_224d283f() {
    // Test ADDS 32-bit with Rd=31 (ZR)
    // Encoding: 0x224D283F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x224D283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `ADDS ZR, X1, #10`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "result discarded, flags set" }
/// ZR destination (64)
#[test]
fn test_aarch32_sub_sp_i_a1_a_adds_oracle_64_rd31_zr_a24d283f() {
    // Test ADDS 64-bit with Rd=31 (ZR)
    // Encoding: 0xA24D283F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xA24D283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `SUB X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_sub_sp_i_a1_a_sub_oracle_32_0_424d2820() {
    // Test SUB 32-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0x424D2820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x424D2820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFCB6064, "W0 should be 0xFFCB6064");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `SUB X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_sub_sp_i_a1_a_sub_oracle_64_0_c24d2820() {
    // Test SUB 64-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0xC24D2820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xC24D2820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFCB6064,
        "X0 should be 0xFFFFFFFFFFCB6064"
    );
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `SUB X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero operands (32)
#[test]
fn test_aarch32_sub_sp_i_a1_a_sub_oracle_32_1_424d0020() {
    // Test SUB 32-bit: zero operands (with oracle verification)
    // Encoding: 0x424D0020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x424D0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFCC0000, "W0 should be 0xFFCC0000");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `SUB X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero operands (64)
#[test]
fn test_aarch32_sub_sp_i_a1_a_sub_oracle_64_1_c24d0020() {
    // Test SUB 64-bit: zero operands (with oracle verification)
    // Encoding: 0xC24D0020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xC24D0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFCC0000,
        "X0 should be 0xFFFFFFFFFFCC0000"
    );
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small values (32)
#[test]
fn test_aarch32_sub_sp_i_a1_a_sub_oracle_32_2_424d0420() {
    // Test SUB 32-bit: small values (with oracle verification)
    // Encoding: 0x424D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x424D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFCBF001, "W0 should be 0xFFCBF001");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// small values (64)
#[test]
fn test_aarch32_sub_sp_i_a1_a_sub_oracle_64_2_c24d0420() {
    // Test SUB 64-bit: small values (with oracle verification)
    // Encoding: 0xC24D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xC24D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFCBF001,
        "X0 should be 0xFFFFFFFFFFCBF001"
    );
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `SUB X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_sub_sp_i_a1_a_sub_oracle_32_3_427ffc20() {
    // Test SUB 32-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0x427FFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x427FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF001000, "W0 should be 0xFF001000");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `SUB X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_sub_sp_i_a1_a_sub_oracle_64_3_c27ffc20() {
    // Test SUB 64-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0xC27FFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xC27FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `SUB X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_sub_sp_i_a1_a_sub_oracle_32_4_427ffc20() {
    // Test SUB 32-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0x427FFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x427FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF001000, "W0 should be 0xFF001000");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `SUB X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_sub_sp_i_a1_a_sub_oracle_64_4_c27ffc20() {
    // Test SUB 64-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0xC27FFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xC27FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max u64 operand (32)
#[test]
fn test_aarch32_sub_sp_i_a1_a_sub_oracle_32_5_424d0420() {
    // Test SUB 32-bit: max u64 operand (with oracle verification)
    // Encoding: 0x424D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x424D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFCBEFFF, "W0 should be 0xFFCBEFFF");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max u64 operand (64)
#[test]
fn test_aarch32_sub_sp_i_a1_a_sub_oracle_64_5_c24d0420() {
    // Test SUB 64-bit: max u64 operand (with oracle verification)
    // Encoding: 0xC24D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xC24D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFCBEFFF,
        "X0 should be 0xFFFFFFFFFFCBEFFF"
    );
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_sub_sp_i_a1_a_sub_oracle_32_6_424d0420() {
    // Test SUB 32-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0x424D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x424D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFCBF000, "W0 should be 0xFFCBF000");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_sub_sp_i_a1_a_sub_oracle_64_6_c24d0420() {
    // Test SUB 64-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0xC24D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xC24D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFCBF000,
        "X0 should be 0xFFFFFFFFFFCBF000"
    );
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_sub_sp_i_a1_a_sub_oracle_32_7_424d0420() {
    // Test SUB 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0x424D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x424D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFCBEFFF, "W0 should be 0xFFCBEFFF");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_sub_sp_i_a1_a_sub_oracle_64_7_c24d0420() {
    // Test SUB 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0xC24D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xC24D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFCBEFFF,
        "X0 should be 0x7FFFFFFFFFCBEFFF"
    );
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_sub_sp_i_a1_a_sub_oracle_32_8_424d0420() {
    // Test SUB 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0x424D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x424D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FCBEFFF, "W0 should be 0x7FCBEFFF");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_sub_sp_i_a1_a_sub_oracle_64_8_c24d0420() {
    // Test SUB 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0xC24D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xC24D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x7FCBEFFF,
        "X0 should be 0x000000007FCBEFFF"
    );
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_sub_sp_i_a1_a_sub_oracle_32_9_424d0420() {
    // Test SUB 32-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0x424D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x424D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFCBEFFF, "W0 should be 0xFFCBEFFF");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_sub_sp_i_a1_a_sub_oracle_64_9_c24d0420() {
    // Test SUB 64-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0xC24D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xC24D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFCBEFFF,
        "X0 should be 0xFFFFFFFFFFCBEFFF"
    );
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_sub_sp_i_a1_a_sub_oracle_32_10_424d0420() {
    // Test SUB 32-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0x424D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x424D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFCBEFFF, "W0 should be 0xFFCBEFFF");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_sub_sp_i_a1_a_sub_oracle_64_10_c24d0420() {
    // Test SUB 64-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0xC24D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xC24D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFCBEFFF,
        "X0 should be 0x00000000FFCBEFFF"
    );
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `SUB SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (32)
#[test]
fn test_aarch32_sub_sp_i_a1_a_sub_oracle_32_rd31_sp_424d283f() {
    // Test SUB 32-bit with Rd=31 (SP)
    // Encoding: 0x424D283F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x424D283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    // TODO: assertion - TestAssertion { check: Sp, expected: U64(4291518564), message: "SP should be 0xFFCB6064" }
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `SUB SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (64)
#[test]
fn test_aarch32_sub_sp_i_a1_a_sub_oracle_64_rd31_sp_c24d283f() {
    // Test SUB 64-bit with Rd=31 (SP)
    // Encoding: 0xC24D283F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xC24D283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    // TODO: assertion - TestAssertion { check: Sp, expected: U64(18446744073706102884), message: "SP should be 0xFFFFFFFFFFCB6064" }
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `SUBS X0, X1, #10`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_sub_sp_i_a1_a_subs_oracle_32_0_624d2820() {
    // Test SUBS 32-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0x624D2820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x624D2820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFCB6064, "W0 should be 0xFFCB6064");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `SUBS X0, X1, #10`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_sub_sp_i_a1_a_subs_oracle_64_0_e24d2820() {
    // Test SUBS 64-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0xE24D2820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xE24D2820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFCB6064,
        "X0 should be 0xFFFFFFFFFFCB6064"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `SUBS X0, X1, #0`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero operands (32)
#[test]
fn test_aarch32_sub_sp_i_a1_a_subs_oracle_32_1_624d0020() {
    // Test SUBS 32-bit: zero operands (with oracle verification)
    // Encoding: 0x624D0020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x624D0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFCC0000, "W0 should be 0xFFCC0000");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `SUBS X0, X1, #0`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero operands (64)
#[test]
fn test_aarch32_sub_sp_i_a1_a_subs_oracle_64_1_e24d0020() {
    // Test SUBS 64-bit: zero operands (with oracle verification)
    // Encoding: 0xE24D0020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xE24D0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFCC0000,
        "X0 should be 0xFFFFFFFFFFCC0000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// small values (32)
#[test]
fn test_aarch32_sub_sp_i_a1_a_subs_oracle_32_2_624d0420() {
    // Test SUBS 32-bit: small values (with oracle verification)
    // Encoding: 0x624D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x624D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFCBF001, "W0 should be 0xFFCBF001");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// small values (64)
#[test]
fn test_aarch32_sub_sp_i_a1_a_subs_oracle_64_2_e24d0420() {
    // Test SUBS 64-bit: small values (with oracle verification)
    // Encoding: 0xE24D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xE24D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFCBF001,
        "X0 should be 0xFFFFFFFFFFCBF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `SUBS X0, X1, #4095`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_sub_sp_i_a1_a_subs_oracle_32_3_627ffc20() {
    // Test SUBS 32-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0x627FFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x627FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF001000, "W0 should be 0xFF001000");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `SUBS X0, X1, #4095`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_sub_sp_i_a1_a_subs_oracle_64_3_e27ffc20() {
    // Test SUBS 64-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0xE27FFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xE27FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `SUBS X0, X1, #4095, LSL #12`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_sub_sp_i_a1_a_subs_oracle_32_4_627ffc20() {
    // Test SUBS 32-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0x627FFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x627FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF001000, "W0 should be 0xFF001000");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `SUBS X0, X1, #4095, LSL #12`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_sub_sp_i_a1_a_subs_oracle_64_4_e27ffc20() {
    // Test SUBS 64-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0xE27FFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xE27FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max u64 operand (32)
#[test]
fn test_aarch32_sub_sp_i_a1_a_subs_oracle_32_5_624d0420() {
    // Test SUBS 32-bit: max u64 operand (with oracle verification)
    // Encoding: 0x624D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x624D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFCBEFFF, "W0 should be 0xFFCBEFFF");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max u64 operand (64)
#[test]
fn test_aarch32_sub_sp_i_a1_a_subs_oracle_64_5_e24d0420() {
    // Test SUBS 64-bit: max u64 operand (with oracle verification)
    // Encoding: 0xE24D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xE24D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFCBEFFF,
        "X0 should be 0xFFFFFFFFFFCBEFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_sub_sp_i_a1_a_subs_oracle_32_6_624d0420() {
    // Test SUBS 32-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0x624D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x624D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFCBF000, "W0 should be 0xFFCBF000");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_sub_sp_i_a1_a_subs_oracle_64_6_e24d0420() {
    // Test SUBS 64-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0xE24D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xE24D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFCBF000,
        "X0 should be 0xFFFFFFFFFFCBF000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_sub_sp_i_a1_a_subs_oracle_32_7_624d0420() {
    // Test SUBS 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0x624D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x624D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFCBEFFF, "W0 should be 0xFFCBEFFF");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_sub_sp_i_a1_a_subs_oracle_64_7_e24d0420() {
    // Test SUBS 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0xE24D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xE24D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFCBEFFF,
        "X0 should be 0x7FFFFFFFFFCBEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_sub_sp_i_a1_a_subs_oracle_32_8_624d0420() {
    // Test SUBS 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0x624D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x624D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FCBEFFF, "W0 should be 0x7FCBEFFF");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_sub_sp_i_a1_a_subs_oracle_64_8_e24d0420() {
    // Test SUBS 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0xE24D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xE24D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x7FCBEFFF,
        "X0 should be 0x000000007FCBEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_sub_sp_i_a1_a_subs_oracle_32_9_624d0420() {
    // Test SUBS 32-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0x624D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x624D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFCBEFFF, "W0 should be 0xFFCBEFFF");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_sub_sp_i_a1_a_subs_oracle_64_9_e24d0420() {
    // Test SUBS 64-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0xE24D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xE24D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFCBEFFF,
        "X0 should be 0xFFFFFFFFFFCBEFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_sub_sp_i_a1_a_subs_oracle_32_10_624d0420() {
    // Test SUBS 32-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0x624D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x624D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFCBEFFF, "W0 should be 0xFFCBEFFF");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_sub_sp_i_a1_a_subs_oracle_64_10_e24d0420() {
    // Test SUBS 64-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0xE24D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xE24D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFCBEFFF,
        "X0 should be 0x00000000FFCBEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `SUBS ZR, X1, #10`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "result discarded, flags set" }
/// ZR destination (32)
#[test]
fn test_aarch32_sub_sp_i_a1_a_subs_oracle_32_rd31_zr_624d283f() {
    // Test SUBS 32-bit with Rd=31 (ZR)
    // Encoding: 0x624D283F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x624D283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `SUBS ZR, X1, #10`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "result discarded, flags set" }
/// ZR destination (64)
#[test]
fn test_aarch32_sub_sp_i_a1_a_subs_oracle_64_rd31_zr_e24d283f() {
    // Test SUBS 64-bit with Rd=31 (ZR)
    // Encoding: 0xE24D283F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xE24D283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `SUB R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x00000000)
#[test]
fn test_aarch32_sub_sp_i_a1_a_a32_add_sub_imm_0_0_0241000a() {
    // Test A32 SUB: small immediate (oracle)
    // Encoding: 0x0241000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x0241000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFF6, "R0 should be 0xFFFFFFF6");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `SUB R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x00000064)
#[test]
fn test_aarch32_sub_sp_i_a1_a_a32_add_sub_imm_0_64_0241000a() {
    // Test A32 SUB: small immediate (oracle)
    // Encoding: 0x0241000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x0241000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x5A, "R0 should be 0x0000005A");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `SUB R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_sub_sp_i_a1_a_a32_add_sub_imm_0_7fffffff_0241000a() {
    // Test A32 SUB: small immediate (oracle)
    // Encoding: 0x0241000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x0241000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FFFFFF5, "R0 should be 0x7FFFFFF5");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `SUB R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x80000000)
#[test]
fn test_aarch32_sub_sp_i_a1_a_a32_add_sub_imm_0_80000000_0241000a() {
    // Test A32 SUB: small immediate (oracle)
    // Encoding: 0x0241000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0x0241000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FFFFFF6, "R0 should be 0x7FFFFFF6");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `SUB R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_sub_sp_i_a1_a_a32_add_sub_imm_0_ffffffff_0241000a() {
    // Test A32 SUB: small immediate (oracle)
    // Encoding: 0x0241000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x0241000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFF5, "R0 should be 0xFFFFFFF5");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `SUB R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x00000000)
#[test]
fn test_aarch32_sub_sp_i_a1_a_a32_add_sub_imm_1_0_024100ff() {
    // Test A32 SUB: max imm8 (oracle)
    // Encoding: 0x024100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x024100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFF01, "R0 should be 0xFFFFFF01");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `SUB R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x00000064)
#[test]
fn test_aarch32_sub_sp_i_a1_a_a32_add_sub_imm_1_64_024100ff() {
    // Test A32 SUB: max imm8 (oracle)
    // Encoding: 0x024100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x024100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFF65, "R0 should be 0xFFFFFF65");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `SUB R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_sub_sp_i_a1_a_a32_add_sub_imm_1_7fffffff_024100ff() {
    // Test A32 SUB: max imm8 (oracle)
    // Encoding: 0x024100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x024100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FFFFF00, "R0 should be 0x7FFFFF00");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `SUB R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x80000000)
#[test]
fn test_aarch32_sub_sp_i_a1_a_a32_add_sub_imm_1_80000000_024100ff() {
    // Test A32 SUB: max imm8 (oracle)
    // Encoding: 0x024100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0x024100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FFFFF01, "R0 should be 0x7FFFFF01");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `SUB R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_sub_sp_i_a1_a_a32_add_sub_imm_1_ffffffff_024100ff() {
    // Test A32 SUB: max imm8 (oracle)
    // Encoding: 0x024100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x024100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFF00, "R0 should be 0xFFFFFF00");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `SUB R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x00000000)
#[test]
fn test_aarch32_sub_sp_i_a1_a_a32_add_sub_imm_2_0_02410180() {
    // Test A32 SUB: rotated by 2 (oracle)
    // Encoding: 0x02410180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x02410180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFE0, "R0 should be 0xFFFFFFE0");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `SUB R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x00000064)
#[test]
fn test_aarch32_sub_sp_i_a1_a_a32_add_sub_imm_2_64_02410180() {
    // Test A32 SUB: rotated by 2 (oracle)
    // Encoding: 0x02410180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x02410180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x44, "R0 should be 0x00000044");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `SUB R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_sub_sp_i_a1_a_a32_add_sub_imm_2_7fffffff_02410180() {
    // Test A32 SUB: rotated by 2 (oracle)
    // Encoding: 0x02410180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x02410180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FFFFFDF, "R0 should be 0x7FFFFFDF");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `SUB R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x80000000)
#[test]
fn test_aarch32_sub_sp_i_a1_a_a32_add_sub_imm_2_80000000_02410180() {
    // Test A32 SUB: rotated by 2 (oracle)
    // Encoding: 0x02410180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0x02410180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FFFFFE0, "R0 should be 0x7FFFFFE0");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `SUB R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_sub_sp_i_a1_a_a32_add_sub_imm_2_ffffffff_02410180() {
    // Test A32 SUB: rotated by 2 (oracle)
    // Encoding: 0x02410180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x02410180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFDF, "R0 should be 0xFFFFFFDF");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `SUB R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x00000000)
#[test]
fn test_aarch32_sub_sp_i_a1_a_a32_add_sub_imm_3_0_0241040f() {
    // Test A32 SUB: rotated by 8 (oracle)
    // Encoding: 0x0241040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x0241040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xF1000000, "R0 should be 0xF1000000");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `SUB R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x00000064)
#[test]
fn test_aarch32_sub_sp_i_a1_a_a32_add_sub_imm_3_64_0241040f() {
    // Test A32 SUB: rotated by 8 (oracle)
    // Encoding: 0x0241040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x0241040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xF1000064, "R0 should be 0xF1000064");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `SUB R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_sub_sp_i_a1_a_a32_add_sub_imm_3_7fffffff_0241040f() {
    // Test A32 SUB: rotated by 8 (oracle)
    // Encoding: 0x0241040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x0241040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x70FFFFFF, "R0 should be 0x70FFFFFF");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `SUB R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x80000000)
#[test]
fn test_aarch32_sub_sp_i_a1_a_a32_add_sub_imm_3_80000000_0241040f() {
    // Test A32 SUB: rotated by 8 (oracle)
    // Encoding: 0x0241040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0x0241040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x71000000, "R0 should be 0x71000000");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `SUB R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_sub_sp_i_a1_a_a32_add_sub_imm_3_ffffffff_0241040f() {
    // Test A32 SUB: rotated by 8 (oracle)
    // Encoding: 0x0241040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x0241040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xF0FFFFFF, "R0 should be 0xF0FFFFFF");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `SUB R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x00000000)
#[test]
fn test_aarch32_sub_sp_i_a1_a_a32_add_sub_imm_4_0_02410000() {
    // Test A32 SUB: zero immediate (oracle)
    // Encoding: 0x02410000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x02410000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `SUB R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x00000064)
#[test]
fn test_aarch32_sub_sp_i_a1_a_a32_add_sub_imm_4_64_02410000() {
    // Test A32 SUB: zero immediate (oracle)
    // Encoding: 0x02410000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x02410000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x64, "R0 should be 0x00000064");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `SUB R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_sub_sp_i_a1_a_a32_add_sub_imm_4_7fffffff_02410000() {
    // Test A32 SUB: zero immediate (oracle)
    // Encoding: 0x02410000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x02410000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FFFFFFF, "R0 should be 0x7FFFFFFF");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `SUB R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x80000000)
#[test]
fn test_aarch32_sub_sp_i_a1_a_a32_add_sub_imm_4_80000000_02410000() {
    // Test A32 SUB: zero immediate (oracle)
    // Encoding: 0x02410000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0x02410000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "R0 should be 0x80000000");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `SUB R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_sub_sp_i_a1_a_a32_add_sub_imm_4_ffffffff_02410000() {
    // Test A32 SUB: zero immediate (oracle)
    // Encoding: 0x02410000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x02410000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "R0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_aarch32_sub_sp_i_a1_a_flags_zeroresult_0_025d0000() {
    // Test aarch32_SUB_SP_i_A1_A flag computation: ZeroResult
    // Encoding: 0x025D0000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x025D0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_aarch32_sub_sp_i_a1_a_flags_zeroresult_1_025d0000() {
    // Test aarch32_SUB_SP_i_A1_A flag computation: ZeroResult
    // Encoding: 0x025D0000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x025D0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_aarch32_sub_sp_i_a1_a_flags_negativeresult_2_025d0000() {
    // Test aarch32_SUB_SP_i_A1_A flag computation: NegativeResult
    // Encoding: 0x025D0000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x025D0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_aarch32_sub_sp_i_a1_a_flags_unsignedoverflow_3_025d0000() {
    // Test aarch32_SUB_SP_i_A1_A flag computation: UnsignedOverflow
    // Encoding: 0x025D0000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x025D0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_aarch32_sub_sp_i_a1_a_flags_unsignedoverflow_4_025d0000() {
    // Test aarch32_SUB_SP_i_A1_A flag computation: UnsignedOverflow
    // Encoding: 0x025D0000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x025D0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_aarch32_sub_sp_i_a1_a_flags_signedoverflow_5_025d0000() {
    // Test aarch32_SUB_SP_i_A1_A flag computation: SignedOverflow
    // Encoding: 0x025D0000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x025D0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_aarch32_sub_sp_i_a1_a_flags_signedoverflow_6_025d0000() {
    // Test aarch32_SUB_SP_i_A1_A flag computation: SignedOverflow
    // Encoding: 0x025D0000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x025D0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_SUB_SP_i_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_aarch32_sub_sp_i_a1_a_flags_positiveresult_7_025d0000() {
    // Test aarch32_SUB_SP_i_A1_A flag computation: PositiveResult
    // Encoding: 0x025D0000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x32);
    let encoding: u32 = 0x025D0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SUB_SP_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 0 (32)
#[test]
fn test_aarch32_sub_sp_i_t1_a_lslv_oracle_32_0_b0820020() {
    // Test LSLV 32-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x12345678, "W0 should be 0x12345678");
}

/// Provenance: aarch32_SUB_SP_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 0 (64)
#[test]
fn test_aarch32_sub_sp_i_t1_a_lslv_oracle_64_0_b0820020() {
    // Test LSLV 64-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x12345678,
        "X0 should be 0x0000000012345678"
    );
}

/// Provenance: aarch32_SUB_SP_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4 (32)
#[test]
fn test_aarch32_sub_sp_i_t1_a_lslv_oracle_32_1_b0820020() {
    // Test LSLV 32-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x4);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x23456780, "W0 should be 0x23456780");
}

/// Provenance: aarch32_SUB_SP_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 4 (64)
#[test]
fn test_aarch32_sub_sp_i_t1_a_lslv_oracle_64_1_b0820020() {
    // Test LSLV 64-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x4);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x23456780,
        "X0 should be 0x0000000123456780"
    );
}

/// Provenance: aarch32_SUB_SP_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 8 (32)
#[test]
fn test_aarch32_sub_sp_i_t1_a_lslv_oracle_32_2_b0820020() {
    // Test LSLV 32-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x8);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x34567800, "W0 should be 0x34567800");
}

/// Provenance: aarch32_SUB_SP_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 8 (64)
#[test]
fn test_aarch32_sub_sp_i_t1_a_lslv_oracle_64_2_b0820020() {
    // Test LSLV 64-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x8);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x34567800,
        "X0 should be 0x0000001234567800"
    );
}

/// Provenance: aarch32_SUB_SP_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1 (32)
#[test]
fn test_aarch32_sub_sp_i_t1_a_lslv_oracle_32_3_b0820020() {
    // Test LSLV 32-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_SUB_SP_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// MSB set, shift 1 (64)
#[test]
fn test_aarch32_sub_sp_i_t1_a_lslv_oracle_64_3_b0820020() {
    // Test LSLV 64-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_SUB_SP_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// LSB set, max shift (32)
#[test]
fn test_aarch32_sub_sp_i_t1_a_lslv_oracle_32_4_b0820020() {
    // Test LSLV 32-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x3F);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "W0 should be 0x80000000");
}

/// Provenance: aarch32_SUB_SP_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// LSB set, max shift (64)
#[test]
fn test_aarch32_sub_sp_i_t1_a_lslv_oracle_64_4_b0820020() {
    // Test LSLV 64-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x3F);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x8000000000000000");
}

/// Provenance: aarch32_SUB_SP_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// all ones, shift 32 (32)
#[test]
fn test_aarch32_sub_sp_i_t1_a_lslv_oracle_32_5_b0820020() {
    // Test LSLV 32-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x20);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "W0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_SUB_SP_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// all ones, shift 32 (64)
#[test]
fn test_aarch32_sub_sp_i_t1_a_lslv_oracle_64_5_b0820020() {
    // Test LSLV 64-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x20);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0xFFFFFFFF00000000");
}

/// Provenance: aarch32_SUB_SP_i_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// no shift
#[test]
fn test_aarch32_sub_sp_i_t1_a_t16_oracle_0_b0800000() {
    // Test T16 LSLS: no shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_SUB_SP_i_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4
#[test]
fn test_aarch32_sub_sp_i_t1_a_t16_oracle_1_b0800000() {
    // Test T16 LSLS: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    set_w(&mut cpu, 2, 0x4);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF0, "R0 should be 0x00000FF0");
}

/// Provenance: aarch32_SUB_SP_i_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1
#[test]
fn test_aarch32_sub_sp_i_t1_a_t16_oracle_2_b0800000() {
    // Test T16 LSLS: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_SUB_SP_i_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift to MSB
#[test]
fn test_aarch32_sub_sp_i_t1_a_t16_oracle_3_b0800000() {
    // Test T16 LSLS: shift to MSB (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x1F);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "R0 should be 0x80000000");
}

/// Provenance: aarch32_SUB_SP_i_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_aarch32_sub_sp_i_t1_a_flags_zeroresult_0_b0800000() {
    // Test aarch32_SUB_SP_i_T1_A flag computation: ZeroResult
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SUB_SP_i_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_aarch32_sub_sp_i_t1_a_flags_zeroresult_1_b0800000() {
    // Test aarch32_SUB_SP_i_T1_A flag computation: ZeroResult
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SUB_SP_i_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_aarch32_sub_sp_i_t1_a_flags_negativeresult_2_b0800000() {
    // Test aarch32_SUB_SP_i_T1_A flag computation: NegativeResult
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SUB_SP_i_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_aarch32_sub_sp_i_t1_a_flags_unsignedoverflow_3_b0800000() {
    // Test aarch32_SUB_SP_i_T1_A flag computation: UnsignedOverflow
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SUB_SP_i_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_aarch32_sub_sp_i_t1_a_flags_unsignedoverflow_4_b0800000() {
    // Test aarch32_SUB_SP_i_T1_A flag computation: UnsignedOverflow
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SUB_SP_i_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_aarch32_sub_sp_i_t1_a_flags_signedoverflow_5_b0800000() {
    // Test aarch32_SUB_SP_i_T1_A flag computation: SignedOverflow
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_SUB_SP_i_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_aarch32_sub_sp_i_t1_a_flags_signedoverflow_6_b0800000() {
    // Test aarch32_SUB_SP_i_T1_A flag computation: SignedOverflow
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_SUB_SP_i_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_aarch32_sub_sp_i_t1_a_flags_positiveresult_7_b0800000() {
    // Test aarch32_SUB_SP_i_T1_A flag computation: PositiveResult
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x32);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `ADD X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_sub_sp_i_t2_a_add_oracle_32_0_f1ad2820() {
    // Test ADD 32-bit: simple addition/subtraction (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF1AD2820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF51A,
        "X0 should be 0xFFFFFFFFFFFFF51A"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `ADD X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_sub_sp_i_t2_a_add_oracle_64_0_f1ad2820() {
    // Test ADD 64-bit: simple addition/subtraction (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF1AD2820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF51A,
        "X0 should be 0xFFFFFFFFFFFFF51A"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `ADD X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero operands (32)
#[test]
fn test_aarch32_sub_sp_i_t2_a_add_oracle_32_1_f1ad0020() {
    // Test ADD 32-bit: zero operands (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1AD0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF4C0,
        "X0 should be 0xFFFFFFFFFFFFF4C0"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `ADD X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero operands (64)
#[test]
fn test_aarch32_sub_sp_i_t2_a_add_oracle_64_1_f1ad0020() {
    // Test ADD 64-bit: zero operands (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1AD0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF4C0,
        "X0 should be 0xFFFFFFFFFFFFF4C0"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small values (32)
#[test]
fn test_aarch32_sub_sp_i_t2_a_add_oracle_32_2_f1ad0420() {
    // Test ADD 32-bit: small values (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF1AD0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF4C0,
        "X0 should be 0xFFFFFFFFFFFFF4C0"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// small values (64)
#[test]
fn test_aarch32_sub_sp_i_t2_a_add_oracle_64_2_f1ad0420() {
    // Test ADD 64-bit: small values (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF1AD0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF4C0,
        "X0 should be 0xFFFFFFFFFFFFF4C0"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `ADD X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_sub_sp_i_t2_a_add_oracle_32_3_f1bffc20() {
    // Test ADD 32-bit: max imm12 unshifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1BFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `ADD X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_sub_sp_i_t2_a_add_oracle_64_3_f1bffc20() {
    // Test ADD 64-bit: max imm12 unshifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1BFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `ADD X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_sub_sp_i_t2_a_add_oracle_32_4_f1fffc20() {
    // Test ADD 32-bit: max imm12 shifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `ADD X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_sub_sp_i_t2_a_add_oracle_64_4_f1fffc20() {
    // Test ADD 64-bit: max imm12 shifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max u64 operand (32)
#[test]
fn test_aarch32_sub_sp_i_t2_a_add_oracle_32_5_f1ad0420() {
    // Test ADD 32-bit: max u64 operand (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1AD0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF4BE,
        "X0 should be 0x00000000FFFFF4BE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max u64 operand (64)
#[test]
fn test_aarch32_sub_sp_i_t2_a_add_oracle_64_5_f1ad0420() {
    // Test ADD 64-bit: max u64 operand (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1AD0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF4BE,
        "X0 should be 0xFFFFFFFFFFFFF4BE"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_sub_sp_i_t2_a_add_oracle_32_6_f1ad0420() {
    // Test ADD 32-bit: zero result (for sub 1-1) (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1AD0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF4BF,
        "X0 should be 0xFFFFFFFFFFFFF4BF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_sub_sp_i_t2_a_add_oracle_64_6_f1ad0420() {
    // Test ADD 64-bit: zero result (for sub 1-1) (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1AD0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF4BF,
        "X0 should be 0xFFFFFFFFFFFFF4BF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_sub_sp_i_t2_a_add_oracle_32_7_f1ad0420() {
    // Test ADD 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1AD0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF4BE,
        "X0 should be 0x00000000FFFFF4BE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_sub_sp_i_t2_a_add_oracle_64_7_f1ad0420() {
    // Test ADD 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1AD0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF4BE,
        "X0 should be 0x7FFFFFFFFFFFF4BE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_sub_sp_i_t2_a_add_oracle_32_8_f1ad0420() {
    // Test ADD 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF1AD0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x7FFFF4BE,
        "X0 should be 0x000000007FFFF4BE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_sub_sp_i_t2_a_add_oracle_64_8_f1ad0420() {
    // Test ADD 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF1AD0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x7FFFF4BE,
        "X0 should be 0x000000007FFFF4BE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_sub_sp_i_t2_a_add_oracle_32_9_f1ad0420() {
    // Test ADD 32-bit: unsigned overflow 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1AD0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF4BE,
        "X0 should be 0x00000000FFFFF4BE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_sub_sp_i_t2_a_add_oracle_64_9_f1ad0420() {
    // Test ADD 64-bit: unsigned overflow 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1AD0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF4BE,
        "X0 should be 0xFFFFFFFFFFFFF4BE"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_sub_sp_i_t2_a_add_oracle_32_10_f1ad0420() {
    // Test ADD 32-bit: unsigned overflow 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1AD0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF4BE,
        "X0 should be 0x00000000FFFFF4BE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_sub_sp_i_t2_a_add_oracle_64_10_f1ad0420() {
    // Test ADD 64-bit: unsigned overflow 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1AD0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF4BE,
        "X0 should be 0x00000000FFFFF4BE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `ADD SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (32)
#[test]
fn test_aarch32_sub_sp_i_t2_a_add_oracle_32_rd31_sp_f1ad283f() {
    // Test ADD 32-bit with Rd=31 (SP)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF1AD283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `ADD SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (64)
#[test]
fn test_aarch32_sub_sp_i_t2_a_add_oracle_64_rd31_sp_f1ad283f() {
    // Test ADD 64-bit with Rd=31 (SP)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF1AD283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `ADDS X0, X1, #10`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_sub_sp_i_t2_a_adds_oracle_32_0_f1ad2820() {
    // Test ADDS 32-bit: simple addition/subtraction (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF1AD2820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF51A,
        "X0 should be 0xFFFFFFFFFFFFF51A"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `ADDS X0, X1, #10`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_sub_sp_i_t2_a_adds_oracle_64_0_f1ad2820() {
    // Test ADDS 64-bit: simple addition/subtraction (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF1AD2820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF51A,
        "X0 should be 0xFFFFFFFFFFFFF51A"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `ADDS X0, X1, #0`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero operands (32)
#[test]
fn test_aarch32_sub_sp_i_t2_a_adds_oracle_32_1_f1ad0020() {
    // Test ADDS 32-bit: zero operands (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1AD0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF4C0,
        "X0 should be 0xFFFFFFFFFFFFF4C0"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `ADDS X0, X1, #0`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero operands (64)
#[test]
fn test_aarch32_sub_sp_i_t2_a_adds_oracle_64_1_f1ad0020() {
    // Test ADDS 64-bit: zero operands (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1AD0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF4C0,
        "X0 should be 0xFFFFFFFFFFFFF4C0"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// small values (32)
#[test]
fn test_aarch32_sub_sp_i_t2_a_adds_oracle_32_2_f1ad0420() {
    // Test ADDS 32-bit: small values (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF1AD0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF4C0,
        "X0 should be 0xFFFFFFFFFFFFF4C0"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// small values (64)
#[test]
fn test_aarch32_sub_sp_i_t2_a_adds_oracle_64_2_f1ad0420() {
    // Test ADDS 64-bit: small values (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF1AD0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF4C0,
        "X0 should be 0xFFFFFFFFFFFFF4C0"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `ADDS X0, X1, #4095`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_sub_sp_i_t2_a_adds_oracle_32_3_f1bffc20() {
    // Test ADDS 32-bit: max imm12 unshifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1BFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `ADDS X0, X1, #4095`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_sub_sp_i_t2_a_adds_oracle_64_3_f1bffc20() {
    // Test ADDS 64-bit: max imm12 unshifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1BFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `ADDS X0, X1, #4095, LSL #12`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_sub_sp_i_t2_a_adds_oracle_32_4_f1fffc20() {
    // Test ADDS 32-bit: max imm12 shifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `ADDS X0, X1, #4095, LSL #12`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_sub_sp_i_t2_a_adds_oracle_64_4_f1fffc20() {
    // Test ADDS 64-bit: max imm12 shifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max u64 operand (32)
#[test]
fn test_aarch32_sub_sp_i_t2_a_adds_oracle_32_5_f1ad0420() {
    // Test ADDS 32-bit: max u64 operand (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1AD0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF4BE,
        "X0 should be 0x00000000FFFFF4BE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max u64 operand (64)
#[test]
fn test_aarch32_sub_sp_i_t2_a_adds_oracle_64_5_f1ad0420() {
    // Test ADDS 64-bit: max u64 operand (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1AD0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF4BE,
        "X0 should be 0xFFFFFFFFFFFFF4BE"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_sub_sp_i_t2_a_adds_oracle_32_6_f1ad0420() {
    // Test ADDS 32-bit: zero result (for sub 1-1) (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1AD0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF4BF,
        "X0 should be 0xFFFFFFFFFFFFF4BF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_sub_sp_i_t2_a_adds_oracle_64_6_f1ad0420() {
    // Test ADDS 64-bit: zero result (for sub 1-1) (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1AD0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF4BF,
        "X0 should be 0xFFFFFFFFFFFFF4BF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_sub_sp_i_t2_a_adds_oracle_32_7_f1ad0420() {
    // Test ADDS 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1AD0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF4BE,
        "X0 should be 0x00000000FFFFF4BE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_sub_sp_i_t2_a_adds_oracle_64_7_f1ad0420() {
    // Test ADDS 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1AD0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF4BE,
        "X0 should be 0x7FFFFFFFFFFFF4BE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_sub_sp_i_t2_a_adds_oracle_32_8_f1ad0420() {
    // Test ADDS 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF1AD0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x7FFFF4BE,
        "X0 should be 0x000000007FFFF4BE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_sub_sp_i_t2_a_adds_oracle_64_8_f1ad0420() {
    // Test ADDS 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF1AD0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x7FFFF4BE,
        "X0 should be 0x000000007FFFF4BE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_sub_sp_i_t2_a_adds_oracle_32_9_f1ad0420() {
    // Test ADDS 32-bit: unsigned overflow 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1AD0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF4BE,
        "X0 should be 0x00000000FFFFF4BE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_sub_sp_i_t2_a_adds_oracle_64_9_f1ad0420() {
    // Test ADDS 64-bit: unsigned overflow 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1AD0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF4BE,
        "X0 should be 0xFFFFFFFFFFFFF4BE"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_sub_sp_i_t2_a_adds_oracle_32_10_f1ad0420() {
    // Test ADDS 32-bit: unsigned overflow 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1AD0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF4BE,
        "X0 should be 0x00000000FFFFF4BE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_sub_sp_i_t2_a_adds_oracle_64_10_f1ad0420() {
    // Test ADDS 64-bit: unsigned overflow 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1AD0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF4BE,
        "X0 should be 0x00000000FFFFF4BE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `ADDS ZR, X1, #10`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "result discarded, flags set" }
/// ZR destination (32)
#[test]
fn test_aarch32_sub_sp_i_t2_a_adds_oracle_32_rd31_zr_f1ad283f() {
    // Test ADDS 32-bit with Rd=31 (ZR)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF1AD283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `ADDS ZR, X1, #10`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "result discarded, flags set" }
/// ZR destination (64)
#[test]
fn test_aarch32_sub_sp_i_t2_a_adds_oracle_64_rd31_zr_f1ad283f() {
    // Test ADDS 64-bit with Rd=31 (ZR)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF1AD283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `SUB X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_sub_sp_i_t2_a_sub_oracle_32_0_f1ad2820() {
    // Test SUB 32-bit: simple addition/subtraction (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF1AD2820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF51A,
        "X0 should be 0xFFFFFFFFFFFFF51A"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `SUB X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_sub_sp_i_t2_a_sub_oracle_64_0_f1ad2820() {
    // Test SUB 64-bit: simple addition/subtraction (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF1AD2820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF51A,
        "X0 should be 0xFFFFFFFFFFFFF51A"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `SUB X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero operands (32)
#[test]
fn test_aarch32_sub_sp_i_t2_a_sub_oracle_32_1_f1ad0020() {
    // Test SUB 32-bit: zero operands (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1AD0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF4C0,
        "X0 should be 0xFFFFFFFFFFFFF4C0"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `SUB X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero operands (64)
#[test]
fn test_aarch32_sub_sp_i_t2_a_sub_oracle_64_1_f1ad0020() {
    // Test SUB 64-bit: zero operands (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1AD0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF4C0,
        "X0 should be 0xFFFFFFFFFFFFF4C0"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small values (32)
#[test]
fn test_aarch32_sub_sp_i_t2_a_sub_oracle_32_2_f1ad0420() {
    // Test SUB 32-bit: small values (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF1AD0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF4C0,
        "X0 should be 0xFFFFFFFFFFFFF4C0"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// small values (64)
#[test]
fn test_aarch32_sub_sp_i_t2_a_sub_oracle_64_2_f1ad0420() {
    // Test SUB 64-bit: small values (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF1AD0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF4C0,
        "X0 should be 0xFFFFFFFFFFFFF4C0"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `SUB X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_sub_sp_i_t2_a_sub_oracle_32_3_f1bffc20() {
    // Test SUB 32-bit: max imm12 unshifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1BFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `SUB X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_sub_sp_i_t2_a_sub_oracle_64_3_f1bffc20() {
    // Test SUB 64-bit: max imm12 unshifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1BFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `SUB X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_sub_sp_i_t2_a_sub_oracle_32_4_f1fffc20() {
    // Test SUB 32-bit: max imm12 shifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `SUB X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_sub_sp_i_t2_a_sub_oracle_64_4_f1fffc20() {
    // Test SUB 64-bit: max imm12 shifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max u64 operand (32)
#[test]
fn test_aarch32_sub_sp_i_t2_a_sub_oracle_32_5_f1ad0420() {
    // Test SUB 32-bit: max u64 operand (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1AD0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF4BE,
        "X0 should be 0x00000000FFFFF4BE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max u64 operand (64)
#[test]
fn test_aarch32_sub_sp_i_t2_a_sub_oracle_64_5_f1ad0420() {
    // Test SUB 64-bit: max u64 operand (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1AD0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF4BE,
        "X0 should be 0xFFFFFFFFFFFFF4BE"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_sub_sp_i_t2_a_sub_oracle_32_6_f1ad0420() {
    // Test SUB 32-bit: zero result (for sub 1-1) (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1AD0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF4BF,
        "X0 should be 0xFFFFFFFFFFFFF4BF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_sub_sp_i_t2_a_sub_oracle_64_6_f1ad0420() {
    // Test SUB 64-bit: zero result (for sub 1-1) (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1AD0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF4BF,
        "X0 should be 0xFFFFFFFFFFFFF4BF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_sub_sp_i_t2_a_sub_oracle_32_7_f1ad0420() {
    // Test SUB 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1AD0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF4BE,
        "X0 should be 0x00000000FFFFF4BE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_sub_sp_i_t2_a_sub_oracle_64_7_f1ad0420() {
    // Test SUB 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1AD0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF4BE,
        "X0 should be 0x7FFFFFFFFFFFF4BE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_sub_sp_i_t2_a_sub_oracle_32_8_f1ad0420() {
    // Test SUB 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF1AD0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x7FFFF4BE,
        "X0 should be 0x000000007FFFF4BE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_sub_sp_i_t2_a_sub_oracle_64_8_f1ad0420() {
    // Test SUB 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF1AD0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x7FFFF4BE,
        "X0 should be 0x000000007FFFF4BE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_sub_sp_i_t2_a_sub_oracle_32_9_f1ad0420() {
    // Test SUB 32-bit: unsigned overflow 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1AD0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF4BE,
        "X0 should be 0x00000000FFFFF4BE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_sub_sp_i_t2_a_sub_oracle_64_9_f1ad0420() {
    // Test SUB 64-bit: unsigned overflow 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1AD0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF4BE,
        "X0 should be 0xFFFFFFFFFFFFF4BE"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_sub_sp_i_t2_a_sub_oracle_32_10_f1ad0420() {
    // Test SUB 32-bit: unsigned overflow 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1AD0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF4BE,
        "X0 should be 0x00000000FFFFF4BE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_sub_sp_i_t2_a_sub_oracle_64_10_f1ad0420() {
    // Test SUB 64-bit: unsigned overflow 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1AD0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF4BE,
        "X0 should be 0x00000000FFFFF4BE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `SUB SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (32)
#[test]
fn test_aarch32_sub_sp_i_t2_a_sub_oracle_32_rd31_sp_f1ad283f() {
    // Test SUB 32-bit with Rd=31 (SP)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF1AD283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `SUB SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (64)
#[test]
fn test_aarch32_sub_sp_i_t2_a_sub_oracle_64_rd31_sp_f1ad283f() {
    // Test SUB 64-bit with Rd=31 (SP)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF1AD283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `SUBS X0, X1, #10`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_sub_sp_i_t2_a_subs_oracle_32_0_f1ad2820() {
    // Test SUBS 32-bit: simple addition/subtraction (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF1AD2820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF51A,
        "X0 should be 0xFFFFFFFFFFFFF51A"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `SUBS X0, X1, #10`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_sub_sp_i_t2_a_subs_oracle_64_0_f1ad2820() {
    // Test SUBS 64-bit: simple addition/subtraction (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF1AD2820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF51A,
        "X0 should be 0xFFFFFFFFFFFFF51A"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `SUBS X0, X1, #0`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero operands (32)
#[test]
fn test_aarch32_sub_sp_i_t2_a_subs_oracle_32_1_f1ad0020() {
    // Test SUBS 32-bit: zero operands (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1AD0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF4C0,
        "X0 should be 0xFFFFFFFFFFFFF4C0"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `SUBS X0, X1, #0`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero operands (64)
#[test]
fn test_aarch32_sub_sp_i_t2_a_subs_oracle_64_1_f1ad0020() {
    // Test SUBS 64-bit: zero operands (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1AD0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF4C0,
        "X0 should be 0xFFFFFFFFFFFFF4C0"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// small values (32)
#[test]
fn test_aarch32_sub_sp_i_t2_a_subs_oracle_32_2_f1ad0420() {
    // Test SUBS 32-bit: small values (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF1AD0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF4C0,
        "X0 should be 0xFFFFFFFFFFFFF4C0"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// small values (64)
#[test]
fn test_aarch32_sub_sp_i_t2_a_subs_oracle_64_2_f1ad0420() {
    // Test SUBS 64-bit: small values (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF1AD0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF4C0,
        "X0 should be 0xFFFFFFFFFFFFF4C0"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `SUBS X0, X1, #4095`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_sub_sp_i_t2_a_subs_oracle_32_3_f1bffc20() {
    // Test SUBS 32-bit: max imm12 unshifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1BFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `SUBS X0, X1, #4095`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_sub_sp_i_t2_a_subs_oracle_64_3_f1bffc20() {
    // Test SUBS 64-bit: max imm12 unshifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1BFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `SUBS X0, X1, #4095, LSL #12`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_sub_sp_i_t2_a_subs_oracle_32_4_f1fffc20() {
    // Test SUBS 32-bit: max imm12 shifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `SUBS X0, X1, #4095, LSL #12`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_sub_sp_i_t2_a_subs_oracle_64_4_f1fffc20() {
    // Test SUBS 64-bit: max imm12 shifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max u64 operand (32)
#[test]
fn test_aarch32_sub_sp_i_t2_a_subs_oracle_32_5_f1ad0420() {
    // Test SUBS 32-bit: max u64 operand (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1AD0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF4BE,
        "X0 should be 0x00000000FFFFF4BE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max u64 operand (64)
#[test]
fn test_aarch32_sub_sp_i_t2_a_subs_oracle_64_5_f1ad0420() {
    // Test SUBS 64-bit: max u64 operand (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1AD0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF4BE,
        "X0 should be 0xFFFFFFFFFFFFF4BE"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_sub_sp_i_t2_a_subs_oracle_32_6_f1ad0420() {
    // Test SUBS 32-bit: zero result (for sub 1-1) (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1AD0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF4BF,
        "X0 should be 0xFFFFFFFFFFFFF4BF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_sub_sp_i_t2_a_subs_oracle_64_6_f1ad0420() {
    // Test SUBS 64-bit: zero result (for sub 1-1) (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1AD0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF4BF,
        "X0 should be 0xFFFFFFFFFFFFF4BF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_sub_sp_i_t2_a_subs_oracle_32_7_f1ad0420() {
    // Test SUBS 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1AD0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF4BE,
        "X0 should be 0x00000000FFFFF4BE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_sub_sp_i_t2_a_subs_oracle_64_7_f1ad0420() {
    // Test SUBS 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1AD0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF4BE,
        "X0 should be 0x7FFFFFFFFFFFF4BE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_sub_sp_i_t2_a_subs_oracle_32_8_f1ad0420() {
    // Test SUBS 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF1AD0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x7FFFF4BE,
        "X0 should be 0x000000007FFFF4BE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_sub_sp_i_t2_a_subs_oracle_64_8_f1ad0420() {
    // Test SUBS 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF1AD0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x7FFFF4BE,
        "X0 should be 0x000000007FFFF4BE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_sub_sp_i_t2_a_subs_oracle_32_9_f1ad0420() {
    // Test SUBS 32-bit: unsigned overflow 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1AD0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF4BE,
        "X0 should be 0x00000000FFFFF4BE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_sub_sp_i_t2_a_subs_oracle_64_9_f1ad0420() {
    // Test SUBS 64-bit: unsigned overflow 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1AD0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF4BE,
        "X0 should be 0xFFFFFFFFFFFFF4BE"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_sub_sp_i_t2_a_subs_oracle_32_10_f1ad0420() {
    // Test SUBS 32-bit: unsigned overflow 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1AD0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF4BE,
        "X0 should be 0x00000000FFFFF4BE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_sub_sp_i_t2_a_subs_oracle_64_10_f1ad0420() {
    // Test SUBS 64-bit: unsigned overflow 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1AD0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF4BE,
        "X0 should be 0x00000000FFFFF4BE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `SUBS ZR, X1, #10`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "result discarded, flags set" }
/// ZR destination (32)
#[test]
fn test_aarch32_sub_sp_i_t2_a_subs_oracle_32_rd31_zr_f1ad283f() {
    // Test SUBS 32-bit with Rd=31 (ZR)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF1AD283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `SUBS ZR, X1, #10`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "result discarded, flags set" }
/// ZR destination (64)
#[test]
fn test_aarch32_sub_sp_i_t2_a_subs_oracle_64_rd31_zr_f1ad283f() {
    // Test SUBS 64-bit with Rd=31 (ZR)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF1AD283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `SUB.W R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple values
#[test]
fn test_aarch32_sub_sp_i_t2_a_t32_oracle_0_f1ad0000() {
    // Test T32 SUB: simple values (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x32);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF1AD0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x32, "R0 should be 0x00000032");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `SUB.W R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero values
#[test]
fn test_aarch32_sub_sp_i_t2_a_t32_oracle_1_f1ad0000() {
    // Test T32 SUB: zero values (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xF1AD0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `SUB.W R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max value
#[test]
fn test_aarch32_sub_sp_i_t2_a_t32_oracle_2_f1ad0000() {
    // Test T32 SUB: max value (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0xF1AD0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFE, "R0 should be 0xFFFFFFFE");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `SUB.W R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// mixed pattern
#[test]
fn test_aarch32_sub_sp_i_t2_a_t32_oracle_3_f1ad0000() {
    // Test T32 SUB: mixed pattern (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0xABCDEF01);
    let encoding: u32 = 0xF1AD0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x66666777, "R0 should be 0x66666777");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_aarch32_sub_sp_i_t2_a_flags_zeroresult_0_f1bd0000() {
    // Test aarch32_SUB_SP_i_T2_A flag computation: ZeroResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xF1BD0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_aarch32_sub_sp_i_t2_a_flags_zeroresult_1_f1bd0000() {
    // Test aarch32_SUB_SP_i_T2_A flag computation: ZeroResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF1BD0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_aarch32_sub_sp_i_t2_a_flags_negativeresult_2_f1bd0000() {
    // Test aarch32_SUB_SP_i_T2_A flag computation: NegativeResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1BD0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_aarch32_sub_sp_i_t2_a_flags_unsignedoverflow_3_f1bd0000() {
    // Test aarch32_SUB_SP_i_T2_A flag computation: UnsignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1BD0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_aarch32_sub_sp_i_t2_a_flags_unsignedoverflow_4_f1bd0000() {
    // Test aarch32_SUB_SP_i_T2_A flag computation: UnsignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1BD0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_aarch32_sub_sp_i_t2_a_flags_signedoverflow_5_f1bd0000() {
    // Test aarch32_SUB_SP_i_T2_A flag computation: SignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1BD0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_aarch32_sub_sp_i_t2_a_flags_signedoverflow_6_f1bd0000() {
    // Test aarch32_SUB_SP_i_T2_A flag computation: SignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1BD0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_SUB_SP_i_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_aarch32_sub_sp_i_t2_a_flags_positiveresult_7_f1bd0000() {
    // Test aarch32_SUB_SP_i_T2_A flag computation: PositiveResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x32);
    let encoding: u32 = 0xF1BD0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SUB_SP_i_T3_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_aarch32_sub_sp_i_t3_a_flags_zeroresult_0_f2ad0000() {
    // Test aarch32_SUB_SP_i_T3_A flag computation: ZeroResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xF2AD0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SUB_SP_i_T3_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_aarch32_sub_sp_i_t3_a_flags_zeroresult_1_f2ad0000() {
    // Test aarch32_SUB_SP_i_T3_A flag computation: ZeroResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0xF2AD0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SUB_SP_i_T3_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_aarch32_sub_sp_i_t3_a_flags_negativeresult_2_f2ad0000() {
    // Test aarch32_SUB_SP_i_T3_A flag computation: NegativeResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF2AD0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SUB_SP_i_T3_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_aarch32_sub_sp_i_t3_a_flags_unsignedoverflow_3_f2ad0000() {
    // Test aarch32_SUB_SP_i_T3_A flag computation: UnsignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0xF2AD0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SUB_SP_i_T3_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_aarch32_sub_sp_i_t3_a_flags_unsignedoverflow_4_f2ad0000() {
    // Test aarch32_SUB_SP_i_T3_A flag computation: UnsignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2AD0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SUB_SP_i_T3_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_aarch32_sub_sp_i_t3_a_flags_signedoverflow_5_f2ad0000() {
    // Test aarch32_SUB_SP_i_T3_A flag computation: SignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF2AD0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_SUB_SP_i_T3_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_aarch32_sub_sp_i_t3_a_flags_signedoverflow_6_f2ad0000() {
    // Test aarch32_SUB_SP_i_T3_A flag computation: SignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0xF2AD0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_SUB_SP_i_T3_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_aarch32_sub_sp_i_t3_a_flags_positiveresult_7_f2ad0000() {
    // Test aarch32_SUB_SP_i_T3_A flag computation: PositiveResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x32);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF2AD0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

// ============================================================================
// aarch32_RSC_rr_A Tests
// ============================================================================

/// Provenance: aarch32_RSC_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_rsc_rr_a1_a_field_cond_0_min_10_00e00010() {
    // Encoding: 0x00E00010
    // Test aarch32_RSC_rr_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, S=0, Rn=0, Rd=0, cond=0, Rs=0, type1=0
    let encoding: u32 = 0x00E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_rsc_rr_a1_a_field_cond_1_poweroftwo_10_10e00010() {
    // Encoding: 0x10E00010
    // Test aarch32_RSC_rr_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rs=0, type1=0, S=0, Rm=0, Rd=0, cond=1
    let encoding: u32 = 0x10E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_rsc_rr_a1_a_field_cond_2_poweroftwo_10_20e00010() {
    // Encoding: 0x20E00010
    // Test aarch32_RSC_rr_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: type1=0, Rd=0, Rm=0, S=0, cond=2, Rn=0, Rs=0
    let encoding: u32 = 0x20E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_rsc_rr_a1_a_field_cond_3_poweroftwo_10_30e00010() {
    // Encoding: 0x30E00010
    // Test aarch32_RSC_rr_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=3, Rd=0, Rm=0, S=0, Rs=0, type1=0
    let encoding: u32 = 0x30E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_rsc_rr_a1_a_field_cond_4_poweroftwo_10_40e00010() {
    // Encoding: 0x40E00010
    // Test aarch32_RSC_rr_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rs=0, Rm=0, type1=0, cond=4, S=0, Rn=0, Rd=0
    let encoding: u32 = 0x40E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_rsc_rr_a1_a_field_cond_5_poweroftwo_10_50e00010() {
    // Encoding: 0x50E00010
    // Test aarch32_RSC_rr_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rm=0, cond=5, Rs=0, S=0, Rn=0, type1=0
    let encoding: u32 = 0x50E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_rsc_rr_a1_a_field_cond_6_poweroftwo_10_60e00010() {
    // Encoding: 0x60E00010
    // Test aarch32_RSC_rr_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rm=0, type1=0, cond=6, S=0, Rd=0, Rs=0
    let encoding: u32 = 0x60E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_rsc_rr_a1_a_field_cond_7_poweroftwo_10_70e00010() {
    // Encoding: 0x70E00010
    // Test aarch32_RSC_rr_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, cond=7, S=0, type1=0, Rn=0, Rs=0, Rm=0
    let encoding: u32 = 0x70E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_rsc_rr_a1_a_field_cond_8_poweroftwo_10_80e00010() {
    // Encoding: 0x80E00010
    // Test aarch32_RSC_rr_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Rs=0, cond=8, type1=0, Rm=0, Rd=0, Rn=0, S=0
    let encoding: u32 = 0x80E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_rsc_rr_a1_a_field_cond_9_poweroftwo_10_90e00010() {
    // Encoding: 0x90E00010
    // Test aarch32_RSC_rr_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Rd=0, Rs=0, cond=9, Rn=0, type1=0, S=0
    let encoding: u32 = 0x90E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_rsc_rr_a1_a_field_cond_10_poweroftwo_10_a0e00010() {
    // Encoding: 0xA0E00010
    // Test aarch32_RSC_rr_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=10, Rd=0, Rn=0, S=0, Rs=0, type1=0, Rm=0
    let encoding: u32 = 0xA0E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_rsc_rr_a1_a_field_cond_11_poweroftwo_10_b0e00010() {
    // Encoding: 0xB0E00010
    // Test aarch32_RSC_rr_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, Rd=0, Rs=0, type1=0, Rm=0, Rn=0, cond=11
    let encoding: u32 = 0xB0E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_rsc_rr_a1_a_field_cond_12_poweroftwo_10_c0e00010() {
    // Encoding: 0xC0E00010
    // Test aarch32_RSC_rr_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rs=0, type1=0, Rm=0, S=0, cond=12, Rn=0
    let encoding: u32 = 0xC0E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_rsc_rr_a1_a_field_cond_13_poweroftwo_10_d0e00010() {
    // Encoding: 0xD0E00010
    // Test aarch32_RSC_rr_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: type1=0, Rm=0, cond=13, S=0, Rn=0, Rd=0, Rs=0
    let encoding: u32 = 0xD0E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_rsc_rr_a1_a_field_cond_14_poweroftwo_10_e0e00010() {
    // Encoding: 0xE0E00010
    // Test aarch32_RSC_rr_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=14, Rm=0, S=0, Rn=0, Rs=0, type1=0, Rd=0
    let encoding: u32 = 0xE0E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_rsc_rr_a1_a_field_cond_15_max_10_f0e00010() {
    // Encoding: 0xF0E00010
    // Test aarch32_RSC_rr_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: Rd=0, Rs=0, type1=0, Rm=0, cond=15, S=0, Rn=0
    let encoding: u32 = 0xF0E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_rr_A1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_rsc_rr_a1_a_field_s_0_min_10_00e00010() {
    // Encoding: 0x00E00010
    // Test aarch32_RSC_rr_A1_A field S = 0 (Min)
    // ISET: A32
    // Fields: type1=0, Rm=0, cond=0, S=0, Rs=0, Rd=0, Rn=0
    let encoding: u32 = 0x00E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_rr_A1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_rsc_rr_a1_a_field_s_1_max_10_00f00010() {
    // Encoding: 0x00F00010
    // Test aarch32_RSC_rr_A1_A field S = 1 (Max)
    // ISET: A32
    // Fields: Rm=0, Rd=0, Rn=0, cond=0, S=1, Rs=0, type1=0
    let encoding: u32 = 0x00F00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_rr_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_rsc_rr_a1_a_field_rn_0_min_10_00e00010() {
    // Encoding: 0x00E00010
    // Test aarch32_RSC_rr_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: type1=0, S=0, Rm=0, cond=0, Rd=0, Rn=0, Rs=0
    let encoding: u32 = 0x00E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_rr_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_rsc_rr_a1_a_field_rn_1_poweroftwo_10_00e10010() {
    // Encoding: 0x00E10010
    // Test aarch32_RSC_rr_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rs=0, Rd=0, cond=0, S=0, Rn=1, type1=0, Rm=0
    let encoding: u32 = 0x00E10010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_rr_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_rsc_rr_a1_a_field_rd_0_min_10_00e00010() {
    // Encoding: 0x00E00010
    // Test aarch32_RSC_rr_A1_A field Rd = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, Rm=0, S=0, Rd=0, Rs=0, cond=0, type1=0
    let encoding: u32 = 0x00E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_rr_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_rsc_rr_a1_a_field_rd_1_poweroftwo_10_00e01010() {
    // Encoding: 0x00E01010
    // Test aarch32_RSC_rr_A1_A field Rd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: type1=0, Rm=0, S=0, Rn=0, cond=0, Rd=1, Rs=0
    let encoding: u32 = 0x00E01010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_rr_A1_A
/// ASL: `field Rs 8 +: 4`
/// Requirement: FieldBoundary { field: "Rs", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_rsc_rr_a1_a_field_rs_0_min_10_00e00010() {
    // Encoding: 0x00E00010
    // Test aarch32_RSC_rr_A1_A field Rs = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, cond=0, S=0, Rd=0, Rs=0, type1=0, Rm=0
    let encoding: u32 = 0x00E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_rr_A1_A
/// ASL: `field Rs 8 +: 4`
/// Requirement: FieldBoundary { field: "Rs", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_rsc_rr_a1_a_field_rs_1_poweroftwo_10_00e00110() {
    // Encoding: 0x00E00110
    // Test aarch32_RSC_rr_A1_A field Rs = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, Rm=0, Rn=0, cond=0, Rd=0, Rs=1, type1=0
    let encoding: u32 = 0x00E00110;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_rr_A1_A
/// ASL: `field type1 5 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_rsc_rr_a1_a_field_type1_0_min_10_00e00010() {
    // Encoding: 0x00E00010
    // Test aarch32_RSC_rr_A1_A field type1 = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rn=0, type1=0, Rd=0, S=0, Rs=0, Rm=0
    let encoding: u32 = 0x00E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_rr_A1_A
/// ASL: `field type1 5 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_rsc_rr_a1_a_field_type1_1_poweroftwo_10_00e00030() {
    // Encoding: 0x00E00030
    // Test aarch32_RSC_rr_A1_A field type1 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: type1=1, Rs=0, S=0, Rm=0, Rd=0, Rn=0, cond=0
    let encoding: u32 = 0x00E00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_rr_A1_A
/// ASL: `field type1 5 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_aarch32_rsc_rr_a1_a_field_type1_3_max_10_00e00070() {
    // Encoding: 0x00E00070
    // Test aarch32_RSC_rr_A1_A field type1 = 3 (Max)
    // ISET: A32
    // Fields: Rs=0, Rn=0, type1=3, Rm=0, S=0, cond=0, Rd=0
    let encoding: u32 = 0x00E00070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_rr_A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_rsc_rr_a1_a_field_rm_0_min_10_00e00010() {
    // Encoding: 0x00E00010
    // Test aarch32_RSC_rr_A1_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: type1=0, Rm=0, Rn=0, cond=0, S=0, Rd=0, Rs=0
    let encoding: u32 = 0x00E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_rr_A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_rsc_rr_a1_a_field_rm_1_poweroftwo_10_00e00011() {
    // Encoding: 0x00E00011
    // Test aarch32_RSC_rr_A1_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=1, cond=0, Rd=0, type1=0, S=0, Rs=0, Rn=0
    let encoding: u32 = 0x00E00011;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_rr_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_rsc_rr_a1_a_combo_0_10_00e00010() {
    // Encoding: 0x00E00010
    // Test aarch32_RSC_rr_A1_A field combination: cond=0, S=0, Rn=0, Rd=0, Rs=0, type1=0, Rm=0
    // ISET: A32
    // Fields: Rn=0, cond=0, S=0, Rs=0, Rd=0, type1=0, Rm=0
    let encoding: u32 = 0x00E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_rr_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_rsc_rr_a1_a_special_cond_0_condition_eq_16_00e00010() {
    // Encoding: 0x00E00010
    // Test aarch32_RSC_rr_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: Rs=0, Rn=0, cond=0, Rd=0, S=0, type1=0, Rm=0
    let encoding: u32 = 0x00E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_rr_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_rsc_rr_a1_a_special_cond_1_condition_ne_16_10e00010() {
    // Encoding: 0x10E00010
    // Test aarch32_RSC_rr_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: S=0, cond=1, type1=0, Rn=0, Rs=0, Rm=0, Rd=0
    let encoding: u32 = 0x10E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_rr_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_rsc_rr_a1_a_special_cond_2_condition_cs_hs_16_20e00010() {
    // Encoding: 0x20E00010
    // Test aarch32_RSC_rr_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: S=0, Rn=0, Rd=0, Rs=0, cond=2, type1=0, Rm=0
    let encoding: u32 = 0x20E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_rr_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_rsc_rr_a1_a_special_cond_3_condition_cc_lo_16_30e00010() {
    // Encoding: 0x30E00010
    // Test aarch32_RSC_rr_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: Rd=0, Rs=0, type1=0, Rm=0, Rn=0, cond=3, S=0
    let encoding: u32 = 0x30E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_rr_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_rsc_rr_a1_a_special_cond_4_condition_mi_16_40e00010() {
    // Encoding: 0x40E00010
    // Test aarch32_RSC_rr_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: cond=4, type1=0, Rn=0, Rs=0, Rd=0, Rm=0, S=0
    let encoding: u32 = 0x40E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_rr_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_rsc_rr_a1_a_special_cond_5_condition_pl_16_50e00010() {
    // Encoding: 0x50E00010
    // Test aarch32_RSC_rr_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: S=0, cond=5, Rd=0, Rs=0, Rm=0, type1=0, Rn=0
    let encoding: u32 = 0x50E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_rr_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_rsc_rr_a1_a_special_cond_6_condition_vs_16_60e00010() {
    // Encoding: 0x60E00010
    // Test aarch32_RSC_rr_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: Rn=0, Rs=0, Rd=0, Rm=0, cond=6, type1=0, S=0
    let encoding: u32 = 0x60E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_rr_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_rsc_rr_a1_a_special_cond_7_condition_vc_16_70e00010() {
    // Encoding: 0x70E00010
    // Test aarch32_RSC_rr_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: S=0, Rm=0, Rs=0, Rd=0, type1=0, cond=7, Rn=0
    let encoding: u32 = 0x70E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_rr_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_rsc_rr_a1_a_special_cond_8_condition_hi_16_80e00010() {
    // Encoding: 0x80E00010
    // Test aarch32_RSC_rr_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: cond=8, Rd=0, Rs=0, Rn=0, S=0, Rm=0, type1=0
    let encoding: u32 = 0x80E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_rr_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_rsc_rr_a1_a_special_cond_9_condition_ls_16_90e00010() {
    // Encoding: 0x90E00010
    // Test aarch32_RSC_rr_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: cond=9, S=0, type1=0, Rd=0, Rn=0, Rs=0, Rm=0
    let encoding: u32 = 0x90E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_rr_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_rsc_rr_a1_a_special_cond_10_condition_ge_16_a0e00010() {
    // Encoding: 0xA0E00010
    // Test aarch32_RSC_rr_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: Rs=0, cond=10, type1=0, Rd=0, Rm=0, S=0, Rn=0
    let encoding: u32 = 0xA0E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_rr_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_rsc_rr_a1_a_special_cond_11_condition_lt_16_b0e00010() {
    // Encoding: 0xB0E00010
    // Test aarch32_RSC_rr_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: Rm=0, type1=0, Rs=0, Rn=0, S=0, cond=11, Rd=0
    let encoding: u32 = 0xB0E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_rr_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_rsc_rr_a1_a_special_cond_12_condition_gt_16_c0e00010() {
    // Encoding: 0xC0E00010
    // Test aarch32_RSC_rr_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: Rm=0, cond=12, Rs=0, Rn=0, type1=0, Rd=0, S=0
    let encoding: u32 = 0xC0E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_rr_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_rsc_rr_a1_a_special_cond_13_condition_le_16_d0e00010() {
    // Encoding: 0xD0E00010
    // Test aarch32_RSC_rr_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: S=0, type1=0, Rm=0, Rn=0, Rd=0, cond=13, Rs=0
    let encoding: u32 = 0xD0E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_rr_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_rsc_rr_a1_a_special_cond_14_condition_al_16_e0e00010() {
    // Encoding: 0xE0E00010
    // Test aarch32_RSC_rr_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: Rn=0, S=0, cond=14, Rd=0, Rm=0, type1=0, Rs=0
    let encoding: u32 = 0xE0E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_rr_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_rsc_rr_a1_a_special_cond_15_condition_nv_16_f0e00010() {
    // Encoding: 0xF0E00010
    // Test aarch32_RSC_rr_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: Rd=0, Rs=0, S=0, type1=0, Rn=0, Rm=0, cond=15
    let encoding: u32 = 0xF0E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_rr_A1_A
/// ASL: `field S = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "S", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_rsc_rr_a1_a_special_s_0_size_variant_0_16_00e00010() {
    // Encoding: 0x00E00010
    // Test aarch32_RSC_rr_A1_A special value S = 0 (Size variant 0)
    // ISET: A32
    // Fields: Rm=0, cond=0, Rn=0, S=0, Rd=0, Rs=0, type1=0
    let encoding: u32 = 0x00E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_rr_A1_A
/// ASL: `field S = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "S", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_rsc_rr_a1_a_special_s_1_size_variant_1_16_00f00010() {
    // Encoding: 0x00F00010
    // Test aarch32_RSC_rr_A1_A special value S = 1 (Size variant 1)
    // ISET: A32
    // Fields: cond=0, Rd=0, Rn=0, S=1, type1=0, Rm=0, Rs=0
    let encoding: u32 = 0x00F00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_rr_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "s" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"s\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_rsc_rr_a1_a_invalid_0_10_00e00010() {
    // Encoding: 0x00E00010
    // Test aarch32_RSC_rr_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "s" }) } }, rhs: LitInt(15) }
    // ISET: A32
    // Fields: Rm=0, Rd=0, cond=0, type1=0, Rn=0, S=0, Rs=0
    let encoding: u32 = 0x00E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_RSC_rr_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_rsc_rr_a1_a_invalid_1_10_00e00010() {
    // Encoding: 0x00E00010
    // Test aarch32_RSC_rr_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: cond=0, Rs=0, type1=0, Rm=0, Rd=0, S=0, Rn=0
    let encoding: u32 = 0x00E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_RSC_rr_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_aarch32_rsc_rr_a1_a_flags_zeroresult_0_00f10012() {
    // Test aarch32_RSC_rr_A1_A flag computation: ZeroResult
    // Encoding: 0x00F10012
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x00F10012;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_RSC_rr_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_aarch32_rsc_rr_a1_a_flags_zeroresult_1_00f10012() {
    // Test aarch32_RSC_rr_A1_A flag computation: ZeroResult
    // Encoding: 0x00F10012
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x00F10012;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_RSC_rr_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_aarch32_rsc_rr_a1_a_flags_negativeresult_2_00f10012() {
    // Test aarch32_RSC_rr_A1_A flag computation: NegativeResult
    // Encoding: 0x00F10012
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x00F10012;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_RSC_rr_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_aarch32_rsc_rr_a1_a_flags_unsignedoverflow_3_00f10012() {
    // Test aarch32_RSC_rr_A1_A flag computation: UnsignedOverflow
    // Encoding: 0x00F10012
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x00F10012;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_RSC_rr_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_aarch32_rsc_rr_a1_a_flags_unsignedoverflow_4_00f10012() {
    // Test aarch32_RSC_rr_A1_A flag computation: UnsignedOverflow
    // Encoding: 0x00F10012
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x00F10012;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_RSC_rr_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_aarch32_rsc_rr_a1_a_flags_signedoverflow_5_00f10012() {
    // Test aarch32_RSC_rr_A1_A flag computation: SignedOverflow
    // Encoding: 0x00F10012
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x00F10012;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_RSC_rr_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_aarch32_rsc_rr_a1_a_flags_signedoverflow_6_00f10012() {
    // Test aarch32_RSC_rr_A1_A flag computation: SignedOverflow
    // Encoding: 0x00F10012
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x00F10012;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_RSC_rr_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_aarch32_rsc_rr_a1_a_flags_positiveresult_7_00f10012() {
    // Test aarch32_RSC_rr_A1_A flag computation: PositiveResult
    // Encoding: 0x00F10012
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x32);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x00F10012;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

// ============================================================================
// aarch32_ADD_SP_i_A Tests
// ============================================================================

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_add_sp_i_a1_a_field_cond_0_min_0_028d0000() {
    // Encoding: 0x028D0000
    // Test aarch32_ADD_SP_i_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: imm12=0, S=0, cond=0, Rd=0
    let encoding: u32 = 0x028D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_add_sp_i_a1_a_field_cond_1_poweroftwo_0_128d0000() {
    // Encoding: 0x128D0000
    // Test aarch32_ADD_SP_i_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=1, imm12=0, Rd=0, S=0
    let encoding: u32 = 0x128D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_add_sp_i_a1_a_field_cond_2_poweroftwo_0_228d0000() {
    // Encoding: 0x228D0000
    // Test aarch32_ADD_SP_i_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=0, Rd=0, cond=2, S=0
    let encoding: u32 = 0x228D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_add_sp_i_a1_a_field_cond_3_poweroftwo_0_328d0000() {
    // Encoding: 0x328D0000
    // Test aarch32_ADD_SP_i_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, S=0, imm12=0, cond=3
    let encoding: u32 = 0x328D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_add_sp_i_a1_a_field_cond_4_poweroftwo_0_428d0000() {
    // Encoding: 0x428D0000
    // Test aarch32_ADD_SP_i_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, cond=4, imm12=0, S=0
    let encoding: u32 = 0x428D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_add_sp_i_a1_a_field_cond_5_poweroftwo_0_528d0000() {
    // Encoding: 0x528D0000
    // Test aarch32_ADD_SP_i_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, cond=5, S=0, imm12=0
    let encoding: u32 = 0x528D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_add_sp_i_a1_a_field_cond_6_poweroftwo_0_628d0000() {
    // Encoding: 0x628D0000
    // Test aarch32_ADD_SP_i_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=6, imm12=0, S=0, Rd=0
    let encoding: u32 = 0x628D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_add_sp_i_a1_a_field_cond_7_poweroftwo_0_728d0000() {
    // Encoding: 0x728D0000
    // Test aarch32_ADD_SP_i_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, imm12=0, S=0, cond=7
    let encoding: u32 = 0x728D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_add_sp_i_a1_a_field_cond_8_poweroftwo_0_828d0000() {
    // Encoding: 0x828D0000
    // Test aarch32_ADD_SP_i_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, cond=8, S=0, imm12=0
    let encoding: u32 = 0x828D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_add_sp_i_a1_a_field_cond_9_poweroftwo_0_928d0000() {
    // Encoding: 0x928D0000
    // Test aarch32_ADD_SP_i_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, imm12=0, cond=9, S=0
    let encoding: u32 = 0x928D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_add_sp_i_a1_a_field_cond_10_poweroftwo_0_a28d0000() {
    // Encoding: 0xA28D0000
    // Test aarch32_ADD_SP_i_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=10, S=0, Rd=0, imm12=0
    let encoding: u32 = 0xA28D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_add_sp_i_a1_a_field_cond_11_poweroftwo_0_b28d0000() {
    // Encoding: 0xB28D0000
    // Test aarch32_ADD_SP_i_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=11, imm12=0, Rd=0, S=0
    let encoding: u32 = 0xB28D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_add_sp_i_a1_a_field_cond_12_poweroftwo_0_c28d0000() {
    // Encoding: 0xC28D0000
    // Test aarch32_ADD_SP_i_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=0, Rd=0, cond=12, S=0
    let encoding: u32 = 0xC28D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_add_sp_i_a1_a_field_cond_13_poweroftwo_0_d28d0000() {
    // Encoding: 0xD28D0000
    // Test aarch32_ADD_SP_i_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=13, Rd=0, S=0, imm12=0
    let encoding: u32 = 0xD28D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_add_sp_i_a1_a_field_cond_14_poweroftwo_0_e28d0000() {
    // Encoding: 0xE28D0000
    // Test aarch32_ADD_SP_i_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=14, Rd=0, imm12=0, S=0
    let encoding: u32 = 0xE28D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_add_sp_i_a1_a_field_cond_15_max_0_f28d0000() {
    // Encoding: 0xF28D0000
    // Test aarch32_ADD_SP_i_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: S=0, imm12=0, Rd=0, cond=15
    let encoding: u32 = 0xF28D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_add_sp_i_a1_a_field_s_0_min_0_028d0000() {
    // Encoding: 0x028D0000
    // Test aarch32_ADD_SP_i_A1_A field S = 0 (Min)
    // ISET: A32
    // Fields: Rd=0, cond=0, S=0, imm12=0
    let encoding: u32 = 0x028D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_add_sp_i_a1_a_field_s_1_max_0_029d0000() {
    // Encoding: 0x029D0000
    // Test aarch32_ADD_SP_i_A1_A field S = 1 (Max)
    // ISET: A32
    // Fields: Rd=0, cond=0, imm12=0, S=1
    let encoding: u32 = 0x029D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_add_sp_i_a1_a_field_rd_0_min_0_028d0000() {
    // Encoding: 0x028D0000
    // Test aarch32_ADD_SP_i_A1_A field Rd = 0 (Min)
    // ISET: A32
    // Fields: S=0, Rd=0, cond=0, imm12=0
    let encoding: u32 = 0x028D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_add_sp_i_a1_a_field_rd_1_poweroftwo_0_028d1000() {
    // Encoding: 0x028D1000
    // Test aarch32_ADD_SP_i_A1_A field Rd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, imm12=0, S=0, Rd=1
    let encoding: u32 = 0x028D1000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_add_sp_i_a1_a_field_imm12_0_zero_0_028d0000() {
    // Encoding: 0x028D0000
    // Test aarch32_ADD_SP_i_A1_A field imm12 = 0 (Zero)
    // ISET: A32
    // Fields: imm12=0, S=0, Rd=0, cond=0
    let encoding: u32 = 0x028D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_add_sp_i_a1_a_field_imm12_1_poweroftwo_0_028d0001() {
    // Encoding: 0x028D0001
    // Test aarch32_ADD_SP_i_A1_A field imm12 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, S=0, cond=0, imm12=1
    let encoding: u32 = 0x028D0001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_add_sp_i_a1_a_field_imm12_3_poweroftwominusone_0_028d0003() {
    // Encoding: 0x028D0003
    // Test aarch32_ADD_SP_i_A1_A field imm12 = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, S=0, imm12=3, Rd=0
    let encoding: u32 = 0x028D0003;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_add_sp_i_a1_a_field_imm12_4_poweroftwo_0_028d0004() {
    // Encoding: 0x028D0004
    // Test aarch32_ADD_SP_i_A1_A field imm12 = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, imm12=4, cond=0, S=0
    let encoding: u32 = 0x028D0004;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_add_sp_i_a1_a_field_imm12_7_poweroftwominusone_0_028d0007() {
    // Encoding: 0x028D0007
    // Test aarch32_ADD_SP_i_A1_A field imm12 = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, S=0, Rd=0, imm12=7
    let encoding: u32 = 0x028D0007;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_add_sp_i_a1_a_field_imm12_8_poweroftwo_0_028d0008() {
    // Encoding: 0x028D0008
    // Test aarch32_ADD_SP_i_A1_A field imm12 = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, Rd=0, cond=0, imm12=8
    let encoding: u32 = 0x028D0008;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_add_sp_i_a1_a_field_imm12_15_poweroftwominusone_0_028d000f() {
    // Encoding: 0x028D000F
    // Test aarch32_ADD_SP_i_A1_A field imm12 = 15 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, S=0, Rd=0, imm12=15
    let encoding: u32 = 0x028D000F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_add_sp_i_a1_a_field_imm12_16_poweroftwo_0_028d0010() {
    // Encoding: 0x028D0010
    // Test aarch32_ADD_SP_i_A1_A field imm12 = 16 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, S=0, Rd=0, imm12=16
    let encoding: u32 = 0x028D0010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_add_sp_i_a1_a_field_imm12_31_poweroftwominusone_0_028d001f() {
    // Encoding: 0x028D001F
    // Test aarch32_ADD_SP_i_A1_A field imm12 = 31 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm12=31, S=0, Rd=0, cond=0
    let encoding: u32 = 0x028D001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_add_sp_i_a1_a_field_imm12_32_poweroftwo_0_028d0020() {
    // Encoding: 0x028D0020
    // Test aarch32_ADD_SP_i_A1_A field imm12 = 32 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, S=0, cond=0, imm12=32
    let encoding: u32 = 0x028D0020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_add_sp_i_a1_a_field_imm12_63_poweroftwominusone_0_028d003f() {
    // Encoding: 0x028D003F
    // Test aarch32_ADD_SP_i_A1_A field imm12 = 63 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rd=0, cond=0, imm12=63, S=0
    let encoding: u32 = 0x028D003F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_add_sp_i_a1_a_field_imm12_64_poweroftwo_0_028d0040() {
    // Encoding: 0x028D0040
    // Test aarch32_ADD_SP_i_A1_A field imm12 = 64 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, imm12=64, Rd=0, cond=0
    let encoding: u32 = 0x028D0040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 127, boundary: PowerOfTwoMinusOne }
/// 2^7 - 1 = 127
#[test]
fn test_aarch32_add_sp_i_a1_a_field_imm12_127_poweroftwominusone_0_028d007f() {
    // Encoding: 0x028D007F
    // Test aarch32_ADD_SP_i_A1_A field imm12 = 127 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: S=0, imm12=127, Rd=0, cond=0
    let encoding: u32 = 0x028D007F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_add_sp_i_a1_a_field_imm12_128_poweroftwo_0_028d0080() {
    // Encoding: 0x028D0080
    // Test aarch32_ADD_SP_i_A1_A field imm12 = 128 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, cond=0, imm12=128, S=0
    let encoding: u32 = 0x028D0080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 255, boundary: PowerOfTwoMinusOne }
/// 2^8 - 1 = 255
#[test]
fn test_aarch32_add_sp_i_a1_a_field_imm12_255_poweroftwominusone_0_028d00ff() {
    // Encoding: 0x028D00FF
    // Test aarch32_ADD_SP_i_A1_A field imm12 = 255 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, S=0, Rd=0, imm12=255
    let encoding: u32 = 0x028D00FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 256, boundary: PowerOfTwo }
/// power of 2 (2^8 = 256)
#[test]
fn test_aarch32_add_sp_i_a1_a_field_imm12_256_poweroftwo_0_028d0100() {
    // Encoding: 0x028D0100
    // Test aarch32_ADD_SP_i_A1_A field imm12 = 256 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, S=0, imm12=256, Rd=0
    let encoding: u32 = 0x028D0100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 511, boundary: PowerOfTwoMinusOne }
/// 2^9 - 1 = 511
#[test]
fn test_aarch32_add_sp_i_a1_a_field_imm12_511_poweroftwominusone_0_028d01ff() {
    // Encoding: 0x028D01FF
    // Test aarch32_ADD_SP_i_A1_A field imm12 = 511 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm12=511, Rd=0, S=0, cond=0
    let encoding: u32 = 0x028D01FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 512, boundary: PowerOfTwo }
/// power of 2 (2^9 = 512)
#[test]
fn test_aarch32_add_sp_i_a1_a_field_imm12_512_poweroftwo_0_028d0200() {
    // Encoding: 0x028D0200
    // Test aarch32_ADD_SP_i_A1_A field imm12 = 512 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=512, S=0, cond=0, Rd=0
    let encoding: u32 = 0x028D0200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1023, boundary: PowerOfTwoMinusOne }
/// 2^10 - 1 = 1023
#[test]
fn test_aarch32_add_sp_i_a1_a_field_imm12_1023_poweroftwominusone_0_028d03ff() {
    // Encoding: 0x028D03FF
    // Test aarch32_ADD_SP_i_A1_A field imm12 = 1023 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rd=0, S=0, imm12=1023, cond=0
    let encoding: u32 = 0x028D03FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1024, boundary: PowerOfTwo }
/// power of 2 (2^10 = 1024)
#[test]
fn test_aarch32_add_sp_i_a1_a_field_imm12_1024_poweroftwo_0_028d0400() {
    // Encoding: 0x028D0400
    // Test aarch32_ADD_SP_i_A1_A field imm12 = 1024 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, S=0, Rd=0, imm12=1024
    let encoding: u32 = 0x028D0400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2047, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (2047)
#[test]
fn test_aarch32_add_sp_i_a1_a_field_imm12_2047_poweroftwominusone_0_028d07ff() {
    // Encoding: 0x028D07FF
    // Test aarch32_ADD_SP_i_A1_A field imm12 = 2047 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm12=2047, cond=0, S=0, Rd=0
    let encoding: u32 = 0x028D07FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2048, boundary: PowerOfTwo }
/// power of 2 (2^11 = 2048)
#[test]
fn test_aarch32_add_sp_i_a1_a_field_imm12_2048_poweroftwo_0_028d0800() {
    // Encoding: 0x028D0800
    // Test aarch32_ADD_SP_i_A1_A field imm12 = 2048 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, imm12=2048, cond=0, Rd=0
    let encoding: u32 = 0x028D0800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4095, boundary: Max }
/// maximum immediate (4095)
#[test]
fn test_aarch32_add_sp_i_a1_a_field_imm12_4095_max_0_028d0fff() {
    // Encoding: 0x028D0FFF
    // Test aarch32_ADD_SP_i_A1_A field imm12 = 4095 (Max)
    // ISET: A32
    // Fields: cond=0, imm12=4095, S=0, Rd=0
    let encoding: u32 = 0x028D0FFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_add_sp_i_a1_a_combo_0_0_028d0000() {
    // Encoding: 0x028D0000
    // Test aarch32_ADD_SP_i_A1_A field combination: cond=0, S=0, Rd=0, imm12=0
    // ISET: A32
    // Fields: cond=0, Rd=0, S=0, imm12=0
    let encoding: u32 = 0x028D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_add_sp_i_a1_a_special_cond_0_condition_eq_0_028d0000() {
    // Encoding: 0x028D0000
    // Test aarch32_ADD_SP_i_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: S=0, imm12=0, Rd=0, cond=0
    let encoding: u32 = 0x028D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_add_sp_i_a1_a_special_cond_1_condition_ne_0_128d0000() {
    // Encoding: 0x128D0000
    // Test aarch32_ADD_SP_i_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: Rd=0, S=0, imm12=0, cond=1
    let encoding: u32 = 0x128D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_add_sp_i_a1_a_special_cond_2_condition_cs_hs_0_228d0000() {
    // Encoding: 0x228D0000
    // Test aarch32_ADD_SP_i_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: S=0, cond=2, Rd=0, imm12=0
    let encoding: u32 = 0x228D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_add_sp_i_a1_a_special_cond_3_condition_cc_lo_0_328d0000() {
    // Encoding: 0x328D0000
    // Test aarch32_ADD_SP_i_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: Rd=0, imm12=0, cond=3, S=0
    let encoding: u32 = 0x328D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_add_sp_i_a1_a_special_cond_4_condition_mi_0_428d0000() {
    // Encoding: 0x428D0000
    // Test aarch32_ADD_SP_i_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: cond=4, S=0, imm12=0, Rd=0
    let encoding: u32 = 0x428D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_add_sp_i_a1_a_special_cond_5_condition_pl_0_528d0000() {
    // Encoding: 0x528D0000
    // Test aarch32_ADD_SP_i_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: Rd=0, imm12=0, S=0, cond=5
    let encoding: u32 = 0x528D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_add_sp_i_a1_a_special_cond_6_condition_vs_0_628d0000() {
    // Encoding: 0x628D0000
    // Test aarch32_ADD_SP_i_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: imm12=0, Rd=0, cond=6, S=0
    let encoding: u32 = 0x628D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_add_sp_i_a1_a_special_cond_7_condition_vc_0_728d0000() {
    // Encoding: 0x728D0000
    // Test aarch32_ADD_SP_i_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: S=0, imm12=0, Rd=0, cond=7
    let encoding: u32 = 0x728D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_add_sp_i_a1_a_special_cond_8_condition_hi_0_828d0000() {
    // Encoding: 0x828D0000
    // Test aarch32_ADD_SP_i_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: S=0, Rd=0, imm12=0, cond=8
    let encoding: u32 = 0x828D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_add_sp_i_a1_a_special_cond_9_condition_ls_0_928d0000() {
    // Encoding: 0x928D0000
    // Test aarch32_ADD_SP_i_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: imm12=0, cond=9, S=0, Rd=0
    let encoding: u32 = 0x928D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_add_sp_i_a1_a_special_cond_10_condition_ge_0_a28d0000() {
    // Encoding: 0xA28D0000
    // Test aarch32_ADD_SP_i_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: cond=10, Rd=0, imm12=0, S=0
    let encoding: u32 = 0xA28D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_add_sp_i_a1_a_special_cond_11_condition_lt_0_b28d0000() {
    // Encoding: 0xB28D0000
    // Test aarch32_ADD_SP_i_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: imm12=0, cond=11, Rd=0, S=0
    let encoding: u32 = 0xB28D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_add_sp_i_a1_a_special_cond_12_condition_gt_0_c28d0000() {
    // Encoding: 0xC28D0000
    // Test aarch32_ADD_SP_i_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: Rd=0, S=0, cond=12, imm12=0
    let encoding: u32 = 0xC28D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_add_sp_i_a1_a_special_cond_13_condition_le_0_d28d0000() {
    // Encoding: 0xD28D0000
    // Test aarch32_ADD_SP_i_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: cond=13, Rd=0, S=0, imm12=0
    let encoding: u32 = 0xD28D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_add_sp_i_a1_a_special_cond_14_condition_al_0_e28d0000() {
    // Encoding: 0xE28D0000
    // Test aarch32_ADD_SP_i_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: cond=14, Rd=0, imm12=0, S=0
    let encoding: u32 = 0xE28D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_add_sp_i_a1_a_special_cond_15_condition_nv_0_f28d0000() {
    // Encoding: 0xF28D0000
    // Test aarch32_ADD_SP_i_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: cond=15, Rd=0, S=0, imm12=0
    let encoding: u32 = 0xF28D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `field S = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "S", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_add_sp_i_a1_a_special_s_0_size_variant_0_0_028d0000() {
    // Encoding: 0x028D0000
    // Test aarch32_ADD_SP_i_A1_A special value S = 0 (Size variant 0)
    // ISET: A32
    // Fields: Rd=0, S=0, cond=0, imm12=0
    let encoding: u32 = 0x028D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `field S = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "S", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_add_sp_i_a1_a_special_s_1_size_variant_1_0_029d0000() {
    // Encoding: 0x029D0000
    // Test aarch32_ADD_SP_i_A1_A special value S = 1 (Size variant 1)
    // ISET: A32
    // Fields: cond=0, S=1, imm12=0, Rd=0
    let encoding: u32 = 0x029D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADD_SP_i_T1_A
/// ASL: `field Rd 24 +: 3`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_add_sp_i_t1_a_field_rd_0_min_0_a8000000() {
    // Thumb encoding (32): 0xA8000000
    // Test aarch32_ADD_SP_i_T1_A field Rd = 0 (Min)
    // ISET: T32
    // Fields: Rd=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xA8000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_i_T1_A
/// ASL: `field Rd 24 +: 3`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_add_sp_i_t1_a_field_rd_1_poweroftwo_0_a9000000() {
    // Thumb encoding (32): 0xA9000000
    // Test aarch32_ADD_SP_i_T1_A field Rd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=0, Rd=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xA9000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_i_T1_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_add_sp_i_t1_a_field_imm8_0_zero_0_a8000000() {
    // Thumb encoding (32): 0xA8000000
    // Test aarch32_ADD_SP_i_T1_A field imm8 = 0 (Zero)
    // ISET: T32
    // Fields: imm8=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xA8000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_i_T1_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_add_sp_i_t1_a_field_imm8_1_poweroftwo_0_a8010000() {
    // Thumb encoding (32): 0xA8010000
    // Test aarch32_ADD_SP_i_T1_A field imm8 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rd=0, imm8=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xA8010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_i_T1_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_add_sp_i_t1_a_field_imm8_3_poweroftwominusone_0_a8030000() {
    // Thumb encoding (32): 0xA8030000
    // Test aarch32_ADD_SP_i_T1_A field imm8 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rd=0, imm8=3
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xA8030000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_i_T1_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_add_sp_i_t1_a_field_imm8_4_poweroftwo_0_a8040000() {
    // Thumb encoding (32): 0xA8040000
    // Test aarch32_ADD_SP_i_T1_A field imm8 = 4 (PowerOfTwo)
    // ISET: T32
    // Fields: Rd=0, imm8=4
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xA8040000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_i_T1_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_add_sp_i_t1_a_field_imm8_7_poweroftwominusone_0_a8070000() {
    // Thumb encoding (32): 0xA8070000
    // Test aarch32_ADD_SP_i_T1_A field imm8 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rd=0, imm8=7
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xA8070000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_i_T1_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_add_sp_i_t1_a_field_imm8_8_poweroftwo_0_a8080000() {
    // Thumb encoding (32): 0xA8080000
    // Test aarch32_ADD_SP_i_T1_A field imm8 = 8 (PowerOfTwo)
    // ISET: T32
    // Fields: Rd=0, imm8=8
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xA8080000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_i_T1_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_add_sp_i_t1_a_field_imm8_15_poweroftwominusone_0_a80f0000() {
    // Thumb encoding (32): 0xA80F0000
    // Test aarch32_ADD_SP_i_T1_A field imm8 = 15 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rd=0, imm8=15
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xA80F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_i_T1_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_add_sp_i_t1_a_field_imm8_16_poweroftwo_0_a8100000() {
    // Thumb encoding (32): 0xA8100000
    // Test aarch32_ADD_SP_i_T1_A field imm8 = 16 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=16, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xA8100000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_i_T1_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_add_sp_i_t1_a_field_imm8_31_poweroftwominusone_0_a81f0000() {
    // Thumb encoding (32): 0xA81F0000
    // Test aarch32_ADD_SP_i_T1_A field imm8 = 31 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rd=0, imm8=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xA81F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_i_T1_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_add_sp_i_t1_a_field_imm8_32_poweroftwo_0_a8200000() {
    // Thumb encoding (32): 0xA8200000
    // Test aarch32_ADD_SP_i_T1_A field imm8 = 32 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=32, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xA8200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_i_T1_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_add_sp_i_t1_a_field_imm8_63_poweroftwominusone_0_a83f0000() {
    // Thumb encoding (32): 0xA83F0000
    // Test aarch32_ADD_SP_i_T1_A field imm8 = 63 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rd=0, imm8=63
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xA83F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_i_T1_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_add_sp_i_t1_a_field_imm8_64_poweroftwo_0_a8400000() {
    // Thumb encoding (32): 0xA8400000
    // Test aarch32_ADD_SP_i_T1_A field imm8 = 64 (PowerOfTwo)
    // ISET: T32
    // Fields: Rd=0, imm8=64
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xA8400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_i_T1_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 127, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (127)
#[test]
fn test_aarch32_add_sp_i_t1_a_field_imm8_127_poweroftwominusone_0_a87f0000() {
    // Thumb encoding (32): 0xA87F0000
    // Test aarch32_ADD_SP_i_T1_A field imm8 = 127 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm8=127, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xA87F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_i_T1_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_add_sp_i_t1_a_field_imm8_128_poweroftwo_0_a8800000() {
    // Thumb encoding (32): 0xA8800000
    // Test aarch32_ADD_SP_i_T1_A field imm8 = 128 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=128, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xA8800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_i_T1_A
/// ASL: `field imm8 16 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 255, boundary: Max }
/// maximum immediate (255)
#[test]
fn test_aarch32_add_sp_i_t1_a_field_imm8_255_max_0_a8ff0000() {
    // Thumb encoding (32): 0xA8FF0000
    // Test aarch32_ADD_SP_i_T1_A field imm8 = 255 (Max)
    // ISET: T32
    // Fields: Rd=0, imm8=255
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xA8FF0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_i_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch32_add_sp_i_t1_a_combo_0_0_a8000000() {
    // Thumb encoding (32): 0xA8000000
    // Test aarch32_ADD_SP_i_T1_A field combination: Rd=0, imm8=0
    // ISET: T32
    // Fields: imm8=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xA8000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_i_T2_A
/// ASL: `field imm7 16 +: 7`
/// Requirement: FieldBoundary { field: "imm7", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_add_sp_i_t2_a_field_imm7_0_zero_0_b0000000() {
    // Thumb encoding (32): 0xB0000000
    // Test aarch32_ADD_SP_i_T2_A field imm7 = 0 (Zero)
    // ISET: T32
    // Fields: imm7=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xB0000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_i_T2_A
/// ASL: `field imm7 16 +: 7`
/// Requirement: FieldBoundary { field: "imm7", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_add_sp_i_t2_a_field_imm7_1_poweroftwo_0_b0010000() {
    // Thumb encoding (32): 0xB0010000
    // Test aarch32_ADD_SP_i_T2_A field imm7 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm7=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xB0010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_i_T2_A
/// ASL: `field imm7 16 +: 7`
/// Requirement: FieldBoundary { field: "imm7", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_add_sp_i_t2_a_field_imm7_3_poweroftwominusone_0_b0030000() {
    // Thumb encoding (32): 0xB0030000
    // Test aarch32_ADD_SP_i_T2_A field imm7 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm7=3
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xB0030000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_i_T2_A
/// ASL: `field imm7 16 +: 7`
/// Requirement: FieldBoundary { field: "imm7", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_add_sp_i_t2_a_field_imm7_4_poweroftwo_0_b0040000() {
    // Thumb encoding (32): 0xB0040000
    // Test aarch32_ADD_SP_i_T2_A field imm7 = 4 (PowerOfTwo)
    // ISET: T32
    // Fields: imm7=4
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xB0040000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_i_T2_A
/// ASL: `field imm7 16 +: 7`
/// Requirement: FieldBoundary { field: "imm7", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_add_sp_i_t2_a_field_imm7_7_poweroftwominusone_0_b0070000() {
    // Thumb encoding (32): 0xB0070000
    // Test aarch32_ADD_SP_i_T2_A field imm7 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm7=7
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xB0070000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_i_T2_A
/// ASL: `field imm7 16 +: 7`
/// Requirement: FieldBoundary { field: "imm7", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_add_sp_i_t2_a_field_imm7_8_poweroftwo_0_b0080000() {
    // Thumb encoding (32): 0xB0080000
    // Test aarch32_ADD_SP_i_T2_A field imm7 = 8 (PowerOfTwo)
    // ISET: T32
    // Fields: imm7=8
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xB0080000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_i_T2_A
/// ASL: `field imm7 16 +: 7`
/// Requirement: FieldBoundary { field: "imm7", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_add_sp_i_t2_a_field_imm7_15_poweroftwominusone_0_b00f0000() {
    // Thumb encoding (32): 0xB00F0000
    // Test aarch32_ADD_SP_i_T2_A field imm7 = 15 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm7=15
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xB00F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_i_T2_A
/// ASL: `field imm7 16 +: 7`
/// Requirement: FieldBoundary { field: "imm7", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_add_sp_i_t2_a_field_imm7_16_poweroftwo_0_b0100000() {
    // Thumb encoding (32): 0xB0100000
    // Test aarch32_ADD_SP_i_T2_A field imm7 = 16 (PowerOfTwo)
    // ISET: T32
    // Fields: imm7=16
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xB0100000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_i_T2_A
/// ASL: `field imm7 16 +: 7`
/// Requirement: FieldBoundary { field: "imm7", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_add_sp_i_t2_a_field_imm7_31_poweroftwominusone_0_b01f0000() {
    // Thumb encoding (32): 0xB01F0000
    // Test aarch32_ADD_SP_i_T2_A field imm7 = 31 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm7=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xB01F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_i_T2_A
/// ASL: `field imm7 16 +: 7`
/// Requirement: FieldBoundary { field: "imm7", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_add_sp_i_t2_a_field_imm7_32_poweroftwo_0_b0200000() {
    // Thumb encoding (32): 0xB0200000
    // Test aarch32_ADD_SP_i_T2_A field imm7 = 32 (PowerOfTwo)
    // ISET: T32
    // Fields: imm7=32
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xB0200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_i_T2_A
/// ASL: `field imm7 16 +: 7`
/// Requirement: FieldBoundary { field: "imm7", value: 63, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (63)
#[test]
fn test_aarch32_add_sp_i_t2_a_field_imm7_63_poweroftwominusone_0_b03f0000() {
    // Thumb encoding (32): 0xB03F0000
    // Test aarch32_ADD_SP_i_T2_A field imm7 = 63 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm7=63
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xB03F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_i_T2_A
/// ASL: `field imm7 16 +: 7`
/// Requirement: FieldBoundary { field: "imm7", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_add_sp_i_t2_a_field_imm7_64_poweroftwo_0_b0400000() {
    // Thumb encoding (32): 0xB0400000
    // Test aarch32_ADD_SP_i_T2_A field imm7 = 64 (PowerOfTwo)
    // ISET: T32
    // Fields: imm7=64
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xB0400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_i_T2_A
/// ASL: `field imm7 16 +: 7`
/// Requirement: FieldBoundary { field: "imm7", value: 127, boundary: Max }
/// maximum immediate (127)
#[test]
fn test_aarch32_add_sp_i_t2_a_field_imm7_127_max_0_b07f0000() {
    // Thumb encoding (32): 0xB07F0000
    // Test aarch32_ADD_SP_i_T2_A field imm7 = 127 (Max)
    // ISET: T32
    // Fields: imm7=127
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xB07F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_i_T2_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm7=0 (immediate value 0)
#[test]
fn test_aarch32_add_sp_i_t2_a_combo_0_0_b0000000() {
    // Thumb encoding (32): 0xB0000000
    // Test aarch32_ADD_SP_i_T2_A field combination: imm7=0
    // ISET: T32
    // Fields: imm7=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xB0000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `field i 26 +: 1`
/// Requirement: FieldBoundary { field: "i", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_add_sp_i_t3_a_field_i_0_min_0_f10d0000() {
    // Thumb encoding (32): 0xF10D0000
    // Test aarch32_ADD_SP_i_T3_A field i = 0 (Min)
    // ISET: T32
    // Fields: i=0, Rd=0, imm3=0, S=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF10D0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `field i 26 +: 1`
/// Requirement: FieldBoundary { field: "i", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_add_sp_i_t3_a_field_i_1_max_0_f50d0000() {
    // Thumb encoding (32): 0xF50D0000
    // Test aarch32_ADD_SP_i_T3_A field i = 1 (Max)
    // ISET: T32
    // Fields: imm8=0, imm3=0, Rd=0, S=0, i=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF50D0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_add_sp_i_t3_a_field_s_0_min_0_f10d0000() {
    // Thumb encoding (32): 0xF10D0000
    // Test aarch32_ADD_SP_i_T3_A field S = 0 (Min)
    // ISET: T32
    // Fields: i=0, imm8=0, imm3=0, S=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF10D0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_add_sp_i_t3_a_field_s_1_max_0_f11d0000() {
    // Thumb encoding (32): 0xF11D0000
    // Test aarch32_ADD_SP_i_T3_A field S = 1 (Max)
    // ISET: T32
    // Fields: imm8=0, Rd=0, S=1, i=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF11D0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_add_sp_i_t3_a_field_imm3_0_zero_0_f10d0000() {
    // Thumb encoding (32): 0xF10D0000
    // Test aarch32_ADD_SP_i_T3_A field imm3 = 0 (Zero)
    // ISET: T32
    // Fields: imm3=0, i=0, S=0, Rd=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF10D0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_add_sp_i_t3_a_field_imm3_1_poweroftwo_0_f10d1000() {
    // Thumb encoding (32): 0xF10D1000
    // Test aarch32_ADD_SP_i_T3_A field imm3 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: S=0, imm3=1, i=0, Rd=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF10D1000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 3, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (3)
#[test]
fn test_aarch32_add_sp_i_t3_a_field_imm3_3_poweroftwominusone_0_f10d3000() {
    // Thumb encoding (32): 0xF10D3000
    // Test aarch32_ADD_SP_i_T3_A field imm3 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm8=0, Rd=0, i=0, imm3=3, S=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF10D3000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 7, boundary: Max }
/// maximum immediate (7)
#[test]
fn test_aarch32_add_sp_i_t3_a_field_imm3_7_max_0_f10d7000() {
    // Thumb encoding (32): 0xF10D7000
    // Test aarch32_ADD_SP_i_T3_A field imm3 = 7 (Max)
    // ISET: T32
    // Fields: i=0, imm8=0, imm3=7, Rd=0, S=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF10D7000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_add_sp_i_t3_a_field_rd_0_min_0_f10d0000() {
    // Thumb encoding (32): 0xF10D0000
    // Test aarch32_ADD_SP_i_T3_A field Rd = 0 (Min)
    // ISET: T32
    // Fields: imm3=0, i=0, Rd=0, imm8=0, S=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF10D0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_add_sp_i_t3_a_field_rd_1_poweroftwo_0_f10d0100() {
    // Thumb encoding (32): 0xF10D0100
    // Test aarch32_ADD_SP_i_T3_A field Rd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rd=1, imm3=0, i=0, S=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF10D0100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_add_sp_i_t3_a_field_imm8_0_zero_0_f10d0000() {
    // Thumb encoding (32): 0xF10D0000
    // Test aarch32_ADD_SP_i_T3_A field imm8 = 0 (Zero)
    // ISET: T32
    // Fields: S=0, imm8=0, Rd=0, imm3=0, i=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF10D0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_add_sp_i_t3_a_field_imm8_1_poweroftwo_0_f10d0001() {
    // Thumb encoding (32): 0xF10D0001
    // Test aarch32_ADD_SP_i_T3_A field imm8 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm3=0, S=0, Rd=0, imm8=1, i=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF10D0001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_add_sp_i_t3_a_field_imm8_3_poweroftwominusone_0_f10d0003() {
    // Thumb encoding (32): 0xF10D0003
    // Test aarch32_ADD_SP_i_T3_A field imm8 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm8=3, i=0, S=0, imm3=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF10D0003;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_add_sp_i_t3_a_field_imm8_4_poweroftwo_0_f10d0004() {
    // Thumb encoding (32): 0xF10D0004
    // Test aarch32_ADD_SP_i_T3_A field imm8 = 4 (PowerOfTwo)
    // ISET: T32
    // Fields: Rd=0, S=0, imm8=4, i=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF10D0004;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_add_sp_i_t3_a_field_imm8_7_poweroftwominusone_0_f10d0007() {
    // Thumb encoding (32): 0xF10D0007
    // Test aarch32_ADD_SP_i_T3_A field imm8 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: S=0, Rd=0, imm8=7, imm3=0, i=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF10D0007;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_add_sp_i_t3_a_field_imm8_8_poweroftwo_0_f10d0008() {
    // Thumb encoding (32): 0xF10D0008
    // Test aarch32_ADD_SP_i_T3_A field imm8 = 8 (PowerOfTwo)
    // ISET: T32
    // Fields: i=0, imm3=0, S=0, Rd=0, imm8=8
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF10D0008;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_add_sp_i_t3_a_field_imm8_15_poweroftwominusone_0_f10d000f() {
    // Thumb encoding (32): 0xF10D000F
    // Test aarch32_ADD_SP_i_T3_A field imm8 = 15 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: i=0, S=0, Rd=0, imm8=15, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF10D000F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_add_sp_i_t3_a_field_imm8_16_poweroftwo_0_f10d0010() {
    // Thumb encoding (32): 0xF10D0010
    // Test aarch32_ADD_SP_i_T3_A field imm8 = 16 (PowerOfTwo)
    // ISET: T32
    // Fields: i=0, S=0, Rd=0, imm8=16, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF10D0010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_add_sp_i_t3_a_field_imm8_31_poweroftwominusone_0_f10d001f() {
    // Thumb encoding (32): 0xF10D001F
    // Test aarch32_ADD_SP_i_T3_A field imm8 = 31 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm3=0, i=0, S=0, imm8=31, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF10D001F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_add_sp_i_t3_a_field_imm8_32_poweroftwo_0_f10d0020() {
    // Thumb encoding (32): 0xF10D0020
    // Test aarch32_ADD_SP_i_T3_A field imm8 = 32 (PowerOfTwo)
    // ISET: T32
    // Fields: S=0, imm3=0, i=0, Rd=0, imm8=32
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF10D0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_add_sp_i_t3_a_field_imm8_63_poweroftwominusone_0_f10d003f() {
    // Thumb encoding (32): 0xF10D003F
    // Test aarch32_ADD_SP_i_T3_A field imm8 = 63 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rd=0, imm8=63, i=0, imm3=0, S=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF10D003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_add_sp_i_t3_a_field_imm8_64_poweroftwo_0_f10d0040() {
    // Thumb encoding (32): 0xF10D0040
    // Test aarch32_ADD_SP_i_T3_A field imm8 = 64 (PowerOfTwo)
    // ISET: T32
    // Fields: Rd=0, imm8=64, i=0, imm3=0, S=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF10D0040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 127, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (127)
#[test]
fn test_aarch32_add_sp_i_t3_a_field_imm8_127_poweroftwominusone_0_f10d007f() {
    // Thumb encoding (32): 0xF10D007F
    // Test aarch32_ADD_SP_i_T3_A field imm8 = 127 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm8=127, Rd=0, S=0, i=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF10D007F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_add_sp_i_t3_a_field_imm8_128_poweroftwo_0_f10d0080() {
    // Thumb encoding (32): 0xF10D0080
    // Test aarch32_ADD_SP_i_T3_A field imm8 = 128 (PowerOfTwo)
    // ISET: T32
    // Fields: i=0, Rd=0, imm8=128, S=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF10D0080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 255, boundary: Max }
/// maximum immediate (255)
#[test]
fn test_aarch32_add_sp_i_t3_a_field_imm8_255_max_0_f10d00ff() {
    // Thumb encoding (32): 0xF10D00FF
    // Test aarch32_ADD_SP_i_T3_A field imm8 = 255 (Max)
    // ISET: T32
    // Fields: imm3=0, i=0, S=0, Rd=0, imm8=255
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF10D00FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// i=0 (minimum value)
#[test]
fn test_aarch32_add_sp_i_t3_a_combo_0_0_f10d0000() {
    // Thumb encoding (32): 0xF10D0000
    // Test aarch32_ADD_SP_i_T3_A field combination: i=0, S=0, imm3=0, Rd=0, imm8=0
    // ISET: T32
    // Fields: S=0, imm3=0, imm8=0, i=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF10D0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `field S = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "S", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_add_sp_i_t3_a_special_s_0_size_variant_0_0_f10d0000() {
    // Thumb encoding (32): 0xF10D0000
    // Test aarch32_ADD_SP_i_T3_A special value S = 0 (Size variant 0)
    // ISET: T32
    // Fields: S=0, imm3=0, i=0, imm8=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF10D0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `field S = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "S", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_add_sp_i_t3_a_special_s_1_size_variant_1_0_f11d0000() {
    // Thumb encoding (32): 0xF11D0000
    // Test aarch32_ADD_SP_i_T3_A special value S = 1 (Size variant 1)
    // ISET: T32
    // Fields: i=0, Rd=0, S=1, imm8=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF11D0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: And, lhs: LitInt(15), rhs: Unary { op: Not, operand: Var(QualifiedIdentifier { qualifier: Any, name: "setflags" }) } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: And, lhs: LitInt(15), rhs: Unary { op: Not, operand: Var(QualifiedIdentifier { qualifier: Any, name: \"setflags\" }) } } }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_add_sp_i_t3_a_invalid_0_0_f10d0000() {
    // Thumb encoding (32): 0xF10D0000
    // Test aarch32_ADD_SP_i_T3_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: And, lhs: LitInt(15), rhs: Unary { op: Not, operand: Var(QualifiedIdentifier { qualifier: Any, name: "setflags" }) } } }
    // ISET: T32
    // Fields: i=0, imm3=0, S=0, Rd=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF10D0000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_add_sp_i_t3_a_invalid_1_0_f10d0000() {
    // Thumb encoding (32): 0xF10D0000
    // Test aarch32_ADD_SP_i_T3_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: i=0, imm8=0, S=0, imm3=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF10D0000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_ADD_SP_i_T4_A
/// ASL: `field i 26 +: 1`
/// Requirement: FieldBoundary { field: "i", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_add_sp_i_t4_a_field_i_0_min_0_f20d0000() {
    // Thumb encoding (32): 0xF20D0000
    // Test aarch32_ADD_SP_i_T4_A field i = 0 (Min)
    // ISET: T32
    // Fields: i=0, imm8=0, imm3=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF20D0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_i_T4_A
/// ASL: `field i 26 +: 1`
/// Requirement: FieldBoundary { field: "i", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_add_sp_i_t4_a_field_i_1_max_0_f60d0000() {
    // Thumb encoding (32): 0xF60D0000
    // Test aarch32_ADD_SP_i_T4_A field i = 1 (Max)
    // ISET: T32
    // Fields: i=1, imm3=0, Rd=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF60D0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_i_T4_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_add_sp_i_t4_a_field_imm3_0_zero_0_f20d0000() {
    // Thumb encoding (32): 0xF20D0000
    // Test aarch32_ADD_SP_i_T4_A field imm3 = 0 (Zero)
    // ISET: T32
    // Fields: imm3=0, Rd=0, i=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF20D0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_i_T4_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_add_sp_i_t4_a_field_imm3_1_poweroftwo_0_f20d1000() {
    // Thumb encoding (32): 0xF20D1000
    // Test aarch32_ADD_SP_i_T4_A field imm3 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: i=0, imm3=1, imm8=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF20D1000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_i_T4_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 3, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (3)
#[test]
fn test_aarch32_add_sp_i_t4_a_field_imm3_3_poweroftwominusone_0_f20d3000() {
    // Thumb encoding (32): 0xF20D3000
    // Test aarch32_ADD_SP_i_T4_A field imm3 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm8=0, imm3=3, Rd=0, i=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF20D3000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_i_T4_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 7, boundary: Max }
/// maximum immediate (7)
#[test]
fn test_aarch32_add_sp_i_t4_a_field_imm3_7_max_0_f20d7000() {
    // Thumb encoding (32): 0xF20D7000
    // Test aarch32_ADD_SP_i_T4_A field imm3 = 7 (Max)
    // ISET: T32
    // Fields: i=0, Rd=0, imm8=0, imm3=7
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF20D7000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_i_T4_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_add_sp_i_t4_a_field_rd_0_min_0_f20d0000() {
    // Thumb encoding (32): 0xF20D0000
    // Test aarch32_ADD_SP_i_T4_A field Rd = 0 (Min)
    // ISET: T32
    // Fields: imm8=0, imm3=0, Rd=0, i=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF20D0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_i_T4_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_add_sp_i_t4_a_field_rd_1_poweroftwo_0_f20d0100() {
    // Thumb encoding (32): 0xF20D0100
    // Test aarch32_ADD_SP_i_T4_A field Rd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: i=0, imm3=0, imm8=0, Rd=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF20D0100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_i_T4_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_add_sp_i_t4_a_field_imm8_0_zero_0_f20d0000() {
    // Thumb encoding (32): 0xF20D0000
    // Test aarch32_ADD_SP_i_T4_A field imm8 = 0 (Zero)
    // ISET: T32
    // Fields: i=0, imm3=0, Rd=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF20D0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_i_T4_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_add_sp_i_t4_a_field_imm8_1_poweroftwo_0_f20d0001() {
    // Thumb encoding (32): 0xF20D0001
    // Test aarch32_ADD_SP_i_T4_A field imm8 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: i=0, imm3=0, imm8=1, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF20D0001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_i_T4_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_add_sp_i_t4_a_field_imm8_3_poweroftwominusone_0_f20d0003() {
    // Thumb encoding (32): 0xF20D0003
    // Test aarch32_ADD_SP_i_T4_A field imm8 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm3=0, i=0, Rd=0, imm8=3
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF20D0003;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_i_T4_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_add_sp_i_t4_a_field_imm8_4_poweroftwo_0_f20d0004() {
    // Thumb encoding (32): 0xF20D0004
    // Test aarch32_ADD_SP_i_T4_A field imm8 = 4 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=4, imm3=0, i=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF20D0004;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_i_T4_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_add_sp_i_t4_a_field_imm8_7_poweroftwominusone_0_f20d0007() {
    // Thumb encoding (32): 0xF20D0007
    // Test aarch32_ADD_SP_i_T4_A field imm8 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: i=0, imm8=7, Rd=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF20D0007;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_i_T4_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_add_sp_i_t4_a_field_imm8_8_poweroftwo_0_f20d0008() {
    // Thumb encoding (32): 0xF20D0008
    // Test aarch32_ADD_SP_i_T4_A field imm8 = 8 (PowerOfTwo)
    // ISET: T32
    // Fields: imm3=0, Rd=0, imm8=8, i=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF20D0008;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_i_T4_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_add_sp_i_t4_a_field_imm8_15_poweroftwominusone_0_f20d000f() {
    // Thumb encoding (32): 0xF20D000F
    // Test aarch32_ADD_SP_i_T4_A field imm8 = 15 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rd=0, imm3=0, i=0, imm8=15
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF20D000F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_i_T4_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_add_sp_i_t4_a_field_imm8_16_poweroftwo_0_f20d0010() {
    // Thumb encoding (32): 0xF20D0010
    // Test aarch32_ADD_SP_i_T4_A field imm8 = 16 (PowerOfTwo)
    // ISET: T32
    // Fields: imm3=0, i=0, Rd=0, imm8=16
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF20D0010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_i_T4_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_add_sp_i_t4_a_field_imm8_31_poweroftwominusone_0_f20d001f() {
    // Thumb encoding (32): 0xF20D001F
    // Test aarch32_ADD_SP_i_T4_A field imm8 = 31 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: i=0, Rd=0, imm3=0, imm8=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF20D001F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_i_T4_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_add_sp_i_t4_a_field_imm8_32_poweroftwo_0_f20d0020() {
    // Thumb encoding (32): 0xF20D0020
    // Test aarch32_ADD_SP_i_T4_A field imm8 = 32 (PowerOfTwo)
    // ISET: T32
    // Fields: imm3=0, i=0, imm8=32, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF20D0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_i_T4_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_add_sp_i_t4_a_field_imm8_63_poweroftwominusone_0_f20d003f() {
    // Thumb encoding (32): 0xF20D003F
    // Test aarch32_ADD_SP_i_T4_A field imm8 = 63 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm8=63, i=0, imm3=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF20D003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_i_T4_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_add_sp_i_t4_a_field_imm8_64_poweroftwo_0_f20d0040() {
    // Thumb encoding (32): 0xF20D0040
    // Test aarch32_ADD_SP_i_T4_A field imm8 = 64 (PowerOfTwo)
    // ISET: T32
    // Fields: Rd=0, i=0, imm3=0, imm8=64
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF20D0040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_i_T4_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 127, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (127)
#[test]
fn test_aarch32_add_sp_i_t4_a_field_imm8_127_poweroftwominusone_0_f20d007f() {
    // Thumb encoding (32): 0xF20D007F
    // Test aarch32_ADD_SP_i_T4_A field imm8 = 127 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: i=0, imm3=0, imm8=127, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF20D007F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_i_T4_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_add_sp_i_t4_a_field_imm8_128_poweroftwo_0_f20d0080() {
    // Thumb encoding (32): 0xF20D0080
    // Test aarch32_ADD_SP_i_T4_A field imm8 = 128 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=128, i=0, imm3=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF20D0080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_i_T4_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 255, boundary: Max }
/// maximum immediate (255)
#[test]
fn test_aarch32_add_sp_i_t4_a_field_imm8_255_max_0_f20d00ff() {
    // Thumb encoding (32): 0xF20D00FF
    // Test aarch32_ADD_SP_i_T4_A field imm8 = 255 (Max)
    // ISET: T32
    // Fields: imm8=255, i=0, imm3=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF20D00FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_i_T4_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// i=0 (minimum value)
#[test]
fn test_aarch32_add_sp_i_t4_a_combo_0_0_f20d0000() {
    // Thumb encoding (32): 0xF20D0000
    // Test aarch32_ADD_SP_i_T4_A field combination: i=0, imm3=0, Rd=0, imm8=0
    // ISET: T32
    // Fields: imm3=0, imm8=0, i=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF20D0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADD_SP_i_T4_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_add_sp_i_t4_a_invalid_0_0_f20d0000() {
    // Thumb encoding (32): 0xF20D0000
    // Test aarch32_ADD_SP_i_T4_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: LitInt(15) }
    // ISET: T32
    // Fields: imm3=0, i=0, imm8=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF20D0000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_ADD_SP_i_T4_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_add_sp_i_t4_a_invalid_1_0_f20d0000() {
    // Thumb encoding (32): 0xF20D0000
    // Test aarch32_ADD_SP_i_T4_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: imm3=0, i=0, imm8=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF20D0000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `ADD X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_add_sp_i_a1_a_add_oracle_32_0_028d2820() {
    // Test ADD 32-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0x028D2820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x028D2820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x3AE, "W0 should be 0x3AE");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `ADD X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_add_sp_i_a1_a_add_oracle_64_0_828d2820() {
    // Test ADD 64-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0x828D2820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x828D2820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x3AE, "X0 should be 0x00000000000003AE");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `ADD X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero operands (32)
#[test]
fn test_aarch32_add_sp_i_a1_a_add_oracle_32_1_028d0020() {
    // Test ADD 32-bit: zero operands (with oracle verification)
    // Encoding: 0x028D0020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x028D0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x340, "W0 should be 0x340");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `ADD X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero operands (64)
#[test]
fn test_aarch32_add_sp_i_a1_a_add_oracle_64_1_828d0020() {
    // Test ADD 64-bit: zero operands (with oracle verification)
    // Encoding: 0x828D0020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x828D0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x340, "X0 should be 0x0000000000000340");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small values (32)
#[test]
fn test_aarch32_add_sp_i_a1_a_add_oracle_32_2_028d0420() {
    // Test ADD 32-bit: small values (with oracle verification)
    // Encoding: 0x028D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x028D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x342, "W0 should be 0x342");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// small values (64)
#[test]
fn test_aarch32_add_sp_i_a1_a_add_oracle_64_2_828d0420() {
    // Test ADD 64-bit: small values (with oracle verification)
    // Encoding: 0x828D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x828D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x342, "X0 should be 0x0000000000000342");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `ADD X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_add_sp_i_a1_a_add_oracle_32_3_02bffc20() {
    // Test ADD 32-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0x02BFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x02BFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF, "W0 should be 0xFFF");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `ADD X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_add_sp_i_a1_a_add_oracle_64_3_82bffc20() {
    // Test ADD 64-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0x82BFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x82BFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF, "X0 should be 0x0000000000000FFF");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `ADD X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_add_sp_i_a1_a_add_oracle_32_4_02fffc20() {
    // Test ADD 32-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0x02FFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x02FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF000, "W0 should be 0xFFF000");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `ADD X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_add_sp_i_a1_a_add_oracle_64_4_82fffc20() {
    // Test ADD 64-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0x82FFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x82FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF000, "X0 should be 0x0000000000FFF000");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max u64 operand (32)
#[test]
fn test_aarch32_add_sp_i_a1_a_add_oracle_32_5_028d0420() {
    // Test ADD 32-bit: max u64 operand (with oracle verification)
    // Encoding: 0x028D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x028D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x340, "W0 should be 0x340");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max u64 operand (64)
#[test]
fn test_aarch32_add_sp_i_a1_a_add_oracle_64_5_828d0420() {
    // Test ADD 64-bit: max u64 operand (with oracle verification)
    // Encoding: 0x828D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x828D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x340, "X0 should be 0x0000000000000340");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_add_sp_i_a1_a_add_oracle_32_6_028d0420() {
    // Test ADD 32-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0x028D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x028D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x341, "W0 should be 0x341");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_add_sp_i_a1_a_add_oracle_64_6_828d0420() {
    // Test ADD 64-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0x828D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x828D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x341, "X0 should be 0x0000000000000341");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_add_sp_i_a1_a_add_oracle_32_7_028d0420() {
    // Test ADD 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0x028D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x028D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x340, "W0 should be 0x340");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_add_sp_i_a1_a_add_oracle_64_7_828d0420() {
    // Test ADD 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0x828D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x828D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x340, "X0 should be 0x8000000000000340");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_add_sp_i_a1_a_add_oracle_32_8_028d0420() {
    // Test ADD 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0x028D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x028D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000340, "W0 should be 0x80000340");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_add_sp_i_a1_a_add_oracle_64_8_828d0420() {
    // Test ADD 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0x828D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x828D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x80000340,
        "X0 should be 0x0000000080000340"
    );
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_add_sp_i_a1_a_add_oracle_32_9_028d0420() {
    // Test ADD 32-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0x028D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x028D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x340, "W0 should be 0x340");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_add_sp_i_a1_a_add_oracle_64_9_828d0420() {
    // Test ADD 64-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0x828D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x828D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x340, "X0 should be 0x0000000000000340");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_add_sp_i_a1_a_add_oracle_32_10_028d0420() {
    // Test ADD 32-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0x028D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x028D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x340, "W0 should be 0x340");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_add_sp_i_a1_a_add_oracle_64_10_828d0420() {
    // Test ADD 64-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0x828D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x828D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x340, "X0 should be 0x0000000100000340");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `ADD SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (32)
#[test]
fn test_aarch32_add_sp_i_a1_a_add_oracle_32_rd31_sp_028d283f() {
    // Test ADD 32-bit with Rd=31 (SP)
    // Encoding: 0x028D283F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x028D283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    // TODO: assertion - TestAssertion { check: Sp, expected: U64(942), message: "SP should be 0x3AE" }
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `ADD SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (64)
#[test]
fn test_aarch32_add_sp_i_a1_a_add_oracle_64_rd31_sp_828d283f() {
    // Test ADD 64-bit with Rd=31 (SP)
    // Encoding: 0x828D283F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x828D283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    // TODO: assertion - TestAssertion { check: Sp, expected: U64(942), message: "SP should be 0x3AE" }
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `ADDS X0, X1, #10`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_add_sp_i_a1_a_adds_oracle_32_0_228d2820() {
    // Test ADDS 32-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0x228D2820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x228D2820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x3AE, "W0 should be 0x3AE");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `ADDS X0, X1, #10`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_add_sp_i_a1_a_adds_oracle_64_0_a28d2820() {
    // Test ADDS 64-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0xA28D2820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xA28D2820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x3AE, "X0 should be 0x00000000000003AE");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `ADDS X0, X1, #0`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero operands (32)
#[test]
fn test_aarch32_add_sp_i_a1_a_adds_oracle_32_1_228d0020() {
    // Test ADDS 32-bit: zero operands (with oracle verification)
    // Encoding: 0x228D0020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x228D0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x340, "W0 should be 0x340");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `ADDS X0, X1, #0`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero operands (64)
#[test]
fn test_aarch32_add_sp_i_a1_a_adds_oracle_64_1_a28d0020() {
    // Test ADDS 64-bit: zero operands (with oracle verification)
    // Encoding: 0xA28D0020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xA28D0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x340, "X0 should be 0x0000000000000340");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// small values (32)
#[test]
fn test_aarch32_add_sp_i_a1_a_adds_oracle_32_2_228d0420() {
    // Test ADDS 32-bit: small values (with oracle verification)
    // Encoding: 0x228D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x228D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x342, "W0 should be 0x342");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// small values (64)
#[test]
fn test_aarch32_add_sp_i_a1_a_adds_oracle_64_2_a28d0420() {
    // Test ADDS 64-bit: small values (with oracle verification)
    // Encoding: 0xA28D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xA28D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x342, "X0 should be 0x0000000000000342");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `ADDS X0, X1, #4095`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_add_sp_i_a1_a_adds_oracle_32_3_22bffc20() {
    // Test ADDS 32-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0x22BFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x22BFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF, "W0 should be 0xFFF");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `ADDS X0, X1, #4095`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_add_sp_i_a1_a_adds_oracle_64_3_a2bffc20() {
    // Test ADDS 64-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0xA2BFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xA2BFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF, "X0 should be 0x0000000000000FFF");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `ADDS X0, X1, #4095, LSL #12`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_add_sp_i_a1_a_adds_oracle_32_4_22fffc20() {
    // Test ADDS 32-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0x22FFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x22FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF000, "W0 should be 0xFFF000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `ADDS X0, X1, #4095, LSL #12`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_add_sp_i_a1_a_adds_oracle_64_4_a2fffc20() {
    // Test ADDS 64-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0xA2FFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xA2FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF000, "X0 should be 0x0000000000FFF000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max u64 operand (32)
#[test]
fn test_aarch32_add_sp_i_a1_a_adds_oracle_32_5_228d0420() {
    // Test ADDS 32-bit: max u64 operand (with oracle verification)
    // Encoding: 0x228D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x228D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x340, "W0 should be 0x340");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max u64 operand (64)
#[test]
fn test_aarch32_add_sp_i_a1_a_adds_oracle_64_5_a28d0420() {
    // Test ADDS 64-bit: max u64 operand (with oracle verification)
    // Encoding: 0xA28D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xA28D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x340, "X0 should be 0x0000000000000340");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_add_sp_i_a1_a_adds_oracle_32_6_228d0420() {
    // Test ADDS 32-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0x228D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x228D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x341, "W0 should be 0x341");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_add_sp_i_a1_a_adds_oracle_64_6_a28d0420() {
    // Test ADDS 64-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0xA28D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xA28D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x341, "X0 should be 0x0000000000000341");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_add_sp_i_a1_a_adds_oracle_32_7_228d0420() {
    // Test ADDS 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0x228D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x228D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x340, "W0 should be 0x340");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_add_sp_i_a1_a_adds_oracle_64_7_a28d0420() {
    // Test ADDS 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0xA28D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xA28D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x340, "X0 should be 0x8000000000000340");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, true, "V flag should be true");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_add_sp_i_a1_a_adds_oracle_32_8_228d0420() {
    // Test ADDS 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0x228D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x228D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000340, "W0 should be 0x80000340");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, true, "V flag should be true");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_add_sp_i_a1_a_adds_oracle_64_8_a28d0420() {
    // Test ADDS 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0xA28D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xA28D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x80000340,
        "X0 should be 0x0000000080000340"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_add_sp_i_a1_a_adds_oracle_32_9_228d0420() {
    // Test ADDS 32-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0x228D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x228D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x340, "W0 should be 0x340");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_add_sp_i_a1_a_adds_oracle_64_9_a28d0420() {
    // Test ADDS 64-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0xA28D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xA28D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x340, "X0 should be 0x0000000000000340");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_add_sp_i_a1_a_adds_oracle_32_10_228d0420() {
    // Test ADDS 32-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0x228D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x228D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x340, "W0 should be 0x340");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_add_sp_i_a1_a_adds_oracle_64_10_a28d0420() {
    // Test ADDS 64-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0xA28D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xA28D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x340, "X0 should be 0x0000000100000340");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `ADDS ZR, X1, #10`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "result discarded, flags set" }
/// ZR destination (32)
#[test]
fn test_aarch32_add_sp_i_a1_a_adds_oracle_32_rd31_zr_228d283f() {
    // Test ADDS 32-bit with Rd=31 (ZR)
    // Encoding: 0x228D283F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x228D283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `ADDS ZR, X1, #10`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "result discarded, flags set" }
/// ZR destination (64)
#[test]
fn test_aarch32_add_sp_i_a1_a_adds_oracle_64_rd31_zr_a28d283f() {
    // Test ADDS 64-bit with Rd=31 (ZR)
    // Encoding: 0xA28D283F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xA28D283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `SUB X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_add_sp_i_a1_a_sub_oracle_32_0_428d2820() {
    // Test SUB 32-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0x428D2820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x428D2820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFD1A, "W0 should be 0xFFFFFD1A");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `SUB X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_add_sp_i_a1_a_sub_oracle_64_0_c28d2820() {
    // Test SUB 64-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0xC28D2820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xC28D2820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFD1A,
        "X0 should be 0xFFFFFFFFFFFFFD1A"
    );
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `SUB X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero operands (32)
#[test]
fn test_aarch32_add_sp_i_a1_a_sub_oracle_32_1_428d0020() {
    // Test SUB 32-bit: zero operands (with oracle verification)
    // Encoding: 0x428D0020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x428D0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFCC0, "W0 should be 0xFFFFFCC0");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `SUB X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero operands (64)
#[test]
fn test_aarch32_add_sp_i_a1_a_sub_oracle_64_1_c28d0020() {
    // Test SUB 64-bit: zero operands (with oracle verification)
    // Encoding: 0xC28D0020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xC28D0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFCC0,
        "X0 should be 0xFFFFFFFFFFFFFCC0"
    );
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small values (32)
#[test]
fn test_aarch32_add_sp_i_a1_a_sub_oracle_32_2_428d0420() {
    // Test SUB 32-bit: small values (with oracle verification)
    // Encoding: 0x428D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x428D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFCC0, "W0 should be 0xFFFFFCC0");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// small values (64)
#[test]
fn test_aarch32_add_sp_i_a1_a_sub_oracle_64_2_c28d0420() {
    // Test SUB 64-bit: small values (with oracle verification)
    // Encoding: 0xC28D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xC28D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFCC0,
        "X0 should be 0xFFFFFFFFFFFFFCC0"
    );
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `SUB X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_add_sp_i_a1_a_sub_oracle_32_3_42bffc20() {
    // Test SUB 32-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0x42BFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x42BFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFF001, "W0 should be 0xFFFFF001");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `SUB X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_add_sp_i_a1_a_sub_oracle_64_3_c2bffc20() {
    // Test SUB 64-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0xC2BFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xC2BFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `SUB X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_add_sp_i_a1_a_sub_oracle_32_4_42fffc20() {
    // Test SUB 32-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0x42FFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x42FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF001000, "W0 should be 0xFF001000");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `SUB X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_add_sp_i_a1_a_sub_oracle_64_4_c2fffc20() {
    // Test SUB 64-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0xC2FFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xC2FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max u64 operand (32)
#[test]
fn test_aarch32_add_sp_i_a1_a_sub_oracle_32_5_428d0420() {
    // Test SUB 32-bit: max u64 operand (with oracle verification)
    // Encoding: 0x428D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x428D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFCBE, "W0 should be 0xFFFFFCBE");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max u64 operand (64)
#[test]
fn test_aarch32_add_sp_i_a1_a_sub_oracle_64_5_c28d0420() {
    // Test SUB 64-bit: max u64 operand (with oracle verification)
    // Encoding: 0xC28D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xC28D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFCBE,
        "X0 should be 0xFFFFFFFFFFFFFCBE"
    );
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_add_sp_i_a1_a_sub_oracle_32_6_428d0420() {
    // Test SUB 32-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0x428D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x428D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFCBF, "W0 should be 0xFFFFFCBF");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_add_sp_i_a1_a_sub_oracle_64_6_c28d0420() {
    // Test SUB 64-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0xC28D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xC28D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFCBF,
        "X0 should be 0xFFFFFFFFFFFFFCBF"
    );
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_add_sp_i_a1_a_sub_oracle_32_7_428d0420() {
    // Test SUB 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0x428D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x428D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFCBE, "W0 should be 0xFFFFFCBE");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_add_sp_i_a1_a_sub_oracle_64_7_c28d0420() {
    // Test SUB 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0xC28D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xC28D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFCBE,
        "X0 should be 0x7FFFFFFFFFFFFCBE"
    );
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_add_sp_i_a1_a_sub_oracle_32_8_428d0420() {
    // Test SUB 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0x428D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x428D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FFFFCBE, "W0 should be 0x7FFFFCBE");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_add_sp_i_a1_a_sub_oracle_64_8_c28d0420() {
    // Test SUB 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0xC28D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xC28D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x7FFFFCBE,
        "X0 should be 0x000000007FFFFCBE"
    );
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_add_sp_i_a1_a_sub_oracle_32_9_428d0420() {
    // Test SUB 32-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0x428D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x428D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFCBE, "W0 should be 0xFFFFFCBE");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_add_sp_i_a1_a_sub_oracle_64_9_c28d0420() {
    // Test SUB 64-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0xC28D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xC28D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFCBE,
        "X0 should be 0xFFFFFFFFFFFFFCBE"
    );
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_add_sp_i_a1_a_sub_oracle_32_10_428d0420() {
    // Test SUB 32-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0x428D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x428D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFCBE, "W0 should be 0xFFFFFCBE");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_add_sp_i_a1_a_sub_oracle_64_10_c28d0420() {
    // Test SUB 64-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0xC28D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xC28D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFCBE,
        "X0 should be 0x00000000FFFFFCBE"
    );
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `SUB SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (32)
#[test]
fn test_aarch32_add_sp_i_a1_a_sub_oracle_32_rd31_sp_428d283f() {
    // Test SUB 32-bit with Rd=31 (SP)
    // Encoding: 0x428D283F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x428D283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    // TODO: assertion - TestAssertion { check: Sp, expected: U64(4294966554), message: "SP should be 0xFFFFFD1A" }
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `SUB SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (64)
#[test]
fn test_aarch32_add_sp_i_a1_a_sub_oracle_64_rd31_sp_c28d283f() {
    // Test SUB 64-bit with Rd=31 (SP)
    // Encoding: 0xC28D283F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xC28D283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    // TODO: assertion - TestAssertion { check: Sp, expected: U64(18446744073709550874), message: "SP should be 0xFFFFFFFFFFFFFD1A" }
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `SUBS X0, X1, #10`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_add_sp_i_a1_a_subs_oracle_32_0_628d2820() {
    // Test SUBS 32-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0x628D2820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x628D2820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFD1A, "W0 should be 0xFFFFFD1A");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `SUBS X0, X1, #10`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_add_sp_i_a1_a_subs_oracle_64_0_e28d2820() {
    // Test SUBS 64-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0xE28D2820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xE28D2820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFD1A,
        "X0 should be 0xFFFFFFFFFFFFFD1A"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `SUBS X0, X1, #0`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero operands (32)
#[test]
fn test_aarch32_add_sp_i_a1_a_subs_oracle_32_1_628d0020() {
    // Test SUBS 32-bit: zero operands (with oracle verification)
    // Encoding: 0x628D0020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x628D0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFCC0, "W0 should be 0xFFFFFCC0");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `SUBS X0, X1, #0`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero operands (64)
#[test]
fn test_aarch32_add_sp_i_a1_a_subs_oracle_64_1_e28d0020() {
    // Test SUBS 64-bit: zero operands (with oracle verification)
    // Encoding: 0xE28D0020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xE28D0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFCC0,
        "X0 should be 0xFFFFFFFFFFFFFCC0"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// small values (32)
#[test]
fn test_aarch32_add_sp_i_a1_a_subs_oracle_32_2_628d0420() {
    // Test SUBS 32-bit: small values (with oracle verification)
    // Encoding: 0x628D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x628D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFCC0, "W0 should be 0xFFFFFCC0");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// small values (64)
#[test]
fn test_aarch32_add_sp_i_a1_a_subs_oracle_64_2_e28d0420() {
    // Test SUBS 64-bit: small values (with oracle verification)
    // Encoding: 0xE28D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xE28D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFCC0,
        "X0 should be 0xFFFFFFFFFFFFFCC0"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `SUBS X0, X1, #4095`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_add_sp_i_a1_a_subs_oracle_32_3_62bffc20() {
    // Test SUBS 32-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0x62BFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x62BFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFF001, "W0 should be 0xFFFFF001");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `SUBS X0, X1, #4095`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_add_sp_i_a1_a_subs_oracle_64_3_e2bffc20() {
    // Test SUBS 64-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0xE2BFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xE2BFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `SUBS X0, X1, #4095, LSL #12`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_add_sp_i_a1_a_subs_oracle_32_4_62fffc20() {
    // Test SUBS 32-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0x62FFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x62FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF001000, "W0 should be 0xFF001000");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `SUBS X0, X1, #4095, LSL #12`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_add_sp_i_a1_a_subs_oracle_64_4_e2fffc20() {
    // Test SUBS 64-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0xE2FFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xE2FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max u64 operand (32)
#[test]
fn test_aarch32_add_sp_i_a1_a_subs_oracle_32_5_628d0420() {
    // Test SUBS 32-bit: max u64 operand (with oracle verification)
    // Encoding: 0x628D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x628D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFCBE, "W0 should be 0xFFFFFCBE");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max u64 operand (64)
#[test]
fn test_aarch32_add_sp_i_a1_a_subs_oracle_64_5_e28d0420() {
    // Test SUBS 64-bit: max u64 operand (with oracle verification)
    // Encoding: 0xE28D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xE28D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFCBE,
        "X0 should be 0xFFFFFFFFFFFFFCBE"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_add_sp_i_a1_a_subs_oracle_32_6_628d0420() {
    // Test SUBS 32-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0x628D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x628D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFCBF, "W0 should be 0xFFFFFCBF");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_add_sp_i_a1_a_subs_oracle_64_6_e28d0420() {
    // Test SUBS 64-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0xE28D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xE28D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFCBF,
        "X0 should be 0xFFFFFFFFFFFFFCBF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_add_sp_i_a1_a_subs_oracle_32_7_628d0420() {
    // Test SUBS 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0x628D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x628D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFCBE, "W0 should be 0xFFFFFCBE");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_add_sp_i_a1_a_subs_oracle_64_7_e28d0420() {
    // Test SUBS 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0xE28D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xE28D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFCBE,
        "X0 should be 0x7FFFFFFFFFFFFCBE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_add_sp_i_a1_a_subs_oracle_32_8_628d0420() {
    // Test SUBS 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0x628D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x628D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FFFFCBE, "W0 should be 0x7FFFFCBE");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_add_sp_i_a1_a_subs_oracle_64_8_e28d0420() {
    // Test SUBS 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0xE28D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xE28D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x7FFFFCBE,
        "X0 should be 0x000000007FFFFCBE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_add_sp_i_a1_a_subs_oracle_32_9_628d0420() {
    // Test SUBS 32-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0x628D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x628D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFCBE, "W0 should be 0xFFFFFCBE");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_add_sp_i_a1_a_subs_oracle_64_9_e28d0420() {
    // Test SUBS 64-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0xE28D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xE28D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFCBE,
        "X0 should be 0xFFFFFFFFFFFFFCBE"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_add_sp_i_a1_a_subs_oracle_32_10_628d0420() {
    // Test SUBS 32-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0x628D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x628D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFCBE, "W0 should be 0xFFFFFCBE");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_add_sp_i_a1_a_subs_oracle_64_10_e28d0420() {
    // Test SUBS 64-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0xE28D0420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xE28D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFCBE,
        "X0 should be 0x00000000FFFFFCBE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `SUBS ZR, X1, #10`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "result discarded, flags set" }
/// ZR destination (32)
#[test]
fn test_aarch32_add_sp_i_a1_a_subs_oracle_32_rd31_zr_628d283f() {
    // Test SUBS 32-bit with Rd=31 (ZR)
    // Encoding: 0x628D283F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x628D283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `SUBS ZR, X1, #10`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "result discarded, flags set" }
/// ZR destination (64)
#[test]
fn test_aarch32_add_sp_i_a1_a_subs_oracle_64_rd31_zr_e28d283f() {
    // Test SUBS 64-bit with Rd=31 (ZR)
    // Encoding: 0xE28D283F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xE28D283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `ADD R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x00000000)
#[test]
fn test_aarch32_add_sp_i_a1_a_a32_add_sub_imm_0_0_0281000a() {
    // Test A32 ADD: small immediate (oracle)
    // Encoding: 0x0281000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x0281000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA, "R0 should be 0x0000000A");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `ADD R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x00000064)
#[test]
fn test_aarch32_add_sp_i_a1_a_a32_add_sub_imm_0_64_0281000a() {
    // Test A32 ADD: small immediate (oracle)
    // Encoding: 0x0281000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x0281000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6E, "R0 should be 0x0000006E");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `ADD R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_add_sp_i_a1_a_a32_add_sub_imm_0_7fffffff_0281000a() {
    // Test A32 ADD: small immediate (oracle)
    // Encoding: 0x0281000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x0281000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000009, "R0 should be 0x80000009");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `ADD R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x80000000)
#[test]
fn test_aarch32_add_sp_i_a1_a_a32_add_sub_imm_0_80000000_0281000a() {
    // Test A32 ADD: small immediate (oracle)
    // Encoding: 0x0281000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0x0281000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x8000000A, "R0 should be 0x8000000A");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `ADD R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_add_sp_i_a1_a_a32_add_sub_imm_0_ffffffff_0281000a() {
    // Test A32 ADD: small immediate (oracle)
    // Encoding: 0x0281000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x0281000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x9, "R0 should be 0x00000009");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `ADD R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x00000000)
#[test]
fn test_aarch32_add_sp_i_a1_a_a32_add_sub_imm_1_0_028100ff() {
    // Test A32 ADD: max imm8 (oracle)
    // Encoding: 0x028100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x028100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `ADD R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x00000064)
#[test]
fn test_aarch32_add_sp_i_a1_a_a32_add_sub_imm_1_64_028100ff() {
    // Test A32 ADD: max imm8 (oracle)
    // Encoding: 0x028100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x028100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x163, "R0 should be 0x00000163");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `ADD R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_add_sp_i_a1_a_a32_add_sub_imm_1_7fffffff_028100ff() {
    // Test A32 ADD: max imm8 (oracle)
    // Encoding: 0x028100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x028100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x800000FE, "R0 should be 0x800000FE");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `ADD R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x80000000)
#[test]
fn test_aarch32_add_sp_i_a1_a_a32_add_sub_imm_1_80000000_028100ff() {
    // Test A32 ADD: max imm8 (oracle)
    // Encoding: 0x028100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0x028100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x800000FF, "R0 should be 0x800000FF");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `ADD R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_add_sp_i_a1_a_a32_add_sub_imm_1_ffffffff_028100ff() {
    // Test A32 ADD: max imm8 (oracle)
    // Encoding: 0x028100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x028100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFE, "R0 should be 0x000000FE");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `ADD R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x00000000)
#[test]
fn test_aarch32_add_sp_i_a1_a_a32_add_sub_imm_2_0_02810180() {
    // Test A32 ADD: rotated by 2 (oracle)
    // Encoding: 0x02810180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x02810180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x20, "R0 should be 0x00000020");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `ADD R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x00000064)
#[test]
fn test_aarch32_add_sp_i_a1_a_a32_add_sub_imm_2_64_02810180() {
    // Test A32 ADD: rotated by 2 (oracle)
    // Encoding: 0x02810180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x02810180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x84, "R0 should be 0x00000084");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `ADD R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_add_sp_i_a1_a_a32_add_sub_imm_2_7fffffff_02810180() {
    // Test A32 ADD: rotated by 2 (oracle)
    // Encoding: 0x02810180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x02810180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x8000001F, "R0 should be 0x8000001F");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `ADD R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x80000000)
#[test]
fn test_aarch32_add_sp_i_a1_a_a32_add_sub_imm_2_80000000_02810180() {
    // Test A32 ADD: rotated by 2 (oracle)
    // Encoding: 0x02810180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0x02810180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000020, "R0 should be 0x80000020");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `ADD R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_add_sp_i_a1_a_a32_add_sub_imm_2_ffffffff_02810180() {
    // Test A32 ADD: rotated by 2 (oracle)
    // Encoding: 0x02810180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x02810180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1F, "R0 should be 0x0000001F");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `ADD R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x00000000)
#[test]
fn test_aarch32_add_sp_i_a1_a_a32_add_sub_imm_3_0_0281040f() {
    // Test A32 ADD: rotated by 8 (oracle)
    // Encoding: 0x0281040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x0281040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xF000000, "R0 should be 0x0F000000");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `ADD R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x00000064)
#[test]
fn test_aarch32_add_sp_i_a1_a_a32_add_sub_imm_3_64_0281040f() {
    // Test A32 ADD: rotated by 8 (oracle)
    // Encoding: 0x0281040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x0281040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xF000064, "R0 should be 0x0F000064");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `ADD R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_add_sp_i_a1_a_a32_add_sub_imm_3_7fffffff_0281040f() {
    // Test A32 ADD: rotated by 8 (oracle)
    // Encoding: 0x0281040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x0281040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x8EFFFFFF, "R0 should be 0x8EFFFFFF");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `ADD R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x80000000)
#[test]
fn test_aarch32_add_sp_i_a1_a_a32_add_sub_imm_3_80000000_0281040f() {
    // Test A32 ADD: rotated by 8 (oracle)
    // Encoding: 0x0281040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0x0281040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x8F000000, "R0 should be 0x8F000000");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `ADD R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_add_sp_i_a1_a_a32_add_sub_imm_3_ffffffff_0281040f() {
    // Test A32 ADD: rotated by 8 (oracle)
    // Encoding: 0x0281040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x0281040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xEFFFFFF, "R0 should be 0x0EFFFFFF");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `ADD R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x00000000)
#[test]
fn test_aarch32_add_sp_i_a1_a_a32_add_sub_imm_4_0_02810000() {
    // Test A32 ADD: zero immediate (oracle)
    // Encoding: 0x02810000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x02810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `ADD R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x00000064)
#[test]
fn test_aarch32_add_sp_i_a1_a_a32_add_sub_imm_4_64_02810000() {
    // Test A32 ADD: zero immediate (oracle)
    // Encoding: 0x02810000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x02810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x64, "R0 should be 0x00000064");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `ADD R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_add_sp_i_a1_a_a32_add_sub_imm_4_7fffffff_02810000() {
    // Test A32 ADD: zero immediate (oracle)
    // Encoding: 0x02810000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x02810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FFFFFFF, "R0 should be 0x7FFFFFFF");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `ADD R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x80000000)
#[test]
fn test_aarch32_add_sp_i_a1_a_a32_add_sub_imm_4_80000000_02810000() {
    // Test A32 ADD: zero immediate (oracle)
    // Encoding: 0x02810000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0x02810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "R0 should be 0x80000000");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `ADD R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_add_sp_i_a1_a_a32_add_sub_imm_4_ffffffff_02810000() {
    // Test A32 ADD: zero immediate (oracle)
    // Encoding: 0x02810000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x02810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "R0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_aarch32_add_sp_i_a1_a_flags_zeroresult_0_029d0000() {
    // Test aarch32_ADD_SP_i_A1_A flag computation: ZeroResult
    // Encoding: 0x029D0000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x029D0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_aarch32_add_sp_i_a1_a_flags_zeroresult_1_029d0000() {
    // Test aarch32_ADD_SP_i_A1_A flag computation: ZeroResult
    // Encoding: 0x029D0000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x029D0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_aarch32_add_sp_i_a1_a_flags_negativeresult_2_029d0000() {
    // Test aarch32_ADD_SP_i_A1_A flag computation: NegativeResult
    // Encoding: 0x029D0000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x029D0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_aarch32_add_sp_i_a1_a_flags_unsignedoverflow_3_029d0000() {
    // Test aarch32_ADD_SP_i_A1_A flag computation: UnsignedOverflow
    // Encoding: 0x029D0000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x029D0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_aarch32_add_sp_i_a1_a_flags_unsignedoverflow_4_029d0000() {
    // Test aarch32_ADD_SP_i_A1_A flag computation: UnsignedOverflow
    // Encoding: 0x029D0000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x029D0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_aarch32_add_sp_i_a1_a_flags_signedoverflow_5_029d0000() {
    // Test aarch32_ADD_SP_i_A1_A flag computation: SignedOverflow
    // Encoding: 0x029D0000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x029D0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_aarch32_add_sp_i_a1_a_flags_signedoverflow_6_029d0000() {
    // Test aarch32_ADD_SP_i_A1_A flag computation: SignedOverflow
    // Encoding: 0x029D0000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x029D0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_ADD_SP_i_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_aarch32_add_sp_i_a1_a_flags_positiveresult_7_029d0000() {
    // Test aarch32_ADD_SP_i_A1_A flag computation: PositiveResult
    // Encoding: 0x029D0000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x32);
    let encoding: u32 = 0x029D0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_SP_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 0 (32)
#[test]
fn test_aarch32_add_sp_i_t1_a_lslv_oracle_32_0_a8020020() {
    // Test LSLV 32-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x12345678, "W0 should be 0x12345678");
}

/// Provenance: aarch32_ADD_SP_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 0 (64)
#[test]
fn test_aarch32_add_sp_i_t1_a_lslv_oracle_64_0_a8020020() {
    // Test LSLV 64-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x12345678,
        "X0 should be 0x0000000012345678"
    );
}

/// Provenance: aarch32_ADD_SP_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4 (32)
#[test]
fn test_aarch32_add_sp_i_t1_a_lslv_oracle_32_1_a8020020() {
    // Test LSLV 32-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x4);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x23456780, "W0 should be 0x23456780");
}

/// Provenance: aarch32_ADD_SP_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 4 (64)
#[test]
fn test_aarch32_add_sp_i_t1_a_lslv_oracle_64_1_a8020020() {
    // Test LSLV 64-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x4);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x23456780,
        "X0 should be 0x0000000123456780"
    );
}

/// Provenance: aarch32_ADD_SP_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 8 (32)
#[test]
fn test_aarch32_add_sp_i_t1_a_lslv_oracle_32_2_a8020020() {
    // Test LSLV 32-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x8);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x34567800, "W0 should be 0x34567800");
}

/// Provenance: aarch32_ADD_SP_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 8 (64)
#[test]
fn test_aarch32_add_sp_i_t1_a_lslv_oracle_64_2_a8020020() {
    // Test LSLV 64-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x8);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x34567800,
        "X0 should be 0x0000001234567800"
    );
}

/// Provenance: aarch32_ADD_SP_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1 (32)
#[test]
fn test_aarch32_add_sp_i_t1_a_lslv_oracle_32_3_a8020020() {
    // Test LSLV 32-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_ADD_SP_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// MSB set, shift 1 (64)
#[test]
fn test_aarch32_add_sp_i_t1_a_lslv_oracle_64_3_a8020020() {
    // Test LSLV 64-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_ADD_SP_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// LSB set, max shift (32)
#[test]
fn test_aarch32_add_sp_i_t1_a_lslv_oracle_32_4_a8020020() {
    // Test LSLV 32-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3F);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "W0 should be 0x80000000");
}

/// Provenance: aarch32_ADD_SP_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// LSB set, max shift (64)
#[test]
fn test_aarch32_add_sp_i_t1_a_lslv_oracle_64_4_a8020020() {
    // Test LSLV 64-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x3F);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x8000000000000000");
}

/// Provenance: aarch32_ADD_SP_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// all ones, shift 32 (32)
#[test]
fn test_aarch32_add_sp_i_t1_a_lslv_oracle_32_5_a8020020() {
    // Test LSLV 32-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x20);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "W0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_ADD_SP_i_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// all ones, shift 32 (64)
#[test]
fn test_aarch32_add_sp_i_t1_a_lslv_oracle_64_5_a8020020() {
    // Test LSLV 64-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x20);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0xFFFFFFFF00000000");
}

/// Provenance: aarch32_ADD_SP_i_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// no shift
#[test]
fn test_aarch32_add_sp_i_t1_a_t16_oracle_0_a8000000() {
    // Test T16 LSLS: no shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_ADD_SP_i_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4
#[test]
fn test_aarch32_add_sp_i_t1_a_t16_oracle_1_a8000000() {
    // Test T16 LSLS: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    set_w(&mut cpu, 2, 0x4);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF0, "R0 should be 0x00000FF0");
}

/// Provenance: aarch32_ADD_SP_i_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1
#[test]
fn test_aarch32_add_sp_i_t1_a_t16_oracle_2_a8000000() {
    // Test T16 LSLS: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_ADD_SP_i_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift to MSB
#[test]
fn test_aarch32_add_sp_i_t1_a_t16_oracle_3_a8000000() {
    // Test T16 LSLS: shift to MSB (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1F);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "R0 should be 0x80000000");
}

/// Provenance: aarch32_ADD_SP_i_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_aarch32_add_sp_i_t1_a_flags_zeroresult_0_a8000000() {
    // Test aarch32_ADD_SP_i_T1_A flag computation: ZeroResult
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_SP_i_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_aarch32_add_sp_i_t1_a_flags_zeroresult_1_a8000000() {
    // Test aarch32_ADD_SP_i_T1_A flag computation: ZeroResult
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_SP_i_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_aarch32_add_sp_i_t1_a_flags_negativeresult_2_a8000000() {
    // Test aarch32_ADD_SP_i_T1_A flag computation: NegativeResult
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_SP_i_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_aarch32_add_sp_i_t1_a_flags_unsignedoverflow_3_a8000000() {
    // Test aarch32_ADD_SP_i_T1_A flag computation: UnsignedOverflow
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_SP_i_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_aarch32_add_sp_i_t1_a_flags_unsignedoverflow_4_a8000000() {
    // Test aarch32_ADD_SP_i_T1_A flag computation: UnsignedOverflow
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_SP_i_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_aarch32_add_sp_i_t1_a_flags_signedoverflow_5_a8000000() {
    // Test aarch32_ADD_SP_i_T1_A flag computation: SignedOverflow
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_ADD_SP_i_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_aarch32_add_sp_i_t1_a_flags_signedoverflow_6_a8000000() {
    // Test aarch32_ADD_SP_i_T1_A flag computation: SignedOverflow
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_ADD_SP_i_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_aarch32_add_sp_i_t1_a_flags_positiveresult_7_a8000000() {
    // Test aarch32_ADD_SP_i_T1_A flag computation: PositiveResult
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x32);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_SP_i_T2_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 0 (32)
#[test]
fn test_aarch32_add_sp_i_t2_a_lslv_oracle_32_0_b0020020() {
    // Test LSLV 32-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x12345678, "W0 should be 0x12345678");
}

/// Provenance: aarch32_ADD_SP_i_T2_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 0 (64)
#[test]
fn test_aarch32_add_sp_i_t2_a_lslv_oracle_64_0_b0020020() {
    // Test LSLV 64-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x12345678,
        "X0 should be 0x0000000012345678"
    );
}

/// Provenance: aarch32_ADD_SP_i_T2_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4 (32)
#[test]
fn test_aarch32_add_sp_i_t2_a_lslv_oracle_32_1_b0020020() {
    // Test LSLV 32-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x4);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x23456780, "W0 should be 0x23456780");
}

/// Provenance: aarch32_ADD_SP_i_T2_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 4 (64)
#[test]
fn test_aarch32_add_sp_i_t2_a_lslv_oracle_64_1_b0020020() {
    // Test LSLV 64-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x4);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x23456780,
        "X0 should be 0x0000000123456780"
    );
}

/// Provenance: aarch32_ADD_SP_i_T2_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 8 (32)
#[test]
fn test_aarch32_add_sp_i_t2_a_lslv_oracle_32_2_b0020020() {
    // Test LSLV 32-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x8);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x34567800, "W0 should be 0x34567800");
}

/// Provenance: aarch32_ADD_SP_i_T2_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 8 (64)
#[test]
fn test_aarch32_add_sp_i_t2_a_lslv_oracle_64_2_b0020020() {
    // Test LSLV 64-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x8);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x34567800,
        "X0 should be 0x0000001234567800"
    );
}

/// Provenance: aarch32_ADD_SP_i_T2_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1 (32)
#[test]
fn test_aarch32_add_sp_i_t2_a_lslv_oracle_32_3_b0020020() {
    // Test LSLV 32-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_ADD_SP_i_T2_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// MSB set, shift 1 (64)
#[test]
fn test_aarch32_add_sp_i_t2_a_lslv_oracle_64_3_b0020020() {
    // Test LSLV 64-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_ADD_SP_i_T2_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// LSB set, max shift (32)
#[test]
fn test_aarch32_add_sp_i_t2_a_lslv_oracle_32_4_b0020020() {
    // Test LSLV 32-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x3F);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "W0 should be 0x80000000");
}

/// Provenance: aarch32_ADD_SP_i_T2_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// LSB set, max shift (64)
#[test]
fn test_aarch32_add_sp_i_t2_a_lslv_oracle_64_4_b0020020() {
    // Test LSLV 64-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x3F);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x8000000000000000");
}

/// Provenance: aarch32_ADD_SP_i_T2_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// all ones, shift 32 (32)
#[test]
fn test_aarch32_add_sp_i_t2_a_lslv_oracle_32_5_b0020020() {
    // Test LSLV 32-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x20);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "W0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_ADD_SP_i_T2_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// all ones, shift 32 (64)
#[test]
fn test_aarch32_add_sp_i_t2_a_lslv_oracle_64_5_b0020020() {
    // Test LSLV 64-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x20);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0xFFFFFFFF00000000");
}

/// Provenance: aarch32_ADD_SP_i_T2_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// no shift
#[test]
fn test_aarch32_add_sp_i_t2_a_t16_oracle_0_b0000000() {
    // Test T16 LSLS: no shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_ADD_SP_i_T2_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4
#[test]
fn test_aarch32_add_sp_i_t2_a_t16_oracle_1_b0000000() {
    // Test T16 LSLS: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x4);
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF0, "R0 should be 0x00000FF0");
}

/// Provenance: aarch32_ADD_SP_i_T2_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1
#[test]
fn test_aarch32_add_sp_i_t2_a_t16_oracle_2_b0000000() {
    // Test T16 LSLS: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_ADD_SP_i_T2_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift to MSB
#[test]
fn test_aarch32_add_sp_i_t2_a_t16_oracle_3_b0000000() {
    // Test T16 LSLS: shift to MSB (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x1F);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "R0 should be 0x80000000");
}

/// Provenance: aarch32_ADD_SP_i_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_aarch32_add_sp_i_t2_a_flags_zeroresult_0_b0000000() {
    // Test aarch32_ADD_SP_i_T2_A flag computation: ZeroResult
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_SP_i_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_aarch32_add_sp_i_t2_a_flags_zeroresult_1_b0000000() {
    // Test aarch32_ADD_SP_i_T2_A flag computation: ZeroResult
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_SP_i_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_aarch32_add_sp_i_t2_a_flags_negativeresult_2_b0000000() {
    // Test aarch32_ADD_SP_i_T2_A flag computation: NegativeResult
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_SP_i_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_aarch32_add_sp_i_t2_a_flags_unsignedoverflow_3_b0000000() {
    // Test aarch32_ADD_SP_i_T2_A flag computation: UnsignedOverflow
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_SP_i_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_aarch32_add_sp_i_t2_a_flags_unsignedoverflow_4_b0000000() {
    // Test aarch32_ADD_SP_i_T2_A flag computation: UnsignedOverflow
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_SP_i_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_aarch32_add_sp_i_t2_a_flags_signedoverflow_5_b0000000() {
    // Test aarch32_ADD_SP_i_T2_A flag computation: SignedOverflow
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_ADD_SP_i_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_aarch32_add_sp_i_t2_a_flags_signedoverflow_6_b0000000() {
    // Test aarch32_ADD_SP_i_T2_A flag computation: SignedOverflow
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_ADD_SP_i_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_aarch32_add_sp_i_t2_a_flags_positiveresult_7_b0000000() {
    // Test aarch32_ADD_SP_i_T2_A flag computation: PositiveResult
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x32);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `ADD X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_add_sp_i_t3_a_add_oracle_32_0_f10d2820() {
    // Test ADD 32-bit: simple addition/subtraction (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF10D2820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFD1A,
        "X0 should be 0xFFFFFFFFFFFFFD1A"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `ADD X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_add_sp_i_t3_a_add_oracle_64_0_f10d2820() {
    // Test ADD 64-bit: simple addition/subtraction (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF10D2820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFD1A,
        "X0 should be 0xFFFFFFFFFFFFFD1A"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `ADD X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero operands (32)
#[test]
fn test_aarch32_add_sp_i_t3_a_add_oracle_32_1_f10d0020() {
    // Test ADD 32-bit: zero operands (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF10D0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFCC0,
        "X0 should be 0xFFFFFFFFFFFFFCC0"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `ADD X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero operands (64)
#[test]
fn test_aarch32_add_sp_i_t3_a_add_oracle_64_1_f10d0020() {
    // Test ADD 64-bit: zero operands (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF10D0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFCC0,
        "X0 should be 0xFFFFFFFFFFFFFCC0"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small values (32)
#[test]
fn test_aarch32_add_sp_i_t3_a_add_oracle_32_2_f10d0420() {
    // Test ADD 32-bit: small values (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF10D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFCC0,
        "X0 should be 0xFFFFFFFFFFFFFCC0"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// small values (64)
#[test]
fn test_aarch32_add_sp_i_t3_a_add_oracle_64_2_f10d0420() {
    // Test ADD 64-bit: small values (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF10D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFCC0,
        "X0 should be 0xFFFFFFFFFFFFFCC0"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `ADD X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_add_sp_i_t3_a_add_oracle_32_3_f13ffc20() {
    // Test ADD 32-bit: max imm12 unshifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF13FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `ADD X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_add_sp_i_t3_a_add_oracle_64_3_f13ffc20() {
    // Test ADD 64-bit: max imm12 unshifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF13FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `ADD X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_add_sp_i_t3_a_add_oracle_32_4_f17ffc20() {
    // Test ADD 32-bit: max imm12 shifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF17FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `ADD X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_add_sp_i_t3_a_add_oracle_64_4_f17ffc20() {
    // Test ADD 64-bit: max imm12 shifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF17FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max u64 operand (32)
#[test]
fn test_aarch32_add_sp_i_t3_a_add_oracle_32_5_f10d0420() {
    // Test ADD 32-bit: max u64 operand (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF10D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFCBE,
        "X0 should be 0x00000000FFFFFCBE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max u64 operand (64)
#[test]
fn test_aarch32_add_sp_i_t3_a_add_oracle_64_5_f10d0420() {
    // Test ADD 64-bit: max u64 operand (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF10D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFCBE,
        "X0 should be 0xFFFFFFFFFFFFFCBE"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_add_sp_i_t3_a_add_oracle_32_6_f10d0420() {
    // Test ADD 32-bit: zero result (for sub 1-1) (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF10D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFCBF,
        "X0 should be 0xFFFFFFFFFFFFFCBF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_add_sp_i_t3_a_add_oracle_64_6_f10d0420() {
    // Test ADD 64-bit: zero result (for sub 1-1) (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF10D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFCBF,
        "X0 should be 0xFFFFFFFFFFFFFCBF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_add_sp_i_t3_a_add_oracle_32_7_f10d0420() {
    // Test ADD 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF10D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFCBE,
        "X0 should be 0x00000000FFFFFCBE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_add_sp_i_t3_a_add_oracle_64_7_f10d0420() {
    // Test ADD 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF10D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFCBE,
        "X0 should be 0x7FFFFFFFFFFFFCBE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_add_sp_i_t3_a_add_oracle_32_8_f10d0420() {
    // Test ADD 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF10D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x7FFFFCBE,
        "X0 should be 0x000000007FFFFCBE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_add_sp_i_t3_a_add_oracle_64_8_f10d0420() {
    // Test ADD 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF10D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x7FFFFCBE,
        "X0 should be 0x000000007FFFFCBE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_add_sp_i_t3_a_add_oracle_32_9_f10d0420() {
    // Test ADD 32-bit: unsigned overflow 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF10D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFCBE,
        "X0 should be 0x00000000FFFFFCBE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_add_sp_i_t3_a_add_oracle_64_9_f10d0420() {
    // Test ADD 64-bit: unsigned overflow 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF10D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFCBE,
        "X0 should be 0xFFFFFFFFFFFFFCBE"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_add_sp_i_t3_a_add_oracle_32_10_f10d0420() {
    // Test ADD 32-bit: unsigned overflow 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF10D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFCBE,
        "X0 should be 0x00000000FFFFFCBE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_add_sp_i_t3_a_add_oracle_64_10_f10d0420() {
    // Test ADD 64-bit: unsigned overflow 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF10D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFCBE,
        "X0 should be 0x00000000FFFFFCBE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `ADD SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (32)
#[test]
fn test_aarch32_add_sp_i_t3_a_add_oracle_32_rd31_sp_f10d283f() {
    // Test ADD 32-bit with Rd=31 (SP)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF10D283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `ADD SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (64)
#[test]
fn test_aarch32_add_sp_i_t3_a_add_oracle_64_rd31_sp_f10d283f() {
    // Test ADD 64-bit with Rd=31 (SP)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF10D283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `ADDS X0, X1, #10`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_add_sp_i_t3_a_adds_oracle_32_0_f10d2820() {
    // Test ADDS 32-bit: simple addition/subtraction (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF10D2820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFD1A,
        "X0 should be 0xFFFFFFFFFFFFFD1A"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `ADDS X0, X1, #10`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_add_sp_i_t3_a_adds_oracle_64_0_f10d2820() {
    // Test ADDS 64-bit: simple addition/subtraction (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF10D2820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFD1A,
        "X0 should be 0xFFFFFFFFFFFFFD1A"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `ADDS X0, X1, #0`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero operands (32)
#[test]
fn test_aarch32_add_sp_i_t3_a_adds_oracle_32_1_f10d0020() {
    // Test ADDS 32-bit: zero operands (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF10D0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFCC0,
        "X0 should be 0xFFFFFFFFFFFFFCC0"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `ADDS X0, X1, #0`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero operands (64)
#[test]
fn test_aarch32_add_sp_i_t3_a_adds_oracle_64_1_f10d0020() {
    // Test ADDS 64-bit: zero operands (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF10D0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFCC0,
        "X0 should be 0xFFFFFFFFFFFFFCC0"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// small values (32)
#[test]
fn test_aarch32_add_sp_i_t3_a_adds_oracle_32_2_f10d0420() {
    // Test ADDS 32-bit: small values (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF10D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFCC0,
        "X0 should be 0xFFFFFFFFFFFFFCC0"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// small values (64)
#[test]
fn test_aarch32_add_sp_i_t3_a_adds_oracle_64_2_f10d0420() {
    // Test ADDS 64-bit: small values (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF10D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFCC0,
        "X0 should be 0xFFFFFFFFFFFFFCC0"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `ADDS X0, X1, #4095`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_add_sp_i_t3_a_adds_oracle_32_3_f13ffc20() {
    // Test ADDS 32-bit: max imm12 unshifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF13FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `ADDS X0, X1, #4095`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_add_sp_i_t3_a_adds_oracle_64_3_f13ffc20() {
    // Test ADDS 64-bit: max imm12 unshifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF13FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `ADDS X0, X1, #4095, LSL #12`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_add_sp_i_t3_a_adds_oracle_32_4_f17ffc20() {
    // Test ADDS 32-bit: max imm12 shifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF17FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `ADDS X0, X1, #4095, LSL #12`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_add_sp_i_t3_a_adds_oracle_64_4_f17ffc20() {
    // Test ADDS 64-bit: max imm12 shifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF17FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max u64 operand (32)
#[test]
fn test_aarch32_add_sp_i_t3_a_adds_oracle_32_5_f10d0420() {
    // Test ADDS 32-bit: max u64 operand (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF10D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFCBE,
        "X0 should be 0x00000000FFFFFCBE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max u64 operand (64)
#[test]
fn test_aarch32_add_sp_i_t3_a_adds_oracle_64_5_f10d0420() {
    // Test ADDS 64-bit: max u64 operand (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF10D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFCBE,
        "X0 should be 0xFFFFFFFFFFFFFCBE"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_add_sp_i_t3_a_adds_oracle_32_6_f10d0420() {
    // Test ADDS 32-bit: zero result (for sub 1-1) (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF10D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFCBF,
        "X0 should be 0xFFFFFFFFFFFFFCBF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_add_sp_i_t3_a_adds_oracle_64_6_f10d0420() {
    // Test ADDS 64-bit: zero result (for sub 1-1) (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF10D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFCBF,
        "X0 should be 0xFFFFFFFFFFFFFCBF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_add_sp_i_t3_a_adds_oracle_32_7_f10d0420() {
    // Test ADDS 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF10D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFCBE,
        "X0 should be 0x00000000FFFFFCBE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_add_sp_i_t3_a_adds_oracle_64_7_f10d0420() {
    // Test ADDS 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF10D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFCBE,
        "X0 should be 0x7FFFFFFFFFFFFCBE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_add_sp_i_t3_a_adds_oracle_32_8_f10d0420() {
    // Test ADDS 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF10D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x7FFFFCBE,
        "X0 should be 0x000000007FFFFCBE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_add_sp_i_t3_a_adds_oracle_64_8_f10d0420() {
    // Test ADDS 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF10D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x7FFFFCBE,
        "X0 should be 0x000000007FFFFCBE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_add_sp_i_t3_a_adds_oracle_32_9_f10d0420() {
    // Test ADDS 32-bit: unsigned overflow 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF10D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFCBE,
        "X0 should be 0x00000000FFFFFCBE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_add_sp_i_t3_a_adds_oracle_64_9_f10d0420() {
    // Test ADDS 64-bit: unsigned overflow 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF10D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFCBE,
        "X0 should be 0xFFFFFFFFFFFFFCBE"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_add_sp_i_t3_a_adds_oracle_32_10_f10d0420() {
    // Test ADDS 32-bit: unsigned overflow 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF10D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFCBE,
        "X0 should be 0x00000000FFFFFCBE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_add_sp_i_t3_a_adds_oracle_64_10_f10d0420() {
    // Test ADDS 64-bit: unsigned overflow 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF10D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFCBE,
        "X0 should be 0x00000000FFFFFCBE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `ADDS ZR, X1, #10`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "result discarded, flags set" }
/// ZR destination (32)
#[test]
fn test_aarch32_add_sp_i_t3_a_adds_oracle_32_rd31_zr_f10d283f() {
    // Test ADDS 32-bit with Rd=31 (ZR)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF10D283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `ADDS ZR, X1, #10`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "result discarded, flags set" }
/// ZR destination (64)
#[test]
fn test_aarch32_add_sp_i_t3_a_adds_oracle_64_rd31_zr_f10d283f() {
    // Test ADDS 64-bit with Rd=31 (ZR)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF10D283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `SUB X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_add_sp_i_t3_a_sub_oracle_32_0_f10d2820() {
    // Test SUB 32-bit: simple addition/subtraction (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF10D2820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFD1A,
        "X0 should be 0xFFFFFFFFFFFFFD1A"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `SUB X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_add_sp_i_t3_a_sub_oracle_64_0_f10d2820() {
    // Test SUB 64-bit: simple addition/subtraction (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF10D2820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFD1A,
        "X0 should be 0xFFFFFFFFFFFFFD1A"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `SUB X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero operands (32)
#[test]
fn test_aarch32_add_sp_i_t3_a_sub_oracle_32_1_f10d0020() {
    // Test SUB 32-bit: zero operands (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF10D0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFCC0,
        "X0 should be 0xFFFFFFFFFFFFFCC0"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `SUB X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero operands (64)
#[test]
fn test_aarch32_add_sp_i_t3_a_sub_oracle_64_1_f10d0020() {
    // Test SUB 64-bit: zero operands (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF10D0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFCC0,
        "X0 should be 0xFFFFFFFFFFFFFCC0"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small values (32)
#[test]
fn test_aarch32_add_sp_i_t3_a_sub_oracle_32_2_f10d0420() {
    // Test SUB 32-bit: small values (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF10D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFCC0,
        "X0 should be 0xFFFFFFFFFFFFFCC0"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// small values (64)
#[test]
fn test_aarch32_add_sp_i_t3_a_sub_oracle_64_2_f10d0420() {
    // Test SUB 64-bit: small values (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF10D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFCC0,
        "X0 should be 0xFFFFFFFFFFFFFCC0"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `SUB X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_add_sp_i_t3_a_sub_oracle_32_3_f13ffc20() {
    // Test SUB 32-bit: max imm12 unshifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF13FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `SUB X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_add_sp_i_t3_a_sub_oracle_64_3_f13ffc20() {
    // Test SUB 64-bit: max imm12 unshifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF13FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `SUB X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_add_sp_i_t3_a_sub_oracle_32_4_f17ffc20() {
    // Test SUB 32-bit: max imm12 shifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF17FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `SUB X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_add_sp_i_t3_a_sub_oracle_64_4_f17ffc20() {
    // Test SUB 64-bit: max imm12 shifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF17FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max u64 operand (32)
#[test]
fn test_aarch32_add_sp_i_t3_a_sub_oracle_32_5_f10d0420() {
    // Test SUB 32-bit: max u64 operand (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF10D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFCBE,
        "X0 should be 0x00000000FFFFFCBE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max u64 operand (64)
#[test]
fn test_aarch32_add_sp_i_t3_a_sub_oracle_64_5_f10d0420() {
    // Test SUB 64-bit: max u64 operand (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF10D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFCBE,
        "X0 should be 0xFFFFFFFFFFFFFCBE"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_add_sp_i_t3_a_sub_oracle_32_6_f10d0420() {
    // Test SUB 32-bit: zero result (for sub 1-1) (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF10D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFCBF,
        "X0 should be 0xFFFFFFFFFFFFFCBF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_add_sp_i_t3_a_sub_oracle_64_6_f10d0420() {
    // Test SUB 64-bit: zero result (for sub 1-1) (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF10D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFCBF,
        "X0 should be 0xFFFFFFFFFFFFFCBF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_add_sp_i_t3_a_sub_oracle_32_7_f10d0420() {
    // Test SUB 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF10D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFCBE,
        "X0 should be 0x00000000FFFFFCBE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_add_sp_i_t3_a_sub_oracle_64_7_f10d0420() {
    // Test SUB 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF10D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFCBE,
        "X0 should be 0x7FFFFFFFFFFFFCBE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_add_sp_i_t3_a_sub_oracle_32_8_f10d0420() {
    // Test SUB 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF10D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x7FFFFCBE,
        "X0 should be 0x000000007FFFFCBE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_add_sp_i_t3_a_sub_oracle_64_8_f10d0420() {
    // Test SUB 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF10D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x7FFFFCBE,
        "X0 should be 0x000000007FFFFCBE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_add_sp_i_t3_a_sub_oracle_32_9_f10d0420() {
    // Test SUB 32-bit: unsigned overflow 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF10D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFCBE,
        "X0 should be 0x00000000FFFFFCBE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_add_sp_i_t3_a_sub_oracle_64_9_f10d0420() {
    // Test SUB 64-bit: unsigned overflow 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF10D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFCBE,
        "X0 should be 0xFFFFFFFFFFFFFCBE"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_add_sp_i_t3_a_sub_oracle_32_10_f10d0420() {
    // Test SUB 32-bit: unsigned overflow 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF10D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFCBE,
        "X0 should be 0x00000000FFFFFCBE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_add_sp_i_t3_a_sub_oracle_64_10_f10d0420() {
    // Test SUB 64-bit: unsigned overflow 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF10D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFCBE,
        "X0 should be 0x00000000FFFFFCBE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `SUB SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (32)
#[test]
fn test_aarch32_add_sp_i_t3_a_sub_oracle_32_rd31_sp_f10d283f() {
    // Test SUB 32-bit with Rd=31 (SP)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF10D283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `SUB SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (64)
#[test]
fn test_aarch32_add_sp_i_t3_a_sub_oracle_64_rd31_sp_f10d283f() {
    // Test SUB 64-bit with Rd=31 (SP)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF10D283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `SUBS X0, X1, #10`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_add_sp_i_t3_a_subs_oracle_32_0_f10d2820() {
    // Test SUBS 32-bit: simple addition/subtraction (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF10D2820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFD1A,
        "X0 should be 0xFFFFFFFFFFFFFD1A"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `SUBS X0, X1, #10`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_add_sp_i_t3_a_subs_oracle_64_0_f10d2820() {
    // Test SUBS 64-bit: simple addition/subtraction (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF10D2820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFD1A,
        "X0 should be 0xFFFFFFFFFFFFFD1A"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `SUBS X0, X1, #0`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero operands (32)
#[test]
fn test_aarch32_add_sp_i_t3_a_subs_oracle_32_1_f10d0020() {
    // Test SUBS 32-bit: zero operands (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF10D0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFCC0,
        "X0 should be 0xFFFFFFFFFFFFFCC0"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `SUBS X0, X1, #0`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero operands (64)
#[test]
fn test_aarch32_add_sp_i_t3_a_subs_oracle_64_1_f10d0020() {
    // Test SUBS 64-bit: zero operands (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF10D0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFCC0,
        "X0 should be 0xFFFFFFFFFFFFFCC0"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// small values (32)
#[test]
fn test_aarch32_add_sp_i_t3_a_subs_oracle_32_2_f10d0420() {
    // Test SUBS 32-bit: small values (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF10D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFCC0,
        "X0 should be 0xFFFFFFFFFFFFFCC0"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// small values (64)
#[test]
fn test_aarch32_add_sp_i_t3_a_subs_oracle_64_2_f10d0420() {
    // Test SUBS 64-bit: small values (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF10D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFCC0,
        "X0 should be 0xFFFFFFFFFFFFFCC0"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `SUBS X0, X1, #4095`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_add_sp_i_t3_a_subs_oracle_32_3_f13ffc20() {
    // Test SUBS 32-bit: max imm12 unshifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF13FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `SUBS X0, X1, #4095`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_add_sp_i_t3_a_subs_oracle_64_3_f13ffc20() {
    // Test SUBS 64-bit: max imm12 unshifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF13FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `SUBS X0, X1, #4095, LSL #12`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_add_sp_i_t3_a_subs_oracle_32_4_f17ffc20() {
    // Test SUBS 32-bit: max imm12 shifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF17FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `SUBS X0, X1, #4095, LSL #12`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_add_sp_i_t3_a_subs_oracle_64_4_f17ffc20() {
    // Test SUBS 64-bit: max imm12 shifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF17FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max u64 operand (32)
#[test]
fn test_aarch32_add_sp_i_t3_a_subs_oracle_32_5_f10d0420() {
    // Test SUBS 32-bit: max u64 operand (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF10D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFCBE,
        "X0 should be 0x00000000FFFFFCBE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max u64 operand (64)
#[test]
fn test_aarch32_add_sp_i_t3_a_subs_oracle_64_5_f10d0420() {
    // Test SUBS 64-bit: max u64 operand (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF10D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFCBE,
        "X0 should be 0xFFFFFFFFFFFFFCBE"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_add_sp_i_t3_a_subs_oracle_32_6_f10d0420() {
    // Test SUBS 32-bit: zero result (for sub 1-1) (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF10D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFCBF,
        "X0 should be 0xFFFFFFFFFFFFFCBF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_add_sp_i_t3_a_subs_oracle_64_6_f10d0420() {
    // Test SUBS 64-bit: zero result (for sub 1-1) (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF10D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFCBF,
        "X0 should be 0xFFFFFFFFFFFFFCBF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_add_sp_i_t3_a_subs_oracle_32_7_f10d0420() {
    // Test SUBS 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF10D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFCBE,
        "X0 should be 0x00000000FFFFFCBE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_add_sp_i_t3_a_subs_oracle_64_7_f10d0420() {
    // Test SUBS 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF10D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFCBE,
        "X0 should be 0x7FFFFFFFFFFFFCBE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_add_sp_i_t3_a_subs_oracle_32_8_f10d0420() {
    // Test SUBS 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF10D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x7FFFFCBE,
        "X0 should be 0x000000007FFFFCBE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_add_sp_i_t3_a_subs_oracle_64_8_f10d0420() {
    // Test SUBS 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF10D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x7FFFFCBE,
        "X0 should be 0x000000007FFFFCBE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_add_sp_i_t3_a_subs_oracle_32_9_f10d0420() {
    // Test SUBS 32-bit: unsigned overflow 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF10D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFCBE,
        "X0 should be 0x00000000FFFFFCBE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_add_sp_i_t3_a_subs_oracle_64_9_f10d0420() {
    // Test SUBS 64-bit: unsigned overflow 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF10D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFCBE,
        "X0 should be 0xFFFFFFFFFFFFFCBE"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_add_sp_i_t3_a_subs_oracle_32_10_f10d0420() {
    // Test SUBS 32-bit: unsigned overflow 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF10D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFCBE,
        "X0 should be 0x00000000FFFFFCBE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_add_sp_i_t3_a_subs_oracle_64_10_f10d0420() {
    // Test SUBS 64-bit: unsigned overflow 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF10D0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFCBE,
        "X0 should be 0x00000000FFFFFCBE"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `SUBS ZR, X1, #10`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "result discarded, flags set" }
/// ZR destination (32)
#[test]
fn test_aarch32_add_sp_i_t3_a_subs_oracle_32_rd31_zr_f10d283f() {
    // Test SUBS 32-bit with Rd=31 (ZR)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF10D283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `SUBS ZR, X1, #10`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "result discarded, flags set" }
/// ZR destination (64)
#[test]
fn test_aarch32_add_sp_i_t3_a_subs_oracle_64_rd31_zr_f10d283f() {
    // Test SUBS 64-bit with Rd=31 (ZR)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF10D283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `ADD.W R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple values
#[test]
fn test_aarch32_add_sp_i_t3_a_t32_oracle_0_f10d0000() {
    // Test T32 ADD: simple values (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x32);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF10D0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x96, "R0 should be 0x00000096");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `ADD.W R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero values
#[test]
fn test_aarch32_add_sp_i_t3_a_t32_oracle_1_f10d0000() {
    // Test T32 ADD: zero values (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF10D0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `ADD.W R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max value
#[test]
fn test_aarch32_add_sp_i_t3_a_t32_oracle_2_f10d0000() {
    // Test T32 ADD: max value (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0xF10D0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `ADD.W R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// mixed pattern
#[test]
fn test_aarch32_add_sp_i_t3_a_t32_oracle_3_f10d0000() {
    // Test T32 ADD: mixed pattern (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xABCDEF01);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u32 = 0xF10D0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xBE024579, "R0 should be 0xBE024579");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_aarch32_add_sp_i_t3_a_flags_zeroresult_0_f11d0000() {
    // Test aarch32_ADD_SP_i_T3_A flag computation: ZeroResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF11D0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_aarch32_add_sp_i_t3_a_flags_zeroresult_1_f11d0000() {
    // Test aarch32_ADD_SP_i_T3_A flag computation: ZeroResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0xF11D0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_aarch32_add_sp_i_t3_a_flags_negativeresult_2_f11d0000() {
    // Test aarch32_ADD_SP_i_T3_A flag computation: NegativeResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xF11D0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_aarch32_add_sp_i_t3_a_flags_unsignedoverflow_3_f11d0000() {
    // Test aarch32_ADD_SP_i_T3_A flag computation: UnsignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0xF11D0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_aarch32_add_sp_i_t3_a_flags_unsignedoverflow_4_f11d0000() {
    // Test aarch32_ADD_SP_i_T3_A flag computation: UnsignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0xF11D0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_aarch32_add_sp_i_t3_a_flags_signedoverflow_5_f11d0000() {
    // Test aarch32_ADD_SP_i_T3_A flag computation: SignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0xF11D0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_aarch32_add_sp_i_t3_a_flags_signedoverflow_6_f11d0000() {
    // Test aarch32_ADD_SP_i_T3_A flag computation: SignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF11D0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_ADD_SP_i_T3_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_aarch32_add_sp_i_t3_a_flags_positiveresult_7_f11d0000() {
    // Test aarch32_ADD_SP_i_T3_A flag computation: PositiveResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x32);
    let encoding: u32 = 0xF11D0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_SP_i_T4_A
/// ASL: `AND X0, X1, #0xFF`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// mask lower 8 bits (64)
#[test]
fn test_aarch32_add_sp_i_t4_a_and_oracle_64_0_92401c20() {
    // Test AND 64-bit: mask lower 8 bits (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x92401C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "X0 should be 0x00000000000000FF");
}

/// Provenance: aarch32_ADD_SP_i_T4_A
/// ASL: `AND X0, X1, #0xFFFF`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// mask lower 16 bits (64)
#[test]
fn test_aarch32_add_sp_i_t4_a_and_oracle_64_1_92403c20() {
    // Test AND 64-bit: mask lower 16 bits (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x92403C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFF, "X0 should be 0x000000000000FFFF");
}

/// Provenance: aarch32_ADD_SP_i_T4_A
/// ASL: `AND X0, X1, #0xFFFFFFFF`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// mask lower 32 bits (64)
#[test]
fn test_aarch32_add_sp_i_t4_a_and_oracle_64_2_92407c20() {
    // Test AND 64-bit: mask lower 32 bits (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x92407C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0x00000000FFFFFFFF"
    );
}

/// Provenance: aarch32_ADD_SP_i_T4_A
/// ASL: `AND X0, X1, #0x1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// single bit mask (64)
#[test]
fn test_aarch32_add_sp_i_t4_a_and_oracle_64_3_92400020() {
    // Test AND 64-bit: single bit mask (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xCAFEBABE);
    let encoding: u32 = 0x92400020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_ADD_SP_i_T4_A
/// ASL: `AND X0, X1, #0x7FFFFFFFFFFFFFFF`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// all but MSB (64)
#[test]
fn test_aarch32_add_sp_i_t4_a_and_oracle_64_4_9240f820() {
    // Test AND 64-bit: all but MSB (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    let encoding: u32 = 0x9240F820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xAAAAAAAA,
        "X0 should be 0x2AAAAAAAAAAAAAAA"
    );
}

/// Provenance: aarch32_ADD_SP_i_T4_A
/// ASL: `AND W0, W1, #0xFF`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// mask lower 8 bits (32)
#[test]
fn test_aarch32_add_sp_i_t4_a_and_oracle_32_0_12001c20() {
    // Test AND 32-bit: mask lower 8 bits (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x12001C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "W0 should be 0x000000FF");
}

/// Provenance: aarch32_ADD_SP_i_T4_A
/// ASL: `AND W0, W1, #0xFFFF`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// mask lower 16 bits (32)
#[test]
fn test_aarch32_add_sp_i_t4_a_and_oracle_32_1_12003c20() {
    // Test AND 32-bit: mask lower 16 bits (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x12003C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFF, "W0 should be 0x0000FFFF");
}

/// Provenance: aarch32_ADD_SP_i_T4_A
/// ASL: `AND W0, W1, #0x1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// single bit mask (32)
#[test]
fn test_aarch32_add_sp_i_t4_a_and_oracle_32_2_12000020() {
    // Test AND 32-bit: single bit mask (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xDEADBEEF);
    let encoding: u32 = 0x12000020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_ADD_SP_i_T4_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_aarch32_add_sp_i_t4_a_flags_zeroresult_0_f20d0000() {
    // Test aarch32_ADD_SP_i_T4_A flag computation: ZeroResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xF20D0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_SP_i_T4_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_aarch32_add_sp_i_t4_a_flags_zeroresult_1_f20d0000() {
    // Test aarch32_ADD_SP_i_T4_A flag computation: ZeroResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF20D0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_SP_i_T4_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_aarch32_add_sp_i_t4_a_flags_negativeresult_2_f20d0000() {
    // Test aarch32_ADD_SP_i_T4_A flag computation: NegativeResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xF20D0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_SP_i_T4_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_aarch32_add_sp_i_t4_a_flags_unsignedoverflow_3_f20d0000() {
    // Test aarch32_ADD_SP_i_T4_A flag computation: UnsignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0xF20D0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_SP_i_T4_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_aarch32_add_sp_i_t4_a_flags_unsignedoverflow_4_f20d0000() {
    // Test aarch32_ADD_SP_i_T4_A flag computation: UnsignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF20D0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADD_SP_i_T4_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_aarch32_add_sp_i_t4_a_flags_signedoverflow_5_f20d0000() {
    // Test aarch32_ADD_SP_i_T4_A flag computation: SignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0xF20D0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_ADD_SP_i_T4_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_aarch32_add_sp_i_t4_a_flags_signedoverflow_6_f20d0000() {
    // Test aarch32_ADD_SP_i_T4_A flag computation: SignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF20D0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_ADD_SP_i_T4_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_aarch32_add_sp_i_t4_a_flags_positiveresult_7_f20d0000() {
    // Test aarch32_ADD_SP_i_T4_A flag computation: PositiveResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x32);
    let encoding: u32 = 0xF20D0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

// ============================================================================
// aarch32_SBC_i_A Tests
// ============================================================================

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_sbc_i_a1_a_field_cond_0_min_0_02c00000() {
    // Encoding: 0x02C00000
    // Test aarch32_SBC_i_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, cond=0, S=0, Rd=0, imm12=0
    let encoding: u32 = 0x02C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_sbc_i_a1_a_field_cond_1_poweroftwo_0_12c00000() {
    // Encoding: 0x12C00000
    // Test aarch32_SBC_i_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=1, Rd=0, S=0, Rn=0, imm12=0
    let encoding: u32 = 0x12C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_sbc_i_a1_a_field_cond_2_poweroftwo_0_22c00000() {
    // Encoding: 0x22C00000
    // Test aarch32_SBC_i_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, imm12=0, Rn=0, cond=2, S=0
    let encoding: u32 = 0x22C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_sbc_i_a1_a_field_cond_3_poweroftwo_0_32c00000() {
    // Encoding: 0x32C00000
    // Test aarch32_SBC_i_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=3, S=0, Rn=0, imm12=0, Rd=0
    let encoding: u32 = 0x32C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_sbc_i_a1_a_field_cond_4_poweroftwo_0_42c00000() {
    // Encoding: 0x42C00000
    // Test aarch32_SBC_i_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, imm12=0, cond=4, S=0, Rn=0
    let encoding: u32 = 0x42C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_sbc_i_a1_a_field_cond_5_poweroftwo_0_52c00000() {
    // Encoding: 0x52C00000
    // Test aarch32_SBC_i_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, S=0, Rd=0, cond=5, imm12=0
    let encoding: u32 = 0x52C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_sbc_i_a1_a_field_cond_6_poweroftwo_0_62c00000() {
    // Encoding: 0x62C00000
    // Test aarch32_SBC_i_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, Rn=0, imm12=0, cond=6, Rd=0
    let encoding: u32 = 0x62C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_sbc_i_a1_a_field_cond_7_poweroftwo_0_72c00000() {
    // Encoding: 0x72C00000
    // Test aarch32_SBC_i_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rd=0, S=0, imm12=0, cond=7
    let encoding: u32 = 0x72C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_sbc_i_a1_a_field_cond_8_poweroftwo_0_82c00000() {
    // Encoding: 0x82C00000
    // Test aarch32_SBC_i_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rd=0, cond=8, imm12=0, S=0
    let encoding: u32 = 0x82C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_sbc_i_a1_a_field_cond_9_poweroftwo_0_92c00000() {
    // Encoding: 0x92C00000
    // Test aarch32_SBC_i_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=9, S=0, Rd=0, imm12=0
    let encoding: u32 = 0x92C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_sbc_i_a1_a_field_cond_10_poweroftwo_0_a2c00000() {
    // Encoding: 0xA2C00000
    // Test aarch32_SBC_i_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, imm12=0, cond=10, S=0, Rn=0
    let encoding: u32 = 0xA2C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_sbc_i_a1_a_field_cond_11_poweroftwo_0_b2c00000() {
    // Encoding: 0xB2C00000
    // Test aarch32_SBC_i_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, Rd=0, imm12=0, cond=11, Rn=0
    let encoding: u32 = 0xB2C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_sbc_i_a1_a_field_cond_12_poweroftwo_0_c2c00000() {
    // Encoding: 0xC2C00000
    // Test aarch32_SBC_i_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, S=0, cond=12, imm12=0, Rn=0
    let encoding: u32 = 0xC2C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_sbc_i_a1_a_field_cond_13_poweroftwo_0_d2c00000() {
    // Encoding: 0xD2C00000
    // Test aarch32_SBC_i_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, cond=13, Rd=0, Rn=0, imm12=0
    let encoding: u32 = 0xD2C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_sbc_i_a1_a_field_cond_14_poweroftwo_0_e2c00000() {
    // Encoding: 0xE2C00000
    // Test aarch32_SBC_i_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rd=0, S=0, imm12=0, cond=14
    let encoding: u32 = 0xE2C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_sbc_i_a1_a_field_cond_15_max_0_f2c00000() {
    // Encoding: 0xF2C00000
    // Test aarch32_SBC_i_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: S=0, Rd=0, imm12=0, Rn=0, cond=15
    let encoding: u32 = 0xF2C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_sbc_i_a1_a_field_s_0_min_0_02c00000() {
    // Encoding: 0x02C00000
    // Test aarch32_SBC_i_A1_A field S = 0 (Min)
    // ISET: A32
    // Fields: cond=0, S=0, imm12=0, Rn=0, Rd=0
    let encoding: u32 = 0x02C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_sbc_i_a1_a_field_s_1_max_0_02d00000() {
    // Encoding: 0x02D00000
    // Test aarch32_SBC_i_A1_A field S = 1 (Max)
    // ISET: A32
    // Fields: Rd=0, cond=0, S=1, Rn=0, imm12=0
    let encoding: u32 = 0x02D00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_sbc_i_a1_a_field_rn_0_min_0_02c00000() {
    // Encoding: 0x02C00000
    // Test aarch32_SBC_i_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: imm12=0, S=0, Rn=0, Rd=0, cond=0
    let encoding: u32 = 0x02C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_sbc_i_a1_a_field_rn_1_poweroftwo_0_02c10000() {
    // Encoding: 0x02C10000
    // Test aarch32_SBC_i_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=0, Rn=1, Rd=0, S=0, cond=0
    let encoding: u32 = 0x02C10000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_sbc_i_a1_a_field_rd_0_min_0_02c00000() {
    // Encoding: 0x02C00000
    // Test aarch32_SBC_i_A1_A field Rd = 0 (Min)
    // ISET: A32
    // Fields: imm12=0, Rn=0, cond=0, Rd=0, S=0
    let encoding: u32 = 0x02C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_sbc_i_a1_a_field_rd_1_poweroftwo_0_02c01000() {
    // Encoding: 0x02C01000
    // Test aarch32_SBC_i_A1_A field Rd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=0, cond=0, S=0, Rd=1, Rn=0
    let encoding: u32 = 0x02C01000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_sbc_i_a1_a_field_imm12_0_zero_0_02c00000() {
    // Encoding: 0x02C00000
    // Test aarch32_SBC_i_A1_A field imm12 = 0 (Zero)
    // ISET: A32
    // Fields: Rn=0, S=0, cond=0, Rd=0, imm12=0
    let encoding: u32 = 0x02C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_sbc_i_a1_a_field_imm12_1_poweroftwo_0_02c00001() {
    // Encoding: 0x02C00001
    // Test aarch32_SBC_i_A1_A field imm12 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, Rn=0, cond=0, imm12=1, Rd=0
    let encoding: u32 = 0x02C00001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_sbc_i_a1_a_field_imm12_3_poweroftwominusone_0_02c00003() {
    // Encoding: 0x02C00003
    // Test aarch32_SBC_i_A1_A field imm12 = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, S=0, imm12=3, Rn=0, Rd=0
    let encoding: u32 = 0x02C00003;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_sbc_i_a1_a_field_imm12_4_poweroftwo_0_02c00004() {
    // Encoding: 0x02C00004
    // Test aarch32_SBC_i_A1_A field imm12 = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rn=0, cond=0, S=0, imm12=4
    let encoding: u32 = 0x02C00004;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_sbc_i_a1_a_field_imm12_7_poweroftwominusone_0_02c00007() {
    // Encoding: 0x02C00007
    // Test aarch32_SBC_i_A1_A field imm12 = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: S=0, cond=0, Rd=0, imm12=7, Rn=0
    let encoding: u32 = 0x02C00007;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_sbc_i_a1_a_field_imm12_8_poweroftwo_0_02c00008() {
    // Encoding: 0x02C00008
    // Test aarch32_SBC_i_A1_A field imm12 = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, Rd=0, Rn=0, imm12=8, cond=0
    let encoding: u32 = 0x02C00008;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_sbc_i_a1_a_field_imm12_15_poweroftwominusone_0_02c0000f() {
    // Encoding: 0x02C0000F
    // Test aarch32_SBC_i_A1_A field imm12 = 15 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm12=15, Rn=0, Rd=0, cond=0, S=0
    let encoding: u32 = 0x02C0000F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_sbc_i_a1_a_field_imm12_16_poweroftwo_0_02c00010() {
    // Encoding: 0x02C00010
    // Test aarch32_SBC_i_A1_A field imm12 = 16 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Rn=0, imm12=16, S=0, Rd=0
    let encoding: u32 = 0x02C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_sbc_i_a1_a_field_imm12_31_poweroftwominusone_0_02c0001f() {
    // Encoding: 0x02C0001F
    // Test aarch32_SBC_i_A1_A field imm12 = 31 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rn=0, imm12=31, Rd=0, S=0, cond=0
    let encoding: u32 = 0x02C0001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_sbc_i_a1_a_field_imm12_32_poweroftwo_0_02c00020() {
    // Encoding: 0x02C00020
    // Test aarch32_SBC_i_A1_A field imm12 = 32 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, cond=0, Rd=0, imm12=32, Rn=0
    let encoding: u32 = 0x02C00020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_sbc_i_a1_a_field_imm12_63_poweroftwominusone_0_02c0003f() {
    // Encoding: 0x02C0003F
    // Test aarch32_SBC_i_A1_A field imm12 = 63 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rd=0, S=0, imm12=63, cond=0, Rn=0
    let encoding: u32 = 0x02C0003F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_sbc_i_a1_a_field_imm12_64_poweroftwo_0_02c00040() {
    // Encoding: 0x02C00040
    // Test aarch32_SBC_i_A1_A field imm12 = 64 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Rn=0, Rd=0, S=0, imm12=64
    let encoding: u32 = 0x02C00040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 127, boundary: PowerOfTwoMinusOne }
/// 2^7 - 1 = 127
#[test]
fn test_aarch32_sbc_i_a1_a_field_imm12_127_poweroftwominusone_0_02c0007f() {
    // Encoding: 0x02C0007F
    // Test aarch32_SBC_i_A1_A field imm12 = 127 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm12=127, Rd=0, Rn=0, S=0, cond=0
    let encoding: u32 = 0x02C0007F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_sbc_i_a1_a_field_imm12_128_poweroftwo_0_02c00080() {
    // Encoding: 0x02C00080
    // Test aarch32_SBC_i_A1_A field imm12 = 128 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, S=0, cond=0, Rn=0, imm12=128
    let encoding: u32 = 0x02C00080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 255, boundary: PowerOfTwoMinusOne }
/// 2^8 - 1 = 255
#[test]
fn test_aarch32_sbc_i_a1_a_field_imm12_255_poweroftwominusone_0_02c000ff() {
    // Encoding: 0x02C000FF
    // Test aarch32_SBC_i_A1_A field imm12 = 255 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, Rn=0, Rd=0, imm12=255, S=0
    let encoding: u32 = 0x02C000FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 256, boundary: PowerOfTwo }
/// power of 2 (2^8 = 256)
#[test]
fn test_aarch32_sbc_i_a1_a_field_imm12_256_poweroftwo_0_02c00100() {
    // Encoding: 0x02C00100
    // Test aarch32_SBC_i_A1_A field imm12 = 256 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, imm12=256, S=0, Rd=0, Rn=0
    let encoding: u32 = 0x02C00100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 511, boundary: PowerOfTwoMinusOne }
/// 2^9 - 1 = 511
#[test]
fn test_aarch32_sbc_i_a1_a_field_imm12_511_poweroftwominusone_0_02c001ff() {
    // Encoding: 0x02C001FF
    // Test aarch32_SBC_i_A1_A field imm12 = 511 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: S=0, Rn=0, Rd=0, imm12=511, cond=0
    let encoding: u32 = 0x02C001FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 512, boundary: PowerOfTwo }
/// power of 2 (2^9 = 512)
#[test]
fn test_aarch32_sbc_i_a1_a_field_imm12_512_poweroftwo_0_02c00200() {
    // Encoding: 0x02C00200
    // Test aarch32_SBC_i_A1_A field imm12 = 512 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, imm12=512, S=0, Rn=0, cond=0
    let encoding: u32 = 0x02C00200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1023, boundary: PowerOfTwoMinusOne }
/// 2^10 - 1 = 1023
#[test]
fn test_aarch32_sbc_i_a1_a_field_imm12_1023_poweroftwominusone_0_02c003ff() {
    // Encoding: 0x02C003FF
    // Test aarch32_SBC_i_A1_A field imm12 = 1023 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, imm12=1023, Rn=0, Rd=0, S=0
    let encoding: u32 = 0x02C003FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1024, boundary: PowerOfTwo }
/// power of 2 (2^10 = 1024)
#[test]
fn test_aarch32_sbc_i_a1_a_field_imm12_1024_poweroftwo_0_02c00400() {
    // Encoding: 0x02C00400
    // Test aarch32_SBC_i_A1_A field imm12 = 1024 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rn=0, cond=0, imm12=1024, S=0
    let encoding: u32 = 0x02C00400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2047, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (2047)
#[test]
fn test_aarch32_sbc_i_a1_a_field_imm12_2047_poweroftwominusone_0_02c007ff() {
    // Encoding: 0x02C007FF
    // Test aarch32_SBC_i_A1_A field imm12 = 2047 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rd=0, imm12=2047, Rn=0, cond=0, S=0
    let encoding: u32 = 0x02C007FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2048, boundary: PowerOfTwo }
/// power of 2 (2^11 = 2048)
#[test]
fn test_aarch32_sbc_i_a1_a_field_imm12_2048_poweroftwo_0_02c00800() {
    // Encoding: 0x02C00800
    // Test aarch32_SBC_i_A1_A field imm12 = 2048 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, S=0, Rn=0, imm12=2048, Rd=0
    let encoding: u32 = 0x02C00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4095, boundary: Max }
/// maximum immediate (4095)
#[test]
fn test_aarch32_sbc_i_a1_a_field_imm12_4095_max_0_02c00fff() {
    // Encoding: 0x02C00FFF
    // Test aarch32_SBC_i_A1_A field imm12 = 4095 (Max)
    // ISET: A32
    // Fields: S=0, Rd=0, Rn=0, imm12=4095, cond=0
    let encoding: u32 = 0x02C00FFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_sbc_i_a1_a_combo_0_0_02c00000() {
    // Encoding: 0x02C00000
    // Test aarch32_SBC_i_A1_A field combination: cond=0, S=0, Rn=0, Rd=0, imm12=0
    // ISET: A32
    // Fields: imm12=0, Rn=0, cond=0, Rd=0, S=0
    let encoding: u32 = 0x02C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_sbc_i_a1_a_special_cond_0_condition_eq_0_02c00000() {
    // Encoding: 0x02C00000
    // Test aarch32_SBC_i_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: imm12=0, Rn=0, Rd=0, cond=0, S=0
    let encoding: u32 = 0x02C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_sbc_i_a1_a_special_cond_1_condition_ne_0_12c00000() {
    // Encoding: 0x12C00000
    // Test aarch32_SBC_i_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: Rd=0, S=0, imm12=0, Rn=0, cond=1
    let encoding: u32 = 0x12C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_sbc_i_a1_a_special_cond_2_condition_cs_hs_0_22c00000() {
    // Encoding: 0x22C00000
    // Test aarch32_SBC_i_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: Rd=0, cond=2, imm12=0, Rn=0, S=0
    let encoding: u32 = 0x22C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_sbc_i_a1_a_special_cond_3_condition_cc_lo_0_32c00000() {
    // Encoding: 0x32C00000
    // Test aarch32_SBC_i_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: Rn=0, Rd=0, imm12=0, S=0, cond=3
    let encoding: u32 = 0x32C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_sbc_i_a1_a_special_cond_4_condition_mi_0_42c00000() {
    // Encoding: 0x42C00000
    // Test aarch32_SBC_i_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: imm12=0, Rn=0, S=0, cond=4, Rd=0
    let encoding: u32 = 0x42C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_sbc_i_a1_a_special_cond_5_condition_pl_0_52c00000() {
    // Encoding: 0x52C00000
    // Test aarch32_SBC_i_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: Rd=0, imm12=0, Rn=0, cond=5, S=0
    let encoding: u32 = 0x52C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_sbc_i_a1_a_special_cond_6_condition_vs_0_62c00000() {
    // Encoding: 0x62C00000
    // Test aarch32_SBC_i_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: cond=6, S=0, Rd=0, imm12=0, Rn=0
    let encoding: u32 = 0x62C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_sbc_i_a1_a_special_cond_7_condition_vc_0_72c00000() {
    // Encoding: 0x72C00000
    // Test aarch32_SBC_i_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: cond=7, Rd=0, Rn=0, imm12=0, S=0
    let encoding: u32 = 0x72C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_sbc_i_a1_a_special_cond_8_condition_hi_0_82c00000() {
    // Encoding: 0x82C00000
    // Test aarch32_SBC_i_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: Rd=0, S=0, Rn=0, imm12=0, cond=8
    let encoding: u32 = 0x82C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_sbc_i_a1_a_special_cond_9_condition_ls_0_92c00000() {
    // Encoding: 0x92C00000
    // Test aarch32_SBC_i_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: imm12=0, Rd=0, Rn=0, cond=9, S=0
    let encoding: u32 = 0x92C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_sbc_i_a1_a_special_cond_10_condition_ge_0_a2c00000() {
    // Encoding: 0xA2C00000
    // Test aarch32_SBC_i_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: imm12=0, S=0, cond=10, Rn=0, Rd=0
    let encoding: u32 = 0xA2C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_sbc_i_a1_a_special_cond_11_condition_lt_0_b2c00000() {
    // Encoding: 0xB2C00000
    // Test aarch32_SBC_i_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: S=0, Rd=0, cond=11, Rn=0, imm12=0
    let encoding: u32 = 0xB2C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_sbc_i_a1_a_special_cond_12_condition_gt_0_c2c00000() {
    // Encoding: 0xC2C00000
    // Test aarch32_SBC_i_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: Rn=0, imm12=0, Rd=0, cond=12, S=0
    let encoding: u32 = 0xC2C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_sbc_i_a1_a_special_cond_13_condition_le_0_d2c00000() {
    // Encoding: 0xD2C00000
    // Test aarch32_SBC_i_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: cond=13, Rd=0, S=0, Rn=0, imm12=0
    let encoding: u32 = 0xD2C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_sbc_i_a1_a_special_cond_14_condition_al_0_e2c00000() {
    // Encoding: 0xE2C00000
    // Test aarch32_SBC_i_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: S=0, Rd=0, cond=14, Rn=0, imm12=0
    let encoding: u32 = 0xE2C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_sbc_i_a1_a_special_cond_15_condition_nv_0_f2c00000() {
    // Encoding: 0xF2C00000
    // Test aarch32_SBC_i_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: S=0, Rn=0, Rd=0, cond=15, imm12=0
    let encoding: u32 = 0xF2C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `field S = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "S", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_sbc_i_a1_a_special_s_0_size_variant_0_0_02c00000() {
    // Encoding: 0x02C00000
    // Test aarch32_SBC_i_A1_A special value S = 0 (Size variant 0)
    // ISET: A32
    // Fields: imm12=0, cond=0, Rn=0, S=0, Rd=0
    let encoding: u32 = 0x02C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `field S = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "S", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_sbc_i_a1_a_special_s_1_size_variant_1_0_02d00000() {
    // Encoding: 0x02D00000
    // Test aarch32_SBC_i_A1_A special value S = 1 (Size variant 1)
    // ISET: A32
    // Fields: S=1, Rd=0, cond=0, Rn=0, imm12=0
    let encoding: u32 = 0x02D00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `field i 26 +: 1`
/// Requirement: FieldBoundary { field: "i", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_sbc_i_t1_a_field_i_0_min_0_f1600000() {
    // Thumb encoding (32): 0xF1600000
    // Test aarch32_SBC_i_T1_A field i = 0 (Min)
    // ISET: T32
    // Fields: i=0, Rn=0, imm3=0, Rd=0, imm8=0, S=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1600000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `field i 26 +: 1`
/// Requirement: FieldBoundary { field: "i", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_sbc_i_t1_a_field_i_1_max_0_f5600000() {
    // Thumb encoding (32): 0xF5600000
    // Test aarch32_SBC_i_T1_A field i = 1 (Max)
    // ISET: T32
    // Fields: S=0, imm8=0, i=1, imm3=0, Rd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF5600000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_sbc_i_t1_a_field_s_0_min_0_f1600000() {
    // Thumb encoding (32): 0xF1600000
    // Test aarch32_SBC_i_T1_A field S = 0 (Min)
    // ISET: T32
    // Fields: i=0, S=0, Rn=0, imm3=0, Rd=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1600000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_sbc_i_t1_a_field_s_1_max_0_f1700000() {
    // Thumb encoding (32): 0xF1700000
    // Test aarch32_SBC_i_T1_A field S = 1 (Max)
    // ISET: T32
    // Fields: Rd=0, Rn=0, S=1, imm3=0, i=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1700000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_sbc_i_t1_a_field_rn_0_min_0_f1600000() {
    // Thumb encoding (32): 0xF1600000
    // Test aarch32_SBC_i_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: imm3=0, Rd=0, i=0, S=0, Rn=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1600000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_sbc_i_t1_a_field_rn_1_poweroftwo_0_f1610000() {
    // Thumb encoding (32): 0xF1610000
    // Test aarch32_SBC_i_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=1, imm8=0, i=0, Rd=0, S=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1610000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_sbc_i_t1_a_field_imm3_0_zero_0_f1600000() {
    // Thumb encoding (32): 0xF1600000
    // Test aarch32_SBC_i_T1_A field imm3 = 0 (Zero)
    // ISET: T32
    // Fields: imm8=0, Rn=0, i=0, imm3=0, S=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1600000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_sbc_i_t1_a_field_imm3_1_poweroftwo_0_f1601000() {
    // Thumb encoding (32): 0xF1601000
    // Test aarch32_SBC_i_T1_A field imm3 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=0, Rn=0, imm3=1, Rd=0, S=0, i=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1601000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 3, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (3)
#[test]
fn test_aarch32_sbc_i_t1_a_field_imm3_3_poweroftwominusone_0_f1603000() {
    // Thumb encoding (32): 0xF1603000
    // Test aarch32_SBC_i_T1_A field imm3 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: i=0, imm3=3, Rd=0, S=0, Rn=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1603000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 7, boundary: Max }
/// maximum immediate (7)
#[test]
fn test_aarch32_sbc_i_t1_a_field_imm3_7_max_0_f1607000() {
    // Thumb encoding (32): 0xF1607000
    // Test aarch32_SBC_i_T1_A field imm3 = 7 (Max)
    // ISET: T32
    // Fields: imm3=7, i=0, S=0, Rn=0, Rd=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1607000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_sbc_i_t1_a_field_rd_0_min_0_f1600000() {
    // Thumb encoding (32): 0xF1600000
    // Test aarch32_SBC_i_T1_A field Rd = 0 (Min)
    // ISET: T32
    // Fields: i=0, Rn=0, imm8=0, Rd=0, S=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1600000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_sbc_i_t1_a_field_rd_1_poweroftwo_0_f1600100() {
    // Thumb encoding (32): 0xF1600100
    // Test aarch32_SBC_i_T1_A field Rd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=0, Rn=0, i=0, S=0, imm3=0, Rd=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1600100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_sbc_i_t1_a_field_imm8_0_zero_0_f1600000() {
    // Thumb encoding (32): 0xF1600000
    // Test aarch32_SBC_i_T1_A field imm8 = 0 (Zero)
    // ISET: T32
    // Fields: imm3=0, S=0, i=0, Rn=0, Rd=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1600000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_sbc_i_t1_a_field_imm8_1_poweroftwo_0_f1600001() {
    // Thumb encoding (32): 0xF1600001
    // Test aarch32_SBC_i_T1_A field imm8 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: i=0, Rd=0, imm8=1, S=0, imm3=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1600001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_sbc_i_t1_a_field_imm8_3_poweroftwominusone_0_f1600003() {
    // Thumb encoding (32): 0xF1600003
    // Test aarch32_SBC_i_T1_A field imm8 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rd=0, imm3=0, imm8=3, i=0, S=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1600003;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_sbc_i_t1_a_field_imm8_4_poweroftwo_0_f1600004() {
    // Thumb encoding (32): 0xF1600004
    // Test aarch32_SBC_i_T1_A field imm8 = 4 (PowerOfTwo)
    // ISET: T32
    // Fields: i=0, Rn=0, Rd=0, imm8=4, S=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1600004;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_sbc_i_t1_a_field_imm8_7_poweroftwominusone_0_f1600007() {
    // Thumb encoding (32): 0xF1600007
    // Test aarch32_SBC_i_T1_A field imm8 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: S=0, i=0, imm8=7, Rn=0, imm3=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1600007;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_sbc_i_t1_a_field_imm8_8_poweroftwo_0_f1600008() {
    // Thumb encoding (32): 0xF1600008
    // Test aarch32_SBC_i_T1_A field imm8 = 8 (PowerOfTwo)
    // ISET: T32
    // Fields: i=0, Rd=0, imm8=8, imm3=0, S=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1600008;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_sbc_i_t1_a_field_imm8_15_poweroftwominusone_0_f160000f() {
    // Thumb encoding (32): 0xF160000F
    // Test aarch32_SBC_i_T1_A field imm8 = 15 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, S=0, i=0, imm3=0, Rd=0, imm8=15
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF160000F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_sbc_i_t1_a_field_imm8_16_poweroftwo_0_f1600010() {
    // Thumb encoding (32): 0xF1600010
    // Test aarch32_SBC_i_T1_A field imm8 = 16 (PowerOfTwo)
    // ISET: T32
    // Fields: i=0, imm8=16, S=0, Rn=0, imm3=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1600010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_sbc_i_t1_a_field_imm8_31_poweroftwominusone_0_f160001f() {
    // Thumb encoding (32): 0xF160001F
    // Test aarch32_SBC_i_T1_A field imm8 = 31 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: S=0, Rn=0, i=0, imm3=0, Rd=0, imm8=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF160001F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_sbc_i_t1_a_field_imm8_32_poweroftwo_0_f1600020() {
    // Thumb encoding (32): 0xF1600020
    // Test aarch32_SBC_i_T1_A field imm8 = 32 (PowerOfTwo)
    // ISET: T32
    // Fields: Rd=0, imm3=0, Rn=0, i=0, imm8=32, S=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1600020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_sbc_i_t1_a_field_imm8_63_poweroftwominusone_0_f160003f() {
    // Thumb encoding (32): 0xF160003F
    // Test aarch32_SBC_i_T1_A field imm8 = 63 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm8=63, i=0, imm3=0, Rn=0, Rd=0, S=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF160003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_sbc_i_t1_a_field_imm8_64_poweroftwo_0_f1600040() {
    // Thumb encoding (32): 0xF1600040
    // Test aarch32_SBC_i_T1_A field imm8 = 64 (PowerOfTwo)
    // ISET: T32
    // Fields: imm3=0, Rd=0, imm8=64, S=0, Rn=0, i=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1600040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 127, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (127)
#[test]
fn test_aarch32_sbc_i_t1_a_field_imm8_127_poweroftwominusone_0_f160007f() {
    // Thumb encoding (32): 0xF160007F
    // Test aarch32_SBC_i_T1_A field imm8 = 127 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm3=0, Rn=0, imm8=127, S=0, i=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF160007F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_sbc_i_t1_a_field_imm8_128_poweroftwo_0_f1600080() {
    // Thumb encoding (32): 0xF1600080
    // Test aarch32_SBC_i_T1_A field imm8 = 128 (PowerOfTwo)
    // ISET: T32
    // Fields: Rd=0, S=0, imm3=0, i=0, Rn=0, imm8=128
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1600080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 255, boundary: Max }
/// maximum immediate (255)
#[test]
fn test_aarch32_sbc_i_t1_a_field_imm8_255_max_0_f16000ff() {
    // Thumb encoding (32): 0xF16000FF
    // Test aarch32_SBC_i_T1_A field imm8 = 255 (Max)
    // ISET: T32
    // Fields: imm8=255, Rn=0, S=0, imm3=0, i=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF16000FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// i=0 (minimum value)
#[test]
fn test_aarch32_sbc_i_t1_a_combo_0_0_f1600000() {
    // Thumb encoding (32): 0xF1600000
    // Test aarch32_SBC_i_T1_A field combination: i=0, S=0, Rn=0, imm3=0, Rd=0, imm8=0
    // ISET: T32
    // Fields: imm3=0, Rn=0, imm8=0, i=0, S=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1600000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `field S = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "S", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_sbc_i_t1_a_special_s_0_size_variant_0_0_f1600000() {
    // Thumb encoding (32): 0xF1600000
    // Test aarch32_SBC_i_T1_A special value S = 0 (Size variant 0)
    // ISET: T32
    // Fields: i=0, Rn=0, imm3=0, Rd=0, S=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1600000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `field S = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "S", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_sbc_i_t1_a_special_s_1_size_variant_1_0_f1700000() {
    // Thumb encoding (32): 0xF1700000
    // Test aarch32_SBC_i_T1_A special value S = 1 (Size variant 1)
    // ISET: T32
    // Fields: i=0, S=1, Rd=0, Rn=0, imm3=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1700000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_sbc_i_t1_a_invalid_0_0_f1600000() {
    // Thumb encoding (32): 0xF1600000
    // Test aarch32_SBC_i_T1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }
    // ISET: T32
    // Fields: i=0, S=0, Rn=0, imm3=0, Rd=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1600000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_sbc_i_t1_a_invalid_1_0_f1600000() {
    // Thumb encoding (32): 0xF1600000
    // Test aarch32_SBC_i_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: imm8=0, S=0, Rn=0, Rd=0, i=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF1600000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `ADD X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_sbc_i_a1_a_add_oracle_32_0_02c02820() {
    // Test ADD 32-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0x02C02820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x02C02820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA064, "W0 should be 0xA064");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `ADD X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_sbc_i_a1_a_add_oracle_64_0_82c02820() {
    // Test ADD 64-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0x82C02820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x82C02820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA064, "X0 should be 0x000000000000A064");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `ADD X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero operands (32)
#[test]
fn test_aarch32_sbc_i_a1_a_add_oracle_32_1_02c00020() {
    // Test ADD 32-bit: zero operands (with oracle verification)
    // Encoding: 0x02C00020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x02C00020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x0");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `ADD X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero operands (64)
#[test]
fn test_aarch32_sbc_i_a1_a_add_oracle_64_1_82c00020() {
    // Test ADD 64-bit: zero operands (with oracle verification)
    // Encoding: 0x82C00020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x82C00020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small values (32)
#[test]
fn test_aarch32_sbc_i_a1_a_add_oracle_32_2_02c00420() {
    // Test ADD 32-bit: small values (with oracle verification)
    // Encoding: 0x02C00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x02C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1001, "W0 should be 0x1001");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// small values (64)
#[test]
fn test_aarch32_sbc_i_a1_a_add_oracle_64_2_82c00420() {
    // Test ADD 64-bit: small values (with oracle verification)
    // Encoding: 0x82C00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x82C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1001, "X0 should be 0x0000000000001001");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `ADD X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_sbc_i_a1_a_add_oracle_32_3_02fffc20() {
    // Test ADD 32-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0x02FFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x02FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF000, "W0 should be 0xFFF000");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `ADD X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_sbc_i_a1_a_add_oracle_64_3_82fffc20() {
    // Test ADD 64-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0x82FFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x82FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF000, "X0 should be 0x0000000000FFF000");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `ADD X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_sbc_i_a1_a_add_oracle_32_4_02fffc20() {
    // Test ADD 32-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0x02FFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x02FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF000, "W0 should be 0xFFF000");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `ADD X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_sbc_i_a1_a_add_oracle_64_4_82fffc20() {
    // Test ADD 64-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0x82FFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x82FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF000, "X0 should be 0x0000000000FFF000");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max u64 operand (32)
#[test]
fn test_aarch32_sbc_i_a1_a_add_oracle_32_5_02c00420() {
    // Test ADD 32-bit: max u64 operand (with oracle verification)
    // Encoding: 0x02C00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x02C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF, "W0 should be 0xFFF");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max u64 operand (64)
#[test]
fn test_aarch32_sbc_i_a1_a_add_oracle_64_5_82c00420() {
    // Test ADD 64-bit: max u64 operand (with oracle verification)
    // Encoding: 0x82C00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x82C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF, "X0 should be 0x0000000000000FFF");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_sbc_i_a1_a_add_oracle_32_6_02c00420() {
    // Test ADD 32-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0x02C00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x02C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1000, "W0 should be 0x1000");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_sbc_i_a1_a_add_oracle_64_6_82c00420() {
    // Test ADD 64-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0x82C00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x82C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1000, "X0 should be 0x0000000000001000");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_sbc_i_a1_a_add_oracle_32_7_02c00420() {
    // Test ADD 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0x02C00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x02C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF, "W0 should be 0xFFF");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_sbc_i_a1_a_add_oracle_64_7_82c00420() {
    // Test ADD 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0x82C00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x82C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF, "X0 should be 0x8000000000000FFF");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_sbc_i_a1_a_add_oracle_32_8_02c00420() {
    // Test ADD 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0x02C00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x02C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000FFF, "W0 should be 0x80000FFF");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_sbc_i_a1_a_add_oracle_64_8_82c00420() {
    // Test ADD 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0x82C00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x82C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x80000FFF,
        "X0 should be 0x0000000080000FFF"
    );
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_sbc_i_a1_a_add_oracle_32_9_02c00420() {
    // Test ADD 32-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0x02C00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x02C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF, "W0 should be 0xFFF");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_sbc_i_a1_a_add_oracle_64_9_82c00420() {
    // Test ADD 64-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0x82C00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x82C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF, "X0 should be 0x0000000000000FFF");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_sbc_i_a1_a_add_oracle_32_10_02c00420() {
    // Test ADD 32-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0x02C00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x02C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF, "W0 should be 0xFFF");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_sbc_i_a1_a_add_oracle_64_10_82c00420() {
    // Test ADD 64-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0x82C00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x82C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF, "X0 should be 0x0000000100000FFF");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `ADD SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (32)
#[test]
fn test_aarch32_sbc_i_a1_a_add_oracle_32_rd31_sp_02c0283f() {
    // Test ADD 32-bit with Rd=31 (SP)
    // Encoding: 0x02C0283F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x02C0283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    // TODO: assertion - TestAssertion { check: Sp, expected: U64(41060), message: "SP should be 0xA064" }
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `ADD SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (64)
#[test]
fn test_aarch32_sbc_i_a1_a_add_oracle_64_rd31_sp_82c0283f() {
    // Test ADD 64-bit with Rd=31 (SP)
    // Encoding: 0x82C0283F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x82C0283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    // TODO: assertion - TestAssertion { check: Sp, expected: U64(41060), message: "SP should be 0xA064" }
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `ADDS X0, X1, #10`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_sbc_i_a1_a_adds_oracle_32_0_22c02820() {
    // Test ADDS 32-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0x22C02820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x22C02820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA064, "W0 should be 0xA064");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `ADDS X0, X1, #10`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_sbc_i_a1_a_adds_oracle_64_0_a2c02820() {
    // Test ADDS 64-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0xA2C02820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xA2C02820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA064, "X0 should be 0x000000000000A064");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `ADDS X0, X1, #0`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero operands (32)
#[test]
fn test_aarch32_sbc_i_a1_a_adds_oracle_32_1_22c00020() {
    // Test ADDS 32-bit: zero operands (with oracle verification)
    // Encoding: 0x22C00020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x22C00020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x0");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `ADDS X0, X1, #0`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero operands (64)
#[test]
fn test_aarch32_sbc_i_a1_a_adds_oracle_64_1_a2c00020() {
    // Test ADDS 64-bit: zero operands (with oracle verification)
    // Encoding: 0xA2C00020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xA2C00020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// small values (32)
#[test]
fn test_aarch32_sbc_i_a1_a_adds_oracle_32_2_22c00420() {
    // Test ADDS 32-bit: small values (with oracle verification)
    // Encoding: 0x22C00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x22C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1001, "W0 should be 0x1001");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// small values (64)
#[test]
fn test_aarch32_sbc_i_a1_a_adds_oracle_64_2_a2c00420() {
    // Test ADDS 64-bit: small values (with oracle verification)
    // Encoding: 0xA2C00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xA2C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1001, "X0 should be 0x0000000000001001");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `ADDS X0, X1, #4095`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_sbc_i_a1_a_adds_oracle_32_3_22fffc20() {
    // Test ADDS 32-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0x22FFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x22FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF000, "W0 should be 0xFFF000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `ADDS X0, X1, #4095`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_sbc_i_a1_a_adds_oracle_64_3_a2fffc20() {
    // Test ADDS 64-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0xA2FFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xA2FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF000, "X0 should be 0x0000000000FFF000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `ADDS X0, X1, #4095, LSL #12`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_sbc_i_a1_a_adds_oracle_32_4_22fffc20() {
    // Test ADDS 32-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0x22FFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x22FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF000, "W0 should be 0xFFF000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `ADDS X0, X1, #4095, LSL #12`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_sbc_i_a1_a_adds_oracle_64_4_a2fffc20() {
    // Test ADDS 64-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0xA2FFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xA2FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF000, "X0 should be 0x0000000000FFF000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max u64 operand (32)
#[test]
fn test_aarch32_sbc_i_a1_a_adds_oracle_32_5_22c00420() {
    // Test ADDS 32-bit: max u64 operand (with oracle verification)
    // Encoding: 0x22C00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x22C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF, "W0 should be 0xFFF");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max u64 operand (64)
#[test]
fn test_aarch32_sbc_i_a1_a_adds_oracle_64_5_a2c00420() {
    // Test ADDS 64-bit: max u64 operand (with oracle verification)
    // Encoding: 0xA2C00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xA2C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF, "X0 should be 0x0000000000000FFF");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_sbc_i_a1_a_adds_oracle_32_6_22c00420() {
    // Test ADDS 32-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0x22C00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x22C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1000, "W0 should be 0x1000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_sbc_i_a1_a_adds_oracle_64_6_a2c00420() {
    // Test ADDS 64-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0xA2C00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xA2C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1000, "X0 should be 0x0000000000001000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_sbc_i_a1_a_adds_oracle_32_7_22c00420() {
    // Test ADDS 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0x22C00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x22C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF, "W0 should be 0xFFF");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_sbc_i_a1_a_adds_oracle_64_7_a2c00420() {
    // Test ADDS 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0xA2C00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xA2C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF, "X0 should be 0x8000000000000FFF");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, true, "V flag should be true");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_sbc_i_a1_a_adds_oracle_32_8_22c00420() {
    // Test ADDS 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0x22C00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x22C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000FFF, "W0 should be 0x80000FFF");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, true, "V flag should be true");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_sbc_i_a1_a_adds_oracle_64_8_a2c00420() {
    // Test ADDS 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0xA2C00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xA2C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x80000FFF,
        "X0 should be 0x0000000080000FFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_sbc_i_a1_a_adds_oracle_32_9_22c00420() {
    // Test ADDS 32-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0x22C00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x22C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF, "W0 should be 0xFFF");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_sbc_i_a1_a_adds_oracle_64_9_a2c00420() {
    // Test ADDS 64-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0xA2C00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xA2C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF, "X0 should be 0x0000000000000FFF");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_sbc_i_a1_a_adds_oracle_32_10_22c00420() {
    // Test ADDS 32-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0x22C00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x22C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF, "W0 should be 0xFFF");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_sbc_i_a1_a_adds_oracle_64_10_a2c00420() {
    // Test ADDS 64-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0xA2C00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xA2C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFF, "X0 should be 0x0000000100000FFF");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `ADDS ZR, X1, #10`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "result discarded, flags set" }
/// ZR destination (32)
#[test]
fn test_aarch32_sbc_i_a1_a_adds_oracle_32_rd31_zr_22c0283f() {
    // Test ADDS 32-bit with Rd=31 (ZR)
    // Encoding: 0x22C0283F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x22C0283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `ADDS ZR, X1, #10`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "result discarded, flags set" }
/// ZR destination (64)
#[test]
fn test_aarch32_sbc_i_a1_a_adds_oracle_64_rd31_zr_a2c0283f() {
    // Test ADDS 64-bit with Rd=31 (ZR)
    // Encoding: 0xA2C0283F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xA2C0283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `SUB X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_sbc_i_a1_a_sub_oracle_32_0_42c02820() {
    // Test SUB 32-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0x42C02820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x42C02820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFF6064, "W0 should be 0xFFFF6064");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `SUB X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_sbc_i_a1_a_sub_oracle_64_0_c2c02820() {
    // Test SUB 64-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0xC2C02820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xC2C02820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFF6064,
        "X0 should be 0xFFFFFFFFFFFF6064"
    );
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `SUB X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero operands (32)
#[test]
fn test_aarch32_sbc_i_a1_a_sub_oracle_32_1_42c00020() {
    // Test SUB 32-bit: zero operands (with oracle verification)
    // Encoding: 0x42C00020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x42C00020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x0");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `SUB X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero operands (64)
#[test]
fn test_aarch32_sbc_i_a1_a_sub_oracle_64_1_c2c00020() {
    // Test SUB 64-bit: zero operands (with oracle verification)
    // Encoding: 0xC2C00020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xC2C00020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small values (32)
#[test]
fn test_aarch32_sbc_i_a1_a_sub_oracle_32_2_42c00420() {
    // Test SUB 32-bit: small values (with oracle verification)
    // Encoding: 0x42C00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x42C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFF001, "W0 should be 0xFFFFF001");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// small values (64)
#[test]
fn test_aarch32_sbc_i_a1_a_sub_oracle_64_2_c2c00420() {
    // Test SUB 64-bit: small values (with oracle verification)
    // Encoding: 0xC2C00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xC2C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `SUB X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_sbc_i_a1_a_sub_oracle_32_3_42fffc20() {
    // Test SUB 32-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0x42FFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x42FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF001000, "W0 should be 0xFF001000");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `SUB X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_sbc_i_a1_a_sub_oracle_64_3_c2fffc20() {
    // Test SUB 64-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0xC2FFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xC2FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `SUB X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_sbc_i_a1_a_sub_oracle_32_4_42fffc20() {
    // Test SUB 32-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0x42FFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x42FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF001000, "W0 should be 0xFF001000");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `SUB X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_sbc_i_a1_a_sub_oracle_64_4_c2fffc20() {
    // Test SUB 64-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0xC2FFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xC2FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max u64 operand (32)
#[test]
fn test_aarch32_sbc_i_a1_a_sub_oracle_32_5_42c00420() {
    // Test SUB 32-bit: max u64 operand (with oracle verification)
    // Encoding: 0x42C00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x42C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFEFFF, "W0 should be 0xFFFFEFFF");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max u64 operand (64)
#[test]
fn test_aarch32_sbc_i_a1_a_sub_oracle_64_5_c2c00420() {
    // Test SUB 64-bit: max u64 operand (with oracle verification)
    // Encoding: 0xC2C00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xC2C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFEFFF,
        "X0 should be 0xFFFFFFFFFFFFEFFF"
    );
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_sbc_i_a1_a_sub_oracle_32_6_42c00420() {
    // Test SUB 32-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0x42C00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x42C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFF000, "W0 should be 0xFFFFF000");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_sbc_i_a1_a_sub_oracle_64_6_c2c00420() {
    // Test SUB 64-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0xC2C00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xC2C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF000,
        "X0 should be 0xFFFFFFFFFFFFF000"
    );
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_sbc_i_a1_a_sub_oracle_32_7_42c00420() {
    // Test SUB 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0x42C00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x42C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFEFFF, "W0 should be 0xFFFFEFFF");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_sbc_i_a1_a_sub_oracle_64_7_c2c00420() {
    // Test SUB 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0xC2C00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xC2C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFEFFF,
        "X0 should be 0x7FFFFFFFFFFFEFFF"
    );
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_sbc_i_a1_a_sub_oracle_32_8_42c00420() {
    // Test SUB 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0x42C00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x42C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FFFEFFF, "W0 should be 0x7FFFEFFF");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_sbc_i_a1_a_sub_oracle_64_8_c2c00420() {
    // Test SUB 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0xC2C00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xC2C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x7FFFEFFF,
        "X0 should be 0x000000007FFFEFFF"
    );
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_sbc_i_a1_a_sub_oracle_32_9_42c00420() {
    // Test SUB 32-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0x42C00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x42C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFEFFF, "W0 should be 0xFFFFEFFF");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_sbc_i_a1_a_sub_oracle_64_9_c2c00420() {
    // Test SUB 64-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0xC2C00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xC2C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFEFFF,
        "X0 should be 0xFFFFFFFFFFFFEFFF"
    );
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_sbc_i_a1_a_sub_oracle_32_10_42c00420() {
    // Test SUB 32-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0x42C00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x42C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFEFFF, "W0 should be 0xFFFFEFFF");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_sbc_i_a1_a_sub_oracle_64_10_c2c00420() {
    // Test SUB 64-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0xC2C00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xC2C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFEFFF,
        "X0 should be 0x00000000FFFFEFFF"
    );
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `SUB SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (32)
#[test]
fn test_aarch32_sbc_i_a1_a_sub_oracle_32_rd31_sp_42c0283f() {
    // Test SUB 32-bit with Rd=31 (SP)
    // Encoding: 0x42C0283F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x42C0283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    // TODO: assertion - TestAssertion { check: Sp, expected: U64(4294926436), message: "SP should be 0xFFFF6064" }
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `SUB SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (64)
#[test]
fn test_aarch32_sbc_i_a1_a_sub_oracle_64_rd31_sp_c2c0283f() {
    // Test SUB 64-bit with Rd=31 (SP)
    // Encoding: 0xC2C0283F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xC2C0283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    // TODO: assertion - TestAssertion { check: Sp, expected: U64(18446744073709510756), message: "SP should be 0xFFFFFFFFFFFF6064" }
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `SUBS X0, X1, #10`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_sbc_i_a1_a_subs_oracle_32_0_62c02820() {
    // Test SUBS 32-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0x62C02820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x62C02820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFF6064, "W0 should be 0xFFFF6064");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `SUBS X0, X1, #10`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_sbc_i_a1_a_subs_oracle_64_0_e2c02820() {
    // Test SUBS 64-bit: simple addition/subtraction (with oracle verification)
    // Encoding: 0xE2C02820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xE2C02820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFF6064,
        "X0 should be 0xFFFFFFFFFFFF6064"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `SUBS X0, X1, #0`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero operands (32)
#[test]
fn test_aarch32_sbc_i_a1_a_subs_oracle_32_1_62c00020() {
    // Test SUBS 32-bit: zero operands (with oracle verification)
    // Encoding: 0x62C00020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x62C00020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x0");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `SUBS X0, X1, #0`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero operands (64)
#[test]
fn test_aarch32_sbc_i_a1_a_subs_oracle_64_1_e2c00020() {
    // Test SUBS 64-bit: zero operands (with oracle verification)
    // Encoding: 0xE2C00020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xE2C00020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// small values (32)
#[test]
fn test_aarch32_sbc_i_a1_a_subs_oracle_32_2_62c00420() {
    // Test SUBS 32-bit: small values (with oracle verification)
    // Encoding: 0x62C00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x62C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFF001, "W0 should be 0xFFFFF001");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// small values (64)
#[test]
fn test_aarch32_sbc_i_a1_a_subs_oracle_64_2_e2c00420() {
    // Test SUBS 64-bit: small values (with oracle verification)
    // Encoding: 0xE2C00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xE2C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF001,
        "X0 should be 0xFFFFFFFFFFFFF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `SUBS X0, X1, #4095`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_sbc_i_a1_a_subs_oracle_32_3_62fffc20() {
    // Test SUBS 32-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0x62FFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x62FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF001000, "W0 should be 0xFF001000");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `SUBS X0, X1, #4095`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_sbc_i_a1_a_subs_oracle_64_3_e2fffc20() {
    // Test SUBS 64-bit: max imm12 unshifted (with oracle verification)
    // Encoding: 0xE2FFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xE2FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `SUBS X0, X1, #4095, LSL #12`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_sbc_i_a1_a_subs_oracle_32_4_62fffc20() {
    // Test SUBS 32-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0x62FFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x62FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF001000, "W0 should be 0xFF001000");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `SUBS X0, X1, #4095, LSL #12`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_sbc_i_a1_a_subs_oracle_64_4_e2fffc20() {
    // Test SUBS 64-bit: max imm12 shifted (with oracle verification)
    // Encoding: 0xE2FFFC20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xE2FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max u64 operand (32)
#[test]
fn test_aarch32_sbc_i_a1_a_subs_oracle_32_5_62c00420() {
    // Test SUBS 32-bit: max u64 operand (with oracle verification)
    // Encoding: 0x62C00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x62C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFEFFF, "W0 should be 0xFFFFEFFF");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max u64 operand (64)
#[test]
fn test_aarch32_sbc_i_a1_a_subs_oracle_64_5_e2c00420() {
    // Test SUBS 64-bit: max u64 operand (with oracle verification)
    // Encoding: 0xE2C00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xE2C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFEFFF,
        "X0 should be 0xFFFFFFFFFFFFEFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_sbc_i_a1_a_subs_oracle_32_6_62c00420() {
    // Test SUBS 32-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0x62C00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x62C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFF000, "W0 should be 0xFFFFF000");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_sbc_i_a1_a_subs_oracle_64_6_e2c00420() {
    // Test SUBS 64-bit: zero result (for sub 1-1) (with oracle verification)
    // Encoding: 0xE2C00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xE2C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFF000,
        "X0 should be 0xFFFFFFFFFFFFF000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_sbc_i_a1_a_subs_oracle_32_7_62c00420() {
    // Test SUBS 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0x62C00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x62C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFEFFF, "W0 should be 0xFFFFEFFF");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_sbc_i_a1_a_subs_oracle_64_7_e2c00420() {
    // Test SUBS 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // Encoding: 0xE2C00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xE2C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFEFFF,
        "X0 should be 0x7FFFFFFFFFFFEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_sbc_i_a1_a_subs_oracle_32_8_62c00420() {
    // Test SUBS 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0x62C00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x62C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FFFEFFF, "W0 should be 0x7FFFEFFF");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_sbc_i_a1_a_subs_oracle_64_8_e2c00420() {
    // Test SUBS 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // Encoding: 0xE2C00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xE2C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x7FFFEFFF,
        "X0 should be 0x000000007FFFEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_sbc_i_a1_a_subs_oracle_32_9_62c00420() {
    // Test SUBS 32-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0x62C00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x62C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFEFFF, "W0 should be 0xFFFFEFFF");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_sbc_i_a1_a_subs_oracle_64_9_e2c00420() {
    // Test SUBS 64-bit: unsigned overflow 64-bit (with oracle verification)
    // Encoding: 0xE2C00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xE2C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFEFFF,
        "X0 should be 0xFFFFFFFFFFFFEFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_sbc_i_a1_a_subs_oracle_32_10_62c00420() {
    // Test SUBS 32-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0x62C00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x62C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFEFFF, "W0 should be 0xFFFFEFFF");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_sbc_i_a1_a_subs_oracle_64_10_e2c00420() {
    // Test SUBS 64-bit: unsigned overflow 32-bit (with oracle verification)
    // Encoding: 0xE2C00420
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xE2C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFEFFF,
        "X0 should be 0x00000000FFFFEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `SUBS ZR, X1, #10`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "result discarded, flags set" }
/// ZR destination (32)
#[test]
fn test_aarch32_sbc_i_a1_a_subs_oracle_32_rd31_zr_62c0283f() {
    // Test SUBS 32-bit with Rd=31 (ZR)
    // Encoding: 0x62C0283F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x62C0283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `SUBS ZR, X1, #10`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "result discarded, flags set" }
/// ZR destination (64)
#[test]
fn test_aarch32_sbc_i_a1_a_subs_oracle_64_rd31_zr_e2c0283f() {
    // Test SUBS 64-bit with Rd=31 (ZR)
    // Encoding: 0xE2C0283F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xE2C0283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `SUB R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x00000000)
#[test]
fn test_aarch32_sbc_i_a1_a_a32_add_sub_imm_0_0_0241000a() {
    // Test A32 SUB: small immediate (oracle)
    // Encoding: 0x0241000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x0241000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFF6, "R0 should be 0xFFFFFFF6");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `SUB R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x00000064)
#[test]
fn test_aarch32_sbc_i_a1_a_a32_add_sub_imm_0_64_0241000a() {
    // Test A32 SUB: small immediate (oracle)
    // Encoding: 0x0241000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x0241000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x5A, "R0 should be 0x0000005A");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `SUB R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_sbc_i_a1_a_a32_add_sub_imm_0_7fffffff_0241000a() {
    // Test A32 SUB: small immediate (oracle)
    // Encoding: 0x0241000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x0241000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FFFFFF5, "R0 should be 0x7FFFFFF5");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `SUB R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x80000000)
#[test]
fn test_aarch32_sbc_i_a1_a_a32_add_sub_imm_0_80000000_0241000a() {
    // Test A32 SUB: small immediate (oracle)
    // Encoding: 0x0241000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0x0241000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FFFFFF6, "R0 should be 0x7FFFFFF6");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `SUB R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_sbc_i_a1_a_a32_add_sub_imm_0_ffffffff_0241000a() {
    // Test A32 SUB: small immediate (oracle)
    // Encoding: 0x0241000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x0241000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFF5, "R0 should be 0xFFFFFFF5");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `SUB R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x00000000)
#[test]
fn test_aarch32_sbc_i_a1_a_a32_add_sub_imm_1_0_024100ff() {
    // Test A32 SUB: max imm8 (oracle)
    // Encoding: 0x024100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x024100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFF01, "R0 should be 0xFFFFFF01");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `SUB R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x00000064)
#[test]
fn test_aarch32_sbc_i_a1_a_a32_add_sub_imm_1_64_024100ff() {
    // Test A32 SUB: max imm8 (oracle)
    // Encoding: 0x024100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x024100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFF65, "R0 should be 0xFFFFFF65");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `SUB R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_sbc_i_a1_a_a32_add_sub_imm_1_7fffffff_024100ff() {
    // Test A32 SUB: max imm8 (oracle)
    // Encoding: 0x024100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x024100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FFFFF00, "R0 should be 0x7FFFFF00");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `SUB R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x80000000)
#[test]
fn test_aarch32_sbc_i_a1_a_a32_add_sub_imm_1_80000000_024100ff() {
    // Test A32 SUB: max imm8 (oracle)
    // Encoding: 0x024100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0x024100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FFFFF01, "R0 should be 0x7FFFFF01");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `SUB R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_sbc_i_a1_a_a32_add_sub_imm_1_ffffffff_024100ff() {
    // Test A32 SUB: max imm8 (oracle)
    // Encoding: 0x024100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x024100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFF00, "R0 should be 0xFFFFFF00");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `SUB R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x00000000)
#[test]
fn test_aarch32_sbc_i_a1_a_a32_add_sub_imm_2_0_02410180() {
    // Test A32 SUB: rotated by 2 (oracle)
    // Encoding: 0x02410180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x02410180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFE0, "R0 should be 0xFFFFFFE0");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `SUB R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x00000064)
#[test]
fn test_aarch32_sbc_i_a1_a_a32_add_sub_imm_2_64_02410180() {
    // Test A32 SUB: rotated by 2 (oracle)
    // Encoding: 0x02410180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x02410180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x44, "R0 should be 0x00000044");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `SUB R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_sbc_i_a1_a_a32_add_sub_imm_2_7fffffff_02410180() {
    // Test A32 SUB: rotated by 2 (oracle)
    // Encoding: 0x02410180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x02410180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FFFFFDF, "R0 should be 0x7FFFFFDF");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `SUB R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x80000000)
#[test]
fn test_aarch32_sbc_i_a1_a_a32_add_sub_imm_2_80000000_02410180() {
    // Test A32 SUB: rotated by 2 (oracle)
    // Encoding: 0x02410180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0x02410180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FFFFFE0, "R0 should be 0x7FFFFFE0");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `SUB R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_sbc_i_a1_a_a32_add_sub_imm_2_ffffffff_02410180() {
    // Test A32 SUB: rotated by 2 (oracle)
    // Encoding: 0x02410180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x02410180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFDF, "R0 should be 0xFFFFFFDF");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `SUB R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x00000000)
#[test]
fn test_aarch32_sbc_i_a1_a_a32_add_sub_imm_3_0_0241040f() {
    // Test A32 SUB: rotated by 8 (oracle)
    // Encoding: 0x0241040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x0241040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xF1000000, "R0 should be 0xF1000000");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `SUB R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x00000064)
#[test]
fn test_aarch32_sbc_i_a1_a_a32_add_sub_imm_3_64_0241040f() {
    // Test A32 SUB: rotated by 8 (oracle)
    // Encoding: 0x0241040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x0241040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xF1000064, "R0 should be 0xF1000064");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `SUB R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_sbc_i_a1_a_a32_add_sub_imm_3_7fffffff_0241040f() {
    // Test A32 SUB: rotated by 8 (oracle)
    // Encoding: 0x0241040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x0241040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x70FFFFFF, "R0 should be 0x70FFFFFF");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `SUB R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x80000000)
#[test]
fn test_aarch32_sbc_i_a1_a_a32_add_sub_imm_3_80000000_0241040f() {
    // Test A32 SUB: rotated by 8 (oracle)
    // Encoding: 0x0241040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0x0241040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x71000000, "R0 should be 0x71000000");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `SUB R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_sbc_i_a1_a_a32_add_sub_imm_3_ffffffff_0241040f() {
    // Test A32 SUB: rotated by 8 (oracle)
    // Encoding: 0x0241040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x0241040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xF0FFFFFF, "R0 should be 0xF0FFFFFF");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `SUB R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x00000000)
#[test]
fn test_aarch32_sbc_i_a1_a_a32_add_sub_imm_4_0_02410000() {
    // Test A32 SUB: zero immediate (oracle)
    // Encoding: 0x02410000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x02410000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `SUB R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x00000064)
#[test]
fn test_aarch32_sbc_i_a1_a_a32_add_sub_imm_4_64_02410000() {
    // Test A32 SUB: zero immediate (oracle)
    // Encoding: 0x02410000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x02410000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x64, "R0 should be 0x00000064");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `SUB R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x7FFFFFFF)
#[test]
fn test_aarch32_sbc_i_a1_a_a32_add_sub_imm_4_7fffffff_02410000() {
    // Test A32 SUB: zero immediate (oracle)
    // Encoding: 0x02410000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x02410000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FFFFFFF, "R0 should be 0x7FFFFFFF");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `SUB R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x80000000)
#[test]
fn test_aarch32_sbc_i_a1_a_a32_add_sub_imm_4_80000000_02410000() {
    // Test A32 SUB: zero immediate (oracle)
    // Encoding: 0x02410000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0x02410000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "R0 should be 0x80000000");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `SUB R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_sbc_i_a1_a_a32_add_sub_imm_4_ffffffff_02410000() {
    // Test A32 SUB: zero immediate (oracle)
    // Encoding: 0x02410000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x02410000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "R0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_aarch32_sbc_i_a1_a_flags_zeroresult_0_02d10000() {
    // Test aarch32_SBC_i_A1_A flag computation: ZeroResult
    // Encoding: 0x02D10000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x02D10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_aarch32_sbc_i_a1_a_flags_zeroresult_1_02d10000() {
    // Test aarch32_SBC_i_A1_A flag computation: ZeroResult
    // Encoding: 0x02D10000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x02D10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_aarch32_sbc_i_a1_a_flags_negativeresult_2_02d10000() {
    // Test aarch32_SBC_i_A1_A flag computation: NegativeResult
    // Encoding: 0x02D10000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x02D10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_aarch32_sbc_i_a1_a_flags_unsignedoverflow_3_02d10000() {
    // Test aarch32_SBC_i_A1_A flag computation: UnsignedOverflow
    // Encoding: 0x02D10000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x02D10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_aarch32_sbc_i_a1_a_flags_unsignedoverflow_4_02d10000() {
    // Test aarch32_SBC_i_A1_A flag computation: UnsignedOverflow
    // Encoding: 0x02D10000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x02D10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_aarch32_sbc_i_a1_a_flags_signedoverflow_5_02d10000() {
    // Test aarch32_SBC_i_A1_A flag computation: SignedOverflow
    // Encoding: 0x02D10000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x02D10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_aarch32_sbc_i_a1_a_flags_signedoverflow_6_02d10000() {
    // Test aarch32_SBC_i_A1_A flag computation: SignedOverflow
    // Encoding: 0x02D10000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x02D10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_SBC_i_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_aarch32_sbc_i_a1_a_flags_positiveresult_7_02d10000() {
    // Test aarch32_SBC_i_A1_A flag computation: PositiveResult
    // Encoding: 0x02D10000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x32);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x02D10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `ADD X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_sbc_i_t1_a_add_oracle_32_0_f1602820() {
    // Test ADD 32-bit: simple addition/subtraction (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF1602820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF7F6064,
        "X0 should be 0xFFFFFFFFFF7F6064"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `ADD X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_sbc_i_t1_a_add_oracle_64_0_f1602820() {
    // Test ADD 64-bit: simple addition/subtraction (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF1602820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF7F6064,
        "X0 should be 0xFFFFFFFFFF7F6064"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `ADD X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero operands (32)
#[test]
fn test_aarch32_sbc_i_t1_a_add_oracle_32_1_f1600020() {
    // Test ADD 32-bit: zero operands (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1600020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF800000,
        "X0 should be 0xFFFFFFFFFF800000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `ADD X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero operands (64)
#[test]
fn test_aarch32_sbc_i_t1_a_add_oracle_64_1_f1600020() {
    // Test ADD 64-bit: zero operands (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1600020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF800000,
        "X0 should be 0xFFFFFFFFFF800000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small values (32)
#[test]
fn test_aarch32_sbc_i_t1_a_add_oracle_32_2_f1600420() {
    // Test ADD 32-bit: small values (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF1600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF7FF001,
        "X0 should be 0xFFFFFFFFFF7FF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// small values (64)
#[test]
fn test_aarch32_sbc_i_t1_a_add_oracle_64_2_f1600420() {
    // Test ADD 64-bit: small values (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF1600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF7FF001,
        "X0 should be 0xFFFFFFFFFF7FF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `ADD X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_sbc_i_t1_a_add_oracle_32_3_f17ffc20() {
    // Test ADD 32-bit: max imm12 unshifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF17FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `ADD X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_sbc_i_t1_a_add_oracle_64_3_f17ffc20() {
    // Test ADD 64-bit: max imm12 unshifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF17FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `ADD X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_sbc_i_t1_a_add_oracle_32_4_f17ffc20() {
    // Test ADD 32-bit: max imm12 shifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF17FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `ADD X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_sbc_i_t1_a_add_oracle_64_4_f17ffc20() {
    // Test ADD 64-bit: max imm12 shifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF17FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max u64 operand (32)
#[test]
fn test_aarch32_sbc_i_t1_a_add_oracle_32_5_f1600420() {
    // Test ADD 32-bit: max u64 operand (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF7FEFFF,
        "X0 should be 0x00000000FF7FEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max u64 operand (64)
#[test]
fn test_aarch32_sbc_i_t1_a_add_oracle_64_5_f1600420() {
    // Test ADD 64-bit: max u64 operand (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF7FEFFF,
        "X0 should be 0xFFFFFFFFFF7FEFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_sbc_i_t1_a_add_oracle_32_6_f1600420() {
    // Test ADD 32-bit: zero result (for sub 1-1) (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF7FF000,
        "X0 should be 0xFFFFFFFFFF7FF000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_sbc_i_t1_a_add_oracle_64_6_f1600420() {
    // Test ADD 64-bit: zero result (for sub 1-1) (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF7FF000,
        "X0 should be 0xFFFFFFFFFF7FF000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_sbc_i_t1_a_add_oracle_32_7_f1600420() {
    // Test ADD 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF7FEFFF,
        "X0 should be 0x00000000FF7FEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_sbc_i_t1_a_add_oracle_64_7_f1600420() {
    // Test ADD 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF7FEFFF,
        "X0 should be 0x7FFFFFFFFF7FEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_sbc_i_t1_a_add_oracle_32_8_f1600420() {
    // Test ADD 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF1600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x7F7FEFFF,
        "X0 should be 0x000000007F7FEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_sbc_i_t1_a_add_oracle_64_8_f1600420() {
    // Test ADD 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF1600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x7F7FEFFF,
        "X0 should be 0x000000007F7FEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_sbc_i_t1_a_add_oracle_32_9_f1600420() {
    // Test ADD 32-bit: unsigned overflow 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF7FEFFF,
        "X0 should be 0x00000000FF7FEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_sbc_i_t1_a_add_oracle_64_9_f1600420() {
    // Test ADD 64-bit: unsigned overflow 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF7FEFFF,
        "X0 should be 0xFFFFFFFFFF7FEFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_sbc_i_t1_a_add_oracle_32_10_f1600420() {
    // Test ADD 32-bit: unsigned overflow 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF7FEFFF,
        "X0 should be 0x00000000FF7FEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_sbc_i_t1_a_add_oracle_64_10_f1600420() {
    // Test ADD 64-bit: unsigned overflow 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF7FEFFF,
        "X0 should be 0x00000000FF7FEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `ADD SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (32)
#[test]
fn test_aarch32_sbc_i_t1_a_add_oracle_32_rd31_sp_f160283f() {
    // Test ADD 32-bit with Rd=31 (SP)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF160283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `ADD SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (64)
#[test]
fn test_aarch32_sbc_i_t1_a_add_oracle_64_rd31_sp_f160283f() {
    // Test ADD 64-bit with Rd=31 (SP)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF160283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `ADDS X0, X1, #10`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_sbc_i_t1_a_adds_oracle_32_0_f1602820() {
    // Test ADDS 32-bit: simple addition/subtraction (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF1602820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF7F6064,
        "X0 should be 0xFFFFFFFFFF7F6064"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `ADDS X0, X1, #10`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_sbc_i_t1_a_adds_oracle_64_0_f1602820() {
    // Test ADDS 64-bit: simple addition/subtraction (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF1602820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF7F6064,
        "X0 should be 0xFFFFFFFFFF7F6064"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `ADDS X0, X1, #0`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero operands (32)
#[test]
fn test_aarch32_sbc_i_t1_a_adds_oracle_32_1_f1600020() {
    // Test ADDS 32-bit: zero operands (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1600020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF800000,
        "X0 should be 0xFFFFFFFFFF800000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `ADDS X0, X1, #0`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero operands (64)
#[test]
fn test_aarch32_sbc_i_t1_a_adds_oracle_64_1_f1600020() {
    // Test ADDS 64-bit: zero operands (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1600020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF800000,
        "X0 should be 0xFFFFFFFFFF800000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// small values (32)
#[test]
fn test_aarch32_sbc_i_t1_a_adds_oracle_32_2_f1600420() {
    // Test ADDS 32-bit: small values (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF1600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF7FF001,
        "X0 should be 0xFFFFFFFFFF7FF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// small values (64)
#[test]
fn test_aarch32_sbc_i_t1_a_adds_oracle_64_2_f1600420() {
    // Test ADDS 64-bit: small values (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF1600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF7FF001,
        "X0 should be 0xFFFFFFFFFF7FF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `ADDS X0, X1, #4095`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_sbc_i_t1_a_adds_oracle_32_3_f17ffc20() {
    // Test ADDS 32-bit: max imm12 unshifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF17FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `ADDS X0, X1, #4095`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_sbc_i_t1_a_adds_oracle_64_3_f17ffc20() {
    // Test ADDS 64-bit: max imm12 unshifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF17FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `ADDS X0, X1, #4095, LSL #12`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_sbc_i_t1_a_adds_oracle_32_4_f17ffc20() {
    // Test ADDS 32-bit: max imm12 shifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF17FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `ADDS X0, X1, #4095, LSL #12`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_sbc_i_t1_a_adds_oracle_64_4_f17ffc20() {
    // Test ADDS 64-bit: max imm12 shifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF17FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max u64 operand (32)
#[test]
fn test_aarch32_sbc_i_t1_a_adds_oracle_32_5_f1600420() {
    // Test ADDS 32-bit: max u64 operand (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF7FEFFF,
        "X0 should be 0x00000000FF7FEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max u64 operand (64)
#[test]
fn test_aarch32_sbc_i_t1_a_adds_oracle_64_5_f1600420() {
    // Test ADDS 64-bit: max u64 operand (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF7FEFFF,
        "X0 should be 0xFFFFFFFFFF7FEFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_sbc_i_t1_a_adds_oracle_32_6_f1600420() {
    // Test ADDS 32-bit: zero result (for sub 1-1) (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF7FF000,
        "X0 should be 0xFFFFFFFFFF7FF000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_sbc_i_t1_a_adds_oracle_64_6_f1600420() {
    // Test ADDS 64-bit: zero result (for sub 1-1) (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF7FF000,
        "X0 should be 0xFFFFFFFFFF7FF000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_sbc_i_t1_a_adds_oracle_32_7_f1600420() {
    // Test ADDS 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF7FEFFF,
        "X0 should be 0x00000000FF7FEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_sbc_i_t1_a_adds_oracle_64_7_f1600420() {
    // Test ADDS 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF7FEFFF,
        "X0 should be 0x7FFFFFFFFF7FEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_sbc_i_t1_a_adds_oracle_32_8_f1600420() {
    // Test ADDS 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF1600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x7F7FEFFF,
        "X0 should be 0x000000007F7FEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_sbc_i_t1_a_adds_oracle_64_8_f1600420() {
    // Test ADDS 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF1600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x7F7FEFFF,
        "X0 should be 0x000000007F7FEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_sbc_i_t1_a_adds_oracle_32_9_f1600420() {
    // Test ADDS 32-bit: unsigned overflow 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF7FEFFF,
        "X0 should be 0x00000000FF7FEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_sbc_i_t1_a_adds_oracle_64_9_f1600420() {
    // Test ADDS 64-bit: unsigned overflow 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF7FEFFF,
        "X0 should be 0xFFFFFFFFFF7FEFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_sbc_i_t1_a_adds_oracle_32_10_f1600420() {
    // Test ADDS 32-bit: unsigned overflow 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF7FEFFF,
        "X0 should be 0x00000000FF7FEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `ADDS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_sbc_i_t1_a_adds_oracle_64_10_f1600420() {
    // Test ADDS 64-bit: unsigned overflow 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF7FEFFF,
        "X0 should be 0x00000000FF7FEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `ADDS ZR, X1, #10`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "result discarded, flags set" }
/// ZR destination (32)
#[test]
fn test_aarch32_sbc_i_t1_a_adds_oracle_32_rd31_zr_f160283f() {
    // Test ADDS 32-bit with Rd=31 (ZR)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF160283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `ADDS ZR, X1, #10`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "result discarded, flags set" }
/// ZR destination (64)
#[test]
fn test_aarch32_sbc_i_t1_a_adds_oracle_64_rd31_zr_f160283f() {
    // Test ADDS 64-bit with Rd=31 (ZR)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF160283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `SUB X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_sbc_i_t1_a_sub_oracle_32_0_f1602820() {
    // Test SUB 32-bit: simple addition/subtraction (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF1602820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF7F6064,
        "X0 should be 0xFFFFFFFFFF7F6064"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `SUB X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_sbc_i_t1_a_sub_oracle_64_0_f1602820() {
    // Test SUB 64-bit: simple addition/subtraction (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF1602820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF7F6064,
        "X0 should be 0xFFFFFFFFFF7F6064"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `SUB X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero operands (32)
#[test]
fn test_aarch32_sbc_i_t1_a_sub_oracle_32_1_f1600020() {
    // Test SUB 32-bit: zero operands (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1600020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF800000,
        "X0 should be 0xFFFFFFFFFF800000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `SUB X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero operands (64)
#[test]
fn test_aarch32_sbc_i_t1_a_sub_oracle_64_1_f1600020() {
    // Test SUB 64-bit: zero operands (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1600020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF800000,
        "X0 should be 0xFFFFFFFFFF800000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small values (32)
#[test]
fn test_aarch32_sbc_i_t1_a_sub_oracle_32_2_f1600420() {
    // Test SUB 32-bit: small values (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF1600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF7FF001,
        "X0 should be 0xFFFFFFFFFF7FF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// small values (64)
#[test]
fn test_aarch32_sbc_i_t1_a_sub_oracle_64_2_f1600420() {
    // Test SUB 64-bit: small values (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF1600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF7FF001,
        "X0 should be 0xFFFFFFFFFF7FF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `SUB X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_sbc_i_t1_a_sub_oracle_32_3_f17ffc20() {
    // Test SUB 32-bit: max imm12 unshifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF17FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `SUB X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_sbc_i_t1_a_sub_oracle_64_3_f17ffc20() {
    // Test SUB 64-bit: max imm12 unshifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF17FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `SUB X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_sbc_i_t1_a_sub_oracle_32_4_f17ffc20() {
    // Test SUB 32-bit: max imm12 shifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF17FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `SUB X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_sbc_i_t1_a_sub_oracle_64_4_f17ffc20() {
    // Test SUB 64-bit: max imm12 shifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF17FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max u64 operand (32)
#[test]
fn test_aarch32_sbc_i_t1_a_sub_oracle_32_5_f1600420() {
    // Test SUB 32-bit: max u64 operand (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF7FEFFF,
        "X0 should be 0x00000000FF7FEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max u64 operand (64)
#[test]
fn test_aarch32_sbc_i_t1_a_sub_oracle_64_5_f1600420() {
    // Test SUB 64-bit: max u64 operand (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF7FEFFF,
        "X0 should be 0xFFFFFFFFFF7FEFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_sbc_i_t1_a_sub_oracle_32_6_f1600420() {
    // Test SUB 32-bit: zero result (for sub 1-1) (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF7FF000,
        "X0 should be 0xFFFFFFFFFF7FF000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_sbc_i_t1_a_sub_oracle_64_6_f1600420() {
    // Test SUB 64-bit: zero result (for sub 1-1) (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF7FF000,
        "X0 should be 0xFFFFFFFFFF7FF000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_sbc_i_t1_a_sub_oracle_32_7_f1600420() {
    // Test SUB 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF7FEFFF,
        "X0 should be 0x00000000FF7FEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_sbc_i_t1_a_sub_oracle_64_7_f1600420() {
    // Test SUB 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF7FEFFF,
        "X0 should be 0x7FFFFFFFFF7FEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_sbc_i_t1_a_sub_oracle_32_8_f1600420() {
    // Test SUB 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF1600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x7F7FEFFF,
        "X0 should be 0x000000007F7FEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_sbc_i_t1_a_sub_oracle_64_8_f1600420() {
    // Test SUB 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF1600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x7F7FEFFF,
        "X0 should be 0x000000007F7FEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_sbc_i_t1_a_sub_oracle_32_9_f1600420() {
    // Test SUB 32-bit: unsigned overflow 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF7FEFFF,
        "X0 should be 0x00000000FF7FEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_sbc_i_t1_a_sub_oracle_64_9_f1600420() {
    // Test SUB 64-bit: unsigned overflow 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF7FEFFF,
        "X0 should be 0xFFFFFFFFFF7FEFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_sbc_i_t1_a_sub_oracle_32_10_f1600420() {
    // Test SUB 32-bit: unsigned overflow 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF7FEFFF,
        "X0 should be 0x00000000FF7FEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_sbc_i_t1_a_sub_oracle_64_10_f1600420() {
    // Test SUB 64-bit: unsigned overflow 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF7FEFFF,
        "X0 should be 0x00000000FF7FEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `SUB SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (32)
#[test]
fn test_aarch32_sbc_i_t1_a_sub_oracle_32_rd31_sp_f160283f() {
    // Test SUB 32-bit with Rd=31 (SP)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF160283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `SUB SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (64)
#[test]
fn test_aarch32_sbc_i_t1_a_sub_oracle_64_rd31_sp_f160283f() {
    // Test SUB 64-bit with Rd=31 (SP)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF160283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `SUBS X0, X1, #10`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_sbc_i_t1_a_subs_oracle_32_0_f1602820() {
    // Test SUBS 32-bit: simple addition/subtraction (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF1602820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF7F6064,
        "X0 should be 0xFFFFFFFFFF7F6064"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `SUBS X0, X1, #10`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_sbc_i_t1_a_subs_oracle_64_0_f1602820() {
    // Test SUBS 64-bit: simple addition/subtraction (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF1602820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF7F6064,
        "X0 should be 0xFFFFFFFFFF7F6064"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `SUBS X0, X1, #0`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero operands (32)
#[test]
fn test_aarch32_sbc_i_t1_a_subs_oracle_32_1_f1600020() {
    // Test SUBS 32-bit: zero operands (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1600020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF800000,
        "X0 should be 0xFFFFFFFFFF800000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `SUBS X0, X1, #0`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero operands (64)
#[test]
fn test_aarch32_sbc_i_t1_a_subs_oracle_64_1_f1600020() {
    // Test SUBS 64-bit: zero operands (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1600020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF800000,
        "X0 should be 0xFFFFFFFFFF800000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// small values (32)
#[test]
fn test_aarch32_sbc_i_t1_a_subs_oracle_32_2_f1600420() {
    // Test SUBS 32-bit: small values (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF1600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF7FF001,
        "X0 should be 0xFFFFFFFFFF7FF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// small values (64)
#[test]
fn test_aarch32_sbc_i_t1_a_subs_oracle_64_2_f1600420() {
    // Test SUBS 64-bit: small values (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF1600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF7FF001,
        "X0 should be 0xFFFFFFFFFF7FF001"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `SUBS X0, X1, #4095`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_sbc_i_t1_a_subs_oracle_32_3_f17ffc20() {
    // Test SUBS 32-bit: max imm12 unshifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF17FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `SUBS X0, X1, #4095`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_sbc_i_t1_a_subs_oracle_64_3_f17ffc20() {
    // Test SUBS 64-bit: max imm12 unshifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF17FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `SUBS X0, X1, #4095, LSL #12`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_sbc_i_t1_a_subs_oracle_32_4_f17ffc20() {
    // Test SUBS 32-bit: max imm12 shifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF17FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `SUBS X0, X1, #4095, LSL #12`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_sbc_i_t1_a_subs_oracle_64_4_f17ffc20() {
    // Test SUBS 64-bit: max imm12 shifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF17FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF001000,
        "X0 should be 0xFFFFFFFFFF001000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max u64 operand (32)
#[test]
fn test_aarch32_sbc_i_t1_a_subs_oracle_32_5_f1600420() {
    // Test SUBS 32-bit: max u64 operand (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF7FEFFF,
        "X0 should be 0x00000000FF7FEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// max u64 operand (64)
#[test]
fn test_aarch32_sbc_i_t1_a_subs_oracle_64_5_f1600420() {
    // Test SUBS 64-bit: max u64 operand (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF7FEFFF,
        "X0 should be 0xFFFFFFFFFF7FEFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_sbc_i_t1_a_subs_oracle_32_6_f1600420() {
    // Test SUBS 32-bit: zero result (for sub 1-1) (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF7FF000,
        "X0 should be 0xFFFFFFFFFF7FF000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_sbc_i_t1_a_subs_oracle_64_6_f1600420() {
    // Test SUBS 64-bit: zero result (for sub 1-1) (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF1600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF7FF000,
        "X0 should be 0xFFFFFFFFFF7FF000"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_sbc_i_t1_a_subs_oracle_32_7_f1600420() {
    // Test SUBS 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF7FEFFF,
        "X0 should be 0x00000000FF7FEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_sbc_i_t1_a_subs_oracle_64_7_f1600420() {
    // Test SUBS 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF7FEFFF,
        "X0 should be 0x7FFFFFFFFF7FEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_sbc_i_t1_a_subs_oracle_32_8_f1600420() {
    // Test SUBS 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF1600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x7F7FEFFF,
        "X0 should be 0x000000007F7FEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_sbc_i_t1_a_subs_oracle_64_8_f1600420() {
    // Test SUBS 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF1600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x7F7FEFFF,
        "X0 should be 0x000000007F7FEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_sbc_i_t1_a_subs_oracle_32_9_f1600420() {
    // Test SUBS 32-bit: unsigned overflow 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF7FEFFF,
        "X0 should be 0x00000000FF7FEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_sbc_i_t1_a_subs_oracle_64_9_f1600420() {
    // Test SUBS 64-bit: unsigned overflow 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF7FEFFF,
        "X0 should be 0xFFFFFFFFFF7FEFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_sbc_i_t1_a_subs_oracle_32_10_f1600420() {
    // Test SUBS 32-bit: unsigned overflow 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF7FEFFF,
        "X0 should be 0x00000000FF7FEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `SUBS X0, X1, #1`
/// Requirement: FlagComputation { flag: N, scenario: NonZeroResult }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_sbc_i_t1_a_subs_oracle_64_10_f1600420() {
    // Test SUBS 64-bit: unsigned overflow 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF7FEFFF,
        "X0 should be 0x00000000FF7FEFFF"
    );
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `SUBS ZR, X1, #10`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "result discarded, flags set" }
/// ZR destination (32)
#[test]
fn test_aarch32_sbc_i_t1_a_subs_oracle_32_rd31_zr_f160283f() {
    // Test SUBS 32-bit with Rd=31 (ZR)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF160283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `SUBS ZR, X1, #10`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "result discarded, flags set" }
/// ZR destination (64)
#[test]
fn test_aarch32_sbc_i_t1_a_subs_oracle_64_rd31_zr_f160283f() {
    // Test SUBS 64-bit with Rd=31 (ZR)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF160283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `SUB.W R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple values
#[test]
fn test_aarch32_sbc_i_t1_a_t32_oracle_0_f1610000() {
    // Test T32 SUB: simple values (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x32);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF1610000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x32, "R0 should be 0x00000032");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `SUB.W R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero values
#[test]
fn test_aarch32_sbc_i_t1_a_t32_oracle_1_f1610000() {
    // Test T32 SUB: zero values (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xF1610000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `SUB.W R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max value
#[test]
fn test_aarch32_sbc_i_t1_a_t32_oracle_2_f1610000() {
    // Test T32 SUB: max value (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1610000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFE, "R0 should be 0xFFFFFFFE");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `SUB.W R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// mixed pattern
#[test]
fn test_aarch32_sbc_i_t1_a_t32_oracle_3_f1610000() {
    // Test T32 SUB: mixed pattern (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0xABCDEF01);
    let encoding: u32 = 0xF1610000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x66666777, "R0 should be 0x66666777");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_aarch32_sbc_i_t1_a_flags_zeroresult_0_f1710000() {
    // Test aarch32_SBC_i_T1_A flag computation: ZeroResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xF1710000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_aarch32_sbc_i_t1_a_flags_zeroresult_1_f1710000() {
    // Test aarch32_SBC_i_T1_A flag computation: ZeroResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0xF1710000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_aarch32_sbc_i_t1_a_flags_negativeresult_2_f1710000() {
    // Test aarch32_SBC_i_T1_A flag computation: NegativeResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xF1710000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_aarch32_sbc_i_t1_a_flags_unsignedoverflow_3_f1710000() {
    // Test aarch32_SBC_i_T1_A flag computation: UnsignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1710000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_aarch32_sbc_i_t1_a_flags_unsignedoverflow_4_f1710000() {
    // Test aarch32_SBC_i_T1_A flag computation: UnsignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF1710000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_aarch32_sbc_i_t1_a_flags_signedoverflow_5_f1710000() {
    // Test aarch32_SBC_i_T1_A flag computation: SignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0xF1710000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_aarch32_sbc_i_t1_a_flags_signedoverflow_6_f1710000() {
    // Test aarch32_SBC_i_T1_A flag computation: SignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0xF1710000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_SBC_i_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_aarch32_sbc_i_t1_a_flags_positiveresult_7_f1710000() {
    // Test aarch32_SBC_i_T1_A flag computation: PositiveResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x32);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF1710000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

// ============================================================================
// aarch32_SUB_r_A Tests
// ============================================================================

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_sub_r_a1_a_field_cond_0_min_0_00400000() {
    // Encoding: 0x00400000
    // Test aarch32_SUB_r_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, S=0, Rd=0, cond=0, Rm=0, imm5=0, type1=0
    let encoding: u32 = 0x00400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_sub_r_a1_a_field_cond_1_poweroftwo_0_10400000() {
    // Encoding: 0x10400000
    // Test aarch32_SUB_r_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, type1=0, Rm=0, S=0, Rn=0, cond=1, imm5=0
    let encoding: u32 = 0x10400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_sub_r_a1_a_field_cond_2_poweroftwo_0_20400000() {
    // Encoding: 0x20400000
    // Test aarch32_SUB_r_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: imm5=0, Rm=0, S=0, cond=2, type1=0, Rn=0, Rd=0
    let encoding: u32 = 0x20400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_sub_r_a1_a_field_cond_3_poweroftwo_0_30400000() {
    // Encoding: 0x30400000
    // Test aarch32_SUB_r_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rn=0, type1=0, Rm=0, cond=3, S=0, imm5=0
    let encoding: u32 = 0x30400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_sub_r_a1_a_field_cond_4_poweroftwo_0_40400000() {
    // Encoding: 0x40400000
    // Test aarch32_SUB_r_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rd=0, cond=4, S=0, imm5=0, type1=0, Rm=0
    let encoding: u32 = 0x40400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_sub_r_a1_a_field_cond_5_poweroftwo_0_50400000() {
    // Encoding: 0x50400000
    // Test aarch32_SUB_r_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: type1=0, Rn=0, Rd=0, cond=5, imm5=0, Rm=0, S=0
    let encoding: u32 = 0x50400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_sub_r_a1_a_field_cond_6_poweroftwo_0_60400000() {
    // Encoding: 0x60400000
    // Test aarch32_SUB_r_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: imm5=0, Rm=0, cond=6, Rd=0, S=0, Rn=0, type1=0
    let encoding: u32 = 0x60400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_sub_r_a1_a_field_cond_7_poweroftwo_0_70400000() {
    // Encoding: 0x70400000
    // Test aarch32_SUB_r_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Rd=0, S=0, Rn=0, imm5=0, cond=7, type1=0
    let encoding: u32 = 0x70400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_sub_r_a1_a_field_cond_8_poweroftwo_0_80400000() {
    // Encoding: 0x80400000
    // Test aarch32_SUB_r_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: type1=0, Rm=0, S=0, imm5=0, cond=8, Rn=0, Rd=0
    let encoding: u32 = 0x80400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_sub_r_a1_a_field_cond_9_poweroftwo_0_90400000() {
    // Encoding: 0x90400000
    // Test aarch32_SUB_r_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: imm5=0, Rm=0, S=0, Rn=0, type1=0, Rd=0, cond=9
    let encoding: u32 = 0x90400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_sub_r_a1_a_field_cond_10_poweroftwo_0_a0400000() {
    // Encoding: 0xA0400000
    // Test aarch32_SUB_r_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: type1=0, S=0, imm5=0, cond=10, Rn=0, Rd=0, Rm=0
    let encoding: u32 = 0xA0400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_sub_r_a1_a_field_cond_11_poweroftwo_0_b0400000() {
    // Encoding: 0xB0400000
    // Test aarch32_SUB_r_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rm=0, cond=11, Rd=0, imm5=0, S=0, type1=0
    let encoding: u32 = 0xB0400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_sub_r_a1_a_field_cond_12_poweroftwo_0_c0400000() {
    // Encoding: 0xC0400000
    // Test aarch32_SUB_r_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, S=0, type1=0, Rn=0, Rm=0, imm5=0, cond=12
    let encoding: u32 = 0xC0400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_sub_r_a1_a_field_cond_13_poweroftwo_0_d0400000() {
    // Encoding: 0xD0400000
    // Test aarch32_SUB_r_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: imm5=0, Rm=0, cond=13, S=0, type1=0, Rn=0, Rd=0
    let encoding: u32 = 0xD0400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_sub_r_a1_a_field_cond_14_poweroftwo_0_e0400000() {
    // Encoding: 0xE0400000
    // Test aarch32_SUB_r_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, S=0, Rd=0, cond=14, imm5=0, Rn=0, type1=0
    let encoding: u32 = 0xE0400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_sub_r_a1_a_field_cond_15_max_0_f0400000() {
    // Encoding: 0xF0400000
    // Test aarch32_SUB_r_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: S=0, type1=0, Rd=0, Rn=0, imm5=0, Rm=0, cond=15
    let encoding: u32 = 0xF0400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_sub_r_a1_a_field_s_0_min_0_00400000() {
    // Encoding: 0x00400000
    // Test aarch32_SUB_r_A1_A field S = 0 (Min)
    // ISET: A32
    // Fields: type1=0, S=0, Rm=0, Rn=0, cond=0, Rd=0, imm5=0
    let encoding: u32 = 0x00400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_sub_r_a1_a_field_s_1_max_0_00500000() {
    // Encoding: 0x00500000
    // Test aarch32_SUB_r_A1_A field S = 1 (Max)
    // ISET: A32
    // Fields: S=1, Rd=0, imm5=0, Rn=0, type1=0, Rm=0, cond=0
    let encoding: u32 = 0x00500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_sub_r_a1_a_field_rn_0_min_0_00400000() {
    // Encoding: 0x00400000
    // Test aarch32_SUB_r_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rm=0, Rn=0, imm5=0, S=0, type1=0, Rd=0
    let encoding: u32 = 0x00400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_sub_r_a1_a_field_rn_1_poweroftwo_0_00410000() {
    // Encoding: 0x00410000
    // Test aarch32_SUB_r_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rm=0, cond=0, S=0, imm5=0, type1=0, Rn=1
    let encoding: u32 = 0x00410000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_sub_r_a1_a_field_rd_0_min_0_00400000() {
    // Encoding: 0x00400000
    // Test aarch32_SUB_r_A1_A field Rd = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, cond=0, imm5=0, Rn=0, type1=0, S=0, Rd=0
    let encoding: u32 = 0x00400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_sub_r_a1_a_field_rd_1_poweroftwo_0_00401000() {
    // Encoding: 0x00401000
    // Test aarch32_SUB_r_A1_A field Rd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=1, cond=0, S=0, imm5=0, type1=0, Rm=0, Rn=0
    let encoding: u32 = 0x00401000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_sub_r_a1_a_field_imm5_0_zero_0_00400000() {
    // Encoding: 0x00400000
    // Test aarch32_SUB_r_A1_A field imm5 = 0 (Zero)
    // ISET: A32
    // Fields: Rn=0, cond=0, imm5=0, type1=0, S=0, Rd=0, Rm=0
    let encoding: u32 = 0x00400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_sub_r_a1_a_field_imm5_1_poweroftwo_0_00400080() {
    // Encoding: 0x00400080
    // Test aarch32_SUB_r_A1_A field imm5 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: type1=0, cond=0, Rd=0, S=0, Rn=0, imm5=1, Rm=0
    let encoding: u32 = 0x00400080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_sub_r_a1_a_field_imm5_3_poweroftwominusone_0_00400180() {
    // Encoding: 0x00400180
    // Test aarch32_SUB_r_A1_A field imm5 = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rm=0, Rd=0, imm5=3, cond=0, Rn=0, S=0, type1=0
    let encoding: u32 = 0x00400180;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_sub_r_a1_a_field_imm5_4_poweroftwo_0_00400200() {
    // Encoding: 0x00400200
    // Test aarch32_SUB_r_A1_A field imm5 = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: type1=0, Rm=0, imm5=4, cond=0, Rd=0, S=0, Rn=0
    let encoding: u32 = 0x00400200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_sub_r_a1_a_field_imm5_7_poweroftwominusone_0_00400380() {
    // Encoding: 0x00400380
    // Test aarch32_SUB_r_A1_A field imm5 = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: type1=0, Rm=0, Rn=0, Rd=0, imm5=7, cond=0, S=0
    let encoding: u32 = 0x00400380;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_sub_r_a1_a_field_imm5_8_poweroftwo_0_00400400() {
    // Encoding: 0x00400400
    // Test aarch32_SUB_r_A1_A field imm5 = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, S=0, Rd=0, imm5=8, type1=0, Rm=0, Rn=0
    let encoding: u32 = 0x00400400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 15, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (15)
#[test]
fn test_aarch32_sub_r_a1_a_field_imm5_15_poweroftwominusone_0_00400780() {
    // Encoding: 0x00400780
    // Test aarch32_SUB_r_A1_A field imm5 = 15 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: type1=0, Rd=0, Rm=0, cond=0, S=0, Rn=0, imm5=15
    let encoding: u32 = 0x00400780;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_sub_r_a1_a_field_imm5_16_poweroftwo_0_00400800() {
    // Encoding: 0x00400800
    // Test aarch32_SUB_r_A1_A field imm5 = 16 (PowerOfTwo)
    // ISET: A32
    // Fields: imm5=16, Rn=0, Rd=0, Rm=0, cond=0, type1=0, S=0
    let encoding: u32 = 0x00400800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 31, boundary: Max }
/// maximum immediate (31)
#[test]
fn test_aarch32_sub_r_a1_a_field_imm5_31_max_0_00400f80() {
    // Encoding: 0x00400F80
    // Test aarch32_SUB_r_A1_A field imm5 = 31 (Max)
    // ISET: A32
    // Fields: S=0, type1=0, Rm=0, cond=0, Rn=0, Rd=0, imm5=31
    let encoding: u32 = 0x00400F80;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `field type1 5 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_sub_r_a1_a_field_type1_0_min_0_00400000() {
    // Encoding: 0x00400000
    // Test aarch32_SUB_r_A1_A field type1 = 0 (Min)
    // ISET: A32
    // Fields: imm5=0, type1=0, Rm=0, S=0, Rd=0, Rn=0, cond=0
    let encoding: u32 = 0x00400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `field type1 5 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_sub_r_a1_a_field_type1_1_poweroftwo_0_00400020() {
    // Encoding: 0x00400020
    // Test aarch32_SUB_r_A1_A field type1 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, imm5=0, type1=1, Rm=0, cond=0, Rn=0, Rd=0
    let encoding: u32 = 0x00400020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `field type1 5 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_aarch32_sub_r_a1_a_field_type1_3_max_0_00400060() {
    // Encoding: 0x00400060
    // Test aarch32_SUB_r_A1_A field type1 = 3 (Max)
    // ISET: A32
    // Fields: S=0, imm5=0, Rn=0, cond=0, Rd=0, Rm=0, type1=3
    let encoding: u32 = 0x00400060;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_sub_r_a1_a_field_rm_0_min_0_00400000() {
    // Encoding: 0x00400000
    // Test aarch32_SUB_r_A1_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, S=0, Rd=0, imm5=0, cond=0, Rn=0, type1=0
    let encoding: u32 = 0x00400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_sub_r_a1_a_field_rm_1_poweroftwo_0_00400001() {
    // Encoding: 0x00400001
    // Test aarch32_SUB_r_A1_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Rd=0, type1=0, imm5=0, S=0, Rn=0, Rm=1
    let encoding: u32 = 0x00400001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_sub_r_a1_a_combo_0_0_00400000() {
    // Encoding: 0x00400000
    // Test aarch32_SUB_r_A1_A field combination: cond=0, S=0, Rn=0, Rd=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: Rm=0, cond=0, S=0, Rd=0, Rn=0, imm5=0, type1=0
    let encoding: u32 = 0x00400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_sub_r_a1_a_special_cond_0_condition_eq_0_00400000() {
    // Encoding: 0x00400000
    // Test aarch32_SUB_r_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: imm5=0, Rd=0, Rm=0, type1=0, S=0, Rn=0, cond=0
    let encoding: u32 = 0x00400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_sub_r_a1_a_special_cond_1_condition_ne_0_10400000() {
    // Encoding: 0x10400000
    // Test aarch32_SUB_r_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: Rn=0, type1=0, Rm=0, cond=1, imm5=0, S=0, Rd=0
    let encoding: u32 = 0x10400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_sub_r_a1_a_special_cond_2_condition_cs_hs_0_20400000() {
    // Encoding: 0x20400000
    // Test aarch32_SUB_r_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: imm5=0, type1=0, Rn=0, Rm=0, S=0, Rd=0, cond=2
    let encoding: u32 = 0x20400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_sub_r_a1_a_special_cond_3_condition_cc_lo_0_30400000() {
    // Encoding: 0x30400000
    // Test aarch32_SUB_r_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: cond=3, Rd=0, imm5=0, Rn=0, S=0, type1=0, Rm=0
    let encoding: u32 = 0x30400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_sub_r_a1_a_special_cond_4_condition_mi_0_40400000() {
    // Encoding: 0x40400000
    // Test aarch32_SUB_r_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: Rd=0, S=0, Rm=0, Rn=0, cond=4, imm5=0, type1=0
    let encoding: u32 = 0x40400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_sub_r_a1_a_special_cond_5_condition_pl_0_50400000() {
    // Encoding: 0x50400000
    // Test aarch32_SUB_r_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: cond=5, Rn=0, Rm=0, imm5=0, Rd=0, type1=0, S=0
    let encoding: u32 = 0x50400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_sub_r_a1_a_special_cond_6_condition_vs_0_60400000() {
    // Encoding: 0x60400000
    // Test aarch32_SUB_r_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: Rm=0, Rn=0, cond=6, S=0, type1=0, Rd=0, imm5=0
    let encoding: u32 = 0x60400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_sub_r_a1_a_special_cond_7_condition_vc_0_70400000() {
    // Encoding: 0x70400000
    // Test aarch32_SUB_r_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: type1=0, S=0, cond=7, imm5=0, Rm=0, Rn=0, Rd=0
    let encoding: u32 = 0x70400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_sub_r_a1_a_special_cond_8_condition_hi_0_80400000() {
    // Encoding: 0x80400000
    // Test aarch32_SUB_r_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: S=0, Rn=0, cond=8, Rd=0, imm5=0, type1=0, Rm=0
    let encoding: u32 = 0x80400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_sub_r_a1_a_special_cond_9_condition_ls_0_90400000() {
    // Encoding: 0x90400000
    // Test aarch32_SUB_r_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: S=0, type1=0, cond=9, Rn=0, Rm=0, imm5=0, Rd=0
    let encoding: u32 = 0x90400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_sub_r_a1_a_special_cond_10_condition_ge_0_a0400000() {
    // Encoding: 0xA0400000
    // Test aarch32_SUB_r_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: imm5=0, cond=10, Rn=0, Rd=0, type1=0, S=0, Rm=0
    let encoding: u32 = 0xA0400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_sub_r_a1_a_special_cond_11_condition_lt_0_b0400000() {
    // Encoding: 0xB0400000
    // Test aarch32_SUB_r_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: S=0, imm5=0, type1=0, Rn=0, cond=11, Rm=0, Rd=0
    let encoding: u32 = 0xB0400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_sub_r_a1_a_special_cond_12_condition_gt_0_c0400000() {
    // Encoding: 0xC0400000
    // Test aarch32_SUB_r_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: Rm=0, Rd=0, S=0, Rn=0, imm5=0, cond=12, type1=0
    let encoding: u32 = 0xC0400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_sub_r_a1_a_special_cond_13_condition_le_0_d0400000() {
    // Encoding: 0xD0400000
    // Test aarch32_SUB_r_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: type1=0, Rn=0, Rd=0, S=0, imm5=0, cond=13, Rm=0
    let encoding: u32 = 0xD0400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_sub_r_a1_a_special_cond_14_condition_al_0_e0400000() {
    // Encoding: 0xE0400000
    // Test aarch32_SUB_r_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: type1=0, Rm=0, cond=14, S=0, Rn=0, Rd=0, imm5=0
    let encoding: u32 = 0xE0400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_sub_r_a1_a_special_cond_15_condition_nv_0_f0400000() {
    // Encoding: 0xF0400000
    // Test aarch32_SUB_r_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: type1=0, Rm=0, Rn=0, imm5=0, S=0, Rd=0, cond=15
    let encoding: u32 = 0xF0400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `field S = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "S", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_sub_r_a1_a_special_s_0_size_variant_0_0_00400000() {
    // Encoding: 0x00400000
    // Test aarch32_SUB_r_A1_A special value S = 0 (Size variant 0)
    // ISET: A32
    // Fields: Rm=0, imm5=0, S=0, Rd=0, type1=0, Rn=0, cond=0
    let encoding: u32 = 0x00400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `field S = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "S", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_sub_r_a1_a_special_s_1_size_variant_1_0_00500000() {
    // Encoding: 0x00500000
    // Test aarch32_SUB_r_A1_A special value S = 1 (Size variant 1)
    // ISET: A32
    // Fields: cond=0, imm5=0, type1=0, Rm=0, Rn=0, Rd=0, S=1
    let encoding: u32 = 0x00500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_r_T1_A
/// ASL: `field Rm 22 +: 3`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_sub_r_t1_a_field_rm_0_min_0_1a000000() {
    // Thumb encoding (32): 0x1A000000
    // Test aarch32_SUB_r_T1_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: Rm=0, Rd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x1A000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_r_T1_A
/// ASL: `field Rm 22 +: 3`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_sub_r_t1_a_field_rm_1_poweroftwo_0_1a400000() {
    // Thumb encoding (32): 0x1A400000
    // Test aarch32_SUB_r_T1_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=1, Rd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x1A400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_r_T1_A
/// ASL: `field Rn 19 +: 3`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_sub_r_t1_a_field_rn_0_min_0_1a000000() {
    // Thumb encoding (32): 0x1A000000
    // Test aarch32_SUB_r_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rm=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x1A000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_r_T1_A
/// ASL: `field Rn 19 +: 3`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_sub_r_t1_a_field_rn_1_poweroftwo_0_1a080000() {
    // Thumb encoding (32): 0x1A080000
    // Test aarch32_SUB_r_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=0, Rn=1, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x1A080000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_r_T1_A
/// ASL: `field Rd 16 +: 3`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_sub_r_t1_a_field_rd_0_min_0_1a000000() {
    // Thumb encoding (32): 0x1A000000
    // Test aarch32_SUB_r_T1_A field Rd = 0 (Min)
    // ISET: T32
    // Fields: Rd=0, Rm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x1A000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_r_T1_A
/// ASL: `field Rd 16 +: 3`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_sub_r_t1_a_field_rd_1_poweroftwo_0_1a010000() {
    // Thumb encoding (32): 0x1A010000
    // Test aarch32_SUB_r_T1_A field Rd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rd=1, Rm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x1A010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_r_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch32_sub_r_t1_a_combo_0_0_1a000000() {
    // Thumb encoding (32): 0x1A000000
    // Test aarch32_SUB_r_T1_A field combination: Rm=0, Rn=0, Rd=0
    // ISET: T32
    // Fields: Rn=0, Rm=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x1A000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_r_T2_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_sub_r_t2_a_field_s_0_min_0_eba00000() {
    // Thumb encoding (32): 0xEBA00000
    // Test aarch32_SUB_r_T2_A field S = 0 (Min)
    // ISET: T32
    // Fields: Rd=0, S=0, type1=0, Rn=0, Rm=0, imm2=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEBA00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_r_T2_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_sub_r_t2_a_field_s_1_max_0_ebb00000() {
    // Thumb encoding (32): 0xEBB00000
    // Test aarch32_SUB_r_T2_A field S = 1 (Max)
    // ISET: T32
    // Fields: imm2=0, S=1, Rn=0, Rd=0, type1=0, Rm=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEBB00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_r_T2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_sub_r_t2_a_field_rn_0_min_0_eba00000() {
    // Thumb encoding (32): 0xEBA00000
    // Test aarch32_SUB_r_T2_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: imm2=0, type1=0, Rn=0, Rm=0, imm3=0, S=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEBA00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_r_T2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_sub_r_t2_a_field_rn_1_poweroftwo_0_eba10000() {
    // Thumb encoding (32): 0xEBA10000
    // Test aarch32_SUB_r_T2_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=0, Rd=0, Rn=1, imm3=0, imm2=0, type1=0, S=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEBA10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_r_T2_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_sub_r_t2_a_field_imm3_0_zero_0_eba00000() {
    // Thumb encoding (32): 0xEBA00000
    // Test aarch32_SUB_r_T2_A field imm3 = 0 (Zero)
    // ISET: T32
    // Fields: type1=0, S=0, imm3=0, Rd=0, imm2=0, Rm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEBA00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_r_T2_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_sub_r_t2_a_field_imm3_1_poweroftwo_0_eba01000() {
    // Thumb encoding (32): 0xEBA01000
    // Test aarch32_SUB_r_T2_A field imm3 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm2=0, Rn=0, Rd=0, imm3=1, S=0, type1=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEBA01000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_r_T2_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 3, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (3)
#[test]
fn test_aarch32_sub_r_t2_a_field_imm3_3_poweroftwominusone_0_eba03000() {
    // Thumb encoding (32): 0xEBA03000
    // Test aarch32_SUB_r_T2_A field imm3 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: type1=0, imm3=3, Rn=0, Rm=0, S=0, Rd=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEBA03000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_r_T2_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 7, boundary: Max }
/// maximum immediate (7)
#[test]
fn test_aarch32_sub_r_t2_a_field_imm3_7_max_0_eba07000() {
    // Thumb encoding (32): 0xEBA07000
    // Test aarch32_SUB_r_T2_A field imm3 = 7 (Max)
    // ISET: T32
    // Fields: type1=0, S=0, Rm=0, imm2=0, Rd=0, imm3=7, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEBA07000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_r_T2_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_sub_r_t2_a_field_rd_0_min_0_eba00000() {
    // Thumb encoding (32): 0xEBA00000
    // Test aarch32_SUB_r_T2_A field Rd = 0 (Min)
    // ISET: T32
    // Fields: type1=0, imm2=0, Rn=0, S=0, imm3=0, Rd=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEBA00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_r_T2_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_sub_r_t2_a_field_rd_1_poweroftwo_0_eba00100() {
    // Thumb encoding (32): 0xEBA00100
    // Test aarch32_SUB_r_T2_A field Rd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rd=1, imm3=0, type1=0, Rn=0, imm2=0, Rm=0, S=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEBA00100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_r_T2_A
/// ASL: `field imm2 6 +: 2`
/// Requirement: FieldBoundary { field: "imm2", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_sub_r_t2_a_field_imm2_0_zero_0_eba00000() {
    // Thumb encoding (32): 0xEBA00000
    // Test aarch32_SUB_r_T2_A field imm2 = 0 (Zero)
    // ISET: T32
    // Fields: S=0, imm3=0, type1=0, imm2=0, Rn=0, Rd=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEBA00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_r_T2_A
/// ASL: `field imm2 6 +: 2`
/// Requirement: FieldBoundary { field: "imm2", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_sub_r_t2_a_field_imm2_1_poweroftwo_0_eba00040() {
    // Thumb encoding (32): 0xEBA00040
    // Test aarch32_SUB_r_T2_A field imm2 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=0, type1=0, imm2=1, S=0, Rn=0, imm3=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEBA00040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_r_T2_A
/// ASL: `field imm2 6 +: 2`
/// Requirement: FieldBoundary { field: "imm2", value: 3, boundary: Max }
/// maximum immediate (3)
#[test]
fn test_aarch32_sub_r_t2_a_field_imm2_3_max_0_eba000c0() {
    // Thumb encoding (32): 0xEBA000C0
    // Test aarch32_SUB_r_T2_A field imm2 = 3 (Max)
    // ISET: T32
    // Fields: S=0, Rm=0, imm3=0, Rn=0, Rd=0, imm2=3, type1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEBA000C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_r_T2_A
/// ASL: `field type1 4 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_sub_r_t2_a_field_type1_0_min_0_eba00000() {
    // Thumb encoding (32): 0xEBA00000
    // Test aarch32_SUB_r_T2_A field type1 = 0 (Min)
    // ISET: T32
    // Fields: S=0, Rd=0, Rn=0, imm2=0, Rm=0, type1=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEBA00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_r_T2_A
/// ASL: `field type1 4 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_sub_r_t2_a_field_type1_1_poweroftwo_0_eba00010() {
    // Thumb encoding (32): 0xEBA00010
    // Test aarch32_SUB_r_T2_A field type1 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm2=0, type1=1, Rm=0, S=0, Rn=0, Rd=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEBA00010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_r_T2_A
/// ASL: `field type1 4 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_aarch32_sub_r_t2_a_field_type1_3_max_0_eba00030() {
    // Thumb encoding (32): 0xEBA00030
    // Test aarch32_SUB_r_T2_A field type1 = 3 (Max)
    // ISET: T32
    // Fields: imm3=0, type1=3, Rm=0, imm2=0, Rn=0, S=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEBA00030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_r_T2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_sub_r_t2_a_field_rm_0_min_0_eba00000() {
    // Thumb encoding (32): 0xEBA00000
    // Test aarch32_SUB_r_T2_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: type1=0, Rm=0, Rn=0, Rd=0, S=0, imm3=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEBA00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_r_T2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_sub_r_t2_a_field_rm_1_poweroftwo_0_eba00001() {
    // Thumb encoding (32): 0xEBA00001
    // Test aarch32_SUB_r_T2_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, imm2=0, type1=0, S=0, Rd=0, Rm=1, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEBA00001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_r_T2_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// S=0 (8-bit / byte size)
#[test]
fn test_aarch32_sub_r_t2_a_combo_0_0_eba00000() {
    // Thumb encoding (32): 0xEBA00000
    // Test aarch32_SUB_r_T2_A field combination: S=0, Rn=0, imm3=0, Rd=0, imm2=0, type1=0, Rm=0
    // ISET: T32
    // Fields: Rm=0, Rd=0, S=0, imm2=0, Rn=0, imm3=0, type1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEBA00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_r_T2_A
/// ASL: `field S = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "S", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_sub_r_t2_a_special_s_0_size_variant_0_0_eba00000() {
    // Thumb encoding (32): 0xEBA00000
    // Test aarch32_SUB_r_T2_A special value S = 0 (Size variant 0)
    // ISET: T32
    // Fields: Rd=0, S=0, imm2=0, Rm=0, type1=0, Rn=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEBA00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_r_T2_A
/// ASL: `field S = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "S", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_sub_r_t2_a_special_s_1_size_variant_1_0_ebb00000() {
    // Thumb encoding (32): 0xEBB00000
    // Test aarch32_SUB_r_T2_A special value S = 1 (Size variant 1)
    // ISET: T32
    // Fields: Rd=0, imm3=0, Rm=0, S=1, Rn=0, imm2=0, type1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEBB00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SUB_r_T2_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Or, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: And, lhs: LitInt(15), rhs: Unary { op: Not, operand: Var(QualifiedIdentifier { qualifier: Any, name: "setflags" }) } } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Or, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: And, lhs: LitInt(15), rhs: Unary { op: Not, operand: Var(QualifiedIdentifier { qualifier: Any, name: \"setflags\" }) } } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_sub_r_t2_a_invalid_0_0_eba00000() {
    // Thumb encoding (32): 0xEBA00000
    // Test aarch32_SUB_r_T2_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Or, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: And, lhs: LitInt(15), rhs: Unary { op: Not, operand: Var(QualifiedIdentifier { qualifier: Any, name: "setflags" }) } } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }
    // ISET: T32
    // Fields: type1=0, S=0, Rn=0, imm3=0, imm2=0, Rd=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEBA00000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_SUB_r_T2_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_sub_r_t2_a_invalid_1_0_eba00000() {
    // Thumb encoding (32): 0xEBA00000
    // Test aarch32_SUB_r_T2_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rn=0, imm2=0, type1=0, Rm=0, S=0, imm3=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEBA00000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `ADD X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// no shift (32)
#[test]
fn test_aarch32_sub_r_a1_a_add_shifted_oracle_32_0_00420020() {
    // Test ADD shifted 32-bit: no shift (oracle)
    // Encoding: 0x00420020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0xA);
    let encoding: u32 = 0x00420020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6E, "W0 should be 0x0000006E");
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `ADD X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// no shift (64)
#[test]
fn test_aarch32_sub_r_a1_a_add_shifted_oracle_64_0_80420020() {
    // Test ADD shifted 64-bit: no shift (oracle)
    // Encoding: 0x80420020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xA);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x80420020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6E, "X0 should be 0x000000000000006E");
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `ADD X0, X1, X2, shift #3`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// LSL #3 (multiply by 8) (32)
#[test]
fn test_aarch32_sub_r_a1_a_add_shifted_oracle_32_1_00420c20() {
    // Test ADD shifted 32-bit: LSL #3 (multiply by 8) (oracle)
    // Encoding: 0x00420C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x00420C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6C, "W0 should be 0x0000006C");
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `ADD X0, X1, X2, shift #3`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// LSL #3 (multiply by 8) (64)
#[test]
fn test_aarch32_sub_r_a1_a_add_shifted_oracle_64_1_80420c20() {
    // Test ADD shifted 64-bit: LSL #3 (multiply by 8) (oracle)
    // Encoding: 0x80420C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x80420C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6C, "X0 should be 0x000000000000006C");
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `ADD X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// overflow test (32)
#[test]
fn test_aarch32_sub_r_a1_a_add_shifted_oracle_32_2_00420020() {
    // Test ADD shifted 32-bit: overflow test (oracle)
    // Encoding: 0x00420020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x00420020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `ADD X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// overflow test (64)
#[test]
fn test_aarch32_sub_r_a1_a_add_shifted_oracle_64_2_80420020() {
    // Test ADD shifted 64-bit: overflow test (oracle)
    // Encoding: 0x80420020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x80420020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `ADD X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// subtract from zero (32)
#[test]
fn test_aarch32_sub_r_a1_a_add_shifted_oracle_32_3_00420020() {
    // Test ADD shifted 32-bit: subtract from zero (oracle)
    // Encoding: 0x00420020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x00420020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "W0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `ADD X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// subtract from zero (64)
#[test]
fn test_aarch32_sub_r_a1_a_add_shifted_oracle_64_3_80420020() {
    // Test ADD shifted 64-bit: subtract from zero (oracle)
    // Encoding: 0x80420020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x80420020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `ADDS X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// no shift (32)
#[test]
fn test_aarch32_sub_r_a1_a_adds_shifted_oracle_32_0_20420020() {
    // Test ADDS shifted 32-bit: no shift (oracle)
    // Encoding: 0x20420020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xA);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x20420020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6E, "W0 should be 0x0000006E");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `ADDS X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// no shift (64)
#[test]
fn test_aarch32_sub_r_a1_a_adds_shifted_oracle_64_0_a0420020() {
    // Test ADDS shifted 64-bit: no shift (oracle)
    // Encoding: 0xA0420020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0xA);
    let encoding: u32 = 0xA0420020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6E, "X0 should be 0x000000000000006E");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `ADDS X0, X1, X2, shift #3`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// LSL #3 (multiply by 8) (32)
#[test]
fn test_aarch32_sub_r_a1_a_adds_shifted_oracle_32_1_20420c20() {
    // Test ADDS shifted 32-bit: LSL #3 (multiply by 8) (oracle)
    // Encoding: 0x20420C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x20420C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6C, "W0 should be 0x0000006C");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `ADDS X0, X1, X2, shift #3`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// LSL #3 (multiply by 8) (64)
#[test]
fn test_aarch32_sub_r_a1_a_adds_shifted_oracle_64_1_a0420c20() {
    // Test ADDS shifted 64-bit: LSL #3 (multiply by 8) (oracle)
    // Encoding: 0xA0420C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0xA0420C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6C, "X0 should be 0x000000000000006C");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `ADDS X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// overflow test (32)
#[test]
fn test_aarch32_sub_r_a1_a_adds_shifted_oracle_32_2_20420020() {
    // Test ADDS shifted 32-bit: overflow test (oracle)
    // Encoding: 0x20420020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x20420020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `ADDS X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// overflow test (64)
#[test]
fn test_aarch32_sub_r_a1_a_adds_shifted_oracle_64_2_a0420020() {
    // Test ADDS shifted 64-bit: overflow test (oracle)
    // Encoding: 0xA0420020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xA0420020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, true, "V flag should be true");
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `ADDS X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// subtract from zero (32)
#[test]
fn test_aarch32_sub_r_a1_a_adds_shifted_oracle_32_3_20420020() {
    // Test ADDS shifted 32-bit: subtract from zero (oracle)
    // Encoding: 0x20420020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x20420020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "W0 should be 0xFFFFFFFF");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `ADDS X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// subtract from zero (64)
#[test]
fn test_aarch32_sub_r_a1_a_adds_shifted_oracle_64_3_a0420020() {
    // Test ADDS shifted 64-bit: subtract from zero (oracle)
    // Encoding: 0xA0420020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0xA0420020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `SUB X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// no shift (32)
#[test]
fn test_aarch32_sub_r_a1_a_sub_shifted_oracle_32_0_40420020() {
    // Test SUB shifted 32-bit: no shift (oracle)
    // Encoding: 0x40420020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xA);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x40420020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x5A, "W0 should be 0x0000005A");
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `SUB X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// no shift (64)
#[test]
fn test_aarch32_sub_r_a1_a_sub_shifted_oracle_64_0_c0420020() {
    // Test SUB shifted 64-bit: no shift (oracle)
    // Encoding: 0xC0420020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0xA);
    let encoding: u32 = 0xC0420020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x5A, "X0 should be 0x000000000000005A");
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `SUB X0, X1, X2, shift #3`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// LSL #3 (multiply by 8) (32)
#[test]
fn test_aarch32_sub_r_a1_a_sub_shifted_oracle_32_1_40420c20() {
    // Test SUB shifted 32-bit: LSL #3 (multiply by 8) (oracle)
    // Encoding: 0x40420C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x40420C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x5C, "W0 should be 0x0000005C");
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `SUB X0, X1, X2, shift #3`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// LSL #3 (multiply by 8) (64)
#[test]
fn test_aarch32_sub_r_a1_a_sub_shifted_oracle_64_1_c0420c20() {
    // Test SUB shifted 64-bit: LSL #3 (multiply by 8) (oracle)
    // Encoding: 0xC0420C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xC0420C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x5C, "X0 should be 0x000000000000005C");
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `SUB X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// overflow test (32)
#[test]
fn test_aarch32_sub_r_a1_a_sub_shifted_oracle_32_2_40420020() {
    // Test SUB shifted 32-bit: overflow test (oracle)
    // Encoding: 0x40420020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x40420020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `SUB X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// overflow test (64)
#[test]
fn test_aarch32_sub_r_a1_a_sub_shifted_oracle_64_2_c0420020() {
    // Test SUB shifted 64-bit: overflow test (oracle)
    // Encoding: 0xC0420020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xC0420020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `SUB X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// subtract from zero (32)
#[test]
fn test_aarch32_sub_r_a1_a_sub_shifted_oracle_32_3_40420020() {
    // Test SUB shifted 32-bit: subtract from zero (oracle)
    // Encoding: 0x40420020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x40420020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `SUB X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// subtract from zero (64)
#[test]
fn test_aarch32_sub_r_a1_a_sub_shifted_oracle_64_3_c0420020() {
    // Test SUB shifted 64-bit: subtract from zero (oracle)
    // Encoding: 0xC0420020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0xC0420020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x0000000000000001");
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `SUBS X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// no shift (32)
#[test]
fn test_aarch32_sub_r_a1_a_subs_shifted_oracle_32_0_60420020() {
    // Test SUBS shifted 32-bit: no shift (oracle)
    // Encoding: 0x60420020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0xA);
    let encoding: u32 = 0x60420020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x5A, "W0 should be 0x0000005A");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `SUBS X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// no shift (64)
#[test]
fn test_aarch32_sub_r_a1_a_subs_shifted_oracle_64_0_e0420020() {
    // Test SUBS shifted 64-bit: no shift (oracle)
    // Encoding: 0xE0420020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0xA);
    let encoding: u32 = 0xE0420020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x5A, "X0 should be 0x000000000000005A");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `SUBS X0, X1, X2, shift #3`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// LSL #3 (multiply by 8) (32)
#[test]
fn test_aarch32_sub_r_a1_a_subs_shifted_oracle_32_1_60420c20() {
    // Test SUBS shifted 32-bit: LSL #3 (multiply by 8) (oracle)
    // Encoding: 0x60420C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x60420C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x5C, "W0 should be 0x0000005C");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `SUBS X0, X1, X2, shift #3`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// LSL #3 (multiply by 8) (64)
#[test]
fn test_aarch32_sub_r_a1_a_subs_shifted_oracle_64_1_e0420c20() {
    // Test SUBS shifted 64-bit: LSL #3 (multiply by 8) (oracle)
    // Encoding: 0xE0420C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0xE0420C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x5C, "X0 should be 0x000000000000005C");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `SUBS X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// overflow test (32)
#[test]
fn test_aarch32_sub_r_a1_a_subs_shifted_oracle_32_2_60420020() {
    // Test SUBS shifted 32-bit: overflow test (oracle)
    // Encoding: 0x60420020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x60420020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `SUBS X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// overflow test (64)
#[test]
fn test_aarch32_sub_r_a1_a_subs_shifted_oracle_64_2_e0420020() {
    // Test SUBS shifted 64-bit: overflow test (oracle)
    // Encoding: 0xE0420020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xE0420020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `SUBS X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// subtract from zero (32)
#[test]
fn test_aarch32_sub_r_a1_a_subs_shifted_oracle_32_3_60420020() {
    // Test SUBS shifted 32-bit: subtract from zero (oracle)
    // Encoding: 0x60420020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x60420020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `SUBS X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// subtract from zero (64)
#[test]
fn test_aarch32_sub_r_a1_a_subs_shifted_oracle_64_3_e0420020() {
    // Test SUBS shifted 64-bit: subtract from zero (oracle)
    // Encoding: 0xE0420020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xE0420020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x0000000000000001");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `SUB R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple values
#[test]
fn test_aarch32_sub_r_a1_a_a32_add_sub_reg_0_00410002() {
    // Test A32 SUB: simple values (oracle)
    // Encoding: 0x00410002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x32);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x00410002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x32, "R0 should be 0x00000032");
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `SUB R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero values
#[test]
fn test_aarch32_sub_r_a1_a_a32_add_sub_reg_1_00410002() {
    // Test A32 SUB: zero values (oracle)
    // Encoding: 0x00410002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x00410002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `SUB R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max value
#[test]
fn test_aarch32_sub_r_a1_a_a32_add_sub_reg_2_00410002() {
    // Test A32 SUB: max value (oracle)
    // Encoding: 0x00410002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x00410002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFE, "R0 should be 0xFFFFFFFE");
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `SUB R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set
#[test]
fn test_aarch32_sub_r_a1_a_a32_add_sub_reg_3_00410002() {
    // Test A32 SUB: MSB set (oracle)
    // Encoding: 0x00410002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x80000000);
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0x00410002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `SUB R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// mixed pattern
#[test]
fn test_aarch32_sub_r_a1_a_a32_add_sub_reg_4_00410002() {
    // Test A32 SUB: mixed pattern (oracle)
    // Encoding: 0x00410002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x9ABCDEF0);
    let encoding: u32 = 0x00410002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x77777788, "R0 should be 0x77777788");
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_aarch32_sub_r_a1_a_flags_zeroresult_0_00510002() {
    // Test aarch32_SUB_r_A1_A flag computation: ZeroResult
    // Encoding: 0x00510002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x00510002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_aarch32_sub_r_a1_a_flags_zeroresult_1_00510002() {
    // Test aarch32_SUB_r_A1_A flag computation: ZeroResult
    // Encoding: 0x00510002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x00510002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_aarch32_sub_r_a1_a_flags_negativeresult_2_00510002() {
    // Test aarch32_SUB_r_A1_A flag computation: NegativeResult
    // Encoding: 0x00510002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x00510002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_aarch32_sub_r_a1_a_flags_unsignedoverflow_3_00510002() {
    // Test aarch32_SUB_r_A1_A flag computation: UnsignedOverflow
    // Encoding: 0x00510002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x00510002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_aarch32_sub_r_a1_a_flags_unsignedoverflow_4_00510002() {
    // Test aarch32_SUB_r_A1_A flag computation: UnsignedOverflow
    // Encoding: 0x00510002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x00510002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_aarch32_sub_r_a1_a_flags_signedoverflow_5_00510002() {
    // Test aarch32_SUB_r_A1_A flag computation: SignedOverflow
    // Encoding: 0x00510002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x00510002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_aarch32_sub_r_a1_a_flags_signedoverflow_6_00510002() {
    // Test aarch32_SUB_r_A1_A flag computation: SignedOverflow
    // Encoding: 0x00510002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x00510002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_SUB_r_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_aarch32_sub_r_a1_a_flags_positiveresult_7_00510002() {
    // Test aarch32_SUB_r_A1_A flag computation: PositiveResult
    // Encoding: 0x00510002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x32);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x00510002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SUB_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 0 (32)
#[test]
fn test_aarch32_sub_r_t1_a_lslv_oracle_32_0_1a020020() {
    // Test LSLV 32-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x12345678, "W0 should be 0x12345678");
}

/// Provenance: aarch32_SUB_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 0 (64)
#[test]
fn test_aarch32_sub_r_t1_a_lslv_oracle_64_0_9a020020() {
    // Test LSLV 64-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x12345678,
        "X0 should be 0x0000000012345678"
    );
}

/// Provenance: aarch32_SUB_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4 (32)
#[test]
fn test_aarch32_sub_r_t1_a_lslv_oracle_32_1_1a020020() {
    // Test LSLV 32-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x4);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x23456780, "W0 should be 0x23456780");
}

/// Provenance: aarch32_SUB_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 4 (64)
#[test]
fn test_aarch32_sub_r_t1_a_lslv_oracle_64_1_9a020020() {
    // Test LSLV 64-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x4);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x23456780,
        "X0 should be 0x0000000123456780"
    );
}

/// Provenance: aarch32_SUB_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 8 (32)
#[test]
fn test_aarch32_sub_r_t1_a_lslv_oracle_32_2_1a020020() {
    // Test LSLV 32-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x8);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x34567800, "W0 should be 0x34567800");
}

/// Provenance: aarch32_SUB_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 8 (64)
#[test]
fn test_aarch32_sub_r_t1_a_lslv_oracle_64_2_9a020020() {
    // Test LSLV 64-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x8);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x34567800,
        "X0 should be 0x0000001234567800"
    );
}

/// Provenance: aarch32_SUB_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1 (32)
#[test]
fn test_aarch32_sub_r_t1_a_lslv_oracle_32_3_1a020020() {
    // Test LSLV 32-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_SUB_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// MSB set, shift 1 (64)
#[test]
fn test_aarch32_sub_r_t1_a_lslv_oracle_64_3_9a020020() {
    // Test LSLV 64-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_SUB_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// LSB set, max shift (32)
#[test]
fn test_aarch32_sub_r_t1_a_lslv_oracle_32_4_1a020020() {
    // Test LSLV 32-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3F);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "W0 should be 0x80000000");
}

/// Provenance: aarch32_SUB_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// LSB set, max shift (64)
#[test]
fn test_aarch32_sub_r_t1_a_lslv_oracle_64_4_9a020020() {
    // Test LSLV 64-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3F);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x8000000000000000");
}

/// Provenance: aarch32_SUB_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// all ones, shift 32 (32)
#[test]
fn test_aarch32_sub_r_t1_a_lslv_oracle_32_5_1a020020() {
    // Test LSLV 32-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x20);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "W0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_SUB_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// all ones, shift 32 (64)
#[test]
fn test_aarch32_sub_r_t1_a_lslv_oracle_64_5_9a020020() {
    // Test LSLV 64-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x20);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0xFFFFFFFF00000000");
}

/// Provenance: aarch32_SUB_r_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// no shift
#[test]
fn test_aarch32_sub_r_t1_a_t16_oracle_0_1a880000() {
    // Test T16 LSLS: no shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_SUB_r_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4
#[test]
fn test_aarch32_sub_r_t1_a_t16_oracle_1_1a880000() {
    // Test T16 LSLS: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x4);
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF0, "R0 should be 0x00000FF0");
}

/// Provenance: aarch32_SUB_r_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1
#[test]
fn test_aarch32_sub_r_t1_a_t16_oracle_2_1a880000() {
    // Test T16 LSLS: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_SUB_r_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift to MSB
#[test]
fn test_aarch32_sub_r_t1_a_t16_oracle_3_1a880000() {
    // Test T16 LSLS: shift to MSB (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1F);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "R0 should be 0x80000000");
}

/// Provenance: aarch32_SUB_r_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_aarch32_sub_r_t1_a_flags_zeroresult_0_1a880000() {
    // Test aarch32_SUB_r_T1_A flag computation: ZeroResult
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SUB_r_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_aarch32_sub_r_t1_a_flags_zeroresult_1_1a880000() {
    // Test aarch32_SUB_r_T1_A flag computation: ZeroResult
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SUB_r_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_aarch32_sub_r_t1_a_flags_negativeresult_2_1a880000() {
    // Test aarch32_SUB_r_T1_A flag computation: NegativeResult
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SUB_r_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_aarch32_sub_r_t1_a_flags_unsignedoverflow_3_1a880000() {
    // Test aarch32_SUB_r_T1_A flag computation: UnsignedOverflow
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SUB_r_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_aarch32_sub_r_t1_a_flags_unsignedoverflow_4_1a880000() {
    // Test aarch32_SUB_r_T1_A flag computation: UnsignedOverflow
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SUB_r_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_aarch32_sub_r_t1_a_flags_signedoverflow_5_1a880000() {
    // Test aarch32_SUB_r_T1_A flag computation: SignedOverflow
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_SUB_r_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_aarch32_sub_r_t1_a_flags_signedoverflow_6_1a880000() {
    // Test aarch32_SUB_r_T1_A flag computation: SignedOverflow
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_SUB_r_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_aarch32_sub_r_t1_a_flags_positiveresult_7_1a880000() {
    // Test aarch32_SUB_r_T1_A flag computation: PositiveResult
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x32);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SUB_r_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_aarch32_sub_r_t2_a_flags_zeroresult_0_ebb10002() {
    // Test aarch32_SUB_r_T2_A flag computation: ZeroResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xEBB10002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SUB_r_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_aarch32_sub_r_t2_a_flags_zeroresult_1_ebb10002() {
    // Test aarch32_SUB_r_T2_A flag computation: ZeroResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0xEBB10002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SUB_r_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_aarch32_sub_r_t2_a_flags_negativeresult_2_ebb10002() {
    // Test aarch32_SUB_r_T2_A flag computation: NegativeResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xEBB10002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SUB_r_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_aarch32_sub_r_t2_a_flags_unsignedoverflow_3_ebb10002() {
    // Test aarch32_SUB_r_T2_A flag computation: UnsignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xEBB10002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SUB_r_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_aarch32_sub_r_t2_a_flags_unsignedoverflow_4_ebb10002() {
    // Test aarch32_SUB_r_T2_A flag computation: UnsignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0xEBB10002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SUB_r_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_aarch32_sub_r_t2_a_flags_signedoverflow_5_ebb10002() {
    // Test aarch32_SUB_r_T2_A flag computation: SignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0xEBB10002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_SUB_r_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_aarch32_sub_r_t2_a_flags_signedoverflow_6_ebb10002() {
    // Test aarch32_SUB_r_T2_A flag computation: SignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xEBB10002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_SUB_r_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_aarch32_sub_r_t2_a_flags_positiveresult_7_ebb10002() {
    // Test aarch32_SUB_r_T2_A flag computation: PositiveResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x32);
    let encoding: u32 = 0xEBB10002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

// ============================================================================
// aarch32_ADC_rr_A Tests
// ============================================================================

/// Provenance: aarch32_ADC_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_adc_rr_a1_a_field_cond_0_min_10_00a00010() {
    // Encoding: 0x00A00010
    // Test aarch32_ADC_rr_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rm=0, Rn=0, type1=0, Rd=0, S=0, Rs=0
    let encoding: u32 = 0x00A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_adc_rr_a1_a_field_cond_1_poweroftwo_10_10a00010() {
    // Encoding: 0x10A00010
    // Test aarch32_ADC_rr_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, type1=0, Rm=0, Rn=0, cond=1, S=0, Rs=0
    let encoding: u32 = 0x10A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_adc_rr_a1_a_field_cond_2_poweroftwo_10_20a00010() {
    // Encoding: 0x20A00010
    // Test aarch32_ADC_rr_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=2, Rs=0, Rn=0, type1=0, S=0, Rm=0, Rd=0
    let encoding: u32 = 0x20A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_adc_rr_a1_a_field_cond_3_poweroftwo_10_30a00010() {
    // Encoding: 0x30A00010
    // Test aarch32_ADC_rr_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, S=0, type1=0, Rm=0, cond=3, Rd=0, Rs=0
    let encoding: u32 = 0x30A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_adc_rr_a1_a_field_cond_4_poweroftwo_10_40a00010() {
    // Encoding: 0x40A00010
    // Test aarch32_ADC_rr_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=4, S=0, Rn=0, Rd=0, Rm=0, type1=0, Rs=0
    let encoding: u32 = 0x40A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_adc_rr_a1_a_field_cond_5_poweroftwo_10_50a00010() {
    // Encoding: 0x50A00010
    // Test aarch32_ADC_rr_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=5, type1=0, Rd=0, Rs=0, Rm=0, S=0
    let encoding: u32 = 0x50A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_adc_rr_a1_a_field_cond_6_poweroftwo_10_60a00010() {
    // Encoding: 0x60A00010
    // Test aarch32_ADC_rr_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, cond=6, Rs=0, Rn=0, Rd=0, type1=0, S=0
    let encoding: u32 = 0x60A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_adc_rr_a1_a_field_cond_7_poweroftwo_10_70a00010() {
    // Encoding: 0x70A00010
    // Test aarch32_ADC_rr_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=7, Rn=0, Rd=0, Rs=0, type1=0, S=0, Rm=0
    let encoding: u32 = 0x70A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_adc_rr_a1_a_field_cond_8_poweroftwo_10_80a00010() {
    // Encoding: 0x80A00010
    // Test aarch32_ADC_rr_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, Rn=0, Rd=0, Rs=0, cond=8, type1=0, Rm=0
    let encoding: u32 = 0x80A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_adc_rr_a1_a_field_cond_9_poweroftwo_10_90a00010() {
    // Encoding: 0x90A00010
    // Test aarch32_ADC_rr_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, Rd=0, cond=9, Rn=0, type1=0, Rm=0, Rs=0
    let encoding: u32 = 0x90A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_adc_rr_a1_a_field_cond_10_poweroftwo_10_a0a00010() {
    // Encoding: 0xA0A00010
    // Test aarch32_ADC_rr_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, Rd=0, Rs=0, Rm=0, type1=0, cond=10, Rn=0
    let encoding: u32 = 0xA0A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_adc_rr_a1_a_field_cond_11_poweroftwo_10_b0a00010() {
    // Encoding: 0xB0A00010
    // Test aarch32_ADC_rr_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=11, Rn=0, Rd=0, Rs=0, S=0, type1=0, Rm=0
    let encoding: u32 = 0xB0A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_adc_rr_a1_a_field_cond_12_poweroftwo_10_c0a00010() {
    // Encoding: 0xC0A00010
    // Test aarch32_ADC_rr_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, S=0, Rs=0, Rm=0, cond=12, Rd=0, type1=0
    let encoding: u32 = 0xC0A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_adc_rr_a1_a_field_cond_13_poweroftwo_10_d0a00010() {
    // Encoding: 0xD0A00010
    // Test aarch32_ADC_rr_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rn=0, Rs=0, cond=13, type1=0, S=0, Rm=0
    let encoding: u32 = 0xD0A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_adc_rr_a1_a_field_cond_14_poweroftwo_10_e0a00010() {
    // Encoding: 0xE0A00010
    // Test aarch32_ADC_rr_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: type1=0, Rm=0, S=0, Rn=0, cond=14, Rd=0, Rs=0
    let encoding: u32 = 0xE0A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_adc_rr_a1_a_field_cond_15_max_10_f0a00010() {
    // Encoding: 0xF0A00010
    // Test aarch32_ADC_rr_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: Rn=0, Rm=0, type1=0, cond=15, Rd=0, Rs=0, S=0
    let encoding: u32 = 0xF0A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_rr_A1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_adc_rr_a1_a_field_s_0_min_10_00a00010() {
    // Encoding: 0x00A00010
    // Test aarch32_ADC_rr_A1_A field S = 0 (Min)
    // ISET: A32
    // Fields: type1=0, Rm=0, cond=0, S=0, Rd=0, Rs=0, Rn=0
    let encoding: u32 = 0x00A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_rr_A1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_adc_rr_a1_a_field_s_1_max_10_00b00010() {
    // Encoding: 0x00B00010
    // Test aarch32_ADC_rr_A1_A field S = 1 (Max)
    // ISET: A32
    // Fields: Rs=0, Rd=0, S=1, type1=0, Rm=0, Rn=0, cond=0
    let encoding: u32 = 0x00B00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_rr_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_adc_rr_a1_a_field_rn_0_min_10_00a00010() {
    // Encoding: 0x00A00010
    // Test aarch32_ADC_rr_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: S=0, Rs=0, type1=0, Rm=0, Rn=0, Rd=0, cond=0
    let encoding: u32 = 0x00A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_rr_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_adc_rr_a1_a_field_rn_1_poweroftwo_10_00a10010() {
    // Encoding: 0x00A10010
    // Test aarch32_ADC_rr_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, S=0, Rm=0, type1=0, Rs=0, Rn=1, Rd=0
    let encoding: u32 = 0x00A10010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_rr_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_adc_rr_a1_a_field_rd_0_min_10_00a00010() {
    // Encoding: 0x00A00010
    // Test aarch32_ADC_rr_A1_A field Rd = 0 (Min)
    // ISET: A32
    // Fields: S=0, Rn=0, Rd=0, cond=0, Rs=0, type1=0, Rm=0
    let encoding: u32 = 0x00A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_rr_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_adc_rr_a1_a_field_rd_1_poweroftwo_10_00a01010() {
    // Encoding: 0x00A01010
    // Test aarch32_ADC_rr_A1_A field Rd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: type1=0, Rm=0, Rd=1, Rn=0, Rs=0, cond=0, S=0
    let encoding: u32 = 0x00A01010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_rr_A1_A
/// ASL: `field Rs 8 +: 4`
/// Requirement: FieldBoundary { field: "Rs", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_adc_rr_a1_a_field_rs_0_min_10_00a00010() {
    // Encoding: 0x00A00010
    // Test aarch32_ADC_rr_A1_A field Rs = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, Rn=0, cond=0, type1=0, Rs=0, S=0, Rd=0
    let encoding: u32 = 0x00A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_rr_A1_A
/// ASL: `field Rs 8 +: 4`
/// Requirement: FieldBoundary { field: "Rs", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_adc_rr_a1_a_field_rs_1_poweroftwo_10_00a00110() {
    // Encoding: 0x00A00110
    // Test aarch32_ADC_rr_A1_A field Rs = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, S=0, Rn=0, cond=0, Rs=1, type1=0, Rd=0
    let encoding: u32 = 0x00A00110;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_rr_A1_A
/// ASL: `field type1 5 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_adc_rr_a1_a_field_type1_0_min_10_00a00010() {
    // Encoding: 0x00A00010
    // Test aarch32_ADC_rr_A1_A field type1 = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, Rs=0, Rm=0, cond=0, type1=0, Rd=0, S=0
    let encoding: u32 = 0x00A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_rr_A1_A
/// ASL: `field type1 5 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_adc_rr_a1_a_field_type1_1_poweroftwo_10_00a00030() {
    // Encoding: 0x00A00030
    // Test aarch32_ADC_rr_A1_A field type1 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Rs=0, Rn=0, cond=0, S=0, Rd=0, type1=1
    let encoding: u32 = 0x00A00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_rr_A1_A
/// ASL: `field type1 5 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_aarch32_adc_rr_a1_a_field_type1_3_max_10_00a00070() {
    // Encoding: 0x00A00070
    // Test aarch32_ADC_rr_A1_A field type1 = 3 (Max)
    // ISET: A32
    // Fields: S=0, Rn=0, cond=0, type1=3, Rd=0, Rs=0, Rm=0
    let encoding: u32 = 0x00A00070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_rr_A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_adc_rr_a1_a_field_rm_0_min_10_00a00010() {
    // Encoding: 0x00A00010
    // Test aarch32_ADC_rr_A1_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: cond=0, S=0, Rd=0, type1=0, Rs=0, Rn=0, Rm=0
    let encoding: u32 = 0x00A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_rr_A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_adc_rr_a1_a_field_rm_1_poweroftwo_10_00a00011() {
    // Encoding: 0x00A00011
    // Test aarch32_ADC_rr_A1_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, S=0, Rm=1, Rd=0, type1=0, Rn=0, Rs=0
    let encoding: u32 = 0x00A00011;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_rr_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_adc_rr_a1_a_combo_0_10_00a00010() {
    // Encoding: 0x00A00010
    // Test aarch32_ADC_rr_A1_A field combination: cond=0, S=0, Rn=0, Rd=0, Rs=0, type1=0, Rm=0
    // ISET: A32
    // Fields: Rn=0, S=0, type1=0, cond=0, Rd=0, Rs=0, Rm=0
    let encoding: u32 = 0x00A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_rr_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_adc_rr_a1_a_special_cond_0_condition_eq_16_00a00010() {
    // Encoding: 0x00A00010
    // Test aarch32_ADC_rr_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: Rs=0, Rn=0, type1=0, Rd=0, cond=0, S=0, Rm=0
    let encoding: u32 = 0x00A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_rr_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_adc_rr_a1_a_special_cond_1_condition_ne_16_10a00010() {
    // Encoding: 0x10A00010
    // Test aarch32_ADC_rr_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: S=0, Rm=0, Rn=0, cond=1, Rd=0, type1=0, Rs=0
    let encoding: u32 = 0x10A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_rr_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_adc_rr_a1_a_special_cond_2_condition_cs_hs_16_20a00010() {
    // Encoding: 0x20A00010
    // Test aarch32_ADC_rr_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: Rd=0, Rs=0, type1=0, S=0, Rm=0, Rn=0, cond=2
    let encoding: u32 = 0x20A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_rr_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_adc_rr_a1_a_special_cond_3_condition_cc_lo_16_30a00010() {
    // Encoding: 0x30A00010
    // Test aarch32_ADC_rr_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: type1=0, Rs=0, Rm=0, S=0, cond=3, Rn=0, Rd=0
    let encoding: u32 = 0x30A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_rr_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_adc_rr_a1_a_special_cond_4_condition_mi_16_40a00010() {
    // Encoding: 0x40A00010
    // Test aarch32_ADC_rr_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: Rs=0, cond=4, type1=0, Rm=0, Rn=0, S=0, Rd=0
    let encoding: u32 = 0x40A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_rr_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_adc_rr_a1_a_special_cond_5_condition_pl_16_50a00010() {
    // Encoding: 0x50A00010
    // Test aarch32_ADC_rr_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: type1=0, Rd=0, cond=5, S=0, Rs=0, Rn=0, Rm=0
    let encoding: u32 = 0x50A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_rr_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_adc_rr_a1_a_special_cond_6_condition_vs_16_60a00010() {
    // Encoding: 0x60A00010
    // Test aarch32_ADC_rr_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: Rn=0, Rd=0, Rs=0, cond=6, type1=0, Rm=0, S=0
    let encoding: u32 = 0x60A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_rr_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_adc_rr_a1_a_special_cond_7_condition_vc_16_70a00010() {
    // Encoding: 0x70A00010
    // Test aarch32_ADC_rr_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: S=0, Rd=0, Rn=0, Rs=0, cond=7, type1=0, Rm=0
    let encoding: u32 = 0x70A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_rr_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_adc_rr_a1_a_special_cond_8_condition_hi_16_80a00010() {
    // Encoding: 0x80A00010
    // Test aarch32_ADC_rr_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: S=0, type1=0, Rn=0, Rm=0, cond=8, Rd=0, Rs=0
    let encoding: u32 = 0x80A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_rr_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_adc_rr_a1_a_special_cond_9_condition_ls_16_90a00010() {
    // Encoding: 0x90A00010
    // Test aarch32_ADC_rr_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: cond=9, S=0, Rd=0, Rn=0, Rs=0, type1=0, Rm=0
    let encoding: u32 = 0x90A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_rr_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_adc_rr_a1_a_special_cond_10_condition_ge_16_a0a00010() {
    // Encoding: 0xA0A00010
    // Test aarch32_ADC_rr_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: S=0, Rd=0, Rm=0, Rn=0, cond=10, type1=0, Rs=0
    let encoding: u32 = 0xA0A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_rr_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_adc_rr_a1_a_special_cond_11_condition_lt_16_b0a00010() {
    // Encoding: 0xB0A00010
    // Test aarch32_ADC_rr_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: Rm=0, Rn=0, S=0, Rs=0, cond=11, Rd=0, type1=0
    let encoding: u32 = 0xB0A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_rr_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_adc_rr_a1_a_special_cond_12_condition_gt_16_c0a00010() {
    // Encoding: 0xC0A00010
    // Test aarch32_ADC_rr_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: Rm=0, Rn=0, cond=12, Rd=0, Rs=0, type1=0, S=0
    let encoding: u32 = 0xC0A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_rr_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_adc_rr_a1_a_special_cond_13_condition_le_16_d0a00010() {
    // Encoding: 0xD0A00010
    // Test aarch32_ADC_rr_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: Rn=0, Rs=0, Rm=0, cond=13, Rd=0, type1=0, S=0
    let encoding: u32 = 0xD0A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_rr_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_adc_rr_a1_a_special_cond_14_condition_al_16_e0a00010() {
    // Encoding: 0xE0A00010
    // Test aarch32_ADC_rr_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: Rn=0, type1=0, S=0, Rd=0, Rs=0, Rm=0, cond=14
    let encoding: u32 = 0xE0A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_rr_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_adc_rr_a1_a_special_cond_15_condition_nv_16_f0a00010() {
    // Encoding: 0xF0A00010
    // Test aarch32_ADC_rr_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: Rm=0, Rn=0, Rd=0, S=0, cond=15, Rs=0, type1=0
    let encoding: u32 = 0xF0A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_rr_A1_A
/// ASL: `field S = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "S", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_adc_rr_a1_a_special_s_0_size_variant_0_16_00a00010() {
    // Encoding: 0x00A00010
    // Test aarch32_ADC_rr_A1_A special value S = 0 (Size variant 0)
    // ISET: A32
    // Fields: Rs=0, Rd=0, S=0, Rn=0, cond=0, type1=0, Rm=0
    let encoding: u32 = 0x00A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_rr_A1_A
/// ASL: `field S = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "S", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_adc_rr_a1_a_special_s_1_size_variant_1_16_00b00010() {
    // Encoding: 0x00B00010
    // Test aarch32_ADC_rr_A1_A special value S = 1 (Size variant 1)
    // ISET: A32
    // Fields: Rd=0, Rm=0, S=1, type1=0, Rs=0, cond=0, Rn=0
    let encoding: u32 = 0x00B00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_rr_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "s" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"s\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_adc_rr_a1_a_invalid_0_10_00a00010() {
    // Encoding: 0x00A00010
    // Test aarch32_ADC_rr_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "s" }) } }, rhs: LitInt(15) }
    // ISET: A32
    // Fields: Rd=0, type1=0, Rm=0, S=0, cond=0, Rn=0, Rs=0
    let encoding: u32 = 0x00A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_ADC_rr_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_adc_rr_a1_a_invalid_1_10_00a00010() {
    // Encoding: 0x00A00010
    // Test aarch32_ADC_rr_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Rm=0, cond=0, Rd=0, S=0, Rs=0, type1=0, Rn=0
    let encoding: u32 = 0x00A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_ADC_rr_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_aarch32_adc_rr_a1_a_flags_zeroresult_0_00b10012() {
    // Test aarch32_ADC_rr_A1_A flag computation: ZeroResult
    // Encoding: 0x00B10012
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x00B10012;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADC_rr_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_aarch32_adc_rr_a1_a_flags_zeroresult_1_00b10012() {
    // Test aarch32_ADC_rr_A1_A flag computation: ZeroResult
    // Encoding: 0x00B10012
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x00B10012;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADC_rr_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_aarch32_adc_rr_a1_a_flags_negativeresult_2_00b10012() {
    // Test aarch32_ADC_rr_A1_A flag computation: NegativeResult
    // Encoding: 0x00B10012
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x00B10012;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADC_rr_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_aarch32_adc_rr_a1_a_flags_unsignedoverflow_3_00b10012() {
    // Test aarch32_ADC_rr_A1_A flag computation: UnsignedOverflow
    // Encoding: 0x00B10012
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x00B10012;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADC_rr_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_aarch32_adc_rr_a1_a_flags_unsignedoverflow_4_00b10012() {
    // Test aarch32_ADC_rr_A1_A flag computation: UnsignedOverflow
    // Encoding: 0x00B10012
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x00B10012;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADC_rr_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_aarch32_adc_rr_a1_a_flags_signedoverflow_5_00b10012() {
    // Test aarch32_ADC_rr_A1_A flag computation: SignedOverflow
    // Encoding: 0x00B10012
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x00B10012;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_ADC_rr_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_aarch32_adc_rr_a1_a_flags_signedoverflow_6_00b10012() {
    // Test aarch32_ADC_rr_A1_A flag computation: SignedOverflow
    // Encoding: 0x00B10012
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x00B10012;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_ADC_rr_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_aarch32_adc_rr_a1_a_flags_positiveresult_7_00b10012() {
    // Test aarch32_ADC_rr_A1_A flag computation: PositiveResult
    // Encoding: 0x00B10012
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x32);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x00B10012;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

// ============================================================================
// aarch32_ADC_r_A Tests
// ============================================================================

/// Provenance: aarch32_ADC_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_adc_r_a1_a_field_cond_0_min_0_00a00000() {
    // Encoding: 0x00A00000
    // Test aarch32_ADC_r_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, Rm=0, cond=0, S=0, imm5=0, type1=0, Rd=0
    let encoding: u32 = 0x00A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_adc_r_a1_a_field_cond_1_poweroftwo_0_10a00000() {
    // Encoding: 0x10A00000
    // Test aarch32_ADC_r_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=1, Rd=0, Rm=0, S=0, imm5=0, type1=0
    let encoding: u32 = 0x10A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_adc_r_a1_a_field_cond_2_poweroftwo_0_20a00000() {
    // Encoding: 0x20A00000
    // Test aarch32_ADC_r_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=2, S=0, imm5=0, Rn=0, Rd=0, type1=0, Rm=0
    let encoding: u32 = 0x20A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_adc_r_a1_a_field_cond_3_poweroftwo_0_30a00000() {
    // Encoding: 0x30A00000
    // Test aarch32_ADC_r_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, type1=0, imm5=0, Rd=0, S=0, cond=3, Rn=0
    let encoding: u32 = 0x30A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_adc_r_a1_a_field_cond_4_poweroftwo_0_40a00000() {
    // Encoding: 0x40A00000
    // Test aarch32_ADC_r_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, imm5=0, S=0, cond=4, Rn=0, Rd=0, type1=0
    let encoding: u32 = 0x40A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_adc_r_a1_a_field_cond_5_poweroftwo_0_50a00000() {
    // Encoding: 0x50A00000
    // Test aarch32_ADC_r_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: imm5=0, type1=0, cond=5, Rn=0, Rd=0, Rm=0, S=0
    let encoding: u32 = 0x50A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_adc_r_a1_a_field_cond_6_poweroftwo_0_60a00000() {
    // Encoding: 0x60A00000
    // Test aarch32_ADC_r_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, imm5=0, Rn=0, Rm=0, type1=0, cond=6, S=0
    let encoding: u32 = 0x60A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_adc_r_a1_a_field_cond_7_poweroftwo_0_70a00000() {
    // Encoding: 0x70A00000
    // Test aarch32_ADC_r_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, Rd=0, imm5=0, type1=0, Rm=0, Rn=0, cond=7
    let encoding: u32 = 0x70A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_adc_r_a1_a_field_cond_8_poweroftwo_0_80a00000() {
    // Encoding: 0x80A00000
    // Test aarch32_ADC_r_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, cond=8, Rd=0, imm5=0, Rn=0, type1=0, Rm=0
    let encoding: u32 = 0x80A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_adc_r_a1_a_field_cond_9_poweroftwo_0_90a00000() {
    // Encoding: 0x90A00000
    // Test aarch32_ADC_r_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: type1=0, S=0, Rm=0, Rd=0, cond=9, Rn=0, imm5=0
    let encoding: u32 = 0x90A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_adc_r_a1_a_field_cond_10_poweroftwo_0_a0a00000() {
    // Encoding: 0xA0A00000
    // Test aarch32_ADC_r_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, cond=10, imm5=0, Rm=0, type1=0, S=0, Rn=0
    let encoding: u32 = 0xA0A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_adc_r_a1_a_field_cond_11_poweroftwo_0_b0a00000() {
    // Encoding: 0xB0A00000
    // Test aarch32_ADC_r_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Rn=0, Rd=0, type1=0, S=0, cond=11, imm5=0
    let encoding: u32 = 0xB0A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_adc_r_a1_a_field_cond_12_poweroftwo_0_c0a00000() {
    // Encoding: 0xC0A00000
    // Test aarch32_ADC_r_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=12, Rd=0, imm5=0, type1=0, Rm=0, S=0, Rn=0
    let encoding: u32 = 0xC0A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_adc_r_a1_a_field_cond_13_poweroftwo_0_d0a00000() {
    // Encoding: 0xD0A00000
    // Test aarch32_ADC_r_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: type1=0, Rm=0, S=0, Rd=0, imm5=0, cond=13, Rn=0
    let encoding: u32 = 0xD0A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_adc_r_a1_a_field_cond_14_poweroftwo_0_e0a00000() {
    // Encoding: 0xE0A00000
    // Test aarch32_ADC_r_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, Rn=0, Rd=0, type1=0, Rm=0, imm5=0, cond=14
    let encoding: u32 = 0xE0A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_adc_r_a1_a_field_cond_15_max_0_f0a00000() {
    // Encoding: 0xF0A00000
    // Test aarch32_ADC_r_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: imm5=0, S=0, Rm=0, Rd=0, cond=15, Rn=0, type1=0
    let encoding: u32 = 0xF0A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_r_A1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_adc_r_a1_a_field_s_0_min_0_00a00000() {
    // Encoding: 0x00A00000
    // Test aarch32_ADC_r_A1_A field S = 0 (Min)
    // ISET: A32
    // Fields: cond=0, imm5=0, Rn=0, S=0, type1=0, Rm=0, Rd=0
    let encoding: u32 = 0x00A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_r_A1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_adc_r_a1_a_field_s_1_max_0_00b00000() {
    // Encoding: 0x00B00000
    // Test aarch32_ADC_r_A1_A field S = 1 (Max)
    // ISET: A32
    // Fields: Rm=0, Rn=0, S=1, cond=0, Rd=0, imm5=0, type1=0
    let encoding: u32 = 0x00B00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_r_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_adc_r_a1_a_field_rn_0_min_0_00a00000() {
    // Encoding: 0x00A00000
    // Test aarch32_ADC_r_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: S=0, imm5=0, cond=0, type1=0, Rm=0, Rd=0, Rn=0
    let encoding: u32 = 0x00A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_r_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_adc_r_a1_a_field_rn_1_poweroftwo_0_00a10000() {
    // Encoding: 0x00A10000
    // Test aarch32_ADC_r_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=1, Rm=0, cond=0, Rd=0, imm5=0, type1=0, S=0
    let encoding: u32 = 0x00A10000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_r_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_adc_r_a1_a_field_rd_0_min_0_00a00000() {
    // Encoding: 0x00A00000
    // Test aarch32_ADC_r_A1_A field Rd = 0 (Min)
    // ISET: A32
    // Fields: S=0, Rd=0, Rn=0, Rm=0, imm5=0, type1=0, cond=0
    let encoding: u32 = 0x00A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_r_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_adc_r_a1_a_field_rd_1_poweroftwo_0_00a01000() {
    // Encoding: 0x00A01000
    // Test aarch32_ADC_r_A1_A field Rd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: type1=0, Rm=0, Rn=0, cond=0, imm5=0, Rd=1, S=0
    let encoding: u32 = 0x00A01000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_adc_r_a1_a_field_imm5_0_zero_0_00a00000() {
    // Encoding: 0x00A00000
    // Test aarch32_ADC_r_A1_A field imm5 = 0 (Zero)
    // ISET: A32
    // Fields: type1=0, imm5=0, Rm=0, S=0, cond=0, Rd=0, Rn=0
    let encoding: u32 = 0x00A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_adc_r_a1_a_field_imm5_1_poweroftwo_0_00a00080() {
    // Encoding: 0x00A00080
    // Test aarch32_ADC_r_A1_A field imm5 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rm=0, S=0, imm5=1, cond=0, type1=0, Rd=0
    let encoding: u32 = 0x00A00080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_adc_r_a1_a_field_imm5_3_poweroftwominusone_0_00a00180() {
    // Encoding: 0x00A00180
    // Test aarch32_ADC_r_A1_A field imm5 = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: type1=0, Rm=0, imm5=3, Rn=0, cond=0, S=0, Rd=0
    let encoding: u32 = 0x00A00180;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_adc_r_a1_a_field_imm5_4_poweroftwo_0_00a00200() {
    // Encoding: 0x00A00200
    // Test aarch32_ADC_r_A1_A field imm5 = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Rd=0, Rm=0, imm5=4, Rn=0, type1=0, S=0
    let encoding: u32 = 0x00A00200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_adc_r_a1_a_field_imm5_7_poweroftwominusone_0_00a00380() {
    // Encoding: 0x00A00380
    // Test aarch32_ADC_r_A1_A field imm5 = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, Rn=0, type1=0, Rm=0, S=0, Rd=0, imm5=7
    let encoding: u32 = 0x00A00380;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_adc_r_a1_a_field_imm5_8_poweroftwo_0_00a00400() {
    // Encoding: 0x00A00400
    // Test aarch32_ADC_r_A1_A field imm5 = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, type1=0, imm5=8, Rm=0, Rn=0, S=0, cond=0
    let encoding: u32 = 0x00A00400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 15, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (15)
#[test]
fn test_aarch32_adc_r_a1_a_field_imm5_15_poweroftwominusone_0_00a00780() {
    // Encoding: 0x00A00780
    // Test aarch32_ADC_r_A1_A field imm5 = 15 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rm=0, Rn=0, S=0, Rd=0, imm5=15, type1=0, cond=0
    let encoding: u32 = 0x00A00780;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_adc_r_a1_a_field_imm5_16_poweroftwo_0_00a00800() {
    // Encoding: 0x00A00800
    // Test aarch32_ADC_r_A1_A field imm5 = 16 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, S=0, Rd=0, Rm=0, type1=0, Rn=0, imm5=16
    let encoding: u32 = 0x00A00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 31, boundary: Max }
/// maximum immediate (31)
#[test]
fn test_aarch32_adc_r_a1_a_field_imm5_31_max_0_00a00f80() {
    // Encoding: 0x00A00F80
    // Test aarch32_ADC_r_A1_A field imm5 = 31 (Max)
    // ISET: A32
    // Fields: cond=0, Rn=0, Rd=0, imm5=31, type1=0, S=0, Rm=0
    let encoding: u32 = 0x00A00F80;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_r_A1_A
/// ASL: `field type1 5 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_adc_r_a1_a_field_type1_0_min_0_00a00000() {
    // Encoding: 0x00A00000
    // Test aarch32_ADC_r_A1_A field type1 = 0 (Min)
    // ISET: A32
    // Fields: Rd=0, imm5=0, S=0, type1=0, Rm=0, Rn=0, cond=0
    let encoding: u32 = 0x00A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_r_A1_A
/// ASL: `field type1 5 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_adc_r_a1_a_field_type1_1_poweroftwo_0_00a00020() {
    // Encoding: 0x00A00020
    // Test aarch32_ADC_r_A1_A field type1 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: type1=1, Rm=0, Rn=0, imm5=0, cond=0, S=0, Rd=0
    let encoding: u32 = 0x00A00020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_r_A1_A
/// ASL: `field type1 5 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_aarch32_adc_r_a1_a_field_type1_3_max_0_00a00060() {
    // Encoding: 0x00A00060
    // Test aarch32_ADC_r_A1_A field type1 = 3 (Max)
    // ISET: A32
    // Fields: cond=0, Rm=0, Rn=0, S=0, Rd=0, imm5=0, type1=3
    let encoding: u32 = 0x00A00060;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_r_A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_adc_r_a1_a_field_rm_0_min_0_00a00000() {
    // Encoding: 0x00A00000
    // Test aarch32_ADC_r_A1_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: cond=0, S=0, Rn=0, imm5=0, type1=0, Rd=0, Rm=0
    let encoding: u32 = 0x00A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_r_A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_adc_r_a1_a_field_rm_1_poweroftwo_0_00a00001() {
    // Encoding: 0x00A00001
    // Test aarch32_ADC_r_A1_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: type1=0, Rn=0, imm5=0, S=0, Rm=1, cond=0, Rd=0
    let encoding: u32 = 0x00A00001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_r_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_adc_r_a1_a_combo_0_0_00a00000() {
    // Encoding: 0x00A00000
    // Test aarch32_ADC_r_A1_A field combination: cond=0, S=0, Rn=0, Rd=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: Rd=0, S=0, Rn=0, cond=0, type1=0, imm5=0, Rm=0
    let encoding: u32 = 0x00A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_r_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_adc_r_a1_a_special_cond_0_condition_eq_0_00a00000() {
    // Encoding: 0x00A00000
    // Test aarch32_ADC_r_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: S=0, Rm=0, cond=0, Rn=0, type1=0, imm5=0, Rd=0
    let encoding: u32 = 0x00A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_r_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_adc_r_a1_a_special_cond_1_condition_ne_0_10a00000() {
    // Encoding: 0x10A00000
    // Test aarch32_ADC_r_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: Rm=0, cond=1, Rd=0, S=0, Rn=0, imm5=0, type1=0
    let encoding: u32 = 0x10A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_r_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_adc_r_a1_a_special_cond_2_condition_cs_hs_0_20a00000() {
    // Encoding: 0x20A00000
    // Test aarch32_ADC_r_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: Rm=0, Rd=0, S=0, cond=2, imm5=0, type1=0, Rn=0
    let encoding: u32 = 0x20A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_r_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_adc_r_a1_a_special_cond_3_condition_cc_lo_0_30a00000() {
    // Encoding: 0x30A00000
    // Test aarch32_ADC_r_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: Rn=0, cond=3, S=0, Rd=0, imm5=0, Rm=0, type1=0
    let encoding: u32 = 0x30A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_r_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_adc_r_a1_a_special_cond_4_condition_mi_0_40a00000() {
    // Encoding: 0x40A00000
    // Test aarch32_ADC_r_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: Rn=0, imm5=0, Rm=0, S=0, cond=4, Rd=0, type1=0
    let encoding: u32 = 0x40A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_r_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_adc_r_a1_a_special_cond_5_condition_pl_0_50a00000() {
    // Encoding: 0x50A00000
    // Test aarch32_ADC_r_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: type1=0, imm5=0, Rn=0, cond=5, S=0, Rm=0, Rd=0
    let encoding: u32 = 0x50A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_r_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_adc_r_a1_a_special_cond_6_condition_vs_0_60a00000() {
    // Encoding: 0x60A00000
    // Test aarch32_ADC_r_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: type1=0, Rd=0, Rm=0, cond=6, S=0, Rn=0, imm5=0
    let encoding: u32 = 0x60A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_r_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_adc_r_a1_a_special_cond_7_condition_vc_0_70a00000() {
    // Encoding: 0x70A00000
    // Test aarch32_ADC_r_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: type1=0, Rd=0, imm5=0, S=0, cond=7, Rn=0, Rm=0
    let encoding: u32 = 0x70A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_r_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_adc_r_a1_a_special_cond_8_condition_hi_0_80a00000() {
    // Encoding: 0x80A00000
    // Test aarch32_ADC_r_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: imm5=0, S=0, Rn=0, Rd=0, type1=0, Rm=0, cond=8
    let encoding: u32 = 0x80A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_r_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_adc_r_a1_a_special_cond_9_condition_ls_0_90a00000() {
    // Encoding: 0x90A00000
    // Test aarch32_ADC_r_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: imm5=0, Rm=0, Rd=0, S=0, Rn=0, type1=0, cond=9
    let encoding: u32 = 0x90A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_r_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_adc_r_a1_a_special_cond_10_condition_ge_0_a0a00000() {
    // Encoding: 0xA0A00000
    // Test aarch32_ADC_r_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: cond=10, S=0, Rn=0, Rd=0, imm5=0, type1=0, Rm=0
    let encoding: u32 = 0xA0A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_r_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_adc_r_a1_a_special_cond_11_condition_lt_0_b0a00000() {
    // Encoding: 0xB0A00000
    // Test aarch32_ADC_r_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: imm5=0, type1=0, Rm=0, Rn=0, cond=11, Rd=0, S=0
    let encoding: u32 = 0xB0A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_r_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_adc_r_a1_a_special_cond_12_condition_gt_0_c0a00000() {
    // Encoding: 0xC0A00000
    // Test aarch32_ADC_r_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: cond=12, Rd=0, imm5=0, S=0, Rn=0, type1=0, Rm=0
    let encoding: u32 = 0xC0A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_r_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_adc_r_a1_a_special_cond_13_condition_le_0_d0a00000() {
    // Encoding: 0xD0A00000
    // Test aarch32_ADC_r_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: imm5=0, Rn=0, Rm=0, S=0, type1=0, cond=13, Rd=0
    let encoding: u32 = 0xD0A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_r_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_adc_r_a1_a_special_cond_14_condition_al_0_e0a00000() {
    // Encoding: 0xE0A00000
    // Test aarch32_ADC_r_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: imm5=0, Rd=0, Rn=0, Rm=0, type1=0, cond=14, S=0
    let encoding: u32 = 0xE0A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_r_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_adc_r_a1_a_special_cond_15_condition_nv_0_f0a00000() {
    // Encoding: 0xF0A00000
    // Test aarch32_ADC_r_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: cond=15, type1=0, S=0, imm5=0, Rn=0, Rm=0, Rd=0
    let encoding: u32 = 0xF0A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_r_A1_A
/// ASL: `field S = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "S", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_adc_r_a1_a_special_s_0_size_variant_0_0_00a00000() {
    // Encoding: 0x00A00000
    // Test aarch32_ADC_r_A1_A special value S = 0 (Size variant 0)
    // ISET: A32
    // Fields: Rm=0, Rd=0, imm5=0, cond=0, Rn=0, S=0, type1=0
    let encoding: u32 = 0x00A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_r_A1_A
/// ASL: `field S = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "S", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_adc_r_a1_a_special_s_1_size_variant_1_0_00b00000() {
    // Encoding: 0x00B00000
    // Test aarch32_ADC_r_A1_A special value S = 1 (Size variant 1)
    // ISET: A32
    // Fields: cond=0, S=1, Rn=0, imm5=0, type1=0, Rm=0, Rd=0
    let encoding: u32 = 0x00B00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ADC_r_T1_A
/// ASL: `field Rm 19 +: 3`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_adc_r_t1_a_field_rm_0_min_0_41400000() {
    // Thumb encoding (32): 0x41400000
    // Test aarch32_ADC_r_T1_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: Rm=0, Rdn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x41400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADC_r_T1_A
/// ASL: `field Rm 19 +: 3`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_adc_r_t1_a_field_rm_1_poweroftwo_0_41480000() {
    // Thumb encoding (32): 0x41480000
    // Test aarch32_ADC_r_T1_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=1, Rdn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x41480000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADC_r_T1_A
/// ASL: `field Rdn 16 +: 3`
/// Requirement: FieldBoundary { field: "Rdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_adc_r_t1_a_field_rdn_0_min_0_41400000() {
    // Thumb encoding (32): 0x41400000
    // Test aarch32_ADC_r_T1_A field Rdn = 0 (Min)
    // ISET: T32
    // Fields: Rm=0, Rdn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x41400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADC_r_T1_A
/// ASL: `field Rdn 16 +: 3`
/// Requirement: FieldBoundary { field: "Rdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_adc_r_t1_a_field_rdn_1_poweroftwo_0_41410000() {
    // Thumb encoding (32): 0x41410000
    // Test aarch32_ADC_r_T1_A field Rdn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rdn=1, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x41410000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADC_r_T1_A
/// ASL: `field Rdn 16 +: 3`
/// Requirement: FieldBoundary { field: "Rdn", value: 7, boundary: Max }
/// maximum value (7)
#[test]
fn test_aarch32_adc_r_t1_a_field_rdn_7_max_0_41470000() {
    // Thumb encoding (32): 0x41470000
    // Test aarch32_ADC_r_T1_A field Rdn = 7 (Max)
    // ISET: T32
    // Fields: Rdn=7, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x41470000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADC_r_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch32_adc_r_t1_a_combo_0_0_41400000() {
    // Thumb encoding (32): 0x41400000
    // Test aarch32_ADC_r_T1_A field combination: Rm=0, Rdn=0
    // ISET: T32
    // Fields: Rdn=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x41400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADC_r_T2_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_adc_r_t2_a_field_s_0_min_0_eb400000() {
    // Thumb encoding (32): 0xEB400000
    // Test aarch32_ADC_r_T2_A field S = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rm=0, Rd=0, S=0, imm2=0, imm3=0, type1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEB400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADC_r_T2_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_adc_r_t2_a_field_s_1_max_0_eb500000() {
    // Thumb encoding (32): 0xEB500000
    // Test aarch32_ADC_r_T2_A field S = 1 (Max)
    // ISET: T32
    // Fields: Rn=0, Rd=0, imm2=0, type1=0, S=1, imm3=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEB500000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADC_r_T2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_adc_r_t2_a_field_rn_0_min_0_eb400000() {
    // Thumb encoding (32): 0xEB400000
    // Test aarch32_ADC_r_T2_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: imm2=0, Rn=0, type1=0, Rm=0, imm3=0, Rd=0, S=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEB400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADC_r_T2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_adc_r_t2_a_field_rn_1_poweroftwo_0_eb410000() {
    // Thumb encoding (32): 0xEB410000
    // Test aarch32_ADC_r_T2_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm3=0, Rd=0, imm2=0, type1=0, Rm=0, S=0, Rn=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEB410000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADC_r_T2_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_adc_r_t2_a_field_imm3_0_zero_0_eb400000() {
    // Thumb encoding (32): 0xEB400000
    // Test aarch32_ADC_r_T2_A field imm3 = 0 (Zero)
    // ISET: T32
    // Fields: imm2=0, S=0, imm3=0, type1=0, Rn=0, Rd=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEB400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADC_r_T2_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_adc_r_t2_a_field_imm3_1_poweroftwo_0_eb401000() {
    // Thumb encoding (32): 0xEB401000
    // Test aarch32_ADC_r_T2_A field imm3 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rd=0, type1=0, imm3=1, Rn=0, imm2=0, S=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEB401000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADC_r_T2_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 3, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (3)
#[test]
fn test_aarch32_adc_r_t2_a_field_imm3_3_poweroftwominusone_0_eb403000() {
    // Thumb encoding (32): 0xEB403000
    // Test aarch32_ADC_r_T2_A field imm3 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm2=0, type1=0, Rn=0, imm3=3, S=0, Rd=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEB403000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADC_r_T2_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 7, boundary: Max }
/// maximum immediate (7)
#[test]
fn test_aarch32_adc_r_t2_a_field_imm3_7_max_0_eb407000() {
    // Thumb encoding (32): 0xEB407000
    // Test aarch32_ADC_r_T2_A field imm3 = 7 (Max)
    // ISET: T32
    // Fields: imm2=0, S=0, type1=0, Rm=0, Rn=0, imm3=7, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEB407000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADC_r_T2_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_adc_r_t2_a_field_rd_0_min_0_eb400000() {
    // Thumb encoding (32): 0xEB400000
    // Test aarch32_ADC_r_T2_A field Rd = 0 (Min)
    // ISET: T32
    // Fields: Rd=0, Rm=0, Rn=0, imm2=0, type1=0, imm3=0, S=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEB400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADC_r_T2_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_adc_r_t2_a_field_rd_1_poweroftwo_0_eb400100() {
    // Thumb encoding (32): 0xEB400100
    // Test aarch32_ADC_r_T2_A field Rd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm3=0, S=0, Rm=0, Rn=0, imm2=0, type1=0, Rd=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEB400100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADC_r_T2_A
/// ASL: `field imm2 6 +: 2`
/// Requirement: FieldBoundary { field: "imm2", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_adc_r_t2_a_field_imm2_0_zero_0_eb400000() {
    // Thumb encoding (32): 0xEB400000
    // Test aarch32_ADC_r_T2_A field imm2 = 0 (Zero)
    // ISET: T32
    // Fields: Rd=0, S=0, Rm=0, Rn=0, imm2=0, imm3=0, type1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEB400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADC_r_T2_A
/// ASL: `field imm2 6 +: 2`
/// Requirement: FieldBoundary { field: "imm2", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_adc_r_t2_a_field_imm2_1_poweroftwo_0_eb400040() {
    // Thumb encoding (32): 0xEB400040
    // Test aarch32_ADC_r_T2_A field imm2 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: S=0, Rm=0, imm3=0, Rd=0, imm2=1, type1=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEB400040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADC_r_T2_A
/// ASL: `field imm2 6 +: 2`
/// Requirement: FieldBoundary { field: "imm2", value: 3, boundary: Max }
/// maximum immediate (3)
#[test]
fn test_aarch32_adc_r_t2_a_field_imm2_3_max_0_eb4000c0() {
    // Thumb encoding (32): 0xEB4000C0
    // Test aarch32_ADC_r_T2_A field imm2 = 3 (Max)
    // ISET: T32
    // Fields: Rn=0, S=0, imm2=3, type1=0, imm3=0, Rd=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEB4000C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADC_r_T2_A
/// ASL: `field type1 4 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_adc_r_t2_a_field_type1_0_min_0_eb400000() {
    // Thumb encoding (32): 0xEB400000
    // Test aarch32_ADC_r_T2_A field type1 = 0 (Min)
    // ISET: T32
    // Fields: S=0, Rn=0, imm2=0, Rd=0, type1=0, imm3=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEB400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADC_r_T2_A
/// ASL: `field type1 4 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_adc_r_t2_a_field_type1_1_poweroftwo_0_eb400010() {
    // Thumb encoding (32): 0xEB400010
    // Test aarch32_ADC_r_T2_A field type1 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: type1=1, Rn=0, imm3=0, Rd=0, imm2=0, Rm=0, S=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEB400010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADC_r_T2_A
/// ASL: `field type1 4 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_aarch32_adc_r_t2_a_field_type1_3_max_0_eb400030() {
    // Thumb encoding (32): 0xEB400030
    // Test aarch32_ADC_r_T2_A field type1 = 3 (Max)
    // ISET: T32
    // Fields: Rn=0, type1=3, imm2=0, Rd=0, Rm=0, imm3=0, S=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEB400030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADC_r_T2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_adc_r_t2_a_field_rm_0_min_0_eb400000() {
    // Thumb encoding (32): 0xEB400000
    // Test aarch32_ADC_r_T2_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rd=0, S=0, type1=0, Rm=0, imm2=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEB400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADC_r_T2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_adc_r_t2_a_field_rm_1_poweroftwo_0_eb400001() {
    // Thumb encoding (32): 0xEB400001
    // Test aarch32_ADC_r_T2_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: S=0, Rm=1, imm3=0, imm2=0, Rd=0, Rn=0, type1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEB400001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADC_r_T2_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// S=0 (8-bit / byte size)
#[test]
fn test_aarch32_adc_r_t2_a_combo_0_0_eb400000() {
    // Thumb encoding (32): 0xEB400000
    // Test aarch32_ADC_r_T2_A field combination: S=0, Rn=0, imm3=0, Rd=0, imm2=0, type1=0, Rm=0
    // ISET: T32
    // Fields: Rn=0, Rd=0, type1=0, Rm=0, imm2=0, imm3=0, S=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEB400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADC_r_T2_A
/// ASL: `field S = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "S", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_adc_r_t2_a_special_s_0_size_variant_0_0_eb400000() {
    // Thumb encoding (32): 0xEB400000
    // Test aarch32_ADC_r_T2_A special value S = 0 (Size variant 0)
    // ISET: T32
    // Fields: Rn=0, imm2=0, type1=0, Rm=0, S=0, imm3=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEB400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADC_r_T2_A
/// ASL: `field S = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "S", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_adc_r_t2_a_special_s_1_size_variant_1_0_eb500000() {
    // Thumb encoding (32): 0xEB500000
    // Test aarch32_ADC_r_T2_A special value S = 1 (Size variant 1)
    // ISET: T32
    // Fields: Rd=0, type1=0, S=1, imm2=0, Rn=0, imm3=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEB500000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ADC_r_T2_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_adc_r_t2_a_invalid_0_0_eb400000() {
    // Thumb encoding (32): 0xEB400000
    // Test aarch32_ADC_r_T2_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }
    // ISET: T32
    // Fields: Rn=0, imm3=0, Rd=0, type1=0, Rm=0, S=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEB400000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_ADC_r_T2_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_adc_r_t2_a_invalid_1_0_eb400000() {
    // Thumb encoding (32): 0xEB400000
    // Test aarch32_ADC_r_T2_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: S=0, Rd=0, imm2=0, Rn=0, Rm=0, type1=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEB400000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_ADC_r_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_aarch32_adc_r_a1_a_flags_zeroresult_0_00b10002() {
    // Test aarch32_ADC_r_A1_A flag computation: ZeroResult
    // Encoding: 0x00B10002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x00B10002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADC_r_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_aarch32_adc_r_a1_a_flags_zeroresult_1_00b10002() {
    // Test aarch32_ADC_r_A1_A flag computation: ZeroResult
    // Encoding: 0x00B10002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x00B10002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADC_r_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_aarch32_adc_r_a1_a_flags_negativeresult_2_00b10002() {
    // Test aarch32_ADC_r_A1_A flag computation: NegativeResult
    // Encoding: 0x00B10002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x00B10002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADC_r_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_aarch32_adc_r_a1_a_flags_unsignedoverflow_3_00b10002() {
    // Test aarch32_ADC_r_A1_A flag computation: UnsignedOverflow
    // Encoding: 0x00B10002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x00B10002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADC_r_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_aarch32_adc_r_a1_a_flags_unsignedoverflow_4_00b10002() {
    // Test aarch32_ADC_r_A1_A flag computation: UnsignedOverflow
    // Encoding: 0x00B10002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x00B10002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADC_r_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_aarch32_adc_r_a1_a_flags_signedoverflow_5_00b10002() {
    // Test aarch32_ADC_r_A1_A flag computation: SignedOverflow
    // Encoding: 0x00B10002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x00B10002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_ADC_r_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_aarch32_adc_r_a1_a_flags_signedoverflow_6_00b10002() {
    // Test aarch32_ADC_r_A1_A flag computation: SignedOverflow
    // Encoding: 0x00B10002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x00B10002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_ADC_r_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_aarch32_adc_r_a1_a_flags_positiveresult_7_00b10002() {
    // Test aarch32_ADC_r_A1_A flag computation: PositiveResult
    // Encoding: 0x00B10002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x32);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x00B10002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADC_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 0 (32)
#[test]
fn test_aarch32_adc_r_t1_a_lslv_oracle_32_0_41420020() {
    // Test LSLV 32-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x12345678, "W0 should be 0x12345678");
}

/// Provenance: aarch32_ADC_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 0 (64)
#[test]
fn test_aarch32_adc_r_t1_a_lslv_oracle_64_0_c1420020() {
    // Test LSLV 64-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x12345678,
        "X0 should be 0x0000000012345678"
    );
}

/// Provenance: aarch32_ADC_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4 (32)
#[test]
fn test_aarch32_adc_r_t1_a_lslv_oracle_32_1_41420020() {
    // Test LSLV 32-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x4);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x23456780, "W0 should be 0x23456780");
}

/// Provenance: aarch32_ADC_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 4 (64)
#[test]
fn test_aarch32_adc_r_t1_a_lslv_oracle_64_1_c1420020() {
    // Test LSLV 64-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x4);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x23456780,
        "X0 should be 0x0000000123456780"
    );
}

/// Provenance: aarch32_ADC_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 8 (32)
#[test]
fn test_aarch32_adc_r_t1_a_lslv_oracle_32_2_41420020() {
    // Test LSLV 32-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x8);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x34567800, "W0 should be 0x34567800");
}

/// Provenance: aarch32_ADC_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 8 (64)
#[test]
fn test_aarch32_adc_r_t1_a_lslv_oracle_64_2_c1420020() {
    // Test LSLV 64-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x8);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x34567800,
        "X0 should be 0x0000001234567800"
    );
}

/// Provenance: aarch32_ADC_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1 (32)
#[test]
fn test_aarch32_adc_r_t1_a_lslv_oracle_32_3_41420020() {
    // Test LSLV 32-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_ADC_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// MSB set, shift 1 (64)
#[test]
fn test_aarch32_adc_r_t1_a_lslv_oracle_64_3_c1420020() {
    // Test LSLV 64-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_ADC_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// LSB set, max shift (32)
#[test]
fn test_aarch32_adc_r_t1_a_lslv_oracle_32_4_41420020() {
    // Test LSLV 32-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x3F);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "W0 should be 0x80000000");
}

/// Provenance: aarch32_ADC_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// LSB set, max shift (64)
#[test]
fn test_aarch32_adc_r_t1_a_lslv_oracle_64_4_c1420020() {
    // Test LSLV 64-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x3F);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x8000000000000000");
}

/// Provenance: aarch32_ADC_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// all ones, shift 32 (32)
#[test]
fn test_aarch32_adc_r_t1_a_lslv_oracle_32_5_41420020() {
    // Test LSLV 32-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x20);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "W0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_ADC_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// all ones, shift 32 (64)
#[test]
fn test_aarch32_adc_r_t1_a_lslv_oracle_64_5_c1420020() {
    // Test LSLV 64-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x20);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0xFFFFFFFF00000000");
}

/// Provenance: aarch32_ADC_r_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// no shift
#[test]
fn test_aarch32_adc_r_t1_a_t16_oracle_0_41500000() {
    // Test T16 LSLS: no shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_ADC_r_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4
#[test]
fn test_aarch32_adc_r_t1_a_t16_oracle_1_41500000() {
    // Test T16 LSLS: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    set_w(&mut cpu, 2, 0x4);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF0, "R0 should be 0x00000FF0");
}

/// Provenance: aarch32_ADC_r_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1
#[test]
fn test_aarch32_adc_r_t1_a_t16_oracle_2_41500000() {
    // Test T16 LSLS: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_ADC_r_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift to MSB
#[test]
fn test_aarch32_adc_r_t1_a_t16_oracle_3_41500000() {
    // Test T16 LSLS: shift to MSB (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x1F);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "R0 should be 0x80000000");
}

/// Provenance: aarch32_ADC_r_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_aarch32_adc_r_t1_a_flags_zeroresult_0_41500000() {
    // Test aarch32_ADC_r_T1_A flag computation: ZeroResult
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADC_r_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_aarch32_adc_r_t1_a_flags_zeroresult_1_41500000() {
    // Test aarch32_ADC_r_T1_A flag computation: ZeroResult
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADC_r_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_aarch32_adc_r_t1_a_flags_negativeresult_2_41500000() {
    // Test aarch32_ADC_r_T1_A flag computation: NegativeResult
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADC_r_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_aarch32_adc_r_t1_a_flags_unsignedoverflow_3_41500000() {
    // Test aarch32_ADC_r_T1_A flag computation: UnsignedOverflow
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADC_r_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_aarch32_adc_r_t1_a_flags_unsignedoverflow_4_41500000() {
    // Test aarch32_ADC_r_T1_A flag computation: UnsignedOverflow
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADC_r_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_aarch32_adc_r_t1_a_flags_signedoverflow_5_41500000() {
    // Test aarch32_ADC_r_T1_A flag computation: SignedOverflow
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_ADC_r_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_aarch32_adc_r_t1_a_flags_signedoverflow_6_41500000() {
    // Test aarch32_ADC_r_T1_A flag computation: SignedOverflow
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_ADC_r_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_aarch32_adc_r_t1_a_flags_positiveresult_7_41500000() {
    // Test aarch32_ADC_r_T1_A flag computation: PositiveResult
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x32);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADC_r_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_aarch32_adc_r_t2_a_flags_zeroresult_0_eb510002() {
    // Test aarch32_ADC_r_T2_A flag computation: ZeroResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xEB510002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADC_r_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_aarch32_adc_r_t2_a_flags_zeroresult_1_eb510002() {
    // Test aarch32_ADC_r_T2_A flag computation: ZeroResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xEB510002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADC_r_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_aarch32_adc_r_t2_a_flags_negativeresult_2_eb510002() {
    // Test aarch32_ADC_r_T2_A flag computation: NegativeResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xEB510002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADC_r_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_aarch32_adc_r_t2_a_flags_unsignedoverflow_3_eb510002() {
    // Test aarch32_ADC_r_T2_A flag computation: UnsignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0xEB510002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADC_r_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_aarch32_adc_r_t2_a_flags_unsignedoverflow_4_eb510002() {
    // Test aarch32_ADC_r_T2_A flag computation: UnsignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0xEB510002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_ADC_r_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_aarch32_adc_r_t2_a_flags_signedoverflow_5_eb510002() {
    // Test aarch32_ADC_r_T2_A flag computation: SignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0xEB510002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_ADC_r_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_aarch32_adc_r_t2_a_flags_signedoverflow_6_eb510002() {
    // Test aarch32_ADC_r_T2_A flag computation: SignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0xEB510002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_ADC_r_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_aarch32_adc_r_t2_a_flags_positiveresult_7_eb510002() {
    // Test aarch32_ADC_r_T2_A flag computation: PositiveResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x32);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xEB510002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

// ============================================================================
// aarch32_SUB_rr_A Tests
// ============================================================================

/// Provenance: aarch32_SUB_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_sub_rr_a1_a_field_cond_0_min_10_00400010() {
    // Encoding: 0x00400010
    // Test aarch32_SUB_rr_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: Rs=0, S=0, Rd=0, Rn=0, type1=0, Rm=0, cond=0
    let encoding: u32 = 0x00400010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_sub_rr_a1_a_field_cond_1_poweroftwo_10_10400010() {
    // Encoding: 0x10400010
    // Test aarch32_SUB_rr_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: type1=0, S=0, Rn=0, cond=1, Rd=0, Rs=0, Rm=0
    let encoding: u32 = 0x10400010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_sub_rr_a1_a_field_cond_2_poweroftwo_10_20400010() {
    // Encoding: 0x20400010
    // Test aarch32_SUB_rr_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, cond=2, S=0, Rs=0, type1=0, Rn=0, Rm=0
    let encoding: u32 = 0x20400010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_sub_rr_a1_a_field_cond_3_poweroftwo_10_30400010() {
    // Encoding: 0x30400010
    // Test aarch32_SUB_rr_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=3, Rd=0, type1=0, Rs=0, Rm=0, S=0
    let encoding: u32 = 0x30400010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_sub_rr_a1_a_field_cond_4_poweroftwo_10_40400010() {
    // Encoding: 0x40400010
    // Test aarch32_SUB_rr_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rd=0, S=0, Rm=0, Rs=0, type1=0, cond=4
    let encoding: u32 = 0x40400010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_sub_rr_a1_a_field_cond_5_poweroftwo_10_50400010() {
    // Encoding: 0x50400010
    // Test aarch32_SUB_rr_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: Rs=0, cond=5, S=0, Rm=0, Rn=0, type1=0, Rd=0
    let encoding: u32 = 0x50400010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_sub_rr_a1_a_field_cond_6_poweroftwo_10_60400010() {
    // Encoding: 0x60400010
    // Test aarch32_SUB_rr_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: Rs=0, S=0, Rn=0, Rd=0, Rm=0, type1=0, cond=6
    let encoding: u32 = 0x60400010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_sub_rr_a1_a_field_cond_7_poweroftwo_10_70400010() {
    // Encoding: 0x70400010
    // Test aarch32_SUB_rr_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rs=0, type1=0, Rm=0, cond=7, Rn=0, S=0
    let encoding: u32 = 0x70400010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_sub_rr_a1_a_field_cond_8_poweroftwo_10_80400010() {
    // Encoding: 0x80400010
    // Test aarch32_SUB_rr_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, cond=8, Rn=0, S=0, type1=0, Rm=0, Rs=0
    let encoding: u32 = 0x80400010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_sub_rr_a1_a_field_cond_9_poweroftwo_10_90400010() {
    // Encoding: 0x90400010
    // Test aarch32_SUB_rr_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: Rs=0, Rd=0, S=0, type1=0, cond=9, Rm=0, Rn=0
    let encoding: u32 = 0x90400010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_sub_rr_a1_a_field_cond_10_poweroftwo_10_a0400010() {
    // Encoding: 0xA0400010
    // Test aarch32_SUB_rr_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rm=0, Rn=0, cond=10, S=0, type1=0, Rs=0
    let encoding: u32 = 0xA0400010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_sub_rr_a1_a_field_cond_11_poweroftwo_10_b0400010() {
    // Encoding: 0xB0400010
    // Test aarch32_SUB_rr_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, Rs=0, Rm=0, Rd=0, cond=11, type1=0, Rn=0
    let encoding: u32 = 0xB0400010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_sub_rr_a1_a_field_cond_12_poweroftwo_10_c0400010() {
    // Encoding: 0xC0400010
    // Test aarch32_SUB_rr_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=12, Rm=0, Rn=0, type1=0, Rs=0, Rd=0, S=0
    let encoding: u32 = 0xC0400010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_sub_rr_a1_a_field_cond_13_poweroftwo_10_d0400010() {
    // Encoding: 0xD0400010
    // Test aarch32_SUB_rr_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=13, type1=0, Rm=0, S=0, Rd=0, Rs=0, Rn=0
    let encoding: u32 = 0xD0400010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_sub_rr_a1_a_field_cond_14_poweroftwo_10_e0400010() {
    // Encoding: 0xE0400010
    // Test aarch32_SUB_rr_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Rn=0, cond=14, Rd=0, Rs=0, type1=0, S=0
    let encoding: u32 = 0xE0400010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_sub_rr_a1_a_field_cond_15_max_10_f0400010() {
    // Encoding: 0xF0400010
    // Test aarch32_SUB_rr_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: Rd=0, type1=0, S=0, Rn=0, cond=15, Rs=0, Rm=0
    let encoding: u32 = 0xF0400010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_rr_A1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_sub_rr_a1_a_field_s_0_min_10_00400010() {
    // Encoding: 0x00400010
    // Test aarch32_SUB_rr_A1_A field S = 0 (Min)
    // ISET: A32
    // Fields: Rd=0, type1=0, Rm=0, Rn=0, S=0, Rs=0, cond=0
    let encoding: u32 = 0x00400010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_rr_A1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_sub_rr_a1_a_field_s_1_max_10_00500010() {
    // Encoding: 0x00500010
    // Test aarch32_SUB_rr_A1_A field S = 1 (Max)
    // ISET: A32
    // Fields: Rn=0, Rd=0, Rs=0, type1=0, Rm=0, cond=0, S=1
    let encoding: u32 = 0x00500010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_rr_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_sub_rr_a1_a_field_rn_0_min_10_00400010() {
    // Encoding: 0x00400010
    // Test aarch32_SUB_rr_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, Rn=0, type1=0, cond=0, S=0, Rd=0, Rs=0
    let encoding: u32 = 0x00400010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_rr_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_sub_rr_a1_a_field_rn_1_poweroftwo_10_00410010() {
    // Encoding: 0x00410010
    // Test aarch32_SUB_rr_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, S=0, Rd=0, type1=0, cond=0, Rn=1, Rs=0
    let encoding: u32 = 0x00410010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_rr_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_sub_rr_a1_a_field_rd_0_min_10_00400010() {
    // Encoding: 0x00400010
    // Test aarch32_SUB_rr_A1_A field Rd = 0 (Min)
    // ISET: A32
    // Fields: Rd=0, cond=0, type1=0, Rm=0, S=0, Rn=0, Rs=0
    let encoding: u32 = 0x00400010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_rr_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_sub_rr_a1_a_field_rd_1_poweroftwo_10_00401010() {
    // Encoding: 0x00401010
    // Test aarch32_SUB_rr_A1_A field Rd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: type1=0, cond=0, S=0, Rs=0, Rm=0, Rn=0, Rd=1
    let encoding: u32 = 0x00401010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_rr_A1_A
/// ASL: `field Rs 8 +: 4`
/// Requirement: FieldBoundary { field: "Rs", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_sub_rr_a1_a_field_rs_0_min_10_00400010() {
    // Encoding: 0x00400010
    // Test aarch32_SUB_rr_A1_A field Rs = 0 (Min)
    // ISET: A32
    // Fields: cond=0, type1=0, S=0, Rd=0, Rs=0, Rn=0, Rm=0
    let encoding: u32 = 0x00400010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_rr_A1_A
/// ASL: `field Rs 8 +: 4`
/// Requirement: FieldBoundary { field: "Rs", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_sub_rr_a1_a_field_rs_1_poweroftwo_10_00400110() {
    // Encoding: 0x00400110
    // Test aarch32_SUB_rr_A1_A field Rs = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rs=1, Rm=0, Rd=0, S=0, type1=0, Rn=0, cond=0
    let encoding: u32 = 0x00400110;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_rr_A1_A
/// ASL: `field type1 5 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_sub_rr_a1_a_field_type1_0_min_10_00400010() {
    // Encoding: 0x00400010
    // Test aarch32_SUB_rr_A1_A field type1 = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rn=0, Rs=0, Rd=0, type1=0, S=0, Rm=0
    let encoding: u32 = 0x00400010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_rr_A1_A
/// ASL: `field type1 5 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_sub_rr_a1_a_field_type1_1_poweroftwo_10_00400030() {
    // Encoding: 0x00400030
    // Test aarch32_SUB_rr_A1_A field type1 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rs=0, type1=1, Rm=0, cond=0, S=0, Rn=0, Rd=0
    let encoding: u32 = 0x00400030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_rr_A1_A
/// ASL: `field type1 5 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_aarch32_sub_rr_a1_a_field_type1_3_max_10_00400070() {
    // Encoding: 0x00400070
    // Test aarch32_SUB_rr_A1_A field type1 = 3 (Max)
    // ISET: A32
    // Fields: type1=3, Rm=0, Rs=0, Rn=0, cond=0, S=0, Rd=0
    let encoding: u32 = 0x00400070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_rr_A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_sub_rr_a1_a_field_rm_0_min_10_00400010() {
    // Encoding: 0x00400010
    // Test aarch32_SUB_rr_A1_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, Rd=0, Rm=0, Rs=0, S=0, cond=0, type1=0
    let encoding: u32 = 0x00400010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_rr_A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_sub_rr_a1_a_field_rm_1_poweroftwo_10_00400011() {
    // Encoding: 0x00400011
    // Test aarch32_SUB_rr_A1_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=0, Rd=0, type1=0, Rm=1, Rs=0, S=0
    let encoding: u32 = 0x00400011;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_rr_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_sub_rr_a1_a_combo_0_10_00400010() {
    // Encoding: 0x00400010
    // Test aarch32_SUB_rr_A1_A field combination: cond=0, S=0, Rn=0, Rd=0, Rs=0, type1=0, Rm=0
    // ISET: A32
    // Fields: Rm=0, Rs=0, Rd=0, type1=0, cond=0, S=0, Rn=0
    let encoding: u32 = 0x00400010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_rr_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_sub_rr_a1_a_special_cond_0_condition_eq_16_00400010() {
    // Encoding: 0x00400010
    // Test aarch32_SUB_rr_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: cond=0, Rn=0, Rd=0, Rs=0, S=0, Rm=0, type1=0
    let encoding: u32 = 0x00400010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_rr_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_sub_rr_a1_a_special_cond_1_condition_ne_16_10400010() {
    // Encoding: 0x10400010
    // Test aarch32_SUB_rr_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: type1=0, Rd=0, Rm=0, Rn=0, Rs=0, cond=1, S=0
    let encoding: u32 = 0x10400010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_rr_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_sub_rr_a1_a_special_cond_2_condition_cs_hs_16_20400010() {
    // Encoding: 0x20400010
    // Test aarch32_SUB_rr_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: Rn=0, Rd=0, S=0, Rs=0, cond=2, type1=0, Rm=0
    let encoding: u32 = 0x20400010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_rr_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_sub_rr_a1_a_special_cond_3_condition_cc_lo_16_30400010() {
    // Encoding: 0x30400010
    // Test aarch32_SUB_rr_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: S=0, Rn=0, Rd=0, cond=3, Rs=0, type1=0, Rm=0
    let encoding: u32 = 0x30400010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_rr_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_sub_rr_a1_a_special_cond_4_condition_mi_16_40400010() {
    // Encoding: 0x40400010
    // Test aarch32_SUB_rr_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: Rm=0, cond=4, Rd=0, type1=0, Rs=0, Rn=0, S=0
    let encoding: u32 = 0x40400010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_rr_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_sub_rr_a1_a_special_cond_5_condition_pl_16_50400010() {
    // Encoding: 0x50400010
    // Test aarch32_SUB_rr_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: cond=5, Rm=0, Rs=0, Rd=0, Rn=0, type1=0, S=0
    let encoding: u32 = 0x50400010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_rr_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_sub_rr_a1_a_special_cond_6_condition_vs_16_60400010() {
    // Encoding: 0x60400010
    // Test aarch32_SUB_rr_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: S=0, type1=0, cond=6, Rn=0, Rm=0, Rd=0, Rs=0
    let encoding: u32 = 0x60400010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_rr_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_sub_rr_a1_a_special_cond_7_condition_vc_16_70400010() {
    // Encoding: 0x70400010
    // Test aarch32_SUB_rr_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: Rm=0, Rs=0, type1=0, cond=7, S=0, Rn=0, Rd=0
    let encoding: u32 = 0x70400010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_rr_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_sub_rr_a1_a_special_cond_8_condition_hi_16_80400010() {
    // Encoding: 0x80400010
    // Test aarch32_SUB_rr_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: Rm=0, cond=8, Rd=0, S=0, Rn=0, Rs=0, type1=0
    let encoding: u32 = 0x80400010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_rr_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_sub_rr_a1_a_special_cond_9_condition_ls_16_90400010() {
    // Encoding: 0x90400010
    // Test aarch32_SUB_rr_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: type1=0, Rd=0, Rm=0, S=0, cond=9, Rn=0, Rs=0
    let encoding: u32 = 0x90400010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_rr_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_sub_rr_a1_a_special_cond_10_condition_ge_16_a0400010() {
    // Encoding: 0xA0400010
    // Test aarch32_SUB_rr_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: Rd=0, Rm=0, Rs=0, type1=0, Rn=0, cond=10, S=0
    let encoding: u32 = 0xA0400010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_rr_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_sub_rr_a1_a_special_cond_11_condition_lt_16_b0400010() {
    // Encoding: 0xB0400010
    // Test aarch32_SUB_rr_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: Rm=0, cond=11, Rd=0, S=0, Rn=0, Rs=0, type1=0
    let encoding: u32 = 0xB0400010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_rr_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_sub_rr_a1_a_special_cond_12_condition_gt_16_c0400010() {
    // Encoding: 0xC0400010
    // Test aarch32_SUB_rr_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: cond=12, Rm=0, Rd=0, type1=0, Rs=0, Rn=0, S=0
    let encoding: u32 = 0xC0400010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_rr_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_sub_rr_a1_a_special_cond_13_condition_le_16_d0400010() {
    // Encoding: 0xD0400010
    // Test aarch32_SUB_rr_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: Rs=0, type1=0, Rm=0, Rd=0, S=0, cond=13, Rn=0
    let encoding: u32 = 0xD0400010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_rr_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_sub_rr_a1_a_special_cond_14_condition_al_16_e0400010() {
    // Encoding: 0xE0400010
    // Test aarch32_SUB_rr_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: cond=14, Rd=0, Rm=0, S=0, type1=0, Rs=0, Rn=0
    let encoding: u32 = 0xE0400010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_rr_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_sub_rr_a1_a_special_cond_15_condition_nv_16_f0400010() {
    // Encoding: 0xF0400010
    // Test aarch32_SUB_rr_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: cond=15, Rd=0, Rn=0, S=0, Rs=0, type1=0, Rm=0
    let encoding: u32 = 0xF0400010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_rr_A1_A
/// ASL: `field S = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "S", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_sub_rr_a1_a_special_s_0_size_variant_0_16_00400010() {
    // Encoding: 0x00400010
    // Test aarch32_SUB_rr_A1_A special value S = 0 (Size variant 0)
    // ISET: A32
    // Fields: Rn=0, cond=0, Rd=0, type1=0, Rm=0, Rs=0, S=0
    let encoding: u32 = 0x00400010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_rr_A1_A
/// ASL: `field S = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "S", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_sub_rr_a1_a_special_s_1_size_variant_1_16_00500010() {
    // Encoding: 0x00500010
    // Test aarch32_SUB_rr_A1_A special value S = 1 (Size variant 1)
    // ISET: A32
    // Fields: Rm=0, S=1, Rn=0, Rd=0, cond=0, type1=0, Rs=0
    let encoding: u32 = 0x00500010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SUB_rr_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "s" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"s\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_sub_rr_a1_a_invalid_0_10_00400010() {
    // Encoding: 0x00400010
    // Test aarch32_SUB_rr_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "s" }) } }, rhs: LitInt(15) }
    // ISET: A32
    // Fields: S=0, Rs=0, Rm=0, Rd=0, cond=0, Rn=0, type1=0
    let encoding: u32 = 0x00400010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_SUB_rr_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_sub_rr_a1_a_invalid_1_10_00400010() {
    // Encoding: 0x00400010
    // Test aarch32_SUB_rr_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: type1=0, Rs=0, Rn=0, Rm=0, cond=0, S=0, Rd=0
    let encoding: u32 = 0x00400010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_SUB_rr_A1_A
/// ASL: `ADD X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// no shift (32)
#[test]
fn test_aarch32_sub_rr_a1_a_add_shifted_oracle_32_0_00420030() {
    // Test ADD shifted 32-bit: no shift (oracle)
    // Encoding: 0x00420030
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xA);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x00420030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6E, "W0 should be 0x0000006E");
}

/// Provenance: aarch32_SUB_rr_A1_A
/// ASL: `ADD X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// no shift (64)
#[test]
fn test_aarch32_sub_rr_a1_a_add_shifted_oracle_64_0_80420030() {
    // Test ADD shifted 64-bit: no shift (oracle)
    // Encoding: 0x80420030
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xA);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x80420030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6E, "X0 should be 0x000000000000006E");
}

/// Provenance: aarch32_SUB_rr_A1_A
/// ASL: `ADD X0, X1, X2, shift #3`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// LSL #3 (multiply by 8) (32)
#[test]
fn test_aarch32_sub_rr_a1_a_add_shifted_oracle_32_1_00420c30() {
    // Test ADD shifted 32-bit: LSL #3 (multiply by 8) (oracle)
    // Encoding: 0x00420C30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x00420C30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6C, "W0 should be 0x0000006C");
}

/// Provenance: aarch32_SUB_rr_A1_A
/// ASL: `ADD X0, X1, X2, shift #3`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// LSL #3 (multiply by 8) (64)
#[test]
fn test_aarch32_sub_rr_a1_a_add_shifted_oracle_64_1_80420c30() {
    // Test ADD shifted 64-bit: LSL #3 (multiply by 8) (oracle)
    // Encoding: 0x80420C30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x80420C30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6C, "X0 should be 0x000000000000006C");
}

/// Provenance: aarch32_SUB_rr_A1_A
/// ASL: `ADD X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// overflow test (32)
#[test]
fn test_aarch32_sub_rr_a1_a_add_shifted_oracle_32_2_00420030() {
    // Test ADD shifted 32-bit: overflow test (oracle)
    // Encoding: 0x00420030
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x00420030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_SUB_rr_A1_A
/// ASL: `ADD X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// overflow test (64)
#[test]
fn test_aarch32_sub_rr_a1_a_add_shifted_oracle_64_2_80420030() {
    // Test ADD shifted 64-bit: overflow test (oracle)
    // Encoding: 0x80420030
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x80420030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_SUB_rr_A1_A
/// ASL: `ADD X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// subtract from zero (32)
#[test]
fn test_aarch32_sub_rr_a1_a_add_shifted_oracle_32_3_00420030() {
    // Test ADD shifted 32-bit: subtract from zero (oracle)
    // Encoding: 0x00420030
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x00420030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "W0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_SUB_rr_A1_A
/// ASL: `ADD X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// subtract from zero (64)
#[test]
fn test_aarch32_sub_rr_a1_a_add_shifted_oracle_64_3_80420030() {
    // Test ADD shifted 64-bit: subtract from zero (oracle)
    // Encoding: 0x80420030
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x80420030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
}

/// Provenance: aarch32_SUB_rr_A1_A
/// ASL: `ADDS X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// no shift (32)
#[test]
fn test_aarch32_sub_rr_a1_a_adds_shifted_oracle_32_0_20420030() {
    // Test ADDS shifted 32-bit: no shift (oracle)
    // Encoding: 0x20420030
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0xA);
    let encoding: u32 = 0x20420030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6E, "W0 should be 0x0000006E");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_rr_A1_A
/// ASL: `ADDS X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// no shift (64)
#[test]
fn test_aarch32_sub_rr_a1_a_adds_shifted_oracle_64_0_a0420030() {
    // Test ADDS shifted 64-bit: no shift (oracle)
    // Encoding: 0xA0420030
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0xA);
    let encoding: u32 = 0xA0420030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6E, "X0 should be 0x000000000000006E");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_rr_A1_A
/// ASL: `ADDS X0, X1, X2, shift #3`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// LSL #3 (multiply by 8) (32)
#[test]
fn test_aarch32_sub_rr_a1_a_adds_shifted_oracle_32_1_20420c30() {
    // Test ADDS shifted 32-bit: LSL #3 (multiply by 8) (oracle)
    // Encoding: 0x20420C30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x20420C30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6C, "W0 should be 0x0000006C");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_rr_A1_A
/// ASL: `ADDS X0, X1, X2, shift #3`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// LSL #3 (multiply by 8) (64)
#[test]
fn test_aarch32_sub_rr_a1_a_adds_shifted_oracle_64_1_a0420c30() {
    // Test ADDS shifted 64-bit: LSL #3 (multiply by 8) (oracle)
    // Encoding: 0xA0420C30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0xA0420C30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6C, "X0 should be 0x000000000000006C");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_rr_A1_A
/// ASL: `ADDS X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// overflow test (32)
#[test]
fn test_aarch32_sub_rr_a1_a_adds_shifted_oracle_32_2_20420030() {
    // Test ADDS shifted 32-bit: overflow test (oracle)
    // Encoding: 0x20420030
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x20420030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_rr_A1_A
/// ASL: `ADDS X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// overflow test (64)
#[test]
fn test_aarch32_sub_rr_a1_a_adds_shifted_oracle_64_2_a0420030() {
    // Test ADDS shifted 64-bit: overflow test (oracle)
    // Encoding: 0xA0420030
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xA0420030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, true, "V flag should be true");
}

/// Provenance: aarch32_SUB_rr_A1_A
/// ASL: `ADDS X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// subtract from zero (32)
#[test]
fn test_aarch32_sub_rr_a1_a_adds_shifted_oracle_32_3_20420030() {
    // Test ADDS shifted 32-bit: subtract from zero (oracle)
    // Encoding: 0x20420030
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x20420030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "W0 should be 0xFFFFFFFF");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_rr_A1_A
/// ASL: `ADDS X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// subtract from zero (64)
#[test]
fn test_aarch32_sub_rr_a1_a_adds_shifted_oracle_64_3_a0420030() {
    // Test ADDS shifted 64-bit: subtract from zero (oracle)
    // Encoding: 0xA0420030
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xA0420030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_rr_A1_A
/// ASL: `SUB X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// no shift (32)
#[test]
fn test_aarch32_sub_rr_a1_a_sub_shifted_oracle_32_0_40420030() {
    // Test SUB shifted 32-bit: no shift (oracle)
    // Encoding: 0x40420030
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0xA);
    let encoding: u32 = 0x40420030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x5A, "W0 should be 0x0000005A");
}

/// Provenance: aarch32_SUB_rr_A1_A
/// ASL: `SUB X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// no shift (64)
#[test]
fn test_aarch32_sub_rr_a1_a_sub_shifted_oracle_64_0_c0420030() {
    // Test SUB shifted 64-bit: no shift (oracle)
    // Encoding: 0xC0420030
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xA);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xC0420030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x5A, "X0 should be 0x000000000000005A");
}

/// Provenance: aarch32_SUB_rr_A1_A
/// ASL: `SUB X0, X1, X2, shift #3`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// LSL #3 (multiply by 8) (32)
#[test]
fn test_aarch32_sub_rr_a1_a_sub_shifted_oracle_32_1_40420c30() {
    // Test SUB shifted 32-bit: LSL #3 (multiply by 8) (oracle)
    // Encoding: 0x40420C30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x40420C30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x5C, "W0 should be 0x0000005C");
}

/// Provenance: aarch32_SUB_rr_A1_A
/// ASL: `SUB X0, X1, X2, shift #3`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// LSL #3 (multiply by 8) (64)
#[test]
fn test_aarch32_sub_rr_a1_a_sub_shifted_oracle_64_1_c0420c30() {
    // Test SUB shifted 64-bit: LSL #3 (multiply by 8) (oracle)
    // Encoding: 0xC0420C30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0xC0420C30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x5C, "X0 should be 0x000000000000005C");
}

/// Provenance: aarch32_SUB_rr_A1_A
/// ASL: `SUB X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// overflow test (32)
#[test]
fn test_aarch32_sub_rr_a1_a_sub_shifted_oracle_32_2_40420030() {
    // Test SUB shifted 32-bit: overflow test (oracle)
    // Encoding: 0x40420030
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x40420030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_SUB_rr_A1_A
/// ASL: `SUB X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// overflow test (64)
#[test]
fn test_aarch32_sub_rr_a1_a_sub_shifted_oracle_64_2_c0420030() {
    // Test SUB shifted 64-bit: overflow test (oracle)
    // Encoding: 0xC0420030
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xC0420030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_SUB_rr_A1_A
/// ASL: `SUB X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// subtract from zero (32)
#[test]
fn test_aarch32_sub_rr_a1_a_sub_shifted_oracle_32_3_40420030() {
    // Test SUB shifted 32-bit: subtract from zero (oracle)
    // Encoding: 0x40420030
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x40420030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_SUB_rr_A1_A
/// ASL: `SUB X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// subtract from zero (64)
#[test]
fn test_aarch32_sub_rr_a1_a_sub_shifted_oracle_64_3_c0420030() {
    // Test SUB shifted 64-bit: subtract from zero (oracle)
    // Encoding: 0xC0420030
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xC0420030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x0000000000000001");
}

/// Provenance: aarch32_SUB_rr_A1_A
/// ASL: `SUBS X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// no shift (32)
#[test]
fn test_aarch32_sub_rr_a1_a_subs_shifted_oracle_32_0_60420030() {
    // Test SUBS shifted 32-bit: no shift (oracle)
    // Encoding: 0x60420030
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0xA);
    let encoding: u32 = 0x60420030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x5A, "W0 should be 0x0000005A");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_rr_A1_A
/// ASL: `SUBS X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// no shift (64)
#[test]
fn test_aarch32_sub_rr_a1_a_subs_shifted_oracle_64_0_e0420030() {
    // Test SUBS shifted 64-bit: no shift (oracle)
    // Encoding: 0xE0420030
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xA);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xE0420030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x5A, "X0 should be 0x000000000000005A");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_rr_A1_A
/// ASL: `SUBS X0, X1, X2, shift #3`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// LSL #3 (multiply by 8) (32)
#[test]
fn test_aarch32_sub_rr_a1_a_subs_shifted_oracle_32_1_60420c30() {
    // Test SUBS shifted 32-bit: LSL #3 (multiply by 8) (oracle)
    // Encoding: 0x60420C30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x60420C30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x5C, "W0 should be 0x0000005C");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_rr_A1_A
/// ASL: `SUBS X0, X1, X2, shift #3`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// LSL #3 (multiply by 8) (64)
#[test]
fn test_aarch32_sub_rr_a1_a_subs_shifted_oracle_64_1_e0420c30() {
    // Test SUBS shifted 64-bit: LSL #3 (multiply by 8) (oracle)
    // Encoding: 0xE0420C30
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xE0420C30;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x5C, "X0 should be 0x000000000000005C");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_rr_A1_A
/// ASL: `SUBS X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// overflow test (32)
#[test]
fn test_aarch32_sub_rr_a1_a_subs_shifted_oracle_32_2_60420030() {
    // Test SUBS shifted 32-bit: overflow test (oracle)
    // Encoding: 0x60420030
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x60420030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_rr_A1_A
/// ASL: `SUBS X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// overflow test (64)
#[test]
fn test_aarch32_sub_rr_a1_a_subs_shifted_oracle_64_2_e0420030() {
    // Test SUBS shifted 64-bit: overflow test (oracle)
    // Encoding: 0xE0420030
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xE0420030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_rr_A1_A
/// ASL: `SUBS X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// subtract from zero (32)
#[test]
fn test_aarch32_sub_rr_a1_a_subs_shifted_oracle_32_3_60420030() {
    // Test SUBS shifted 32-bit: subtract from zero (oracle)
    // Encoding: 0x60420030
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x60420030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_rr_A1_A
/// ASL: `SUBS X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// subtract from zero (64)
#[test]
fn test_aarch32_sub_rr_a1_a_subs_shifted_oracle_64_3_e0420030() {
    // Test SUBS shifted 64-bit: subtract from zero (oracle)
    // Encoding: 0xE0420030
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0xE0420030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x0000000000000001");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SUB_rr_A1_A
/// ASL: `SUB R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple values
#[test]
fn test_aarch32_sub_rr_a1_a_a32_add_sub_reg_0_00410002() {
    // Test A32 SUB: simple values (oracle)
    // Encoding: 0x00410002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x32);
    let encoding: u32 = 0x00410002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x32, "R0 should be 0x00000032");
}

/// Provenance: aarch32_SUB_rr_A1_A
/// ASL: `SUB R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero values
#[test]
fn test_aarch32_sub_rr_a1_a_a32_add_sub_reg_1_00410002() {
    // Test A32 SUB: zero values (oracle)
    // Encoding: 0x00410002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x00410002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_SUB_rr_A1_A
/// ASL: `SUB R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max value
#[test]
fn test_aarch32_sub_rr_a1_a_a32_add_sub_reg_2_00410002() {
    // Test A32 SUB: max value (oracle)
    // Encoding: 0x00410002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x00410002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFE, "R0 should be 0xFFFFFFFE");
}

/// Provenance: aarch32_SUB_rr_A1_A
/// ASL: `SUB R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set
#[test]
fn test_aarch32_sub_rr_a1_a_a32_add_sub_reg_3_00410002() {
    // Test A32 SUB: MSB set (oracle)
    // Encoding: 0x00410002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    set_w(&mut cpu, 2, 0x80000000);
    let encoding: u32 = 0x00410002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_SUB_rr_A1_A
/// ASL: `SUB R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// mixed pattern
#[test]
fn test_aarch32_sub_rr_a1_a_a32_add_sub_reg_4_00410002() {
    // Test A32 SUB: mixed pattern (oracle)
    // Encoding: 0x00410002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x9ABCDEF0);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u32 = 0x00410002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x77777788, "R0 should be 0x77777788");
}

/// Provenance: aarch32_SUB_rr_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_aarch32_sub_rr_a1_a_flags_zeroresult_0_00510012() {
    // Test aarch32_SUB_rr_A1_A flag computation: ZeroResult
    // Encoding: 0x00510012
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x00510012;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SUB_rr_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_aarch32_sub_rr_a1_a_flags_zeroresult_1_00510012() {
    // Test aarch32_SUB_rr_A1_A flag computation: ZeroResult
    // Encoding: 0x00510012
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x00510012;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SUB_rr_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_aarch32_sub_rr_a1_a_flags_negativeresult_2_00510012() {
    // Test aarch32_SUB_rr_A1_A flag computation: NegativeResult
    // Encoding: 0x00510012
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x00510012;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SUB_rr_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_aarch32_sub_rr_a1_a_flags_unsignedoverflow_3_00510012() {
    // Test aarch32_SUB_rr_A1_A flag computation: UnsignedOverflow
    // Encoding: 0x00510012
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x00510012;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SUB_rr_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_aarch32_sub_rr_a1_a_flags_unsignedoverflow_4_00510012() {
    // Test aarch32_SUB_rr_A1_A flag computation: UnsignedOverflow
    // Encoding: 0x00510012
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x00510012;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_SUB_rr_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_aarch32_sub_rr_a1_a_flags_signedoverflow_5_00510012() {
    // Test aarch32_SUB_rr_A1_A flag computation: SignedOverflow
    // Encoding: 0x00510012
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x00510012;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_SUB_rr_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_aarch32_sub_rr_a1_a_flags_signedoverflow_6_00510012() {
    // Test aarch32_SUB_rr_A1_A flag computation: SignedOverflow
    // Encoding: 0x00510012
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x00510012;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_SUB_rr_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_aarch32_sub_rr_a1_a_flags_positiveresult_7_00510012() {
    // Test aarch32_SUB_rr_A1_A flag computation: PositiveResult
    // Encoding: 0x00510012
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x32);
    let encoding: u32 = 0x00510012;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

// ============================================================================
// aarch32_RSC_r_A Tests
// ============================================================================

/// Provenance: aarch32_RSC_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_rsc_r_a1_a_field_cond_0_min_0_00e00000() {
    // Encoding: 0x00E00000
    // Test aarch32_RSC_r_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, imm5=0, S=0, Rm=0, Rd=0, cond=0, type1=0
    let encoding: u32 = 0x00E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_rsc_r_a1_a_field_cond_1_poweroftwo_0_10e00000() {
    // Encoding: 0x10E00000
    // Test aarch32_RSC_r_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, cond=1, imm5=0, type1=0, Rm=0, Rn=0, S=0
    let encoding: u32 = 0x10E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_rsc_r_a1_a_field_cond_2_poweroftwo_0_20e00000() {
    // Encoding: 0x20E00000
    // Test aarch32_RSC_r_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=2, Rn=0, type1=0, Rm=0, S=0, Rd=0, imm5=0
    let encoding: u32 = 0x20E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_rsc_r_a1_a_field_cond_3_poweroftwo_0_30e00000() {
    // Encoding: 0x30E00000
    // Test aarch32_RSC_r_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rd=0, cond=3, imm5=0, type1=0, Rm=0, S=0
    let encoding: u32 = 0x30E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_rsc_r_a1_a_field_cond_4_poweroftwo_0_40e00000() {
    // Encoding: 0x40E00000
    // Test aarch32_RSC_r_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, imm5=0, Rd=0, type1=0, S=0, cond=4, Rm=0
    let encoding: u32 = 0x40E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_rsc_r_a1_a_field_cond_5_poweroftwo_0_50e00000() {
    // Encoding: 0x50E00000
    // Test aarch32_RSC_r_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, imm5=0, type1=0, S=0, Rn=0, cond=5, Rd=0
    let encoding: u32 = 0x50E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_rsc_r_a1_a_field_cond_6_poweroftwo_0_60e00000() {
    // Encoding: 0x60E00000
    // Test aarch32_RSC_r_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: type1=0, Rm=0, cond=6, S=0, Rn=0, Rd=0, imm5=0
    let encoding: u32 = 0x60E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_rsc_r_a1_a_field_cond_7_poweroftwo_0_70e00000() {
    // Encoding: 0x70E00000
    // Test aarch32_RSC_r_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, S=0, imm5=0, Rm=0, type1=0, Rn=0, cond=7
    let encoding: u32 = 0x70E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_rsc_r_a1_a_field_cond_8_poweroftwo_0_80e00000() {
    // Encoding: 0x80E00000
    // Test aarch32_RSC_r_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rm=0, cond=8, imm5=0, S=0, type1=0, Rn=0
    let encoding: u32 = 0x80E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_rsc_r_a1_a_field_cond_9_poweroftwo_0_90e00000() {
    // Encoding: 0x90E00000
    // Test aarch32_RSC_r_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, type1=0, cond=9, Rm=0, Rd=0, imm5=0, Rn=0
    let encoding: u32 = 0x90E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_rsc_r_a1_a_field_cond_10_poweroftwo_0_a0e00000() {
    // Encoding: 0xA0E00000
    // Test aarch32_RSC_r_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: type1=0, Rn=0, imm5=0, Rm=0, S=0, cond=10, Rd=0
    let encoding: u32 = 0xA0E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_rsc_r_a1_a_field_cond_11_poweroftwo_0_b0e00000() {
    // Encoding: 0xB0E00000
    // Test aarch32_RSC_r_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: imm5=0, type1=0, Rn=0, Rm=0, cond=11, S=0, Rd=0
    let encoding: u32 = 0xB0E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_rsc_r_a1_a_field_cond_12_poweroftwo_0_c0e00000() {
    // Encoding: 0xC0E00000
    // Test aarch32_RSC_r_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Rn=0, type1=0, cond=12, imm5=0, Rd=0, S=0
    let encoding: u32 = 0xC0E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_rsc_r_a1_a_field_cond_13_poweroftwo_0_d0e00000() {
    // Encoding: 0xD0E00000
    // Test aarch32_RSC_r_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=13, Rn=0, S=0, imm5=0, type1=0, Rd=0, Rm=0
    let encoding: u32 = 0xD0E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_rsc_r_a1_a_field_cond_14_poweroftwo_0_e0e00000() {
    // Encoding: 0xE0E00000
    // Test aarch32_RSC_r_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: type1=0, cond=14, Rm=0, imm5=0, Rd=0, S=0, Rn=0
    let encoding: u32 = 0xE0E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_rsc_r_a1_a_field_cond_15_max_0_f0e00000() {
    // Encoding: 0xF0E00000
    // Test aarch32_RSC_r_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: type1=0, cond=15, Rm=0, Rn=0, imm5=0, S=0, Rd=0
    let encoding: u32 = 0xF0E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_r_A1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_rsc_r_a1_a_field_s_0_min_0_00e00000() {
    // Encoding: 0x00E00000
    // Test aarch32_RSC_r_A1_A field S = 0 (Min)
    // ISET: A32
    // Fields: imm5=0, Rn=0, S=0, Rd=0, cond=0, type1=0, Rm=0
    let encoding: u32 = 0x00E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_r_A1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_rsc_r_a1_a_field_s_1_max_0_00f00000() {
    // Encoding: 0x00F00000
    // Test aarch32_RSC_r_A1_A field S = 1 (Max)
    // ISET: A32
    // Fields: cond=0, Rn=0, Rd=0, imm5=0, S=1, type1=0, Rm=0
    let encoding: u32 = 0x00F00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_r_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_rsc_r_a1_a_field_rn_0_min_0_00e00000() {
    // Encoding: 0x00E00000
    // Test aarch32_RSC_r_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rd=0, imm5=0, type1=0, Rm=0, Rn=0, S=0
    let encoding: u32 = 0x00E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_r_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_rsc_r_a1_a_field_rn_1_poweroftwo_0_00e10000() {
    // Encoding: 0x00E10000
    // Test aarch32_RSC_r_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, S=0, cond=0, imm5=0, type1=0, Rn=1, Rd=0
    let encoding: u32 = 0x00E10000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_r_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_rsc_r_a1_a_field_rd_0_min_0_00e00000() {
    // Encoding: 0x00E00000
    // Test aarch32_RSC_r_A1_A field Rd = 0 (Min)
    // ISET: A32
    // Fields: cond=0, type1=0, Rm=0, Rd=0, imm5=0, S=0, Rn=0
    let encoding: u32 = 0x00E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_r_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_rsc_r_a1_a_field_rd_1_poweroftwo_0_00e01000() {
    // Encoding: 0x00E01000
    // Test aarch32_RSC_r_A1_A field Rd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: type1=0, cond=0, Rd=1, imm5=0, Rn=0, S=0, Rm=0
    let encoding: u32 = 0x00E01000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_rsc_r_a1_a_field_imm5_0_zero_0_00e00000() {
    // Encoding: 0x00E00000
    // Test aarch32_RSC_r_A1_A field imm5 = 0 (Zero)
    // ISET: A32
    // Fields: Rd=0, type1=0, Rm=0, cond=0, S=0, Rn=0, imm5=0
    let encoding: u32 = 0x00E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_rsc_r_a1_a_field_imm5_1_poweroftwo_0_00e00080() {
    // Encoding: 0x00E00080
    // Test aarch32_RSC_r_A1_A field imm5 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, type1=0, Rn=0, Rm=0, Rd=0, imm5=1, cond=0
    let encoding: u32 = 0x00E00080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_rsc_r_a1_a_field_imm5_3_poweroftwominusone_0_00e00180() {
    // Encoding: 0x00E00180
    // Test aarch32_RSC_r_A1_A field imm5 = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rd=0, cond=0, imm5=3, Rm=0, type1=0, Rn=0, S=0
    let encoding: u32 = 0x00E00180;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_rsc_r_a1_a_field_imm5_4_poweroftwo_0_00e00200() {
    // Encoding: 0x00E00200
    // Test aarch32_RSC_r_A1_A field imm5 = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rd=0, cond=0, imm5=4, S=0, type1=0, Rm=0
    let encoding: u32 = 0x00E00200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_rsc_r_a1_a_field_imm5_7_poweroftwominusone_0_00e00380() {
    // Encoding: 0x00E00380
    // Test aarch32_RSC_r_A1_A field imm5 = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rd=0, Rn=0, type1=0, cond=0, S=0, Rm=0, imm5=7
    let encoding: u32 = 0x00E00380;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_rsc_r_a1_a_field_imm5_8_poweroftwo_0_00e00400() {
    // Encoding: 0x00E00400
    // Test aarch32_RSC_r_A1_A field imm5 = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, S=0, Rd=0, type1=0, imm5=8, Rm=0, cond=0
    let encoding: u32 = 0x00E00400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 15, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (15)
#[test]
fn test_aarch32_rsc_r_a1_a_field_imm5_15_poweroftwominusone_0_00e00780() {
    // Encoding: 0x00E00780
    // Test aarch32_RSC_r_A1_A field imm5 = 15 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rn=0, S=0, imm5=15, cond=0, Rd=0, type1=0, Rm=0
    let encoding: u32 = 0x00E00780;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_rsc_r_a1_a_field_imm5_16_poweroftwo_0_00e00800() {
    // Encoding: 0x00E00800
    // Test aarch32_RSC_r_A1_A field imm5 = 16 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, S=0, imm5=16, Rm=0, Rn=0, Rd=0, type1=0
    let encoding: u32 = 0x00E00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 31, boundary: Max }
/// maximum immediate (31)
#[test]
fn test_aarch32_rsc_r_a1_a_field_imm5_31_max_0_00e00f80() {
    // Encoding: 0x00E00F80
    // Test aarch32_RSC_r_A1_A field imm5 = 31 (Max)
    // ISET: A32
    // Fields: type1=0, cond=0, S=0, Rd=0, Rm=0, Rn=0, imm5=31
    let encoding: u32 = 0x00E00F80;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_r_A1_A
/// ASL: `field type1 5 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_rsc_r_a1_a_field_type1_0_min_0_00e00000() {
    // Encoding: 0x00E00000
    // Test aarch32_RSC_r_A1_A field type1 = 0 (Min)
    // ISET: A32
    // Fields: cond=0, type1=0, Rm=0, Rn=0, Rd=0, imm5=0, S=0
    let encoding: u32 = 0x00E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_r_A1_A
/// ASL: `field type1 5 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_rsc_r_a1_a_field_type1_1_poweroftwo_0_00e00020() {
    // Encoding: 0x00E00020
    // Test aarch32_RSC_r_A1_A field type1 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: imm5=0, cond=0, Rm=0, S=0, Rd=0, Rn=0, type1=1
    let encoding: u32 = 0x00E00020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_r_A1_A
/// ASL: `field type1 5 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_aarch32_rsc_r_a1_a_field_type1_3_max_0_00e00060() {
    // Encoding: 0x00E00060
    // Test aarch32_RSC_r_A1_A field type1 = 3 (Max)
    // ISET: A32
    // Fields: type1=3, imm5=0, cond=0, S=0, Rm=0, Rd=0, Rn=0
    let encoding: u32 = 0x00E00060;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_r_A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_rsc_r_a1_a_field_rm_0_min_0_00e00000() {
    // Encoding: 0x00E00000
    // Test aarch32_RSC_r_A1_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: Rd=0, Rm=0, S=0, Rn=0, imm5=0, type1=0, cond=0
    let encoding: u32 = 0x00E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_r_A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_rsc_r_a1_a_field_rm_1_poweroftwo_0_00e00001() {
    // Encoding: 0x00E00001
    // Test aarch32_RSC_r_A1_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: type1=0, S=0, Rn=0, Rm=1, cond=0, Rd=0, imm5=0
    let encoding: u32 = 0x00E00001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_r_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_rsc_r_a1_a_combo_0_0_00e00000() {
    // Encoding: 0x00E00000
    // Test aarch32_RSC_r_A1_A field combination: cond=0, S=0, Rn=0, Rd=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: imm5=0, Rn=0, S=0, Rd=0, cond=0, Rm=0, type1=0
    let encoding: u32 = 0x00E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_r_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_rsc_r_a1_a_special_cond_0_condition_eq_0_00e00000() {
    // Encoding: 0x00E00000
    // Test aarch32_RSC_r_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: S=0, Rn=0, cond=0, type1=0, Rm=0, imm5=0, Rd=0
    let encoding: u32 = 0x00E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_r_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_rsc_r_a1_a_special_cond_1_condition_ne_0_10e00000() {
    // Encoding: 0x10E00000
    // Test aarch32_RSC_r_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: type1=0, Rm=0, S=0, cond=1, Rn=0, imm5=0, Rd=0
    let encoding: u32 = 0x10E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_r_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_rsc_r_a1_a_special_cond_2_condition_cs_hs_0_20e00000() {
    // Encoding: 0x20E00000
    // Test aarch32_RSC_r_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: Rm=0, Rd=0, cond=2, type1=0, Rn=0, S=0, imm5=0
    let encoding: u32 = 0x20E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_r_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_rsc_r_a1_a_special_cond_3_condition_cc_lo_0_30e00000() {
    // Encoding: 0x30E00000
    // Test aarch32_RSC_r_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: Rd=0, type1=0, S=0, imm5=0, Rm=0, Rn=0, cond=3
    let encoding: u32 = 0x30E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_r_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_rsc_r_a1_a_special_cond_4_condition_mi_0_40e00000() {
    // Encoding: 0x40E00000
    // Test aarch32_RSC_r_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: Rn=0, imm5=0, Rd=0, cond=4, type1=0, Rm=0, S=0
    let encoding: u32 = 0x40E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_r_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_rsc_r_a1_a_special_cond_5_condition_pl_0_50e00000() {
    // Encoding: 0x50E00000
    // Test aarch32_RSC_r_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: S=0, cond=5, Rd=0, imm5=0, Rm=0, Rn=0, type1=0
    let encoding: u32 = 0x50E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_r_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_rsc_r_a1_a_special_cond_6_condition_vs_0_60e00000() {
    // Encoding: 0x60E00000
    // Test aarch32_RSC_r_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: imm5=0, Rn=0, Rm=0, cond=6, type1=0, S=0, Rd=0
    let encoding: u32 = 0x60E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_r_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_rsc_r_a1_a_special_cond_7_condition_vc_0_70e00000() {
    // Encoding: 0x70E00000
    // Test aarch32_RSC_r_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: imm5=0, type1=0, Rm=0, S=0, cond=7, Rn=0, Rd=0
    let encoding: u32 = 0x70E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_r_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_rsc_r_a1_a_special_cond_8_condition_hi_0_80e00000() {
    // Encoding: 0x80E00000
    // Test aarch32_RSC_r_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: type1=0, Rm=0, Rd=0, cond=8, S=0, Rn=0, imm5=0
    let encoding: u32 = 0x80E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_r_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_rsc_r_a1_a_special_cond_9_condition_ls_0_90e00000() {
    // Encoding: 0x90E00000
    // Test aarch32_RSC_r_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: imm5=0, type1=0, Rd=0, Rm=0, cond=9, S=0, Rn=0
    let encoding: u32 = 0x90E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_r_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_rsc_r_a1_a_special_cond_10_condition_ge_0_a0e00000() {
    // Encoding: 0xA0E00000
    // Test aarch32_RSC_r_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: S=0, imm5=0, cond=10, Rn=0, type1=0, Rd=0, Rm=0
    let encoding: u32 = 0xA0E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_r_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_rsc_r_a1_a_special_cond_11_condition_lt_0_b0e00000() {
    // Encoding: 0xB0E00000
    // Test aarch32_RSC_r_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: cond=11, Rn=0, Rd=0, imm5=0, Rm=0, type1=0, S=0
    let encoding: u32 = 0xB0E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_r_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_rsc_r_a1_a_special_cond_12_condition_gt_0_c0e00000() {
    // Encoding: 0xC0E00000
    // Test aarch32_RSC_r_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: Rm=0, type1=0, Rn=0, S=0, cond=12, Rd=0, imm5=0
    let encoding: u32 = 0xC0E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_r_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_rsc_r_a1_a_special_cond_13_condition_le_0_d0e00000() {
    // Encoding: 0xD0E00000
    // Test aarch32_RSC_r_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: S=0, Rn=0, Rd=0, imm5=0, Rm=0, cond=13, type1=0
    let encoding: u32 = 0xD0E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_r_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_rsc_r_a1_a_special_cond_14_condition_al_0_e0e00000() {
    // Encoding: 0xE0E00000
    // Test aarch32_RSC_r_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: type1=0, Rn=0, cond=14, Rd=0, imm5=0, Rm=0, S=0
    let encoding: u32 = 0xE0E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_r_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_rsc_r_a1_a_special_cond_15_condition_nv_0_f0e00000() {
    // Encoding: 0xF0E00000
    // Test aarch32_RSC_r_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: type1=0, S=0, Rm=0, cond=15, Rn=0, Rd=0, imm5=0
    let encoding: u32 = 0xF0E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_r_A1_A
/// ASL: `field S = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "S", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_rsc_r_a1_a_special_s_0_size_variant_0_0_00e00000() {
    // Encoding: 0x00E00000
    // Test aarch32_RSC_r_A1_A special value S = 0 (Size variant 0)
    // ISET: A32
    // Fields: S=0, imm5=0, type1=0, Rm=0, Rd=0, cond=0, Rn=0
    let encoding: u32 = 0x00E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_r_A1_A
/// ASL: `field S = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "S", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_rsc_r_a1_a_special_s_1_size_variant_1_0_00f00000() {
    // Encoding: 0x00F00000
    // Test aarch32_RSC_r_A1_A special value S = 1 (Size variant 1)
    // ISET: A32
    // Fields: cond=0, Rd=0, Rn=0, S=1, Rm=0, imm5=0, type1=0
    let encoding: u32 = 0x00F00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_RSC_r_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_aarch32_rsc_r_a1_a_flags_zeroresult_0_00f10002() {
    // Test aarch32_RSC_r_A1_A flag computation: ZeroResult
    // Encoding: 0x00F10002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x00F10002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_RSC_r_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_aarch32_rsc_r_a1_a_flags_zeroresult_1_00f10002() {
    // Test aarch32_RSC_r_A1_A flag computation: ZeroResult
    // Encoding: 0x00F10002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x00F10002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_RSC_r_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_aarch32_rsc_r_a1_a_flags_negativeresult_2_00f10002() {
    // Test aarch32_RSC_r_A1_A flag computation: NegativeResult
    // Encoding: 0x00F10002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x00F10002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_RSC_r_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_aarch32_rsc_r_a1_a_flags_unsignedoverflow_3_00f10002() {
    // Test aarch32_RSC_r_A1_A flag computation: UnsignedOverflow
    // Encoding: 0x00F10002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x00F10002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_RSC_r_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_aarch32_rsc_r_a1_a_flags_unsignedoverflow_4_00f10002() {
    // Test aarch32_RSC_r_A1_A flag computation: UnsignedOverflow
    // Encoding: 0x00F10002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x00F10002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: aarch32_RSC_r_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_aarch32_rsc_r_a1_a_flags_signedoverflow_5_00f10002() {
    // Test aarch32_RSC_r_A1_A flag computation: SignedOverflow
    // Encoding: 0x00F10002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x00F10002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_RSC_r_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_aarch32_rsc_r_a1_a_flags_signedoverflow_6_00f10002() {
    // Test aarch32_RSC_r_A1_A flag computation: SignedOverflow
    // Encoding: 0x00F10002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x00F10002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: aarch32_RSC_r_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_aarch32_rsc_r_a1_a_flags_positiveresult_7_00f10002() {
    // Test aarch32_RSC_r_A1_A flag computation: PositiveResult
    // Encoding: 0x00F10002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x32);
    let encoding: u32 = 0x00F10002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}
