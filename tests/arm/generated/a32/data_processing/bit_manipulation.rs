//! A32 data_processing bit_manipulation tests.
//!
//! Auto-generated from ARM ASL specifications.
//! DO NOT EDIT MANUALLY.

#![allow(unused_imports)]
#![allow(dead_code)]

use crate::generated::test_helpers_32::*;

// ============================================================================
// aarch32_USAT16_A Tests
// ============================================================================

/// Provenance: aarch32_USAT16_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_usat16_a1_a_field_cond_0_min_30_06e00030() {
    // Encoding: 0x06E00030
    // Test aarch32_USAT16_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: sat_imm=0, cond=0, Rn=0, Rd=0
    let encoding: u32 = 0x06E00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT16_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_usat16_a1_a_field_cond_1_poweroftwo_30_16e00030() {
    // Encoding: 0x16E00030
    // Test aarch32_USAT16_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=1, sat_imm=0, Rn=0, Rd=0
    let encoding: u32 = 0x16E00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT16_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_usat16_a1_a_field_cond_2_poweroftwo_30_26e00030() {
    // Encoding: 0x26E00030
    // Test aarch32_USAT16_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rd=0, cond=2, sat_imm=0
    let encoding: u32 = 0x26E00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT16_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_usat16_a1_a_field_cond_3_poweroftwo_30_36e00030() {
    // Encoding: 0x36E00030
    // Test aarch32_USAT16_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=3, Rd=0, sat_imm=0, Rn=0
    let encoding: u32 = 0x36E00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT16_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_usat16_a1_a_field_cond_4_poweroftwo_30_46e00030() {
    // Encoding: 0x46E00030
    // Test aarch32_USAT16_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=4, sat_imm=0, Rd=0
    let encoding: u32 = 0x46E00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT16_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_usat16_a1_a_field_cond_5_poweroftwo_30_56e00030() {
    // Encoding: 0x56E00030
    // Test aarch32_USAT16_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, sat_imm=0, Rn=0, cond=5
    let encoding: u32 = 0x56E00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT16_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_usat16_a1_a_field_cond_6_poweroftwo_30_66e00030() {
    // Encoding: 0x66E00030
    // Test aarch32_USAT16_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=6, sat_imm=0, Rn=0, Rd=0
    let encoding: u32 = 0x66E00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT16_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_usat16_a1_a_field_cond_7_poweroftwo_30_76e00030() {
    // Encoding: 0x76E00030
    // Test aarch32_USAT16_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, sat_imm=0, Rd=0, cond=7
    let encoding: u32 = 0x76E00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT16_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_usat16_a1_a_field_cond_8_poweroftwo_30_86e00030() {
    // Encoding: 0x86E00030
    // Test aarch32_USAT16_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, sat_imm=0, cond=8, Rd=0
    let encoding: u32 = 0x86E00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT16_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_usat16_a1_a_field_cond_9_poweroftwo_30_96e00030() {
    // Encoding: 0x96E00030
    // Test aarch32_USAT16_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=9, sat_imm=0, Rd=0
    let encoding: u32 = 0x96E00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT16_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_usat16_a1_a_field_cond_10_poweroftwo_30_a6e00030() {
    // Encoding: 0xA6E00030
    // Test aarch32_USAT16_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: sat_imm=0, Rd=0, cond=10, Rn=0
    let encoding: u32 = 0xA6E00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT16_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_usat16_a1_a_field_cond_11_poweroftwo_30_b6e00030() {
    // Encoding: 0xB6E00030
    // Test aarch32_USAT16_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=11, sat_imm=0, Rn=0, Rd=0
    let encoding: u32 = 0xB6E00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT16_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_usat16_a1_a_field_cond_12_poweroftwo_30_c6e00030() {
    // Encoding: 0xC6E00030
    // Test aarch32_USAT16_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=12, Rn=0, sat_imm=0, Rd=0
    let encoding: u32 = 0xC6E00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT16_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_usat16_a1_a_field_cond_13_poweroftwo_30_d6e00030() {
    // Encoding: 0xD6E00030
    // Test aarch32_USAT16_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: sat_imm=0, Rn=0, cond=13, Rd=0
    let encoding: u32 = 0xD6E00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT16_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_usat16_a1_a_field_cond_14_poweroftwo_30_e6e00030() {
    // Encoding: 0xE6E00030
    // Test aarch32_USAT16_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rn=0, cond=14, sat_imm=0
    let encoding: u32 = 0xE6E00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT16_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_usat16_a1_a_field_cond_15_max_30_f6e00030() {
    // Encoding: 0xF6E00030
    // Test aarch32_USAT16_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: Rn=0, cond=15, Rd=0, sat_imm=0
    let encoding: u32 = 0xF6E00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT16_A1_A
/// ASL: `field sat_imm 16 +: 4`
/// Requirement: FieldBoundary { field: "sat_imm", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_usat16_a1_a_field_sat_imm_0_min_30_06e00030() {
    // Encoding: 0x06E00030
    // Test aarch32_USAT16_A1_A field sat_imm = 0 (Min)
    // ISET: A32
    // Fields: sat_imm=0, cond=0, Rd=0, Rn=0
    let encoding: u32 = 0x06E00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT16_A1_A
/// ASL: `field sat_imm 16 +: 4`
/// Requirement: FieldBoundary { field: "sat_imm", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_usat16_a1_a_field_sat_imm_1_poweroftwo_30_06e10030() {
    // Encoding: 0x06E10030
    // Test aarch32_USAT16_A1_A field sat_imm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, cond=0, sat_imm=1, Rn=0
    let encoding: u32 = 0x06E10030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT16_A1_A
/// ASL: `field sat_imm 16 +: 4`
/// Requirement: FieldBoundary { field: "sat_imm", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_usat16_a1_a_field_sat_imm_7_poweroftwominusone_30_06e70030() {
    // Encoding: 0x06E70030
    // Test aarch32_USAT16_A1_A field sat_imm = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rn=0, cond=0, Rd=0, sat_imm=7
    let encoding: u32 = 0x06E70030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT16_A1_A
/// ASL: `field sat_imm 16 +: 4`
/// Requirement: FieldBoundary { field: "sat_imm", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_usat16_a1_a_field_sat_imm_15_max_30_06ef0030() {
    // Encoding: 0x06EF0030
    // Test aarch32_USAT16_A1_A field sat_imm = 15 (Max)
    // ISET: A32
    // Fields: Rn=0, cond=0, sat_imm=15, Rd=0
    let encoding: u32 = 0x06EF0030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT16_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_usat16_a1_a_field_rd_0_min_30_06e00030() {
    // Encoding: 0x06E00030
    // Test aarch32_USAT16_A1_A field Rd = 0 (Min)
    // ISET: A32
    // Fields: sat_imm=0, cond=0, Rd=0, Rn=0
    let encoding: u32 = 0x06E00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT16_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_usat16_a1_a_field_rd_1_poweroftwo_30_06e01030() {
    // Encoding: 0x06E01030
    // Test aarch32_USAT16_A1_A field Rd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=1, Rn=0, cond=0, sat_imm=0
    let encoding: u32 = 0x06E01030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT16_A1_A
/// ASL: `field Rn 0 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_usat16_a1_a_field_rn_0_min_30_06e00030() {
    // Encoding: 0x06E00030
    // Test aarch32_USAT16_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: sat_imm=0, Rd=0, cond=0, Rn=0
    let encoding: u32 = 0x06E00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT16_A1_A
/// ASL: `field Rn 0 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_usat16_a1_a_field_rn_1_poweroftwo_30_06e00031() {
    // Encoding: 0x06E00031
    // Test aarch32_USAT16_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rn=1, sat_imm=0, cond=0
    let encoding: u32 = 0x06E00031;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT16_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_usat16_a1_a_combo_0_30_06e00030() {
    // Encoding: 0x06E00030
    // Test aarch32_USAT16_A1_A field combination: cond=0, sat_imm=0, Rd=0, Rn=0
    // ISET: A32
    // Fields: Rd=0, sat_imm=0, cond=0, Rn=0
    let encoding: u32 = 0x06E00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT16_A1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=1 (condition NE (not equal))
#[test]
fn test_aarch32_usat16_a1_a_combo_1_30_16e00030() {
    // Encoding: 0x16E00030
    // Test aarch32_USAT16_A1_A field combination: cond=1, sat_imm=0, Rd=0, Rn=0
    // ISET: A32
    // Fields: cond=1, Rd=0, Rn=0, sat_imm=0
    let encoding: u32 = 0x16E00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT16_A1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=2 (condition CS/HS (carry set))
#[test]
fn test_aarch32_usat16_a1_a_combo_2_30_26e00030() {
    // Encoding: 0x26E00030
    // Test aarch32_USAT16_A1_A field combination: cond=2, sat_imm=0, Rd=0, Rn=0
    // ISET: A32
    // Fields: sat_imm=0, Rn=0, cond=2, Rd=0
    let encoding: u32 = 0x26E00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT16_A1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=3 (condition CC/LO (carry clear))
#[test]
fn test_aarch32_usat16_a1_a_combo_3_30_36e00030() {
    // Encoding: 0x36E00030
    // Test aarch32_USAT16_A1_A field combination: cond=3, sat_imm=0, Rd=0, Rn=0
    // ISET: A32
    // Fields: cond=3, Rd=0, Rn=0, sat_imm=0
    let encoding: u32 = 0x36E00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT16_A1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=4 (condition MI (minus/negative))
#[test]
fn test_aarch32_usat16_a1_a_combo_4_30_46e00030() {
    // Encoding: 0x46E00030
    // Test aarch32_USAT16_A1_A field combination: cond=4, sat_imm=0, Rd=0, Rn=0
    // ISET: A32
    // Fields: sat_imm=0, Rd=0, cond=4, Rn=0
    let encoding: u32 = 0x46E00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT16_A1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=5 (condition PL (plus/positive))
#[test]
fn test_aarch32_usat16_a1_a_combo_5_30_56e00030() {
    // Encoding: 0x56E00030
    // Test aarch32_USAT16_A1_A field combination: cond=5, sat_imm=0, Rd=0, Rn=0
    // ISET: A32
    // Fields: cond=5, sat_imm=0, Rd=0, Rn=0
    let encoding: u32 = 0x56E00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT16_A1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=6 (condition VS (overflow set))
#[test]
fn test_aarch32_usat16_a1_a_combo_6_30_66e00030() {
    // Encoding: 0x66E00030
    // Test aarch32_USAT16_A1_A field combination: cond=6, sat_imm=0, Rd=0, Rn=0
    // ISET: A32
    // Fields: Rd=0, cond=6, sat_imm=0, Rn=0
    let encoding: u32 = 0x66E00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT16_A1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=7 (condition VC (overflow clear))
#[test]
fn test_aarch32_usat16_a1_a_combo_7_30_76e00030() {
    // Encoding: 0x76E00030
    // Test aarch32_USAT16_A1_A field combination: cond=7, sat_imm=0, Rd=0, Rn=0
    // ISET: A32
    // Fields: Rn=0, cond=7, Rd=0, sat_imm=0
    let encoding: u32 = 0x76E00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT16_A1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=8 (condition HI (unsigned higher))
#[test]
fn test_aarch32_usat16_a1_a_combo_8_30_86e00030() {
    // Encoding: 0x86E00030
    // Test aarch32_USAT16_A1_A field combination: cond=8, sat_imm=0, Rd=0, Rn=0
    // ISET: A32
    // Fields: Rn=0, sat_imm=0, cond=8, Rd=0
    let encoding: u32 = 0x86E00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT16_A1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=9 (condition LS (unsigned lower or same))
#[test]
fn test_aarch32_usat16_a1_a_combo_9_30_96e00030() {
    // Encoding: 0x96E00030
    // Test aarch32_USAT16_A1_A field combination: cond=9, sat_imm=0, Rd=0, Rn=0
    // ISET: A32
    // Fields: Rn=0, sat_imm=0, Rd=0, cond=9
    let encoding: u32 = 0x96E00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT16_A1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=10 (condition GE (signed >=))
#[test]
fn test_aarch32_usat16_a1_a_combo_10_30_a6e00030() {
    // Encoding: 0xA6E00030
    // Test aarch32_USAT16_A1_A field combination: cond=10, sat_imm=0, Rd=0, Rn=0
    // ISET: A32
    // Fields: cond=10, Rn=0, sat_imm=0, Rd=0
    let encoding: u32 = 0xA6E00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT16_A1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=11 (condition LT (signed <))
#[test]
fn test_aarch32_usat16_a1_a_combo_11_30_b6e00030() {
    // Encoding: 0xB6E00030
    // Test aarch32_USAT16_A1_A field combination: cond=11, sat_imm=0, Rd=0, Rn=0
    // ISET: A32
    // Fields: sat_imm=0, Rn=0, cond=11, Rd=0
    let encoding: u32 = 0xB6E00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT16_A1_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=12 (condition GT (signed >))
#[test]
fn test_aarch32_usat16_a1_a_combo_12_30_c6e00030() {
    // Encoding: 0xC6E00030
    // Test aarch32_USAT16_A1_A field combination: cond=12, sat_imm=0, Rd=0, Rn=0
    // ISET: A32
    // Fields: Rd=0, cond=12, sat_imm=0, Rn=0
    let encoding: u32 = 0xC6E00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT16_A1_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=13 (condition LE (signed <=))
#[test]
fn test_aarch32_usat16_a1_a_combo_13_30_d6e00030() {
    // Encoding: 0xD6E00030
    // Test aarch32_USAT16_A1_A field combination: cond=13, sat_imm=0, Rd=0, Rn=0
    // ISET: A32
    // Fields: sat_imm=0, Rd=0, Rn=0, cond=13
    let encoding: u32 = 0xD6E00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT16_A1_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=14 (condition AL (always))
#[test]
fn test_aarch32_usat16_a1_a_combo_14_30_e6e00030() {
    // Encoding: 0xE6E00030
    // Test aarch32_USAT16_A1_A field combination: cond=14, sat_imm=0, Rd=0, Rn=0
    // ISET: A32
    // Fields: Rd=0, Rn=0, sat_imm=0, cond=14
    let encoding: u32 = 0xE6E00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT16_A1_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=15 (condition NV (never, reserved))
#[test]
fn test_aarch32_usat16_a1_a_combo_15_30_f6e00030() {
    // Encoding: 0xF6E00030
    // Test aarch32_USAT16_A1_A field combination: cond=15, sat_imm=0, Rd=0, Rn=0
    // ISET: A32
    // Fields: Rd=0, Rn=0, cond=15, sat_imm=0
    let encoding: u32 = 0xF6E00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT16_A1_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sat_imm=0 (minimum value)
#[test]
fn test_aarch32_usat16_a1_a_combo_16_30_06e00030() {
    // Encoding: 0x06E00030
    // Test aarch32_USAT16_A1_A field combination: cond=0, sat_imm=0, Rd=0, Rn=0
    // ISET: A32
    // Fields: Rn=0, cond=0, sat_imm=0, Rd=0
    let encoding: u32 = 0x06E00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT16_A1_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sat_imm=1 (value 1)
#[test]
fn test_aarch32_usat16_a1_a_combo_17_30_06e10030() {
    // Encoding: 0x06E10030
    // Test aarch32_USAT16_A1_A field combination: cond=0, sat_imm=1, Rd=0, Rn=0
    // ISET: A32
    // Fields: sat_imm=1, cond=0, Rd=0, Rn=0
    let encoding: u32 = 0x06E10030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT16_A1_A
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sat_imm=7 (midpoint (7))
#[test]
fn test_aarch32_usat16_a1_a_combo_18_30_06e70030() {
    // Encoding: 0x06E70030
    // Test aarch32_USAT16_A1_A field combination: cond=0, sat_imm=7, Rd=0, Rn=0
    // ISET: A32
    // Fields: Rn=0, cond=0, Rd=0, sat_imm=7
    let encoding: u32 = 0x06E70030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT16_A1_A
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sat_imm=15 (maximum value (15))
#[test]
fn test_aarch32_usat16_a1_a_combo_19_30_06ef0030() {
    // Encoding: 0x06EF0030
    // Test aarch32_USAT16_A1_A field combination: cond=0, sat_imm=15, Rd=0, Rn=0
    // ISET: A32
    // Fields: sat_imm=15, Rn=0, cond=0, Rd=0
    let encoding: u32 = 0x06EF0030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT16_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_usat16_a1_a_special_cond_0_condition_eq_48_06e00030() {
    // Encoding: 0x06E00030
    // Test aarch32_USAT16_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: sat_imm=0, Rn=0, Rd=0, cond=0
    let encoding: u32 = 0x06E00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT16_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_usat16_a1_a_special_cond_1_condition_ne_48_16e00030() {
    // Encoding: 0x16E00030
    // Test aarch32_USAT16_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: Rn=0, cond=1, Rd=0, sat_imm=0
    let encoding: u32 = 0x16E00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT16_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_usat16_a1_a_special_cond_2_condition_cs_hs_48_26e00030() {
    // Encoding: 0x26E00030
    // Test aarch32_USAT16_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: Rn=0, cond=2, Rd=0, sat_imm=0
    let encoding: u32 = 0x26E00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT16_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_usat16_a1_a_special_cond_3_condition_cc_lo_48_36e00030() {
    // Encoding: 0x36E00030
    // Test aarch32_USAT16_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: Rd=0, sat_imm=0, Rn=0, cond=3
    let encoding: u32 = 0x36E00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT16_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_usat16_a1_a_special_cond_4_condition_mi_48_46e00030() {
    // Encoding: 0x46E00030
    // Test aarch32_USAT16_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: sat_imm=0, cond=4, Rd=0, Rn=0
    let encoding: u32 = 0x46E00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT16_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_usat16_a1_a_special_cond_5_condition_pl_48_56e00030() {
    // Encoding: 0x56E00030
    // Test aarch32_USAT16_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: Rn=0, cond=5, sat_imm=0, Rd=0
    let encoding: u32 = 0x56E00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT16_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_usat16_a1_a_special_cond_6_condition_vs_48_66e00030() {
    // Encoding: 0x66E00030
    // Test aarch32_USAT16_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: Rn=0, Rd=0, sat_imm=0, cond=6
    let encoding: u32 = 0x66E00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT16_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_usat16_a1_a_special_cond_7_condition_vc_48_76e00030() {
    // Encoding: 0x76E00030
    // Test aarch32_USAT16_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: Rd=0, Rn=0, cond=7, sat_imm=0
    let encoding: u32 = 0x76E00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT16_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_usat16_a1_a_special_cond_8_condition_hi_48_86e00030() {
    // Encoding: 0x86E00030
    // Test aarch32_USAT16_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: Rd=0, sat_imm=0, Rn=0, cond=8
    let encoding: u32 = 0x86E00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT16_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_usat16_a1_a_special_cond_9_condition_ls_48_96e00030() {
    // Encoding: 0x96E00030
    // Test aarch32_USAT16_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: Rn=0, Rd=0, sat_imm=0, cond=9
    let encoding: u32 = 0x96E00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT16_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_usat16_a1_a_special_cond_10_condition_ge_48_a6e00030() {
    // Encoding: 0xA6E00030
    // Test aarch32_USAT16_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: cond=10, Rd=0, Rn=0, sat_imm=0
    let encoding: u32 = 0xA6E00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT16_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_usat16_a1_a_special_cond_11_condition_lt_48_b6e00030() {
    // Encoding: 0xB6E00030
    // Test aarch32_USAT16_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: Rd=0, sat_imm=0, cond=11, Rn=0
    let encoding: u32 = 0xB6E00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT16_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_usat16_a1_a_special_cond_12_condition_gt_48_c6e00030() {
    // Encoding: 0xC6E00030
    // Test aarch32_USAT16_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: cond=12, Rd=0, sat_imm=0, Rn=0
    let encoding: u32 = 0xC6E00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT16_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_usat16_a1_a_special_cond_13_condition_le_48_d6e00030() {
    // Encoding: 0xD6E00030
    // Test aarch32_USAT16_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: cond=13, sat_imm=0, Rd=0, Rn=0
    let encoding: u32 = 0xD6E00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT16_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_usat16_a1_a_special_cond_14_condition_al_48_e6e00030() {
    // Encoding: 0xE6E00030
    // Test aarch32_USAT16_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: Rd=0, Rn=0, sat_imm=0, cond=14
    let encoding: u32 = 0xE6E00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT16_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_usat16_a1_a_special_cond_15_condition_nv_48_f6e00030() {
    // Encoding: 0xF6E00030
    // Test aarch32_USAT16_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: sat_imm=0, cond=15, Rd=0, Rn=0
    let encoding: u32 = 0xF6E00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT16_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_usat16_a1_a_invalid_0_30_06e00030() {
    // Encoding: 0x06E00030
    // Test aarch32_USAT16_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }
    // ISET: A32
    // Fields: Rn=0, Rd=0, sat_imm=0, cond=0
    let encoding: u32 = 0x06E00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_USAT16_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_usat16_a1_a_invalid_1_30_06e00030() {
    // Encoding: 0x06E00030
    // Test aarch32_USAT16_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Rd=0, sat_imm=0, Rn=0, cond=0
    let encoding: u32 = 0x06E00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_USAT16_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_usat16_t1_a_field_rn_0_min_0_f3a00000() {
    // Thumb encoding (32): 0xF3A00000
    // Test aarch32_USAT16_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rd=0, Rn=0, sat_imm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_USAT16_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_usat16_t1_a_field_rn_1_poweroftwo_0_f3a10000() {
    // Thumb encoding (32): 0xF3A10000
    // Test aarch32_USAT16_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rd=0, sat_imm=0, Rn=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3A10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_USAT16_T1_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_usat16_t1_a_field_rd_0_min_0_f3a00000() {
    // Thumb encoding (32): 0xF3A00000
    // Test aarch32_USAT16_T1_A field Rd = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rd=0, sat_imm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_USAT16_T1_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_usat16_t1_a_field_rd_1_poweroftwo_0_f3a00100() {
    // Thumb encoding (32): 0xF3A00100
    // Test aarch32_USAT16_T1_A field Rd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Rd=1, sat_imm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3A00100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_USAT16_T1_A
/// ASL: `field sat_imm 0 +: 4`
/// Requirement: FieldBoundary { field: "sat_imm", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_usat16_t1_a_field_sat_imm_0_min_0_f3a00000() {
    // Thumb encoding (32): 0xF3A00000
    // Test aarch32_USAT16_T1_A field sat_imm = 0 (Min)
    // ISET: T32
    // Fields: sat_imm=0, Rn=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_USAT16_T1_A
/// ASL: `field sat_imm 0 +: 4`
/// Requirement: FieldBoundary { field: "sat_imm", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_usat16_t1_a_field_sat_imm_1_poweroftwo_0_f3a00001() {
    // Thumb encoding (32): 0xF3A00001
    // Test aarch32_USAT16_T1_A field sat_imm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Rd=0, sat_imm=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3A00001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_USAT16_T1_A
/// ASL: `field sat_imm 0 +: 4`
/// Requirement: FieldBoundary { field: "sat_imm", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_usat16_t1_a_field_sat_imm_7_poweroftwominusone_0_f3a00007() {
    // Thumb encoding (32): 0xF3A00007
    // Test aarch32_USAT16_T1_A field sat_imm = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rd=0, Rn=0, sat_imm=7
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3A00007;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_USAT16_T1_A
/// ASL: `field sat_imm 0 +: 4`
/// Requirement: FieldBoundary { field: "sat_imm", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_usat16_t1_a_field_sat_imm_15_max_0_f3a0000f() {
    // Thumb encoding (32): 0xF3A0000F
    // Test aarch32_USAT16_T1_A field sat_imm = 15 (Max)
    // ISET: T32
    // Fields: Rd=0, Rn=0, sat_imm=15
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3A0000F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_USAT16_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_usat16_t1_a_combo_0_0_f3a00000() {
    // Thumb encoding (32): 0xF3A00000
    // Test aarch32_USAT16_T1_A field combination: Rn=0, Rd=0, sat_imm=0
    // ISET: T32
    // Fields: Rn=0, Rd=0, sat_imm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_USAT16_T1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_usat16_t1_a_combo_1_0_f3a10000() {
    // Thumb encoding (32): 0xF3A10000
    // Test aarch32_USAT16_T1_A field combination: Rn=1, Rd=0, sat_imm=0
    // ISET: T32
    // Fields: Rd=0, sat_imm=0, Rn=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3A10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_USAT16_T1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch32_usat16_t1_a_combo_2_0_f3a00000() {
    // Thumb encoding (32): 0xF3A00000
    // Test aarch32_USAT16_T1_A field combination: Rn=0, Rd=0, sat_imm=0
    // ISET: T32
    // Fields: sat_imm=0, Rn=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_USAT16_T1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch32_usat16_t1_a_combo_3_0_f3a00100() {
    // Thumb encoding (32): 0xF3A00100
    // Test aarch32_USAT16_T1_A field combination: Rn=0, Rd=1, sat_imm=0
    // ISET: T32
    // Fields: Rn=0, Rd=1, sat_imm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3A00100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_USAT16_T1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sat_imm=0 (minimum value)
#[test]
fn test_aarch32_usat16_t1_a_combo_4_0_f3a00000() {
    // Thumb encoding (32): 0xF3A00000
    // Test aarch32_USAT16_T1_A field combination: Rn=0, Rd=0, sat_imm=0
    // ISET: T32
    // Fields: Rn=0, Rd=0, sat_imm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_USAT16_T1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sat_imm=1 (value 1)
#[test]
fn test_aarch32_usat16_t1_a_combo_5_0_f3a00001() {
    // Thumb encoding (32): 0xF3A00001
    // Test aarch32_USAT16_T1_A field combination: Rn=0, Rd=0, sat_imm=1
    // ISET: T32
    // Fields: Rd=0, Rn=0, sat_imm=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3A00001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_USAT16_T1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sat_imm=7 (midpoint (7))
#[test]
fn test_aarch32_usat16_t1_a_combo_6_0_f3a00007() {
    // Thumb encoding (32): 0xF3A00007
    // Test aarch32_USAT16_T1_A field combination: Rn=0, Rd=0, sat_imm=7
    // ISET: T32
    // Fields: sat_imm=7, Rd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3A00007;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_USAT16_T1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sat_imm=15 (maximum value (15))
#[test]
fn test_aarch32_usat16_t1_a_combo_7_0_f3a0000f() {
    // Thumb encoding (32): 0xF3A0000F
    // Test aarch32_USAT16_T1_A field combination: Rn=0, Rd=0, sat_imm=15
    // ISET: T32
    // Fields: Rd=0, sat_imm=15, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3A0000F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_USAT16_T1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch32_usat16_t1_a_combo_8_0_f3a10100() {
    // Thumb encoding (32): 0xF3A10100
    // Test aarch32_USAT16_T1_A field combination: Rn=1, Rd=1, sat_imm=0
    // ISET: T32
    // Fields: Rd=1, Rn=1, sat_imm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3A10100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_USAT16_T1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch32_usat16_t1_a_combo_9_0_f3af0f00() {
    // Thumb encoding (32): 0xF3AF0F00
    // Test aarch32_USAT16_T1_A field combination: Rn=31, Rd=31, sat_imm=0
    // ISET: T32
    // Fields: Rn=31, Rd=31, sat_imm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3AF0F00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_USAT16_T1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_usat16_t1_a_invalid_0_0_f3a00000() {
    // Thumb encoding (32): 0xF3A00000
    // Test aarch32_USAT16_T1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }
    // ISET: T32
    // Fields: Rd=0, sat_imm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3A00000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_USAT16_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_usat16_t1_a_invalid_1_0_f3a00000() {
    // Thumb encoding (32): 0xF3A00000
    // Test aarch32_USAT16_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rd=0, sat_imm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3A00000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_USAT16_T1_A
/// ASL: `SUB X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_usat16_t1_a_sub_oracle_32_0_f3a02820() {
    // Test SUB 32-bit: simple addition/subtraction (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF3A02820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFF85A, "X0 should be 0xFFFFFFFFFFFFF85A");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_USAT16_T1_A
/// ASL: `SUB X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_usat16_t1_a_sub_oracle_64_0_f3a02820() {
    // Test SUB 64-bit: simple addition/subtraction (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF3A02820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFF85A, "X0 should be 0xFFFFFFFFFFFFF85A");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_USAT16_T1_A
/// ASL: `SUB X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero operands (32)
#[test]
fn test_aarch32_usat16_t1_a_sub_oracle_32_1_f3a00020() {
    // Test SUB 32-bit: zero operands (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF3A00020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFF800, "X0 should be 0xFFFFFFFFFFFFF800");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_USAT16_T1_A
/// ASL: `SUB X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero operands (64)
#[test]
fn test_aarch32_usat16_t1_a_sub_oracle_64_1_f3a00020() {
    // Test SUB 64-bit: zero operands (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF3A00020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFF800, "X0 should be 0xFFFFFFFFFFFFF800");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_USAT16_T1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small values (32)
#[test]
fn test_aarch32_usat16_t1_a_sub_oracle_32_2_f3a00420() {
    // Test SUB 32-bit: small values (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF3A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFF800, "X0 should be 0xFFFFFFFFFFFFF800");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_USAT16_T1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// small values (64)
#[test]
fn test_aarch32_usat16_t1_a_sub_oracle_64_2_f3a00420() {
    // Test SUB 64-bit: small values (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF3A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFF800, "X0 should be 0xFFFFFFFFFFFFF800");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_USAT16_T1_A
/// ASL: `SUB X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_usat16_t1_a_sub_oracle_32_3_f3bffc20() {
    // Test SUB 32-bit: max imm12 unshifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF3BFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFF001, "X0 should be 0xFFFFFFFFFFFFF001");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_USAT16_T1_A
/// ASL: `SUB X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_usat16_t1_a_sub_oracle_64_3_f3bffc20() {
    // Test SUB 64-bit: max imm12 unshifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF3BFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFF001, "X0 should be 0xFFFFFFFFFFFFF001");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_USAT16_T1_A
/// ASL: `SUB X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_usat16_t1_a_sub_oracle_32_4_f3fffc20() {
    // Test SUB 32-bit: max imm12 shifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF3FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF001000, "X0 should be 0xFFFFFFFFFF001000");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_USAT16_T1_A
/// ASL: `SUB X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_usat16_t1_a_sub_oracle_64_4_f3fffc20() {
    // Test SUB 64-bit: max imm12 shifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF3FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF001000, "X0 should be 0xFFFFFFFFFF001000");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_USAT16_T1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max u64 operand (32)
#[test]
fn test_aarch32_usat16_t1_a_sub_oracle_32_5_f3a00420() {
    // Test SUB 32-bit: max u64 operand (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF3A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFF7FE, "X0 should be 0x00000000FFFFF7FE");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_USAT16_T1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max u64 operand (64)
#[test]
fn test_aarch32_usat16_t1_a_sub_oracle_64_5_f3a00420() {
    // Test SUB 64-bit: max u64 operand (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF3A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFF7FE, "X0 should be 0xFFFFFFFFFFFFF7FE");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_USAT16_T1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_usat16_t1_a_sub_oracle_32_6_f3a00420() {
    // Test SUB 32-bit: zero result (for sub 1-1) (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF3A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFF7FF, "X0 should be 0xFFFFFFFFFFFFF7FF");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_USAT16_T1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_usat16_t1_a_sub_oracle_64_6_f3a00420() {
    // Test SUB 64-bit: zero result (for sub 1-1) (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF3A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFF7FF, "X0 should be 0xFFFFFFFFFFFFF7FF");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_USAT16_T1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_usat16_t1_a_sub_oracle_32_7_f3a00420() {
    // Test SUB 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF3A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFF7FE, "X0 should be 0x00000000FFFFF7FE");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_USAT16_T1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_usat16_t1_a_sub_oracle_64_7_f3a00420() {
    // Test SUB 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF3A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFF7FE, "X0 should be 0x7FFFFFFFFFFFF7FE");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_USAT16_T1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_usat16_t1_a_sub_oracle_32_8_f3a00420() {
    // Test SUB 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF3A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FFFF7FE, "X0 should be 0x000000007FFFF7FE");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_USAT16_T1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_usat16_t1_a_sub_oracle_64_8_f3a00420() {
    // Test SUB 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF3A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FFFF7FE, "X0 should be 0x000000007FFFF7FE");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_USAT16_T1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_usat16_t1_a_sub_oracle_32_9_f3a00420() {
    // Test SUB 32-bit: unsigned overflow 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF3A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFF7FE, "X0 should be 0x00000000FFFFF7FE");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_USAT16_T1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_usat16_t1_a_sub_oracle_64_9_f3a00420() {
    // Test SUB 64-bit: unsigned overflow 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF3A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFF7FE, "X0 should be 0xFFFFFFFFFFFFF7FE");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_USAT16_T1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_usat16_t1_a_sub_oracle_32_10_f3a00420() {
    // Test SUB 32-bit: unsigned overflow 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF3A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFF7FE, "X0 should be 0x00000000FFFFF7FE");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_USAT16_T1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_usat16_t1_a_sub_oracle_64_10_f3a00420() {
    // Test SUB 64-bit: unsigned overflow 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF3A00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFF7FE, "X0 should be 0x00000000FFFFF7FE");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_USAT16_T1_A
/// ASL: `SUB SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (32)
#[test]
fn test_aarch32_usat16_t1_a_sub_oracle_32_rd31_sp_f3a0283f() {
    // Test SUB 32-bit with Rd=31 (SP)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF3A0283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_USAT16_T1_A
/// ASL: `SUB SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (64)
#[test]
fn test_aarch32_usat16_t1_a_sub_oracle_64_rd31_sp_f3a0283f() {
    // Test SUB 64-bit with Rd=31 (SP)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF3A0283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_USAT16_T1_A
/// ASL: `SUB.W R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple values
#[test]
fn test_aarch32_usat16_t1_a_t32_oracle_0_f3a10000() {
    // Test T32 SUB: simple values (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x32);
    let encoding: u32 = 0xF3A10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x32, "R0 should be 0x00000032");
}

/// Provenance: aarch32_USAT16_T1_A
/// ASL: `SUB.W R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero values
#[test]
fn test_aarch32_usat16_t1_a_t32_oracle_1_f3a10000() {
    // Test T32 SUB: zero values (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xF3A10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_USAT16_T1_A
/// ASL: `SUB.W R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max value
#[test]
fn test_aarch32_usat16_t1_a_t32_oracle_2_f3a10000() {
    // Test T32 SUB: max value (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0xF3A10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFE, "R0 should be 0xFFFFFFFE");
}

/// Provenance: aarch32_USAT16_T1_A
/// ASL: `SUB.W R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// mixed pattern
#[test]
fn test_aarch32_usat16_t1_a_t32_oracle_3_f3a10000() {
    // Test T32 SUB: mixed pattern (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xABCDEF01);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u32 = 0xF3A10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x66666777, "R0 should be 0x66666777");
}

// ============================================================================
// aarch32_REVSH_A Tests
// ============================================================================

/// Provenance: aarch32_REVSH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_revsh_a1_a_field_cond_0_min_b0_06f000b0() {
    // Encoding: 0x06F000B0
    // Test aarch32_REVSH_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, cond=0, Rd=0
    let encoding: u32 = 0x06F000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REVSH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_revsh_a1_a_field_cond_1_poweroftwo_b0_16f000b0() {
    // Encoding: 0x16F000B0
    // Test aarch32_REVSH_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, cond=1, Rd=0
    let encoding: u32 = 0x16F000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REVSH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_revsh_a1_a_field_cond_2_poweroftwo_b0_26f000b0() {
    // Encoding: 0x26F000B0
    // Test aarch32_REVSH_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, cond=2, Rd=0
    let encoding: u32 = 0x26F000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REVSH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_revsh_a1_a_field_cond_3_poweroftwo_b0_36f000b0() {
    // Encoding: 0x36F000B0
    // Test aarch32_REVSH_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Rd=0, cond=3
    let encoding: u32 = 0x36F000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REVSH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_revsh_a1_a_field_cond_4_poweroftwo_b0_46f000b0() {
    // Encoding: 0x46F000B0
    // Test aarch32_REVSH_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, cond=4, Rm=0
    let encoding: u32 = 0x46F000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REVSH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_revsh_a1_a_field_cond_5_poweroftwo_b0_56f000b0() {
    // Encoding: 0x56F000B0
    // Test aarch32_REVSH_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=5, Rd=0, Rm=0
    let encoding: u32 = 0x56F000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REVSH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_revsh_a1_a_field_cond_6_poweroftwo_b0_66f000b0() {
    // Encoding: 0x66F000B0
    // Test aarch32_REVSH_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rm=0, cond=6
    let encoding: u32 = 0x66F000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REVSH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_revsh_a1_a_field_cond_7_poweroftwo_b0_76f000b0() {
    // Encoding: 0x76F000B0
    // Test aarch32_REVSH_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=7, Rm=0, Rd=0
    let encoding: u32 = 0x76F000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REVSH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_revsh_a1_a_field_cond_8_poweroftwo_b0_86f000b0() {
    // Encoding: 0x86F000B0
    // Test aarch32_REVSH_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=8, Rd=0, Rm=0
    let encoding: u32 = 0x86F000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REVSH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_revsh_a1_a_field_cond_9_poweroftwo_b0_96f000b0() {
    // Encoding: 0x96F000B0
    // Test aarch32_REVSH_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=9, Rd=0, Rm=0
    let encoding: u32 = 0x96F000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REVSH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_revsh_a1_a_field_cond_10_poweroftwo_b0_a6f000b0() {
    // Encoding: 0xA6F000B0
    // Test aarch32_REVSH_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Rd=0, cond=10
    let encoding: u32 = 0xA6F000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REVSH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_revsh_a1_a_field_cond_11_poweroftwo_b0_b6f000b0() {
    // Encoding: 0xB6F000B0
    // Test aarch32_REVSH_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=11, Rd=0, Rm=0
    let encoding: u32 = 0xB6F000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REVSH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_revsh_a1_a_field_cond_12_poweroftwo_b0_c6f000b0() {
    // Encoding: 0xC6F000B0
    // Test aarch32_REVSH_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, cond=12, Rd=0
    let encoding: u32 = 0xC6F000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REVSH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_revsh_a1_a_field_cond_13_poweroftwo_b0_d6f000b0() {
    // Encoding: 0xD6F000B0
    // Test aarch32_REVSH_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Rd=0, cond=13
    let encoding: u32 = 0xD6F000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REVSH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_revsh_a1_a_field_cond_14_poweroftwo_b0_e6f000b0() {
    // Encoding: 0xE6F000B0
    // Test aarch32_REVSH_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Rd=0, cond=14
    let encoding: u32 = 0xE6F000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REVSH_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_revsh_a1_a_field_cond_15_max_b0_f6f000b0() {
    // Encoding: 0xF6F000B0
    // Test aarch32_REVSH_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: Rm=0, cond=15, Rd=0
    let encoding: u32 = 0xF6F000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REVSH_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_revsh_a1_a_field_rd_0_min_b0_06f000b0() {
    // Encoding: 0x06F000B0
    // Test aarch32_REVSH_A1_A field Rd = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, Rd=0, cond=0
    let encoding: u32 = 0x06F000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REVSH_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_revsh_a1_a_field_rd_1_poweroftwo_b0_06f010b0() {
    // Encoding: 0x06F010B0
    // Test aarch32_REVSH_A1_A field Rd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=1, cond=0, Rm=0
    let encoding: u32 = 0x06F010B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REVSH_A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_revsh_a1_a_field_rm_0_min_b0_06f000b0() {
    // Encoding: 0x06F000B0
    // Test aarch32_REVSH_A1_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, cond=0, Rd=0
    let encoding: u32 = 0x06F000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REVSH_A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_revsh_a1_a_field_rm_1_poweroftwo_b0_06f000b1() {
    // Encoding: 0x06F000B1
    // Test aarch32_REVSH_A1_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Rd=0, Rm=1
    let encoding: u32 = 0x06F000B1;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REVSH_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_revsh_a1_a_combo_0_b0_06f000b0() {
    // Encoding: 0x06F000B0
    // Test aarch32_REVSH_A1_A field combination: cond=0, Rd=0, Rm=0
    // ISET: A32
    // Fields: Rm=0, cond=0, Rd=0
    let encoding: u32 = 0x06F000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REVSH_A1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=1 (condition NE (not equal))
#[test]
fn test_aarch32_revsh_a1_a_combo_1_b0_16f000b0() {
    // Encoding: 0x16F000B0
    // Test aarch32_REVSH_A1_A field combination: cond=1, Rd=0, Rm=0
    // ISET: A32
    // Fields: Rm=0, cond=1, Rd=0
    let encoding: u32 = 0x16F000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REVSH_A1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=2 (condition CS/HS (carry set))
#[test]
fn test_aarch32_revsh_a1_a_combo_2_b0_26f000b0() {
    // Encoding: 0x26F000B0
    // Test aarch32_REVSH_A1_A field combination: cond=2, Rd=0, Rm=0
    // ISET: A32
    // Fields: cond=2, Rd=0, Rm=0
    let encoding: u32 = 0x26F000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REVSH_A1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=3 (condition CC/LO (carry clear))
#[test]
fn test_aarch32_revsh_a1_a_combo_3_b0_36f000b0() {
    // Encoding: 0x36F000B0
    // Test aarch32_REVSH_A1_A field combination: cond=3, Rd=0, Rm=0
    // ISET: A32
    // Fields: Rm=0, cond=3, Rd=0
    let encoding: u32 = 0x36F000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REVSH_A1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=4 (condition MI (minus/negative))
#[test]
fn test_aarch32_revsh_a1_a_combo_4_b0_46f000b0() {
    // Encoding: 0x46F000B0
    // Test aarch32_REVSH_A1_A field combination: cond=4, Rd=0, Rm=0
    // ISET: A32
    // Fields: cond=4, Rd=0, Rm=0
    let encoding: u32 = 0x46F000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REVSH_A1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=5 (condition PL (plus/positive))
#[test]
fn test_aarch32_revsh_a1_a_combo_5_b0_56f000b0() {
    // Encoding: 0x56F000B0
    // Test aarch32_REVSH_A1_A field combination: cond=5, Rd=0, Rm=0
    // ISET: A32
    // Fields: cond=5, Rd=0, Rm=0
    let encoding: u32 = 0x56F000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REVSH_A1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=6 (condition VS (overflow set))
#[test]
fn test_aarch32_revsh_a1_a_combo_6_b0_66f000b0() {
    // Encoding: 0x66F000B0
    // Test aarch32_REVSH_A1_A field combination: cond=6, Rd=0, Rm=0
    // ISET: A32
    // Fields: Rm=0, cond=6, Rd=0
    let encoding: u32 = 0x66F000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REVSH_A1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=7 (condition VC (overflow clear))
#[test]
fn test_aarch32_revsh_a1_a_combo_7_b0_76f000b0() {
    // Encoding: 0x76F000B0
    // Test aarch32_REVSH_A1_A field combination: cond=7, Rd=0, Rm=0
    // ISET: A32
    // Fields: cond=7, Rd=0, Rm=0
    let encoding: u32 = 0x76F000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REVSH_A1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=8 (condition HI (unsigned higher))
#[test]
fn test_aarch32_revsh_a1_a_combo_8_b0_86f000b0() {
    // Encoding: 0x86F000B0
    // Test aarch32_REVSH_A1_A field combination: cond=8, Rd=0, Rm=0
    // ISET: A32
    // Fields: cond=8, Rm=0, Rd=0
    let encoding: u32 = 0x86F000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REVSH_A1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=9 (condition LS (unsigned lower or same))
#[test]
fn test_aarch32_revsh_a1_a_combo_9_b0_96f000b0() {
    // Encoding: 0x96F000B0
    // Test aarch32_REVSH_A1_A field combination: cond=9, Rd=0, Rm=0
    // ISET: A32
    // Fields: cond=9, Rm=0, Rd=0
    let encoding: u32 = 0x96F000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REVSH_A1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=10 (condition GE (signed >=))
#[test]
fn test_aarch32_revsh_a1_a_combo_10_b0_a6f000b0() {
    // Encoding: 0xA6F000B0
    // Test aarch32_REVSH_A1_A field combination: cond=10, Rd=0, Rm=0
    // ISET: A32
    // Fields: Rd=0, Rm=0, cond=10
    let encoding: u32 = 0xA6F000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REVSH_A1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=11 (condition LT (signed <))
#[test]
fn test_aarch32_revsh_a1_a_combo_11_b0_b6f000b0() {
    // Encoding: 0xB6F000B0
    // Test aarch32_REVSH_A1_A field combination: cond=11, Rd=0, Rm=0
    // ISET: A32
    // Fields: Rm=0, Rd=0, cond=11
    let encoding: u32 = 0xB6F000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REVSH_A1_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=12 (condition GT (signed >))
#[test]
fn test_aarch32_revsh_a1_a_combo_12_b0_c6f000b0() {
    // Encoding: 0xC6F000B0
    // Test aarch32_REVSH_A1_A field combination: cond=12, Rd=0, Rm=0
    // ISET: A32
    // Fields: cond=12, Rm=0, Rd=0
    let encoding: u32 = 0xC6F000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REVSH_A1_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=13 (condition LE (signed <=))
#[test]
fn test_aarch32_revsh_a1_a_combo_13_b0_d6f000b0() {
    // Encoding: 0xD6F000B0
    // Test aarch32_REVSH_A1_A field combination: cond=13, Rd=0, Rm=0
    // ISET: A32
    // Fields: cond=13, Rd=0, Rm=0
    let encoding: u32 = 0xD6F000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REVSH_A1_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=14 (condition AL (always))
#[test]
fn test_aarch32_revsh_a1_a_combo_14_b0_e6f000b0() {
    // Encoding: 0xE6F000B0
    // Test aarch32_REVSH_A1_A field combination: cond=14, Rd=0, Rm=0
    // ISET: A32
    // Fields: cond=14, Rd=0, Rm=0
    let encoding: u32 = 0xE6F000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REVSH_A1_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=15 (condition NV (never, reserved))
#[test]
fn test_aarch32_revsh_a1_a_combo_15_b0_f6f000b0() {
    // Encoding: 0xF6F000B0
    // Test aarch32_REVSH_A1_A field combination: cond=15, Rd=0, Rm=0
    // ISET: A32
    // Fields: Rd=0, Rm=0, cond=15
    let encoding: u32 = 0xF6F000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REVSH_A1_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch32_revsh_a1_a_combo_16_b0_06f000b0() {
    // Encoding: 0x06F000B0
    // Test aarch32_REVSH_A1_A field combination: cond=0, Rd=0, Rm=0
    // ISET: A32
    // Fields: Rd=0, cond=0, Rm=0
    let encoding: u32 = 0x06F000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REVSH_A1_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch32_revsh_a1_a_combo_17_b0_06f010b0() {
    // Encoding: 0x06F010B0
    // Test aarch32_REVSH_A1_A field combination: cond=0, Rd=1, Rm=0
    // ISET: A32
    // Fields: cond=0, Rd=1, Rm=0
    let encoding: u32 = 0x06F010B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REVSH_A1_A
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch32_revsh_a1_a_combo_18_b0_06f000b0() {
    // Encoding: 0x06F000B0
    // Test aarch32_REVSH_A1_A field combination: cond=0, Rd=0, Rm=0
    // ISET: A32
    // Fields: Rm=0, Rd=0, cond=0
    let encoding: u32 = 0x06F000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REVSH_A1_A
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_aarch32_revsh_a1_a_combo_19_b0_06f000b1() {
    // Encoding: 0x06F000B1
    // Test aarch32_REVSH_A1_A field combination: cond=0, Rd=0, Rm=1
    // ISET: A32
    // Fields: Rd=0, Rm=1, cond=0
    let encoding: u32 = 0x06F000B1;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REVSH_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_revsh_a1_a_special_cond_0_condition_eq_176_06f000b0() {
    // Encoding: 0x06F000B0
    // Test aarch32_REVSH_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: cond=0, Rd=0, Rm=0
    let encoding: u32 = 0x06F000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REVSH_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_revsh_a1_a_special_cond_1_condition_ne_176_16f000b0() {
    // Encoding: 0x16F000B0
    // Test aarch32_REVSH_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: cond=1, Rd=0, Rm=0
    let encoding: u32 = 0x16F000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REVSH_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_revsh_a1_a_special_cond_2_condition_cs_hs_176_26f000b0() {
    // Encoding: 0x26F000B0
    // Test aarch32_REVSH_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: Rm=0, Rd=0, cond=2
    let encoding: u32 = 0x26F000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REVSH_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_revsh_a1_a_special_cond_3_condition_cc_lo_176_36f000b0() {
    // Encoding: 0x36F000B0
    // Test aarch32_REVSH_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: Rm=0, cond=3, Rd=0
    let encoding: u32 = 0x36F000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REVSH_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_revsh_a1_a_special_cond_4_condition_mi_176_46f000b0() {
    // Encoding: 0x46F000B0
    // Test aarch32_REVSH_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: cond=4, Rm=0, Rd=0
    let encoding: u32 = 0x46F000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REVSH_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_revsh_a1_a_special_cond_5_condition_pl_176_56f000b0() {
    // Encoding: 0x56F000B0
    // Test aarch32_REVSH_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: Rd=0, Rm=0, cond=5
    let encoding: u32 = 0x56F000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REVSH_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_revsh_a1_a_special_cond_6_condition_vs_176_66f000b0() {
    // Encoding: 0x66F000B0
    // Test aarch32_REVSH_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: cond=6, Rd=0, Rm=0
    let encoding: u32 = 0x66F000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REVSH_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_revsh_a1_a_special_cond_7_condition_vc_176_76f000b0() {
    // Encoding: 0x76F000B0
    // Test aarch32_REVSH_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: Rd=0, cond=7, Rm=0
    let encoding: u32 = 0x76F000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REVSH_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_revsh_a1_a_special_cond_8_condition_hi_176_86f000b0() {
    // Encoding: 0x86F000B0
    // Test aarch32_REVSH_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: Rd=0, Rm=0, cond=8
    let encoding: u32 = 0x86F000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REVSH_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_revsh_a1_a_special_cond_9_condition_ls_176_96f000b0() {
    // Encoding: 0x96F000B0
    // Test aarch32_REVSH_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: cond=9, Rm=0, Rd=0
    let encoding: u32 = 0x96F000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REVSH_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_revsh_a1_a_special_cond_10_condition_ge_176_a6f000b0() {
    // Encoding: 0xA6F000B0
    // Test aarch32_REVSH_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: cond=10, Rd=0, Rm=0
    let encoding: u32 = 0xA6F000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REVSH_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_revsh_a1_a_special_cond_11_condition_lt_176_b6f000b0() {
    // Encoding: 0xB6F000B0
    // Test aarch32_REVSH_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: cond=11, Rm=0, Rd=0
    let encoding: u32 = 0xB6F000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REVSH_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_revsh_a1_a_special_cond_12_condition_gt_176_c6f000b0() {
    // Encoding: 0xC6F000B0
    // Test aarch32_REVSH_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: Rd=0, Rm=0, cond=12
    let encoding: u32 = 0xC6F000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REVSH_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_revsh_a1_a_special_cond_13_condition_le_176_d6f000b0() {
    // Encoding: 0xD6F000B0
    // Test aarch32_REVSH_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: Rd=0, Rm=0, cond=13
    let encoding: u32 = 0xD6F000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REVSH_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_revsh_a1_a_special_cond_14_condition_al_176_e6f000b0() {
    // Encoding: 0xE6F000B0
    // Test aarch32_REVSH_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: Rm=0, Rd=0, cond=14
    let encoding: u32 = 0xE6F000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REVSH_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_revsh_a1_a_special_cond_15_condition_nv_176_f6f000b0() {
    // Encoding: 0xF6F000B0
    // Test aarch32_REVSH_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: Rd=0, Rm=0, cond=15
    let encoding: u32 = 0xF6F000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REVSH_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_revsh_a1_a_invalid_0_b0_06f000b0() {
    // Encoding: 0x06F000B0
    // Test aarch32_REVSH_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }
    // ISET: A32
    // Fields: Rm=0, cond=0, Rd=0
    let encoding: u32 = 0x06F000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_REVSH_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_revsh_a1_a_invalid_1_b0_06f000b0() {
    // Encoding: 0x06F000B0
    // Test aarch32_REVSH_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Rm=0, cond=0, Rd=0
    let encoding: u32 = 0x06F000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_REVSH_T1_A
/// ASL: `field Rm 19 +: 3`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_revsh_t1_a_field_rm_0_min_0_bac00000() {
    // Thumb encoding (32): 0xBAC00000
    // Test aarch32_REVSH_T1_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: Rm=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xBAC00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_REVSH_T1_A
/// ASL: `field Rm 19 +: 3`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_revsh_t1_a_field_rm_1_poweroftwo_0_bac80000() {
    // Thumb encoding (32): 0xBAC80000
    // Test aarch32_REVSH_T1_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rd=0, Rm=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xBAC80000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_REVSH_T1_A
/// ASL: `field Rd 16 +: 3`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_revsh_t1_a_field_rd_0_min_0_bac00000() {
    // Thumb encoding (32): 0xBAC00000
    // Test aarch32_REVSH_T1_A field Rd = 0 (Min)
    // ISET: T32
    // Fields: Rd=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xBAC00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_REVSH_T1_A
/// ASL: `field Rd 16 +: 3`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_revsh_t1_a_field_rd_1_poweroftwo_0_bac10000() {
    // Thumb encoding (32): 0xBAC10000
    // Test aarch32_REVSH_T1_A field Rd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=0, Rd=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xBAC10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_REVSH_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch32_revsh_t1_a_combo_0_0_bac00000() {
    // Thumb encoding (32): 0xBAC00000
    // Test aarch32_REVSH_T1_A field combination: Rm=0, Rd=0
    // ISET: T32
    // Fields: Rd=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xBAC00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_REVSH_T1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_aarch32_revsh_t1_a_combo_1_0_bac80000() {
    // Thumb encoding (32): 0xBAC80000
    // Test aarch32_REVSH_T1_A field combination: Rm=1, Rd=0
    // ISET: T32
    // Fields: Rd=0, Rm=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xBAC80000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_REVSH_T1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch32_revsh_t1_a_combo_2_0_bac00000() {
    // Thumb encoding (32): 0xBAC00000
    // Test aarch32_REVSH_T1_A field combination: Rm=0, Rd=0
    // ISET: T32
    // Fields: Rd=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xBAC00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_REVSH_T1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch32_revsh_t1_a_combo_3_0_bac10000() {
    // Thumb encoding (32): 0xBAC10000
    // Test aarch32_REVSH_T1_A field combination: Rm=0, Rd=1
    // ISET: T32
    // Fields: Rm=0, Rd=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xBAC10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_REVSH_T1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch32_revsh_t1_a_combo_4_0_bac90000() {
    // Thumb encoding (32): 0xBAC90000
    // Test aarch32_REVSH_T1_A field combination: Rm=1, Rd=1
    // ISET: T32
    // Fields: Rm=1, Rd=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xBAC90000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_REVSH_T1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch32_revsh_t1_a_combo_5_0_baff0000() {
    // Thumb encoding (32): 0xBAFF0000
    // Test aarch32_REVSH_T1_A field combination: Rm=31, Rd=31
    // ISET: T32
    // Fields: Rm=31, Rd=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xBAFF0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_REVSH_T2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_revsh_t2_a_field_rn_0_min_f0b0_fa90f0b0() {
    // Thumb encoding (32): 0xFA90F0B0
    // Test aarch32_REVSH_T2_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rd=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFA90F0B0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_REVSH_T2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_revsh_t2_a_field_rn_1_poweroftwo_f0b0_fa91f0b0() {
    // Thumb encoding (32): 0xFA91F0B0
    // Test aarch32_REVSH_T2_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=0, Rn=1, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFA91F0B0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_REVSH_T2_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_revsh_t2_a_field_rd_0_min_f0b0_fa90f0b0() {
    // Thumb encoding (32): 0xFA90F0B0
    // Test aarch32_REVSH_T2_A field Rd = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rm=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFA90F0B0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_REVSH_T2_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_revsh_t2_a_field_rd_1_poweroftwo_f0b0_fa90f1b0() {
    // Thumb encoding (32): 0xFA90F1B0
    // Test aarch32_REVSH_T2_A field Rd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Rd=1, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFA90F1B0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_REVSH_T2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_revsh_t2_a_field_rm_0_min_f0b0_fa90f0b0() {
    // Thumb encoding (32): 0xFA90F0B0
    // Test aarch32_REVSH_T2_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: Rm=0, Rn=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFA90F0B0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_REVSH_T2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_revsh_t2_a_field_rm_1_poweroftwo_f0b0_fa90f0b1() {
    // Thumb encoding (32): 0xFA90F0B1
    // Test aarch32_REVSH_T2_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rd=0, Rn=0, Rm=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFA90F0B1;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_REVSH_T2_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_revsh_t2_a_combo_0_f0b0_fa90f0b0() {
    // Thumb encoding (32): 0xFA90F0B0
    // Test aarch32_REVSH_T2_A field combination: Rn=0, Rd=0, Rm=0
    // ISET: T32
    // Fields: Rn=0, Rd=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFA90F0B0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_REVSH_T2_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_revsh_t2_a_combo_1_f0b0_fa91f0b0() {
    // Thumb encoding (32): 0xFA91F0B0
    // Test aarch32_REVSH_T2_A field combination: Rn=1, Rd=0, Rm=0
    // ISET: T32
    // Fields: Rd=0, Rn=1, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFA91F0B0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_REVSH_T2_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch32_revsh_t2_a_combo_2_f0b0_fa90f0b0() {
    // Thumb encoding (32): 0xFA90F0B0
    // Test aarch32_REVSH_T2_A field combination: Rn=0, Rd=0, Rm=0
    // ISET: T32
    // Fields: Rn=0, Rm=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFA90F0B0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_REVSH_T2_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch32_revsh_t2_a_combo_3_f0b0_fa90f1b0() {
    // Thumb encoding (32): 0xFA90F1B0
    // Test aarch32_REVSH_T2_A field combination: Rn=0, Rd=1, Rm=0
    // ISET: T32
    // Fields: Rm=0, Rn=0, Rd=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFA90F1B0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_REVSH_T2_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch32_revsh_t2_a_combo_4_f0b0_fa90f0b0() {
    // Thumb encoding (32): 0xFA90F0B0
    // Test aarch32_REVSH_T2_A field combination: Rn=0, Rd=0, Rm=0
    // ISET: T32
    // Fields: Rn=0, Rd=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFA90F0B0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_REVSH_T2_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_aarch32_revsh_t2_a_combo_5_f0b0_fa90f0b1() {
    // Thumb encoding (32): 0xFA90F0B1
    // Test aarch32_REVSH_T2_A field combination: Rn=0, Rd=0, Rm=1
    // ISET: T32
    // Fields: Rm=1, Rd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFA90F0B1;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_REVSH_T2_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch32_revsh_t2_a_combo_6_f0b0_fa91f1b0() {
    // Thumb encoding (32): 0xFA91F1B0
    // Test aarch32_REVSH_T2_A field combination: Rn=1, Rd=1, Rm=0
    // ISET: T32
    // Fields: Rd=1, Rm=0, Rn=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFA91F1B0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_REVSH_T2_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch32_revsh_t2_a_combo_7_f0b0_fa9fffb0() {
    // Thumb encoding (32): 0xFA9FFFB0
    // Test aarch32_REVSH_T2_A field combination: Rn=31, Rd=31, Rm=0
    // ISET: T32
    // Fields: Rn=31, Rm=0, Rd=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFA9FFFB0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_REVSH_T2_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rm=1 (same register test (reg=1))
#[test]
fn test_aarch32_revsh_t2_a_combo_8_f0b0_fa91f0b1() {
    // Thumb encoding (32): 0xFA91F0B1
    // Test aarch32_REVSH_T2_A field combination: Rn=1, Rd=0, Rm=1
    // ISET: T32
    // Fields: Rm=1, Rd=0, Rn=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFA91F0B1;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_REVSH_T2_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rm=31 (same register test (reg=31))
#[test]
fn test_aarch32_revsh_t2_a_combo_9_f0b0_fa9ff0bf() {
    // Thumb encoding (32): 0xFA9FF0BF
    // Test aarch32_REVSH_T2_A field combination: Rn=31, Rd=0, Rm=31
    // ISET: T32
    // Fields: Rn=31, Rm=31, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFA9FF0BF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_REVSH_T2_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (same register test (reg=1)), Rm=1 (same register test (reg=1))
#[test]
fn test_aarch32_revsh_t2_a_combo_10_f0b0_fa90f1b1() {
    // Thumb encoding (32): 0xFA90F1B1
    // Test aarch32_REVSH_T2_A field combination: Rn=0, Rd=1, Rm=1
    // ISET: T32
    // Fields: Rd=1, Rn=0, Rm=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFA90F1B1;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_REVSH_T2_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=31 (same register test (reg=31)), Rm=31 (same register test (reg=31))
#[test]
fn test_aarch32_revsh_t2_a_combo_11_f0b0_fa90ffbf() {
    // Thumb encoding (32): 0xFA90FFBF
    // Test aarch32_REVSH_T2_A field combination: Rn=0, Rd=31, Rm=31
    // ISET: T32
    // Fields: Rn=0, Rd=31, Rm=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFA90FFBF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_REVSH_T2_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }), rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }), rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_revsh_t2_a_invalid_0_f0b0_fa90f0b0() {
    // Thumb encoding (32): 0xFA90F0B0
    // Test aarch32_REVSH_T2_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }), rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }
    // ISET: T32
    // Fields: Rd=0, Rm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFA90F0B0;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_REVSH_T2_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_revsh_t2_a_invalid_1_f0b0_fa90f0b0() {
    // Thumb encoding (32): 0xFA90F0B0
    // Test aarch32_REVSH_T2_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rd=0, Rm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFA90F0B0;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_REVSH_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 0 (32)
#[test]
fn test_aarch32_revsh_t1_a_lslv_oracle_32_0_bac20020() {
    // Test LSLV 32-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x12345678, "W0 should be 0x12345678");
}

/// Provenance: aarch32_REVSH_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 0 (64)
#[test]
fn test_aarch32_revsh_t1_a_lslv_oracle_64_0_bac20020() {
    // Test LSLV 64-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x12345678, "X0 should be 0x0000000012345678");
}

/// Provenance: aarch32_REVSH_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4 (32)
#[test]
fn test_aarch32_revsh_t1_a_lslv_oracle_32_1_bac20020() {
    // Test LSLV 32-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x4);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x23456780, "W0 should be 0x23456780");
}

/// Provenance: aarch32_REVSH_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 4 (64)
#[test]
fn test_aarch32_revsh_t1_a_lslv_oracle_64_1_bac20020() {
    // Test LSLV 64-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x4);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x23456780, "X0 should be 0x0000000123456780");
}

/// Provenance: aarch32_REVSH_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 8 (32)
#[test]
fn test_aarch32_revsh_t1_a_lslv_oracle_32_2_bac20020() {
    // Test LSLV 32-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x8);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x34567800, "W0 should be 0x34567800");
}

/// Provenance: aarch32_REVSH_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 8 (64)
#[test]
fn test_aarch32_revsh_t1_a_lslv_oracle_64_2_bac20020() {
    // Test LSLV 64-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x8);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x34567800, "X0 should be 0x0000001234567800");
}

/// Provenance: aarch32_REVSH_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1 (32)
#[test]
fn test_aarch32_revsh_t1_a_lslv_oracle_32_3_bac20020() {
    // Test LSLV 32-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_REVSH_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// MSB set, shift 1 (64)
#[test]
fn test_aarch32_revsh_t1_a_lslv_oracle_64_3_bac20020() {
    // Test LSLV 64-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_REVSH_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// LSB set, max shift (32)
#[test]
fn test_aarch32_revsh_t1_a_lslv_oracle_32_4_bac20020() {
    // Test LSLV 32-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3F);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "W0 should be 0x80000000");
}

/// Provenance: aarch32_REVSH_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// LSB set, max shift (64)
#[test]
fn test_aarch32_revsh_t1_a_lslv_oracle_64_4_bac20020() {
    // Test LSLV 64-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3F);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x8000000000000000");
}

/// Provenance: aarch32_REVSH_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// all ones, shift 32 (32)
#[test]
fn test_aarch32_revsh_t1_a_lslv_oracle_32_5_bac20020() {
    // Test LSLV 32-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x20);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "W0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_REVSH_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// all ones, shift 32 (64)
#[test]
fn test_aarch32_revsh_t1_a_lslv_oracle_64_5_bac20020() {
    // Test LSLV 64-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x20);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0xFFFFFFFF00000000");
}

/// Provenance: aarch32_REVSH_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// no shift
#[test]
fn test_aarch32_revsh_t1_a_t16_oracle_0_bad00000() {
    // Test T16 LSLS: no shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_REVSH_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4
#[test]
fn test_aarch32_revsh_t1_a_t16_oracle_1_bad00000() {
    // Test T16 LSLS: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x4);
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF0, "R0 should be 0x00000FF0");
}

/// Provenance: aarch32_REVSH_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1
#[test]
fn test_aarch32_revsh_t1_a_t16_oracle_2_bad00000() {
    // Test T16 LSLS: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_REVSH_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift to MSB
#[test]
fn test_aarch32_revsh_t1_a_t16_oracle_3_bad00000() {
    // Test T16 LSLS: shift to MSB (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x1F);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "R0 should be 0x80000000");
}

// ============================================================================
// aarch32_RBIT_A Tests
// ============================================================================

/// Provenance: aarch32_RBIT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_rbit_a1_a_field_cond_0_min_30_06f00030() {
    // Encoding: 0x06F00030
    // Test aarch32_RBIT_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rd=0, Rm=0
    let encoding: u32 = 0x06F00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_RBIT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_rbit_a1_a_field_cond_1_poweroftwo_30_16f00030() {
    // Encoding: 0x16F00030
    // Test aarch32_RBIT_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Rd=0, cond=1
    let encoding: u32 = 0x16F00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_RBIT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_rbit_a1_a_field_cond_2_poweroftwo_30_26f00030() {
    // Encoding: 0x26F00030
    // Test aarch32_RBIT_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=2, Rm=0, Rd=0
    let encoding: u32 = 0x26F00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_RBIT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_rbit_a1_a_field_cond_3_poweroftwo_30_36f00030() {
    // Encoding: 0x36F00030
    // Test aarch32_RBIT_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, cond=3, Rd=0
    let encoding: u32 = 0x36F00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_RBIT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_rbit_a1_a_field_cond_4_poweroftwo_30_46f00030() {
    // Encoding: 0x46F00030
    // Test aarch32_RBIT_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=4, Rm=0, Rd=0
    let encoding: u32 = 0x46F00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_RBIT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_rbit_a1_a_field_cond_5_poweroftwo_30_56f00030() {
    // Encoding: 0x56F00030
    // Test aarch32_RBIT_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, cond=5, Rd=0
    let encoding: u32 = 0x56F00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_RBIT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_rbit_a1_a_field_cond_6_poweroftwo_30_66f00030() {
    // Encoding: 0x66F00030
    // Test aarch32_RBIT_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, cond=6, Rm=0
    let encoding: u32 = 0x66F00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_RBIT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_rbit_a1_a_field_cond_7_poweroftwo_30_76f00030() {
    // Encoding: 0x76F00030
    // Test aarch32_RBIT_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rm=0, cond=7
    let encoding: u32 = 0x76F00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_RBIT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_rbit_a1_a_field_cond_8_poweroftwo_30_86f00030() {
    // Encoding: 0x86F00030
    // Test aarch32_RBIT_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, cond=8, Rm=0
    let encoding: u32 = 0x86F00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_RBIT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_rbit_a1_a_field_cond_9_poweroftwo_30_96f00030() {
    // Encoding: 0x96F00030
    // Test aarch32_RBIT_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=9, Rd=0, Rm=0
    let encoding: u32 = 0x96F00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_RBIT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_rbit_a1_a_field_cond_10_poweroftwo_30_a6f00030() {
    // Encoding: 0xA6F00030
    // Test aarch32_RBIT_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=10, Rd=0, Rm=0
    let encoding: u32 = 0xA6F00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_RBIT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_rbit_a1_a_field_cond_11_poweroftwo_30_b6f00030() {
    // Encoding: 0xB6F00030
    // Test aarch32_RBIT_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, cond=11, Rm=0
    let encoding: u32 = 0xB6F00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_RBIT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_rbit_a1_a_field_cond_12_poweroftwo_30_c6f00030() {
    // Encoding: 0xC6F00030
    // Test aarch32_RBIT_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, cond=12, Rd=0
    let encoding: u32 = 0xC6F00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_RBIT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_rbit_a1_a_field_cond_13_poweroftwo_30_d6f00030() {
    // Encoding: 0xD6F00030
    // Test aarch32_RBIT_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rm=0, cond=13
    let encoding: u32 = 0xD6F00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_RBIT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_rbit_a1_a_field_cond_14_poweroftwo_30_e6f00030() {
    // Encoding: 0xE6F00030
    // Test aarch32_RBIT_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=14, Rm=0, Rd=0
    let encoding: u32 = 0xE6F00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_RBIT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_rbit_a1_a_field_cond_15_max_30_f6f00030() {
    // Encoding: 0xF6F00030
    // Test aarch32_RBIT_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: cond=15, Rm=0, Rd=0
    let encoding: u32 = 0xF6F00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_RBIT_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_rbit_a1_a_field_rd_0_min_30_06f00030() {
    // Encoding: 0x06F00030
    // Test aarch32_RBIT_A1_A field Rd = 0 (Min)
    // ISET: A32
    // Fields: Rd=0, cond=0, Rm=0
    let encoding: u32 = 0x06F00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_RBIT_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_rbit_a1_a_field_rd_1_poweroftwo_30_06f01030() {
    // Encoding: 0x06F01030
    // Test aarch32_RBIT_A1_A field Rd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Rd=1, Rm=0
    let encoding: u32 = 0x06F01030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_RBIT_A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_rbit_a1_a_field_rm_0_min_30_06f00030() {
    // Encoding: 0x06F00030
    // Test aarch32_RBIT_A1_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: Rd=0, cond=0, Rm=0
    let encoding: u32 = 0x06F00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_RBIT_A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_rbit_a1_a_field_rm_1_poweroftwo_30_06f00031() {
    // Encoding: 0x06F00031
    // Test aarch32_RBIT_A1_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rm=1, cond=0
    let encoding: u32 = 0x06F00031;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_RBIT_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_rbit_a1_a_combo_0_30_06f00030() {
    // Encoding: 0x06F00030
    // Test aarch32_RBIT_A1_A field combination: cond=0, Rd=0, Rm=0
    // ISET: A32
    // Fields: cond=0, Rm=0, Rd=0
    let encoding: u32 = 0x06F00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_RBIT_A1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=1 (condition NE (not equal))
#[test]
fn test_aarch32_rbit_a1_a_combo_1_30_16f00030() {
    // Encoding: 0x16F00030
    // Test aarch32_RBIT_A1_A field combination: cond=1, Rd=0, Rm=0
    // ISET: A32
    // Fields: cond=1, Rm=0, Rd=0
    let encoding: u32 = 0x16F00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_RBIT_A1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=2 (condition CS/HS (carry set))
#[test]
fn test_aarch32_rbit_a1_a_combo_2_30_26f00030() {
    // Encoding: 0x26F00030
    // Test aarch32_RBIT_A1_A field combination: cond=2, Rd=0, Rm=0
    // ISET: A32
    // Fields: Rd=0, cond=2, Rm=0
    let encoding: u32 = 0x26F00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_RBIT_A1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=3 (condition CC/LO (carry clear))
#[test]
fn test_aarch32_rbit_a1_a_combo_3_30_36f00030() {
    // Encoding: 0x36F00030
    // Test aarch32_RBIT_A1_A field combination: cond=3, Rd=0, Rm=0
    // ISET: A32
    // Fields: cond=3, Rd=0, Rm=0
    let encoding: u32 = 0x36F00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_RBIT_A1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=4 (condition MI (minus/negative))
#[test]
fn test_aarch32_rbit_a1_a_combo_4_30_46f00030() {
    // Encoding: 0x46F00030
    // Test aarch32_RBIT_A1_A field combination: cond=4, Rd=0, Rm=0
    // ISET: A32
    // Fields: Rm=0, Rd=0, cond=4
    let encoding: u32 = 0x46F00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_RBIT_A1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=5 (condition PL (plus/positive))
#[test]
fn test_aarch32_rbit_a1_a_combo_5_30_56f00030() {
    // Encoding: 0x56F00030
    // Test aarch32_RBIT_A1_A field combination: cond=5, Rd=0, Rm=0
    // ISET: A32
    // Fields: cond=5, Rd=0, Rm=0
    let encoding: u32 = 0x56F00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_RBIT_A1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=6 (condition VS (overflow set))
#[test]
fn test_aarch32_rbit_a1_a_combo_6_30_66f00030() {
    // Encoding: 0x66F00030
    // Test aarch32_RBIT_A1_A field combination: cond=6, Rd=0, Rm=0
    // ISET: A32
    // Fields: Rm=0, cond=6, Rd=0
    let encoding: u32 = 0x66F00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_RBIT_A1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=7 (condition VC (overflow clear))
#[test]
fn test_aarch32_rbit_a1_a_combo_7_30_76f00030() {
    // Encoding: 0x76F00030
    // Test aarch32_RBIT_A1_A field combination: cond=7, Rd=0, Rm=0
    // ISET: A32
    // Fields: Rd=0, Rm=0, cond=7
    let encoding: u32 = 0x76F00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_RBIT_A1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=8 (condition HI (unsigned higher))
#[test]
fn test_aarch32_rbit_a1_a_combo_8_30_86f00030() {
    // Encoding: 0x86F00030
    // Test aarch32_RBIT_A1_A field combination: cond=8, Rd=0, Rm=0
    // ISET: A32
    // Fields: cond=8, Rm=0, Rd=0
    let encoding: u32 = 0x86F00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_RBIT_A1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=9 (condition LS (unsigned lower or same))
#[test]
fn test_aarch32_rbit_a1_a_combo_9_30_96f00030() {
    // Encoding: 0x96F00030
    // Test aarch32_RBIT_A1_A field combination: cond=9, Rd=0, Rm=0
    // ISET: A32
    // Fields: Rd=0, Rm=0, cond=9
    let encoding: u32 = 0x96F00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_RBIT_A1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=10 (condition GE (signed >=))
#[test]
fn test_aarch32_rbit_a1_a_combo_10_30_a6f00030() {
    // Encoding: 0xA6F00030
    // Test aarch32_RBIT_A1_A field combination: cond=10, Rd=0, Rm=0
    // ISET: A32
    // Fields: Rd=0, Rm=0, cond=10
    let encoding: u32 = 0xA6F00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_RBIT_A1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=11 (condition LT (signed <))
#[test]
fn test_aarch32_rbit_a1_a_combo_11_30_b6f00030() {
    // Encoding: 0xB6F00030
    // Test aarch32_RBIT_A1_A field combination: cond=11, Rd=0, Rm=0
    // ISET: A32
    // Fields: cond=11, Rm=0, Rd=0
    let encoding: u32 = 0xB6F00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_RBIT_A1_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=12 (condition GT (signed >))
#[test]
fn test_aarch32_rbit_a1_a_combo_12_30_c6f00030() {
    // Encoding: 0xC6F00030
    // Test aarch32_RBIT_A1_A field combination: cond=12, Rd=0, Rm=0
    // ISET: A32
    // Fields: Rm=0, Rd=0, cond=12
    let encoding: u32 = 0xC6F00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_RBIT_A1_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=13 (condition LE (signed <=))
#[test]
fn test_aarch32_rbit_a1_a_combo_13_30_d6f00030() {
    // Encoding: 0xD6F00030
    // Test aarch32_RBIT_A1_A field combination: cond=13, Rd=0, Rm=0
    // ISET: A32
    // Fields: Rd=0, cond=13, Rm=0
    let encoding: u32 = 0xD6F00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_RBIT_A1_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=14 (condition AL (always))
#[test]
fn test_aarch32_rbit_a1_a_combo_14_30_e6f00030() {
    // Encoding: 0xE6F00030
    // Test aarch32_RBIT_A1_A field combination: cond=14, Rd=0, Rm=0
    // ISET: A32
    // Fields: Rd=0, Rm=0, cond=14
    let encoding: u32 = 0xE6F00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_RBIT_A1_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=15 (condition NV (never, reserved))
#[test]
fn test_aarch32_rbit_a1_a_combo_15_30_f6f00030() {
    // Encoding: 0xF6F00030
    // Test aarch32_RBIT_A1_A field combination: cond=15, Rd=0, Rm=0
    // ISET: A32
    // Fields: cond=15, Rd=0, Rm=0
    let encoding: u32 = 0xF6F00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_RBIT_A1_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch32_rbit_a1_a_combo_16_30_06f00030() {
    // Encoding: 0x06F00030
    // Test aarch32_RBIT_A1_A field combination: cond=0, Rd=0, Rm=0
    // ISET: A32
    // Fields: cond=0, Rm=0, Rd=0
    let encoding: u32 = 0x06F00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_RBIT_A1_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch32_rbit_a1_a_combo_17_30_06f01030() {
    // Encoding: 0x06F01030
    // Test aarch32_RBIT_A1_A field combination: cond=0, Rd=1, Rm=0
    // ISET: A32
    // Fields: Rm=0, cond=0, Rd=1
    let encoding: u32 = 0x06F01030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_RBIT_A1_A
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch32_rbit_a1_a_combo_18_30_06f00030() {
    // Encoding: 0x06F00030
    // Test aarch32_RBIT_A1_A field combination: cond=0, Rd=0, Rm=0
    // ISET: A32
    // Fields: Rm=0, cond=0, Rd=0
    let encoding: u32 = 0x06F00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_RBIT_A1_A
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_aarch32_rbit_a1_a_combo_19_30_06f00031() {
    // Encoding: 0x06F00031
    // Test aarch32_RBIT_A1_A field combination: cond=0, Rd=0, Rm=1
    // ISET: A32
    // Fields: cond=0, Rm=1, Rd=0
    let encoding: u32 = 0x06F00031;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_RBIT_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_rbit_a1_a_special_cond_0_condition_eq_48_06f00030() {
    // Encoding: 0x06F00030
    // Test aarch32_RBIT_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: Rd=0, cond=0, Rm=0
    let encoding: u32 = 0x06F00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_RBIT_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_rbit_a1_a_special_cond_1_condition_ne_48_16f00030() {
    // Encoding: 0x16F00030
    // Test aarch32_RBIT_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: Rm=0, cond=1, Rd=0
    let encoding: u32 = 0x16F00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_RBIT_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_rbit_a1_a_special_cond_2_condition_cs_hs_48_26f00030() {
    // Encoding: 0x26F00030
    // Test aarch32_RBIT_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: Rd=0, cond=2, Rm=0
    let encoding: u32 = 0x26F00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_RBIT_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_rbit_a1_a_special_cond_3_condition_cc_lo_48_36f00030() {
    // Encoding: 0x36F00030
    // Test aarch32_RBIT_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: cond=3, Rd=0, Rm=0
    let encoding: u32 = 0x36F00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_RBIT_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_rbit_a1_a_special_cond_4_condition_mi_48_46f00030() {
    // Encoding: 0x46F00030
    // Test aarch32_RBIT_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: Rd=0, cond=4, Rm=0
    let encoding: u32 = 0x46F00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_RBIT_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_rbit_a1_a_special_cond_5_condition_pl_48_56f00030() {
    // Encoding: 0x56F00030
    // Test aarch32_RBIT_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: cond=5, Rd=0, Rm=0
    let encoding: u32 = 0x56F00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_RBIT_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_rbit_a1_a_special_cond_6_condition_vs_48_66f00030() {
    // Encoding: 0x66F00030
    // Test aarch32_RBIT_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: Rm=0, cond=6, Rd=0
    let encoding: u32 = 0x66F00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_RBIT_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_rbit_a1_a_special_cond_7_condition_vc_48_76f00030() {
    // Encoding: 0x76F00030
    // Test aarch32_RBIT_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: Rd=0, Rm=0, cond=7
    let encoding: u32 = 0x76F00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_RBIT_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_rbit_a1_a_special_cond_8_condition_hi_48_86f00030() {
    // Encoding: 0x86F00030
    // Test aarch32_RBIT_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: Rd=0, Rm=0, cond=8
    let encoding: u32 = 0x86F00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_RBIT_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_rbit_a1_a_special_cond_9_condition_ls_48_96f00030() {
    // Encoding: 0x96F00030
    // Test aarch32_RBIT_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: cond=9, Rm=0, Rd=0
    let encoding: u32 = 0x96F00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_RBIT_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_rbit_a1_a_special_cond_10_condition_ge_48_a6f00030() {
    // Encoding: 0xA6F00030
    // Test aarch32_RBIT_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: Rm=0, Rd=0, cond=10
    let encoding: u32 = 0xA6F00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_RBIT_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_rbit_a1_a_special_cond_11_condition_lt_48_b6f00030() {
    // Encoding: 0xB6F00030
    // Test aarch32_RBIT_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: Rm=0, cond=11, Rd=0
    let encoding: u32 = 0xB6F00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_RBIT_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_rbit_a1_a_special_cond_12_condition_gt_48_c6f00030() {
    // Encoding: 0xC6F00030
    // Test aarch32_RBIT_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: Rd=0, Rm=0, cond=12
    let encoding: u32 = 0xC6F00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_RBIT_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_rbit_a1_a_special_cond_13_condition_le_48_d6f00030() {
    // Encoding: 0xD6F00030
    // Test aarch32_RBIT_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: Rm=0, cond=13, Rd=0
    let encoding: u32 = 0xD6F00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_RBIT_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_rbit_a1_a_special_cond_14_condition_al_48_e6f00030() {
    // Encoding: 0xE6F00030
    // Test aarch32_RBIT_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: cond=14, Rm=0, Rd=0
    let encoding: u32 = 0xE6F00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_RBIT_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_rbit_a1_a_special_cond_15_condition_nv_48_f6f00030() {
    // Encoding: 0xF6F00030
    // Test aarch32_RBIT_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: Rm=0, cond=15, Rd=0
    let encoding: u32 = 0xF6F00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_RBIT_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_rbit_a1_a_invalid_0_30_06f00030() {
    // Encoding: 0x06F00030
    // Test aarch32_RBIT_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }
    // ISET: A32
    // Fields: Rm=0, Rd=0, cond=0
    let encoding: u32 = 0x06F00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_RBIT_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_rbit_a1_a_invalid_1_30_06f00030() {
    // Encoding: 0x06F00030
    // Test aarch32_RBIT_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Rm=0, cond=0, Rd=0
    let encoding: u32 = 0x06F00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_RBIT_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_rbit_t1_a_field_rn_0_min_f0a0_fa90f0a0() {
    // Thumb encoding (32): 0xFA90F0A0
    // Test aarch32_RBIT_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rm=0, Rd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFA90F0A0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_RBIT_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_rbit_t1_a_field_rn_1_poweroftwo_f0a0_fa91f0a0() {
    // Thumb encoding (32): 0xFA91F0A0
    // Test aarch32_RBIT_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rd=0, Rm=0, Rn=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFA91F0A0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_RBIT_T1_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_rbit_t1_a_field_rd_0_min_f0a0_fa90f0a0() {
    // Thumb encoding (32): 0xFA90F0A0
    // Test aarch32_RBIT_T1_A field Rd = 0 (Min)
    // ISET: T32
    // Fields: Rm=0, Rd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFA90F0A0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_RBIT_T1_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_rbit_t1_a_field_rd_1_poweroftwo_f0a0_fa90f1a0() {
    // Thumb encoding (32): 0xFA90F1A0
    // Test aarch32_RBIT_T1_A field Rd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Rd=1, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFA90F1A0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_RBIT_T1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_rbit_t1_a_field_rm_0_min_f0a0_fa90f0a0() {
    // Thumb encoding (32): 0xFA90F0A0
    // Test aarch32_RBIT_T1_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: Rm=0, Rn=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFA90F0A0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_RBIT_T1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_rbit_t1_a_field_rm_1_poweroftwo_f0a0_fa90f0a1() {
    // Thumb encoding (32): 0xFA90F0A1
    // Test aarch32_RBIT_T1_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Rd=0, Rm=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFA90F0A1;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_RBIT_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_rbit_t1_a_combo_0_f0a0_fa90f0a0() {
    // Thumb encoding (32): 0xFA90F0A0
    // Test aarch32_RBIT_T1_A field combination: Rn=0, Rd=0, Rm=0
    // ISET: T32
    // Fields: Rm=0, Rn=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFA90F0A0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_RBIT_T1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_rbit_t1_a_combo_1_f0a0_fa91f0a0() {
    // Thumb encoding (32): 0xFA91F0A0
    // Test aarch32_RBIT_T1_A field combination: Rn=1, Rd=0, Rm=0
    // ISET: T32
    // Fields: Rn=1, Rm=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFA91F0A0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_RBIT_T1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch32_rbit_t1_a_combo_2_f0a0_fa90f0a0() {
    // Thumb encoding (32): 0xFA90F0A0
    // Test aarch32_RBIT_T1_A field combination: Rn=0, Rd=0, Rm=0
    // ISET: T32
    // Fields: Rd=0, Rm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFA90F0A0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_RBIT_T1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch32_rbit_t1_a_combo_3_f0a0_fa90f1a0() {
    // Thumb encoding (32): 0xFA90F1A0
    // Test aarch32_RBIT_T1_A field combination: Rn=0, Rd=1, Rm=0
    // ISET: T32
    // Fields: Rn=0, Rd=1, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFA90F1A0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_RBIT_T1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch32_rbit_t1_a_combo_4_f0a0_fa90f0a0() {
    // Thumb encoding (32): 0xFA90F0A0
    // Test aarch32_RBIT_T1_A field combination: Rn=0, Rd=0, Rm=0
    // ISET: T32
    // Fields: Rd=0, Rm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFA90F0A0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_RBIT_T1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_aarch32_rbit_t1_a_combo_5_f0a0_fa90f0a1() {
    // Thumb encoding (32): 0xFA90F0A1
    // Test aarch32_RBIT_T1_A field combination: Rn=0, Rd=0, Rm=1
    // ISET: T32
    // Fields: Rm=1, Rn=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFA90F0A1;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_RBIT_T1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch32_rbit_t1_a_combo_6_f0a0_fa91f1a0() {
    // Thumb encoding (32): 0xFA91F1A0
    // Test aarch32_RBIT_T1_A field combination: Rn=1, Rd=1, Rm=0
    // ISET: T32
    // Fields: Rd=1, Rn=1, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFA91F1A0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_RBIT_T1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch32_rbit_t1_a_combo_7_f0a0_fa9fffa0() {
    // Thumb encoding (32): 0xFA9FFFA0
    // Test aarch32_RBIT_T1_A field combination: Rn=31, Rd=31, Rm=0
    // ISET: T32
    // Fields: Rn=31, Rd=31, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFA9FFFA0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_RBIT_T1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rm=1 (same register test (reg=1))
#[test]
fn test_aarch32_rbit_t1_a_combo_8_f0a0_fa91f0a1() {
    // Thumb encoding (32): 0xFA91F0A1
    // Test aarch32_RBIT_T1_A field combination: Rn=1, Rd=0, Rm=1
    // ISET: T32
    // Fields: Rm=1, Rn=1, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFA91F0A1;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_RBIT_T1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rm=31 (same register test (reg=31))
#[test]
fn test_aarch32_rbit_t1_a_combo_9_f0a0_fa9ff0af() {
    // Thumb encoding (32): 0xFA9FF0AF
    // Test aarch32_RBIT_T1_A field combination: Rn=31, Rd=0, Rm=31
    // ISET: T32
    // Fields: Rm=31, Rn=31, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFA9FF0AF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_RBIT_T1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (same register test (reg=1)), Rm=1 (same register test (reg=1))
#[test]
fn test_aarch32_rbit_t1_a_combo_10_f0a0_fa90f1a1() {
    // Thumb encoding (32): 0xFA90F1A1
    // Test aarch32_RBIT_T1_A field combination: Rn=0, Rd=1, Rm=1
    // ISET: T32
    // Fields: Rm=1, Rd=1, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFA90F1A1;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_RBIT_T1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=31 (same register test (reg=31)), Rm=31 (same register test (reg=31))
#[test]
fn test_aarch32_rbit_t1_a_combo_11_f0a0_fa90ffaf() {
    // Thumb encoding (32): 0xFA90FFAF
    // Test aarch32_RBIT_T1_A field combination: Rn=0, Rd=31, Rm=31
    // ISET: T32
    // Fields: Rn=0, Rd=31, Rm=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFA90FFAF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_RBIT_T1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }), rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }), rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_rbit_t1_a_invalid_0_f0a0_fa90f0a0() {
    // Thumb encoding (32): 0xFA90F0A0
    // Test aarch32_RBIT_T1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }), rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }
    // ISET: T32
    // Fields: Rd=0, Rm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFA90F0A0;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_RBIT_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_rbit_t1_a_invalid_1_f0a0_fa90f0a0() {
    // Thumb encoding (32): 0xFA90F0A0
    // Test aarch32_RBIT_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rn=0, Rd=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFA90F0A0;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

// ============================================================================
// aarch32_CLZ_A Tests
// ============================================================================

/// Provenance: aarch32_CLZ_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_clz_a1_a_field_cond_0_min_10_01600010() {
    // Encoding: 0x01600010
    // Test aarch32_CLZ_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: Rd=0, cond=0, Rm=0
    let encoding: u32 = 0x01600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_CLZ_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_clz_a1_a_field_cond_1_poweroftwo_10_11600010() {
    // Encoding: 0x11600010
    // Test aarch32_CLZ_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=1, Rm=0, Rd=0
    let encoding: u32 = 0x11600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_CLZ_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_clz_a1_a_field_cond_2_poweroftwo_10_21600010() {
    // Encoding: 0x21600010
    // Test aarch32_CLZ_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, cond=2, Rm=0
    let encoding: u32 = 0x21600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_CLZ_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_clz_a1_a_field_cond_3_poweroftwo_10_31600010() {
    // Encoding: 0x31600010
    // Test aarch32_CLZ_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, cond=3, Rd=0
    let encoding: u32 = 0x31600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_CLZ_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_clz_a1_a_field_cond_4_poweroftwo_10_41600010() {
    // Encoding: 0x41600010
    // Test aarch32_CLZ_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=4, Rd=0, Rm=0
    let encoding: u32 = 0x41600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_CLZ_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_clz_a1_a_field_cond_5_poweroftwo_10_51600010() {
    // Encoding: 0x51600010
    // Test aarch32_CLZ_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, cond=5, Rm=0
    let encoding: u32 = 0x51600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_CLZ_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_clz_a1_a_field_cond_6_poweroftwo_10_61600010() {
    // Encoding: 0x61600010
    // Test aarch32_CLZ_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, cond=6, Rd=0
    let encoding: u32 = 0x61600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_CLZ_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_clz_a1_a_field_cond_7_poweroftwo_10_71600010() {
    // Encoding: 0x71600010
    // Test aarch32_CLZ_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rm=0, cond=7
    let encoding: u32 = 0x71600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_CLZ_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_clz_a1_a_field_cond_8_poweroftwo_10_81600010() {
    // Encoding: 0x81600010
    // Test aarch32_CLZ_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=8, Rm=0, Rd=0
    let encoding: u32 = 0x81600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_CLZ_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_clz_a1_a_field_cond_9_poweroftwo_10_91600010() {
    // Encoding: 0x91600010
    // Test aarch32_CLZ_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=9, Rm=0, Rd=0
    let encoding: u32 = 0x91600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_CLZ_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_clz_a1_a_field_cond_10_poweroftwo_10_a1600010() {
    // Encoding: 0xA1600010
    // Test aarch32_CLZ_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Rd=0, cond=10
    let encoding: u32 = 0xA1600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_CLZ_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_clz_a1_a_field_cond_11_poweroftwo_10_b1600010() {
    // Encoding: 0xB1600010
    // Test aarch32_CLZ_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rm=0, cond=11
    let encoding: u32 = 0xB1600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_CLZ_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_clz_a1_a_field_cond_12_poweroftwo_10_c1600010() {
    // Encoding: 0xC1600010
    // Test aarch32_CLZ_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, cond=12, Rd=0
    let encoding: u32 = 0xC1600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_CLZ_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_clz_a1_a_field_cond_13_poweroftwo_10_d1600010() {
    // Encoding: 0xD1600010
    // Test aarch32_CLZ_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rm=0, cond=13
    let encoding: u32 = 0xD1600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_CLZ_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_clz_a1_a_field_cond_14_poweroftwo_10_e1600010() {
    // Encoding: 0xE1600010
    // Test aarch32_CLZ_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Rd=0, cond=14
    let encoding: u32 = 0xE1600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_CLZ_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_clz_a1_a_field_cond_15_max_10_f1600010() {
    // Encoding: 0xF1600010
    // Test aarch32_CLZ_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: cond=15, Rd=0, Rm=0
    let encoding: u32 = 0xF1600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_CLZ_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_clz_a1_a_field_rd_0_min_10_01600010() {
    // Encoding: 0x01600010
    // Test aarch32_CLZ_A1_A field Rd = 0 (Min)
    // ISET: A32
    // Fields: Rd=0, cond=0, Rm=0
    let encoding: u32 = 0x01600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_CLZ_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_clz_a1_a_field_rd_1_poweroftwo_10_01601010() {
    // Encoding: 0x01601010
    // Test aarch32_CLZ_A1_A field Rd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Rm=0, Rd=1
    let encoding: u32 = 0x01601010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_CLZ_A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_clz_a1_a_field_rm_0_min_10_01600010() {
    // Encoding: 0x01600010
    // Test aarch32_CLZ_A1_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: Rd=0, cond=0, Rm=0
    let encoding: u32 = 0x01600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_CLZ_A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_clz_a1_a_field_rm_1_poweroftwo_10_01600011() {
    // Encoding: 0x01600011
    // Test aarch32_CLZ_A1_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=1, Rd=0, cond=0
    let encoding: u32 = 0x01600011;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_CLZ_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_clz_a1_a_combo_0_10_01600010() {
    // Encoding: 0x01600010
    // Test aarch32_CLZ_A1_A field combination: cond=0, Rd=0, Rm=0
    // ISET: A32
    // Fields: Rm=0, cond=0, Rd=0
    let encoding: u32 = 0x01600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_CLZ_A1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=1 (condition NE (not equal))
#[test]
fn test_aarch32_clz_a1_a_combo_1_10_11600010() {
    // Encoding: 0x11600010
    // Test aarch32_CLZ_A1_A field combination: cond=1, Rd=0, Rm=0
    // ISET: A32
    // Fields: Rd=0, Rm=0, cond=1
    let encoding: u32 = 0x11600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_CLZ_A1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=2 (condition CS/HS (carry set))
#[test]
fn test_aarch32_clz_a1_a_combo_2_10_21600010() {
    // Encoding: 0x21600010
    // Test aarch32_CLZ_A1_A field combination: cond=2, Rd=0, Rm=0
    // ISET: A32
    // Fields: cond=2, Rd=0, Rm=0
    let encoding: u32 = 0x21600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_CLZ_A1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=3 (condition CC/LO (carry clear))
#[test]
fn test_aarch32_clz_a1_a_combo_3_10_31600010() {
    // Encoding: 0x31600010
    // Test aarch32_CLZ_A1_A field combination: cond=3, Rd=0, Rm=0
    // ISET: A32
    // Fields: cond=3, Rm=0, Rd=0
    let encoding: u32 = 0x31600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_CLZ_A1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=4 (condition MI (minus/negative))
#[test]
fn test_aarch32_clz_a1_a_combo_4_10_41600010() {
    // Encoding: 0x41600010
    // Test aarch32_CLZ_A1_A field combination: cond=4, Rd=0, Rm=0
    // ISET: A32
    // Fields: cond=4, Rm=0, Rd=0
    let encoding: u32 = 0x41600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_CLZ_A1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=5 (condition PL (plus/positive))
#[test]
fn test_aarch32_clz_a1_a_combo_5_10_51600010() {
    // Encoding: 0x51600010
    // Test aarch32_CLZ_A1_A field combination: cond=5, Rd=0, Rm=0
    // ISET: A32
    // Fields: Rm=0, Rd=0, cond=5
    let encoding: u32 = 0x51600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_CLZ_A1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=6 (condition VS (overflow set))
#[test]
fn test_aarch32_clz_a1_a_combo_6_10_61600010() {
    // Encoding: 0x61600010
    // Test aarch32_CLZ_A1_A field combination: cond=6, Rd=0, Rm=0
    // ISET: A32
    // Fields: cond=6, Rm=0, Rd=0
    let encoding: u32 = 0x61600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_CLZ_A1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=7 (condition VC (overflow clear))
#[test]
fn test_aarch32_clz_a1_a_combo_7_10_71600010() {
    // Encoding: 0x71600010
    // Test aarch32_CLZ_A1_A field combination: cond=7, Rd=0, Rm=0
    // ISET: A32
    // Fields: Rm=0, Rd=0, cond=7
    let encoding: u32 = 0x71600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_CLZ_A1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=8 (condition HI (unsigned higher))
#[test]
fn test_aarch32_clz_a1_a_combo_8_10_81600010() {
    // Encoding: 0x81600010
    // Test aarch32_CLZ_A1_A field combination: cond=8, Rd=0, Rm=0
    // ISET: A32
    // Fields: cond=8, Rd=0, Rm=0
    let encoding: u32 = 0x81600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_CLZ_A1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=9 (condition LS (unsigned lower or same))
#[test]
fn test_aarch32_clz_a1_a_combo_9_10_91600010() {
    // Encoding: 0x91600010
    // Test aarch32_CLZ_A1_A field combination: cond=9, Rd=0, Rm=0
    // ISET: A32
    // Fields: cond=9, Rd=0, Rm=0
    let encoding: u32 = 0x91600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_CLZ_A1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=10 (condition GE (signed >=))
#[test]
fn test_aarch32_clz_a1_a_combo_10_10_a1600010() {
    // Encoding: 0xA1600010
    // Test aarch32_CLZ_A1_A field combination: cond=10, Rd=0, Rm=0
    // ISET: A32
    // Fields: Rm=0, Rd=0, cond=10
    let encoding: u32 = 0xA1600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_CLZ_A1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=11 (condition LT (signed <))
#[test]
fn test_aarch32_clz_a1_a_combo_11_10_b1600010() {
    // Encoding: 0xB1600010
    // Test aarch32_CLZ_A1_A field combination: cond=11, Rd=0, Rm=0
    // ISET: A32
    // Fields: Rm=0, Rd=0, cond=11
    let encoding: u32 = 0xB1600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_CLZ_A1_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=12 (condition GT (signed >))
#[test]
fn test_aarch32_clz_a1_a_combo_12_10_c1600010() {
    // Encoding: 0xC1600010
    // Test aarch32_CLZ_A1_A field combination: cond=12, Rd=0, Rm=0
    // ISET: A32
    // Fields: Rm=0, cond=12, Rd=0
    let encoding: u32 = 0xC1600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_CLZ_A1_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=13 (condition LE (signed <=))
#[test]
fn test_aarch32_clz_a1_a_combo_13_10_d1600010() {
    // Encoding: 0xD1600010
    // Test aarch32_CLZ_A1_A field combination: cond=13, Rd=0, Rm=0
    // ISET: A32
    // Fields: Rd=0, Rm=0, cond=13
    let encoding: u32 = 0xD1600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_CLZ_A1_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=14 (condition AL (always))
#[test]
fn test_aarch32_clz_a1_a_combo_14_10_e1600010() {
    // Encoding: 0xE1600010
    // Test aarch32_CLZ_A1_A field combination: cond=14, Rd=0, Rm=0
    // ISET: A32
    // Fields: Rm=0, cond=14, Rd=0
    let encoding: u32 = 0xE1600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_CLZ_A1_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=15 (condition NV (never, reserved))
#[test]
fn test_aarch32_clz_a1_a_combo_15_10_f1600010() {
    // Encoding: 0xF1600010
    // Test aarch32_CLZ_A1_A field combination: cond=15, Rd=0, Rm=0
    // ISET: A32
    // Fields: cond=15, Rd=0, Rm=0
    let encoding: u32 = 0xF1600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_CLZ_A1_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch32_clz_a1_a_combo_16_10_01600010() {
    // Encoding: 0x01600010
    // Test aarch32_CLZ_A1_A field combination: cond=0, Rd=0, Rm=0
    // ISET: A32
    // Fields: cond=0, Rd=0, Rm=0
    let encoding: u32 = 0x01600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_CLZ_A1_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch32_clz_a1_a_combo_17_10_01601010() {
    // Encoding: 0x01601010
    // Test aarch32_CLZ_A1_A field combination: cond=0, Rd=1, Rm=0
    // ISET: A32
    // Fields: cond=0, Rd=1, Rm=0
    let encoding: u32 = 0x01601010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_CLZ_A1_A
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch32_clz_a1_a_combo_18_10_01600010() {
    // Encoding: 0x01600010
    // Test aarch32_CLZ_A1_A field combination: cond=0, Rd=0, Rm=0
    // ISET: A32
    // Fields: Rd=0, Rm=0, cond=0
    let encoding: u32 = 0x01600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_CLZ_A1_A
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_aarch32_clz_a1_a_combo_19_10_01600011() {
    // Encoding: 0x01600011
    // Test aarch32_CLZ_A1_A field combination: cond=0, Rd=0, Rm=1
    // ISET: A32
    // Fields: Rm=1, cond=0, Rd=0
    let encoding: u32 = 0x01600011;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_CLZ_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_clz_a1_a_special_cond_0_condition_eq_16_01600010() {
    // Encoding: 0x01600010
    // Test aarch32_CLZ_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: cond=0, Rd=0, Rm=0
    let encoding: u32 = 0x01600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_CLZ_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_clz_a1_a_special_cond_1_condition_ne_16_11600010() {
    // Encoding: 0x11600010
    // Test aarch32_CLZ_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: cond=1, Rd=0, Rm=0
    let encoding: u32 = 0x11600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_CLZ_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_clz_a1_a_special_cond_2_condition_cs_hs_16_21600010() {
    // Encoding: 0x21600010
    // Test aarch32_CLZ_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: cond=2, Rm=0, Rd=0
    let encoding: u32 = 0x21600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_CLZ_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_clz_a1_a_special_cond_3_condition_cc_lo_16_31600010() {
    // Encoding: 0x31600010
    // Test aarch32_CLZ_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: Rd=0, Rm=0, cond=3
    let encoding: u32 = 0x31600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_CLZ_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_clz_a1_a_special_cond_4_condition_mi_16_41600010() {
    // Encoding: 0x41600010
    // Test aarch32_CLZ_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: Rm=0, Rd=0, cond=4
    let encoding: u32 = 0x41600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_CLZ_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_clz_a1_a_special_cond_5_condition_pl_16_51600010() {
    // Encoding: 0x51600010
    // Test aarch32_CLZ_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: Rm=0, Rd=0, cond=5
    let encoding: u32 = 0x51600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_CLZ_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_clz_a1_a_special_cond_6_condition_vs_16_61600010() {
    // Encoding: 0x61600010
    // Test aarch32_CLZ_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: Rm=0, cond=6, Rd=0
    let encoding: u32 = 0x61600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_CLZ_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_clz_a1_a_special_cond_7_condition_vc_16_71600010() {
    // Encoding: 0x71600010
    // Test aarch32_CLZ_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: Rm=0, cond=7, Rd=0
    let encoding: u32 = 0x71600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_CLZ_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_clz_a1_a_special_cond_8_condition_hi_16_81600010() {
    // Encoding: 0x81600010
    // Test aarch32_CLZ_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: Rd=0, Rm=0, cond=8
    let encoding: u32 = 0x81600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_CLZ_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_clz_a1_a_special_cond_9_condition_ls_16_91600010() {
    // Encoding: 0x91600010
    // Test aarch32_CLZ_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: cond=9, Rm=0, Rd=0
    let encoding: u32 = 0x91600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_CLZ_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_clz_a1_a_special_cond_10_condition_ge_16_a1600010() {
    // Encoding: 0xA1600010
    // Test aarch32_CLZ_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: cond=10, Rd=0, Rm=0
    let encoding: u32 = 0xA1600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_CLZ_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_clz_a1_a_special_cond_11_condition_lt_16_b1600010() {
    // Encoding: 0xB1600010
    // Test aarch32_CLZ_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: Rd=0, cond=11, Rm=0
    let encoding: u32 = 0xB1600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_CLZ_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_clz_a1_a_special_cond_12_condition_gt_16_c1600010() {
    // Encoding: 0xC1600010
    // Test aarch32_CLZ_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: Rm=0, cond=12, Rd=0
    let encoding: u32 = 0xC1600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_CLZ_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_clz_a1_a_special_cond_13_condition_le_16_d1600010() {
    // Encoding: 0xD1600010
    // Test aarch32_CLZ_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: Rd=0, Rm=0, cond=13
    let encoding: u32 = 0xD1600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_CLZ_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_clz_a1_a_special_cond_14_condition_al_16_e1600010() {
    // Encoding: 0xE1600010
    // Test aarch32_CLZ_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: Rd=0, Rm=0, cond=14
    let encoding: u32 = 0xE1600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_CLZ_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_clz_a1_a_special_cond_15_condition_nv_16_f1600010() {
    // Encoding: 0xF1600010
    // Test aarch32_CLZ_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: Rd=0, Rm=0, cond=15
    let encoding: u32 = 0xF1600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_CLZ_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_clz_a1_a_invalid_0_10_01600010() {
    // Encoding: 0x01600010
    // Test aarch32_CLZ_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }
    // ISET: A32
    // Fields: cond=0, Rd=0, Rm=0
    let encoding: u32 = 0x01600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_CLZ_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_clz_a1_a_invalid_1_10_01600010() {
    // Encoding: 0x01600010
    // Test aarch32_CLZ_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Rd=0, Rm=0, cond=0
    let encoding: u32 = 0x01600010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_CLZ_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_clz_t1_a_field_rn_0_min_f080_fab0f080() {
    // Thumb encoding (32): 0xFAB0F080
    // Test aarch32_CLZ_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rd=0, Rm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFAB0F080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_CLZ_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_clz_t1_a_field_rn_1_poweroftwo_f080_fab1f080() {
    // Thumb encoding (32): 0xFAB1F080
    // Test aarch32_CLZ_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=1, Rd=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFAB1F080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_CLZ_T1_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_clz_t1_a_field_rd_0_min_f080_fab0f080() {
    // Thumb encoding (32): 0xFAB0F080
    // Test aarch32_CLZ_T1_A field Rd = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rd=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFAB0F080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_CLZ_T1_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_clz_t1_a_field_rd_1_poweroftwo_f080_fab0f180() {
    // Thumb encoding (32): 0xFAB0F180
    // Test aarch32_CLZ_T1_A field Rd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=0, Rn=0, Rd=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFAB0F180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_CLZ_T1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_clz_t1_a_field_rm_0_min_f080_fab0f080() {
    // Thumb encoding (32): 0xFAB0F080
    // Test aarch32_CLZ_T1_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: Rd=0, Rn=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFAB0F080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_CLZ_T1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_clz_t1_a_field_rm_1_poweroftwo_f080_fab0f081() {
    // Thumb encoding (32): 0xFAB0F081
    // Test aarch32_CLZ_T1_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rd=0, Rm=1, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFAB0F081;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_CLZ_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_clz_t1_a_combo_0_f080_fab0f080() {
    // Thumb encoding (32): 0xFAB0F080
    // Test aarch32_CLZ_T1_A field combination: Rn=0, Rd=0, Rm=0
    // ISET: T32
    // Fields: Rn=0, Rd=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFAB0F080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_CLZ_T1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_clz_t1_a_combo_1_f080_fab1f080() {
    // Thumb encoding (32): 0xFAB1F080
    // Test aarch32_CLZ_T1_A field combination: Rn=1, Rd=0, Rm=0
    // ISET: T32
    // Fields: Rd=0, Rn=1, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFAB1F080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_CLZ_T1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch32_clz_t1_a_combo_2_f080_fab0f080() {
    // Thumb encoding (32): 0xFAB0F080
    // Test aarch32_CLZ_T1_A field combination: Rn=0, Rd=0, Rm=0
    // ISET: T32
    // Fields: Rd=0, Rn=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFAB0F080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_CLZ_T1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch32_clz_t1_a_combo_3_f080_fab0f180() {
    // Thumb encoding (32): 0xFAB0F180
    // Test aarch32_CLZ_T1_A field combination: Rn=0, Rd=1, Rm=0
    // ISET: T32
    // Fields: Rd=1, Rn=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFAB0F180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_CLZ_T1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch32_clz_t1_a_combo_4_f080_fab0f080() {
    // Thumb encoding (32): 0xFAB0F080
    // Test aarch32_CLZ_T1_A field combination: Rn=0, Rd=0, Rm=0
    // ISET: T32
    // Fields: Rn=0, Rm=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFAB0F080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_CLZ_T1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_aarch32_clz_t1_a_combo_5_f080_fab0f081() {
    // Thumb encoding (32): 0xFAB0F081
    // Test aarch32_CLZ_T1_A field combination: Rn=0, Rd=0, Rm=1
    // ISET: T32
    // Fields: Rd=0, Rm=1, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFAB0F081;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_CLZ_T1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch32_clz_t1_a_combo_6_f080_fab1f180() {
    // Thumb encoding (32): 0xFAB1F180
    // Test aarch32_CLZ_T1_A field combination: Rn=1, Rd=1, Rm=0
    // ISET: T32
    // Fields: Rn=1, Rm=0, Rd=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFAB1F180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_CLZ_T1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch32_clz_t1_a_combo_7_f080_fabfff80() {
    // Thumb encoding (32): 0xFABFFF80
    // Test aarch32_CLZ_T1_A field combination: Rn=31, Rd=31, Rm=0
    // ISET: T32
    // Fields: Rd=31, Rm=0, Rn=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFABFFF80;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_CLZ_T1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rm=1 (same register test (reg=1))
#[test]
fn test_aarch32_clz_t1_a_combo_8_f080_fab1f081() {
    // Thumb encoding (32): 0xFAB1F081
    // Test aarch32_CLZ_T1_A field combination: Rn=1, Rd=0, Rm=1
    // ISET: T32
    // Fields: Rn=1, Rm=1, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFAB1F081;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_CLZ_T1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rm=31 (same register test (reg=31))
#[test]
fn test_aarch32_clz_t1_a_combo_9_f080_fabff08f() {
    // Thumb encoding (32): 0xFABFF08F
    // Test aarch32_CLZ_T1_A field combination: Rn=31, Rd=0, Rm=31
    // ISET: T32
    // Fields: Rn=31, Rm=31, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFABFF08F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_CLZ_T1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (same register test (reg=1)), Rm=1 (same register test (reg=1))
#[test]
fn test_aarch32_clz_t1_a_combo_10_f080_fab0f181() {
    // Thumb encoding (32): 0xFAB0F181
    // Test aarch32_CLZ_T1_A field combination: Rn=0, Rd=1, Rm=1
    // ISET: T32
    // Fields: Rn=0, Rd=1, Rm=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFAB0F181;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_CLZ_T1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=31 (same register test (reg=31)), Rm=31 (same register test (reg=31))
#[test]
fn test_aarch32_clz_t1_a_combo_11_f080_fab0ff8f() {
    // Thumb encoding (32): 0xFAB0FF8F
    // Test aarch32_CLZ_T1_A field combination: Rn=0, Rd=31, Rm=31
    // ISET: T32
    // Fields: Rn=0, Rd=31, Rm=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFAB0FF8F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_CLZ_T1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }), rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }), rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_clz_t1_a_invalid_0_f080_fab0f080() {
    // Thumb encoding (32): 0xFAB0F080
    // Test aarch32_CLZ_T1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }), rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }
    // ISET: T32
    // Fields: Rm=0, Rd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFAB0F080;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_CLZ_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_clz_t1_a_invalid_1_f080_fab0f080() {
    // Thumb encoding (32): 0xFAB0F080
    // Test aarch32_CLZ_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rm=0, Rn=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFAB0F080;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

// ============================================================================
// aarch32_SSAT16_A Tests
// ============================================================================

/// Provenance: aarch32_SSAT16_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_ssat16_a1_a_field_cond_0_min_30_06a00030() {
    // Encoding: 0x06A00030
    // Test aarch32_SSAT16_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, sat_imm=0, Rd=0, cond=0
    let encoding: u32 = 0x06A00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT16_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_ssat16_a1_a_field_cond_1_poweroftwo_30_16a00030() {
    // Encoding: 0x16A00030
    // Test aarch32_SSAT16_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rd=0, cond=1, sat_imm=0
    let encoding: u32 = 0x16A00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT16_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_ssat16_a1_a_field_cond_2_poweroftwo_30_26a00030() {
    // Encoding: 0x26A00030
    // Test aarch32_SSAT16_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, cond=2, sat_imm=0, Rn=0
    let encoding: u32 = 0x26A00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT16_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_ssat16_a1_a_field_cond_3_poweroftwo_30_36a00030() {
    // Encoding: 0x36A00030
    // Test aarch32_SSAT16_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, cond=3, sat_imm=0, Rn=0
    let encoding: u32 = 0x36A00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT16_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_ssat16_a1_a_field_cond_4_poweroftwo_30_46a00030() {
    // Encoding: 0x46A00030
    // Test aarch32_SSAT16_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, sat_imm=0, Rn=0, cond=4
    let encoding: u32 = 0x46A00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT16_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_ssat16_a1_a_field_cond_5_poweroftwo_30_56a00030() {
    // Encoding: 0x56A00030
    // Test aarch32_SSAT16_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: sat_imm=0, Rd=0, cond=5, Rn=0
    let encoding: u32 = 0x56A00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT16_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_ssat16_a1_a_field_cond_6_poweroftwo_30_66a00030() {
    // Encoding: 0x66A00030
    // Test aarch32_SSAT16_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=6, sat_imm=0, Rd=0, Rn=0
    let encoding: u32 = 0x66A00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT16_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_ssat16_a1_a_field_cond_7_poweroftwo_30_76a00030() {
    // Encoding: 0x76A00030
    // Test aarch32_SSAT16_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rd=0, sat_imm=0, cond=7
    let encoding: u32 = 0x76A00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT16_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_ssat16_a1_a_field_cond_8_poweroftwo_30_86a00030() {
    // Encoding: 0x86A00030
    // Test aarch32_SSAT16_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, sat_imm=0, cond=8, Rn=0
    let encoding: u32 = 0x86A00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT16_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_ssat16_a1_a_field_cond_9_poweroftwo_30_96a00030() {
    // Encoding: 0x96A00030
    // Test aarch32_SSAT16_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: sat_imm=0, cond=9, Rd=0, Rn=0
    let encoding: u32 = 0x96A00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT16_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_ssat16_a1_a_field_cond_10_poweroftwo_30_a6a00030() {
    // Encoding: 0xA6A00030
    // Test aarch32_SSAT16_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: sat_imm=0, cond=10, Rn=0, Rd=0
    let encoding: u32 = 0xA6A00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT16_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_ssat16_a1_a_field_cond_11_poweroftwo_30_b6a00030() {
    // Encoding: 0xB6A00030
    // Test aarch32_SSAT16_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: sat_imm=0, cond=11, Rd=0, Rn=0
    let encoding: u32 = 0xB6A00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT16_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_ssat16_a1_a_field_cond_12_poweroftwo_30_c6a00030() {
    // Encoding: 0xC6A00030
    // Test aarch32_SSAT16_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, sat_imm=0, cond=12, Rn=0
    let encoding: u32 = 0xC6A00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT16_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_ssat16_a1_a_field_cond_13_poweroftwo_30_d6a00030() {
    // Encoding: 0xD6A00030
    // Test aarch32_SSAT16_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, cond=13, Rn=0, sat_imm=0
    let encoding: u32 = 0xD6A00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT16_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_ssat16_a1_a_field_cond_14_poweroftwo_30_e6a00030() {
    // Encoding: 0xE6A00030
    // Test aarch32_SSAT16_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=14, Rd=0, sat_imm=0
    let encoding: u32 = 0xE6A00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT16_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_ssat16_a1_a_field_cond_15_max_30_f6a00030() {
    // Encoding: 0xF6A00030
    // Test aarch32_SSAT16_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: sat_imm=0, cond=15, Rd=0, Rn=0
    let encoding: u32 = 0xF6A00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT16_A1_A
/// ASL: `field sat_imm 16 +: 4`
/// Requirement: FieldBoundary { field: "sat_imm", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ssat16_a1_a_field_sat_imm_0_min_30_06a00030() {
    // Encoding: 0x06A00030
    // Test aarch32_SSAT16_A1_A field sat_imm = 0 (Min)
    // ISET: A32
    // Fields: Rd=0, sat_imm=0, cond=0, Rn=0
    let encoding: u32 = 0x06A00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT16_A1_A
/// ASL: `field sat_imm 16 +: 4`
/// Requirement: FieldBoundary { field: "sat_imm", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_ssat16_a1_a_field_sat_imm_1_poweroftwo_30_06a10030() {
    // Encoding: 0x06A10030
    // Test aarch32_SSAT16_A1_A field sat_imm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, sat_imm=1, Rd=0, Rn=0
    let encoding: u32 = 0x06A10030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT16_A1_A
/// ASL: `field sat_imm 16 +: 4`
/// Requirement: FieldBoundary { field: "sat_imm", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_ssat16_a1_a_field_sat_imm_7_poweroftwominusone_30_06a70030() {
    // Encoding: 0x06A70030
    // Test aarch32_SSAT16_A1_A field sat_imm = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rn=0, cond=0, sat_imm=7, Rd=0
    let encoding: u32 = 0x06A70030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT16_A1_A
/// ASL: `field sat_imm 16 +: 4`
/// Requirement: FieldBoundary { field: "sat_imm", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_ssat16_a1_a_field_sat_imm_15_max_30_06af0030() {
    // Encoding: 0x06AF0030
    // Test aarch32_SSAT16_A1_A field sat_imm = 15 (Max)
    // ISET: A32
    // Fields: cond=0, sat_imm=15, Rn=0, Rd=0
    let encoding: u32 = 0x06AF0030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT16_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ssat16_a1_a_field_rd_0_min_30_06a00030() {
    // Encoding: 0x06A00030
    // Test aarch32_SSAT16_A1_A field Rd = 0 (Min)
    // ISET: A32
    // Fields: cond=0, sat_imm=0, Rn=0, Rd=0
    let encoding: u32 = 0x06A00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT16_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ssat16_a1_a_field_rd_1_poweroftwo_30_06a01030() {
    // Encoding: 0x06A01030
    // Test aarch32_SSAT16_A1_A field Rd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=0, Rd=1, sat_imm=0
    let encoding: u32 = 0x06A01030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT16_A1_A
/// ASL: `field Rn 0 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ssat16_a1_a_field_rn_0_min_30_06a00030() {
    // Encoding: 0x06A00030
    // Test aarch32_SSAT16_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rn=0, Rd=0, sat_imm=0
    let encoding: u32 = 0x06A00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT16_A1_A
/// ASL: `field Rn 0 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ssat16_a1_a_field_rn_1_poweroftwo_30_06a00031() {
    // Encoding: 0x06A00031
    // Test aarch32_SSAT16_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: sat_imm=0, cond=0, Rd=0, Rn=1
    let encoding: u32 = 0x06A00031;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT16_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_ssat16_a1_a_combo_0_30_06a00030() {
    // Encoding: 0x06A00030
    // Test aarch32_SSAT16_A1_A field combination: cond=0, sat_imm=0, Rd=0, Rn=0
    // ISET: A32
    // Fields: Rn=0, cond=0, sat_imm=0, Rd=0
    let encoding: u32 = 0x06A00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT16_A1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=1 (condition NE (not equal))
#[test]
fn test_aarch32_ssat16_a1_a_combo_1_30_16a00030() {
    // Encoding: 0x16A00030
    // Test aarch32_SSAT16_A1_A field combination: cond=1, sat_imm=0, Rd=0, Rn=0
    // ISET: A32
    // Fields: Rn=0, cond=1, sat_imm=0, Rd=0
    let encoding: u32 = 0x16A00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT16_A1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=2 (condition CS/HS (carry set))
#[test]
fn test_aarch32_ssat16_a1_a_combo_2_30_26a00030() {
    // Encoding: 0x26A00030
    // Test aarch32_SSAT16_A1_A field combination: cond=2, sat_imm=0, Rd=0, Rn=0
    // ISET: A32
    // Fields: sat_imm=0, Rd=0, Rn=0, cond=2
    let encoding: u32 = 0x26A00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT16_A1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=3 (condition CC/LO (carry clear))
#[test]
fn test_aarch32_ssat16_a1_a_combo_3_30_36a00030() {
    // Encoding: 0x36A00030
    // Test aarch32_SSAT16_A1_A field combination: cond=3, sat_imm=0, Rd=0, Rn=0
    // ISET: A32
    // Fields: sat_imm=0, Rd=0, cond=3, Rn=0
    let encoding: u32 = 0x36A00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT16_A1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=4 (condition MI (minus/negative))
#[test]
fn test_aarch32_ssat16_a1_a_combo_4_30_46a00030() {
    // Encoding: 0x46A00030
    // Test aarch32_SSAT16_A1_A field combination: cond=4, sat_imm=0, Rd=0, Rn=0
    // ISET: A32
    // Fields: Rn=0, cond=4, sat_imm=0, Rd=0
    let encoding: u32 = 0x46A00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT16_A1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=5 (condition PL (plus/positive))
#[test]
fn test_aarch32_ssat16_a1_a_combo_5_30_56a00030() {
    // Encoding: 0x56A00030
    // Test aarch32_SSAT16_A1_A field combination: cond=5, sat_imm=0, Rd=0, Rn=0
    // ISET: A32
    // Fields: cond=5, Rd=0, sat_imm=0, Rn=0
    let encoding: u32 = 0x56A00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT16_A1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=6 (condition VS (overflow set))
#[test]
fn test_aarch32_ssat16_a1_a_combo_6_30_66a00030() {
    // Encoding: 0x66A00030
    // Test aarch32_SSAT16_A1_A field combination: cond=6, sat_imm=0, Rd=0, Rn=0
    // ISET: A32
    // Fields: Rn=0, cond=6, sat_imm=0, Rd=0
    let encoding: u32 = 0x66A00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT16_A1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=7 (condition VC (overflow clear))
#[test]
fn test_aarch32_ssat16_a1_a_combo_7_30_76a00030() {
    // Encoding: 0x76A00030
    // Test aarch32_SSAT16_A1_A field combination: cond=7, sat_imm=0, Rd=0, Rn=0
    // ISET: A32
    // Fields: sat_imm=0, Rn=0, cond=7, Rd=0
    let encoding: u32 = 0x76A00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT16_A1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=8 (condition HI (unsigned higher))
#[test]
fn test_aarch32_ssat16_a1_a_combo_8_30_86a00030() {
    // Encoding: 0x86A00030
    // Test aarch32_SSAT16_A1_A field combination: cond=8, sat_imm=0, Rd=0, Rn=0
    // ISET: A32
    // Fields: Rd=0, cond=8, sat_imm=0, Rn=0
    let encoding: u32 = 0x86A00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT16_A1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=9 (condition LS (unsigned lower or same))
#[test]
fn test_aarch32_ssat16_a1_a_combo_9_30_96a00030() {
    // Encoding: 0x96A00030
    // Test aarch32_SSAT16_A1_A field combination: cond=9, sat_imm=0, Rd=0, Rn=0
    // ISET: A32
    // Fields: sat_imm=0, Rd=0, cond=9, Rn=0
    let encoding: u32 = 0x96A00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT16_A1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=10 (condition GE (signed >=))
#[test]
fn test_aarch32_ssat16_a1_a_combo_10_30_a6a00030() {
    // Encoding: 0xA6A00030
    // Test aarch32_SSAT16_A1_A field combination: cond=10, sat_imm=0, Rd=0, Rn=0
    // ISET: A32
    // Fields: Rn=0, Rd=0, cond=10, sat_imm=0
    let encoding: u32 = 0xA6A00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT16_A1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=11 (condition LT (signed <))
#[test]
fn test_aarch32_ssat16_a1_a_combo_11_30_b6a00030() {
    // Encoding: 0xB6A00030
    // Test aarch32_SSAT16_A1_A field combination: cond=11, sat_imm=0, Rd=0, Rn=0
    // ISET: A32
    // Fields: Rd=0, Rn=0, cond=11, sat_imm=0
    let encoding: u32 = 0xB6A00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT16_A1_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=12 (condition GT (signed >))
#[test]
fn test_aarch32_ssat16_a1_a_combo_12_30_c6a00030() {
    // Encoding: 0xC6A00030
    // Test aarch32_SSAT16_A1_A field combination: cond=12, sat_imm=0, Rd=0, Rn=0
    // ISET: A32
    // Fields: Rd=0, Rn=0, cond=12, sat_imm=0
    let encoding: u32 = 0xC6A00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT16_A1_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=13 (condition LE (signed <=))
#[test]
fn test_aarch32_ssat16_a1_a_combo_13_30_d6a00030() {
    // Encoding: 0xD6A00030
    // Test aarch32_SSAT16_A1_A field combination: cond=13, sat_imm=0, Rd=0, Rn=0
    // ISET: A32
    // Fields: Rd=0, sat_imm=0, cond=13, Rn=0
    let encoding: u32 = 0xD6A00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT16_A1_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=14 (condition AL (always))
#[test]
fn test_aarch32_ssat16_a1_a_combo_14_30_e6a00030() {
    // Encoding: 0xE6A00030
    // Test aarch32_SSAT16_A1_A field combination: cond=14, sat_imm=0, Rd=0, Rn=0
    // ISET: A32
    // Fields: Rn=0, Rd=0, cond=14, sat_imm=0
    let encoding: u32 = 0xE6A00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT16_A1_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=15 (condition NV (never, reserved))
#[test]
fn test_aarch32_ssat16_a1_a_combo_15_30_f6a00030() {
    // Encoding: 0xF6A00030
    // Test aarch32_SSAT16_A1_A field combination: cond=15, sat_imm=0, Rd=0, Rn=0
    // ISET: A32
    // Fields: cond=15, sat_imm=0, Rd=0, Rn=0
    let encoding: u32 = 0xF6A00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT16_A1_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sat_imm=0 (minimum value)
#[test]
fn test_aarch32_ssat16_a1_a_combo_16_30_06a00030() {
    // Encoding: 0x06A00030
    // Test aarch32_SSAT16_A1_A field combination: cond=0, sat_imm=0, Rd=0, Rn=0
    // ISET: A32
    // Fields: Rd=0, Rn=0, sat_imm=0, cond=0
    let encoding: u32 = 0x06A00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT16_A1_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sat_imm=1 (value 1)
#[test]
fn test_aarch32_ssat16_a1_a_combo_17_30_06a10030() {
    // Encoding: 0x06A10030
    // Test aarch32_SSAT16_A1_A field combination: cond=0, sat_imm=1, Rd=0, Rn=0
    // ISET: A32
    // Fields: Rd=0, cond=0, sat_imm=1, Rn=0
    let encoding: u32 = 0x06A10030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT16_A1_A
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sat_imm=7 (midpoint (7))
#[test]
fn test_aarch32_ssat16_a1_a_combo_18_30_06a70030() {
    // Encoding: 0x06A70030
    // Test aarch32_SSAT16_A1_A field combination: cond=0, sat_imm=7, Rd=0, Rn=0
    // ISET: A32
    // Fields: Rn=0, Rd=0, sat_imm=7, cond=0
    let encoding: u32 = 0x06A70030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT16_A1_A
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sat_imm=15 (maximum value (15))
#[test]
fn test_aarch32_ssat16_a1_a_combo_19_30_06af0030() {
    // Encoding: 0x06AF0030
    // Test aarch32_SSAT16_A1_A field combination: cond=0, sat_imm=15, Rd=0, Rn=0
    // ISET: A32
    // Fields: sat_imm=15, cond=0, Rd=0, Rn=0
    let encoding: u32 = 0x06AF0030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT16_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_ssat16_a1_a_special_cond_0_condition_eq_48_06a00030() {
    // Encoding: 0x06A00030
    // Test aarch32_SSAT16_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: sat_imm=0, Rn=0, Rd=0, cond=0
    let encoding: u32 = 0x06A00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT16_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_ssat16_a1_a_special_cond_1_condition_ne_48_16a00030() {
    // Encoding: 0x16A00030
    // Test aarch32_SSAT16_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: sat_imm=0, Rn=0, cond=1, Rd=0
    let encoding: u32 = 0x16A00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT16_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_ssat16_a1_a_special_cond_2_condition_cs_hs_48_26a00030() {
    // Encoding: 0x26A00030
    // Test aarch32_SSAT16_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: sat_imm=0, Rn=0, Rd=0, cond=2
    let encoding: u32 = 0x26A00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT16_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_ssat16_a1_a_special_cond_3_condition_cc_lo_48_36a00030() {
    // Encoding: 0x36A00030
    // Test aarch32_SSAT16_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: sat_imm=0, Rd=0, cond=3, Rn=0
    let encoding: u32 = 0x36A00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT16_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_ssat16_a1_a_special_cond_4_condition_mi_48_46a00030() {
    // Encoding: 0x46A00030
    // Test aarch32_SSAT16_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: Rd=0, Rn=0, sat_imm=0, cond=4
    let encoding: u32 = 0x46A00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT16_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_ssat16_a1_a_special_cond_5_condition_pl_48_56a00030() {
    // Encoding: 0x56A00030
    // Test aarch32_SSAT16_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: Rn=0, sat_imm=0, cond=5, Rd=0
    let encoding: u32 = 0x56A00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT16_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_ssat16_a1_a_special_cond_6_condition_vs_48_66a00030() {
    // Encoding: 0x66A00030
    // Test aarch32_SSAT16_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: Rd=0, cond=6, sat_imm=0, Rn=0
    let encoding: u32 = 0x66A00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT16_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_ssat16_a1_a_special_cond_7_condition_vc_48_76a00030() {
    // Encoding: 0x76A00030
    // Test aarch32_SSAT16_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: sat_imm=0, Rd=0, cond=7, Rn=0
    let encoding: u32 = 0x76A00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT16_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_ssat16_a1_a_special_cond_8_condition_hi_48_86a00030() {
    // Encoding: 0x86A00030
    // Test aarch32_SSAT16_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: Rd=0, sat_imm=0, cond=8, Rn=0
    let encoding: u32 = 0x86A00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT16_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_ssat16_a1_a_special_cond_9_condition_ls_48_96a00030() {
    // Encoding: 0x96A00030
    // Test aarch32_SSAT16_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: Rd=0, sat_imm=0, cond=9, Rn=0
    let encoding: u32 = 0x96A00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT16_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_ssat16_a1_a_special_cond_10_condition_ge_48_a6a00030() {
    // Encoding: 0xA6A00030
    // Test aarch32_SSAT16_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: sat_imm=0, cond=10, Rd=0, Rn=0
    let encoding: u32 = 0xA6A00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT16_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_ssat16_a1_a_special_cond_11_condition_lt_48_b6a00030() {
    // Encoding: 0xB6A00030
    // Test aarch32_SSAT16_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: Rn=0, Rd=0, cond=11, sat_imm=0
    let encoding: u32 = 0xB6A00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT16_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_ssat16_a1_a_special_cond_12_condition_gt_48_c6a00030() {
    // Encoding: 0xC6A00030
    // Test aarch32_SSAT16_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: sat_imm=0, Rd=0, cond=12, Rn=0
    let encoding: u32 = 0xC6A00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT16_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_ssat16_a1_a_special_cond_13_condition_le_48_d6a00030() {
    // Encoding: 0xD6A00030
    // Test aarch32_SSAT16_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: Rd=0, Rn=0, cond=13, sat_imm=0
    let encoding: u32 = 0xD6A00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT16_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_ssat16_a1_a_special_cond_14_condition_al_48_e6a00030() {
    // Encoding: 0xE6A00030
    // Test aarch32_SSAT16_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: sat_imm=0, cond=14, Rd=0, Rn=0
    let encoding: u32 = 0xE6A00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT16_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_ssat16_a1_a_special_cond_15_condition_nv_48_f6a00030() {
    // Encoding: 0xF6A00030
    // Test aarch32_SSAT16_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: Rn=0, Rd=0, sat_imm=0, cond=15
    let encoding: u32 = 0xF6A00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT16_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ssat16_a1_a_invalid_0_30_06a00030() {
    // Encoding: 0x06A00030
    // Test aarch32_SSAT16_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }
    // ISET: A32
    // Fields: Rn=0, sat_imm=0, Rd=0, cond=0
    let encoding: u32 = 0x06A00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_SSAT16_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ssat16_a1_a_invalid_1_30_06a00030() {
    // Encoding: 0x06A00030
    // Test aarch32_SSAT16_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: sat_imm=0, Rd=0, Rn=0, cond=0
    let encoding: u32 = 0x06A00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_SSAT16_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ssat16_t1_a_field_rn_0_min_0_f3200000() {
    // Thumb encoding (32): 0xF3200000
    // Test aarch32_SSAT16_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, sat_imm=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_SSAT16_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ssat16_t1_a_field_rn_1_poweroftwo_0_f3210000() {
    // Thumb encoding (32): 0xF3210000
    // Test aarch32_SSAT16_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: sat_imm=0, Rn=1, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3210000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_SSAT16_T1_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ssat16_t1_a_field_rd_0_min_0_f3200000() {
    // Thumb encoding (32): 0xF3200000
    // Test aarch32_SSAT16_T1_A field Rd = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rd=0, sat_imm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_SSAT16_T1_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ssat16_t1_a_field_rd_1_poweroftwo_0_f3200100() {
    // Thumb encoding (32): 0xF3200100
    // Test aarch32_SSAT16_T1_A field Rd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rd=1, sat_imm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3200100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_SSAT16_T1_A
/// ASL: `field sat_imm 0 +: 4`
/// Requirement: FieldBoundary { field: "sat_imm", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ssat16_t1_a_field_sat_imm_0_min_0_f3200000() {
    // Thumb encoding (32): 0xF3200000
    // Test aarch32_SSAT16_T1_A field sat_imm = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, sat_imm=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_SSAT16_T1_A
/// ASL: `field sat_imm 0 +: 4`
/// Requirement: FieldBoundary { field: "sat_imm", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_ssat16_t1_a_field_sat_imm_1_poweroftwo_0_f3200001() {
    // Thumb encoding (32): 0xF3200001
    // Test aarch32_SSAT16_T1_A field sat_imm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rd=0, sat_imm=1, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3200001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_SSAT16_T1_A
/// ASL: `field sat_imm 0 +: 4`
/// Requirement: FieldBoundary { field: "sat_imm", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_ssat16_t1_a_field_sat_imm_7_poweroftwominusone_0_f3200007() {
    // Thumb encoding (32): 0xF3200007
    // Test aarch32_SSAT16_T1_A field sat_imm = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rd=0, Rn=0, sat_imm=7
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3200007;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_SSAT16_T1_A
/// ASL: `field sat_imm 0 +: 4`
/// Requirement: FieldBoundary { field: "sat_imm", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_ssat16_t1_a_field_sat_imm_15_max_0_f320000f() {
    // Thumb encoding (32): 0xF320000F
    // Test aarch32_SSAT16_T1_A field sat_imm = 15 (Max)
    // ISET: T32
    // Fields: Rd=0, sat_imm=15, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF320000F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_SSAT16_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_ssat16_t1_a_combo_0_0_f3200000() {
    // Thumb encoding (32): 0xF3200000
    // Test aarch32_SSAT16_T1_A field combination: Rn=0, Rd=0, sat_imm=0
    // ISET: T32
    // Fields: sat_imm=0, Rn=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_SSAT16_T1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_ssat16_t1_a_combo_1_0_f3210000() {
    // Thumb encoding (32): 0xF3210000
    // Test aarch32_SSAT16_T1_A field combination: Rn=1, Rd=0, sat_imm=0
    // ISET: T32
    // Fields: Rd=0, Rn=1, sat_imm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3210000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_SSAT16_T1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch32_ssat16_t1_a_combo_2_0_f3200000() {
    // Thumb encoding (32): 0xF3200000
    // Test aarch32_SSAT16_T1_A field combination: Rn=0, Rd=0, sat_imm=0
    // ISET: T32
    // Fields: sat_imm=0, Rd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_SSAT16_T1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch32_ssat16_t1_a_combo_3_0_f3200100() {
    // Thumb encoding (32): 0xF3200100
    // Test aarch32_SSAT16_T1_A field combination: Rn=0, Rd=1, sat_imm=0
    // ISET: T32
    // Fields: sat_imm=0, Rn=0, Rd=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3200100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_SSAT16_T1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sat_imm=0 (minimum value)
#[test]
fn test_aarch32_ssat16_t1_a_combo_4_0_f3200000() {
    // Thumb encoding (32): 0xF3200000
    // Test aarch32_SSAT16_T1_A field combination: Rn=0, Rd=0, sat_imm=0
    // ISET: T32
    // Fields: Rd=0, Rn=0, sat_imm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_SSAT16_T1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sat_imm=1 (value 1)
#[test]
fn test_aarch32_ssat16_t1_a_combo_5_0_f3200001() {
    // Thumb encoding (32): 0xF3200001
    // Test aarch32_SSAT16_T1_A field combination: Rn=0, Rd=0, sat_imm=1
    // ISET: T32
    // Fields: sat_imm=1, Rd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3200001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_SSAT16_T1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sat_imm=7 (midpoint (7))
#[test]
fn test_aarch32_ssat16_t1_a_combo_6_0_f3200007() {
    // Thumb encoding (32): 0xF3200007
    // Test aarch32_SSAT16_T1_A field combination: Rn=0, Rd=0, sat_imm=7
    // ISET: T32
    // Fields: Rd=0, sat_imm=7, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3200007;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_SSAT16_T1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sat_imm=15 (maximum value (15))
#[test]
fn test_aarch32_ssat16_t1_a_combo_7_0_f320000f() {
    // Thumb encoding (32): 0xF320000F
    // Test aarch32_SSAT16_T1_A field combination: Rn=0, Rd=0, sat_imm=15
    // ISET: T32
    // Fields: Rd=0, sat_imm=15, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF320000F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_SSAT16_T1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch32_ssat16_t1_a_combo_8_0_f3210100() {
    // Thumb encoding (32): 0xF3210100
    // Test aarch32_SSAT16_T1_A field combination: Rn=1, Rd=1, sat_imm=0
    // ISET: T32
    // Fields: sat_imm=0, Rd=1, Rn=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3210100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_SSAT16_T1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch32_ssat16_t1_a_combo_9_0_f32f0f00() {
    // Thumb encoding (32): 0xF32F0F00
    // Test aarch32_SSAT16_T1_A field combination: Rn=31, Rd=31, sat_imm=0
    // ISET: T32
    // Fields: Rn=31, sat_imm=0, Rd=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF32F0F00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_SSAT16_T1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ssat16_t1_a_invalid_0_0_f3200000() {
    // Thumb encoding (32): 0xF3200000
    // Test aarch32_SSAT16_T1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }
    // ISET: T32
    // Fields: Rn=0, sat_imm=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3200000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_SSAT16_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ssat16_t1_a_invalid_1_0_f3200000() {
    // Thumb encoding (32): 0xF3200000
    // Test aarch32_SSAT16_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: sat_imm=0, Rn=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3200000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

// ============================================================================
// aarch32_BFI_A Tests
// ============================================================================

/// Provenance: aarch32_BFI_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_bfi_a1_a_field_cond_0_min_10_07c00010() {
    // Encoding: 0x07C00010
    // Test aarch32_BFI_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rn=0, Rd=0, msb=0, lsb=0
    let encoding: u32 = 0x07C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFI_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_bfi_a1_a_field_cond_1_poweroftwo_10_17c00010() {
    // Encoding: 0x17C00010
    // Test aarch32_BFI_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, lsb=0, msb=0, cond=1, Rn=0
    let encoding: u32 = 0x17C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFI_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_bfi_a1_a_field_cond_2_poweroftwo_10_27c00010() {
    // Encoding: 0x27C00010
    // Test aarch32_BFI_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rd=0, cond=2, msb=0, lsb=0
    let encoding: u32 = 0x27C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFI_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_bfi_a1_a_field_cond_3_poweroftwo_10_37c00010() {
    // Encoding: 0x37C00010
    // Test aarch32_BFI_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=3, Rn=0, lsb=0, Rd=0, msb=0
    let encoding: u32 = 0x37C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFI_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_bfi_a1_a_field_cond_4_poweroftwo_10_47c00010() {
    // Encoding: 0x47C00010
    // Test aarch32_BFI_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: lsb=0, msb=0, cond=4, Rn=0, Rd=0
    let encoding: u32 = 0x47C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFI_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_bfi_a1_a_field_cond_5_poweroftwo_10_57c00010() {
    // Encoding: 0x57C00010
    // Test aarch32_BFI_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: msb=0, Rd=0, cond=5, Rn=0, lsb=0
    let encoding: u32 = 0x57C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFI_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_bfi_a1_a_field_cond_6_poweroftwo_10_67c00010() {
    // Encoding: 0x67C00010
    // Test aarch32_BFI_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: msb=0, Rn=0, cond=6, Rd=0, lsb=0
    let encoding: u32 = 0x67C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFI_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_bfi_a1_a_field_cond_7_poweroftwo_10_77c00010() {
    // Encoding: 0x77C00010
    // Test aarch32_BFI_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=7, msb=0, Rd=0, lsb=0, Rn=0
    let encoding: u32 = 0x77C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFI_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_bfi_a1_a_field_cond_8_poweroftwo_10_87c00010() {
    // Encoding: 0x87C00010
    // Test aarch32_BFI_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=8, msb=0, Rd=0, Rn=0, lsb=0
    let encoding: u32 = 0x87C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFI_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_bfi_a1_a_field_cond_9_poweroftwo_10_97c00010() {
    // Encoding: 0x97C00010
    // Test aarch32_BFI_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: msb=0, lsb=0, cond=9, Rn=0, Rd=0
    let encoding: u32 = 0x97C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFI_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_bfi_a1_a_field_cond_10_poweroftwo_10_a7c00010() {
    // Encoding: 0xA7C00010
    // Test aarch32_BFI_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=10, lsb=0, Rd=0, Rn=0, msb=0
    let encoding: u32 = 0xA7C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFI_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_bfi_a1_a_field_cond_11_poweroftwo_10_b7c00010() {
    // Encoding: 0xB7C00010
    // Test aarch32_BFI_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: lsb=0, msb=0, cond=11, Rn=0, Rd=0
    let encoding: u32 = 0xB7C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFI_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_bfi_a1_a_field_cond_12_poweroftwo_10_c7c00010() {
    // Encoding: 0xC7C00010
    // Test aarch32_BFI_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=12, msb=0, lsb=0, Rd=0
    let encoding: u32 = 0xC7C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFI_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_bfi_a1_a_field_cond_13_poweroftwo_10_d7c00010() {
    // Encoding: 0xD7C00010
    // Test aarch32_BFI_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=13, lsb=0, msb=0, Rn=0, Rd=0
    let encoding: u32 = 0xD7C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFI_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_bfi_a1_a_field_cond_14_poweroftwo_10_e7c00010() {
    // Encoding: 0xE7C00010
    // Test aarch32_BFI_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: lsb=0, cond=14, msb=0, Rn=0, Rd=0
    let encoding: u32 = 0xE7C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFI_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_bfi_a1_a_field_cond_15_max_10_f7c00010() {
    // Encoding: 0xF7C00010
    // Test aarch32_BFI_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: cond=15, Rd=0, msb=0, Rn=0, lsb=0
    let encoding: u32 = 0xF7C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFI_A1_A
/// ASL: `field msb 16 +: 5`
/// Requirement: FieldBoundary { field: "msb", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_bfi_a1_a_field_msb_0_min_10_07c00010() {
    // Encoding: 0x07C00010
    // Test aarch32_BFI_A1_A field msb = 0 (Min)
    // ISET: A32
    // Fields: lsb=0, Rn=0, Rd=0, msb=0, cond=0
    let encoding: u32 = 0x07C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFI_A1_A
/// ASL: `field msb 16 +: 5`
/// Requirement: FieldBoundary { field: "msb", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_bfi_a1_a_field_msb_1_poweroftwo_10_07c10010() {
    // Encoding: 0x07C10010
    // Test aarch32_BFI_A1_A field msb = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rd=0, msb=1, cond=0, lsb=0
    let encoding: u32 = 0x07C10010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFI_A1_A
/// ASL: `field msb 16 +: 5`
/// Requirement: FieldBoundary { field: "msb", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_aarch32_bfi_a1_a_field_msb_15_poweroftwominusone_10_07cf0010() {
    // Encoding: 0x07CF0010
    // Test aarch32_BFI_A1_A field msb = 15 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rd=0, msb=15, cond=0, Rn=0, lsb=0
    let encoding: u32 = 0x07CF0010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFI_A1_A
/// ASL: `field msb 16 +: 5`
/// Requirement: FieldBoundary { field: "msb", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_aarch32_bfi_a1_a_field_msb_31_max_10_07df0010() {
    // Encoding: 0x07DF0010
    // Test aarch32_BFI_A1_A field msb = 31 (Max)
    // ISET: A32
    // Fields: Rd=0, lsb=0, msb=31, cond=0, Rn=0
    let encoding: u32 = 0x07DF0010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFI_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_bfi_a1_a_field_rd_0_min_10_07c00010() {
    // Encoding: 0x07C00010
    // Test aarch32_BFI_A1_A field Rd = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rn=0, msb=0, Rd=0, lsb=0
    let encoding: u32 = 0x07C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFI_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_bfi_a1_a_field_rd_1_poweroftwo_10_07c01010() {
    // Encoding: 0x07C01010
    // Test aarch32_BFI_A1_A field Rd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Rn=0, Rd=1, lsb=0, msb=0
    let encoding: u32 = 0x07C01010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFI_A1_A
/// ASL: `field lsb 7 +: 5`
/// Requirement: FieldBoundary { field: "lsb", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_bfi_a1_a_field_lsb_0_min_10_07c00010() {
    // Encoding: 0x07C00010
    // Test aarch32_BFI_A1_A field lsb = 0 (Min)
    // ISET: A32
    // Fields: lsb=0, Rn=0, msb=0, Rd=0, cond=0
    let encoding: u32 = 0x07C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFI_A1_A
/// ASL: `field lsb 7 +: 5`
/// Requirement: FieldBoundary { field: "lsb", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_bfi_a1_a_field_lsb_1_poweroftwo_10_07c00090() {
    // Encoding: 0x07C00090
    // Test aarch32_BFI_A1_A field lsb = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: lsb=1, Rn=0, msb=0, Rd=0, cond=0
    let encoding: u32 = 0x07C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFI_A1_A
/// ASL: `field lsb 7 +: 5`
/// Requirement: FieldBoundary { field: "lsb", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_aarch32_bfi_a1_a_field_lsb_15_poweroftwominusone_10_07c00790() {
    // Encoding: 0x07C00790
    // Test aarch32_BFI_A1_A field lsb = 15 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rd=0, cond=0, msb=0, lsb=15, Rn=0
    let encoding: u32 = 0x07C00790;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFI_A1_A
/// ASL: `field lsb 7 +: 5`
/// Requirement: FieldBoundary { field: "lsb", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_aarch32_bfi_a1_a_field_lsb_31_max_10_07c00f90() {
    // Encoding: 0x07C00F90
    // Test aarch32_BFI_A1_A field lsb = 31 (Max)
    // ISET: A32
    // Fields: Rd=0, cond=0, msb=0, Rn=0, lsb=31
    let encoding: u32 = 0x07C00F90;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFI_A1_A
/// ASL: `field Rn 0 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_bfi_a1_a_field_rn_0_min_10_07c00010() {
    // Encoding: 0x07C00010
    // Test aarch32_BFI_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: lsb=0, Rn=0, msb=0, cond=0, Rd=0
    let encoding: u32 = 0x07C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFI_A1_A
/// ASL: `field Rn 0 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_bfi_a1_a_field_rn_1_poweroftwo_10_07c00011() {
    // Encoding: 0x07C00011
    // Test aarch32_BFI_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: msb=0, lsb=0, Rd=0, Rn=1, cond=0
    let encoding: u32 = 0x07C00011;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFI_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_bfi_a1_a_combo_0_10_07c00010() {
    // Encoding: 0x07C00010
    // Test aarch32_BFI_A1_A field combination: cond=0, msb=0, Rd=0, lsb=0, Rn=0
    // ISET: A32
    // Fields: Rn=0, Rd=0, msb=0, lsb=0, cond=0
    let encoding: u32 = 0x07C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFI_A1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=1 (condition NE (not equal))
#[test]
fn test_aarch32_bfi_a1_a_combo_1_10_17c00010() {
    // Encoding: 0x17C00010
    // Test aarch32_BFI_A1_A field combination: cond=1, msb=0, Rd=0, lsb=0, Rn=0
    // ISET: A32
    // Fields: Rn=0, cond=1, msb=0, lsb=0, Rd=0
    let encoding: u32 = 0x17C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFI_A1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=2 (condition CS/HS (carry set))
#[test]
fn test_aarch32_bfi_a1_a_combo_2_10_27c00010() {
    // Encoding: 0x27C00010
    // Test aarch32_BFI_A1_A field combination: cond=2, msb=0, Rd=0, lsb=0, Rn=0
    // ISET: A32
    // Fields: msb=0, Rn=0, Rd=0, lsb=0, cond=2
    let encoding: u32 = 0x27C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFI_A1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=3 (condition CC/LO (carry clear))
#[test]
fn test_aarch32_bfi_a1_a_combo_3_10_37c00010() {
    // Encoding: 0x37C00010
    // Test aarch32_BFI_A1_A field combination: cond=3, msb=0, Rd=0, lsb=0, Rn=0
    // ISET: A32
    // Fields: cond=3, lsb=0, Rn=0, Rd=0, msb=0
    let encoding: u32 = 0x37C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFI_A1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=4 (condition MI (minus/negative))
#[test]
fn test_aarch32_bfi_a1_a_combo_4_10_47c00010() {
    // Encoding: 0x47C00010
    // Test aarch32_BFI_A1_A field combination: cond=4, msb=0, Rd=0, lsb=0, Rn=0
    // ISET: A32
    // Fields: Rd=0, cond=4, Rn=0, lsb=0, msb=0
    let encoding: u32 = 0x47C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFI_A1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=5 (condition PL (plus/positive))
#[test]
fn test_aarch32_bfi_a1_a_combo_5_10_57c00010() {
    // Encoding: 0x57C00010
    // Test aarch32_BFI_A1_A field combination: cond=5, msb=0, Rd=0, lsb=0, Rn=0
    // ISET: A32
    // Fields: lsb=0, Rd=0, cond=5, msb=0, Rn=0
    let encoding: u32 = 0x57C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFI_A1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=6 (condition VS (overflow set))
#[test]
fn test_aarch32_bfi_a1_a_combo_6_10_67c00010() {
    // Encoding: 0x67C00010
    // Test aarch32_BFI_A1_A field combination: cond=6, msb=0, Rd=0, lsb=0, Rn=0
    // ISET: A32
    // Fields: Rn=0, lsb=0, msb=0, cond=6, Rd=0
    let encoding: u32 = 0x67C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFI_A1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=7 (condition VC (overflow clear))
#[test]
fn test_aarch32_bfi_a1_a_combo_7_10_77c00010() {
    // Encoding: 0x77C00010
    // Test aarch32_BFI_A1_A field combination: cond=7, msb=0, Rd=0, lsb=0, Rn=0
    // ISET: A32
    // Fields: lsb=0, msb=0, cond=7, Rd=0, Rn=0
    let encoding: u32 = 0x77C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFI_A1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=8 (condition HI (unsigned higher))
#[test]
fn test_aarch32_bfi_a1_a_combo_8_10_87c00010() {
    // Encoding: 0x87C00010
    // Test aarch32_BFI_A1_A field combination: cond=8, msb=0, Rd=0, lsb=0, Rn=0
    // ISET: A32
    // Fields: cond=8, lsb=0, Rn=0, Rd=0, msb=0
    let encoding: u32 = 0x87C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFI_A1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=9 (condition LS (unsigned lower or same))
#[test]
fn test_aarch32_bfi_a1_a_combo_9_10_97c00010() {
    // Encoding: 0x97C00010
    // Test aarch32_BFI_A1_A field combination: cond=9, msb=0, Rd=0, lsb=0, Rn=0
    // ISET: A32
    // Fields: Rn=0, cond=9, msb=0, lsb=0, Rd=0
    let encoding: u32 = 0x97C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFI_A1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=10 (condition GE (signed >=))
#[test]
fn test_aarch32_bfi_a1_a_combo_10_10_a7c00010() {
    // Encoding: 0xA7C00010
    // Test aarch32_BFI_A1_A field combination: cond=10, msb=0, Rd=0, lsb=0, Rn=0
    // ISET: A32
    // Fields: msb=0, Rd=0, lsb=0, Rn=0, cond=10
    let encoding: u32 = 0xA7C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFI_A1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=11 (condition LT (signed <))
#[test]
fn test_aarch32_bfi_a1_a_combo_11_10_b7c00010() {
    // Encoding: 0xB7C00010
    // Test aarch32_BFI_A1_A field combination: cond=11, msb=0, Rd=0, lsb=0, Rn=0
    // ISET: A32
    // Fields: cond=11, msb=0, Rn=0, lsb=0, Rd=0
    let encoding: u32 = 0xB7C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFI_A1_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=12 (condition GT (signed >))
#[test]
fn test_aarch32_bfi_a1_a_combo_12_10_c7c00010() {
    // Encoding: 0xC7C00010
    // Test aarch32_BFI_A1_A field combination: cond=12, msb=0, Rd=0, lsb=0, Rn=0
    // ISET: A32
    // Fields: cond=12, lsb=0, Rd=0, Rn=0, msb=0
    let encoding: u32 = 0xC7C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFI_A1_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=13 (condition LE (signed <=))
#[test]
fn test_aarch32_bfi_a1_a_combo_13_10_d7c00010() {
    // Encoding: 0xD7C00010
    // Test aarch32_BFI_A1_A field combination: cond=13, msb=0, Rd=0, lsb=0, Rn=0
    // ISET: A32
    // Fields: Rn=0, Rd=0, msb=0, cond=13, lsb=0
    let encoding: u32 = 0xD7C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFI_A1_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=14 (condition AL (always))
#[test]
fn test_aarch32_bfi_a1_a_combo_14_10_e7c00010() {
    // Encoding: 0xE7C00010
    // Test aarch32_BFI_A1_A field combination: cond=14, msb=0, Rd=0, lsb=0, Rn=0
    // ISET: A32
    // Fields: Rd=0, msb=0, lsb=0, cond=14, Rn=0
    let encoding: u32 = 0xE7C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFI_A1_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=15 (condition NV (never, reserved))
#[test]
fn test_aarch32_bfi_a1_a_combo_15_10_f7c00010() {
    // Encoding: 0xF7C00010
    // Test aarch32_BFI_A1_A field combination: cond=15, msb=0, Rd=0, lsb=0, Rn=0
    // ISET: A32
    // Fields: msb=0, Rn=0, Rd=0, cond=15, lsb=0
    let encoding: u32 = 0xF7C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFI_A1_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// msb=0 (minimum value)
#[test]
fn test_aarch32_bfi_a1_a_combo_16_10_07c00010() {
    // Encoding: 0x07C00010
    // Test aarch32_BFI_A1_A field combination: cond=0, msb=0, Rd=0, lsb=0, Rn=0
    // ISET: A32
    // Fields: lsb=0, msb=0, Rd=0, Rn=0, cond=0
    let encoding: u32 = 0x07C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFI_A1_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// msb=1 (value 1)
#[test]
fn test_aarch32_bfi_a1_a_combo_17_10_07c10010() {
    // Encoding: 0x07C10010
    // Test aarch32_BFI_A1_A field combination: cond=0, msb=1, Rd=0, lsb=0, Rn=0
    // ISET: A32
    // Fields: Rd=0, lsb=0, cond=0, Rn=0, msb=1
    let encoding: u32 = 0x07C10010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFI_A1_A
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// msb=15 (midpoint (15))
#[test]
fn test_aarch32_bfi_a1_a_combo_18_10_07cf0010() {
    // Encoding: 0x07CF0010
    // Test aarch32_BFI_A1_A field combination: cond=0, msb=15, Rd=0, lsb=0, Rn=0
    // ISET: A32
    // Fields: cond=0, msb=15, Rd=0, lsb=0, Rn=0
    let encoding: u32 = 0x07CF0010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFI_A1_A
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// msb=31 (maximum value (31))
#[test]
fn test_aarch32_bfi_a1_a_combo_19_10_07df0010() {
    // Encoding: 0x07DF0010
    // Test aarch32_BFI_A1_A field combination: cond=0, msb=31, Rd=0, lsb=0, Rn=0
    // ISET: A32
    // Fields: cond=0, msb=31, Rn=0, lsb=0, Rd=0
    let encoding: u32 = 0x07DF0010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFI_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_bfi_a1_a_special_cond_0_condition_eq_16_07c00010() {
    // Encoding: 0x07C00010
    // Test aarch32_BFI_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: msb=0, cond=0, lsb=0, Rn=0, Rd=0
    let encoding: u32 = 0x07C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFI_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_bfi_a1_a_special_cond_1_condition_ne_16_17c00010() {
    // Encoding: 0x17C00010
    // Test aarch32_BFI_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: cond=1, lsb=0, Rd=0, Rn=0, msb=0
    let encoding: u32 = 0x17C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFI_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_bfi_a1_a_special_cond_2_condition_cs_hs_16_27c00010() {
    // Encoding: 0x27C00010
    // Test aarch32_BFI_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: msb=0, cond=2, Rn=0, Rd=0, lsb=0
    let encoding: u32 = 0x27C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFI_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_bfi_a1_a_special_cond_3_condition_cc_lo_16_37c00010() {
    // Encoding: 0x37C00010
    // Test aarch32_BFI_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: Rn=0, msb=0, Rd=0, cond=3, lsb=0
    let encoding: u32 = 0x37C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFI_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_bfi_a1_a_special_cond_4_condition_mi_16_47c00010() {
    // Encoding: 0x47C00010
    // Test aarch32_BFI_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: msb=0, cond=4, Rd=0, lsb=0, Rn=0
    let encoding: u32 = 0x47C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFI_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_bfi_a1_a_special_cond_5_condition_pl_16_57c00010() {
    // Encoding: 0x57C00010
    // Test aarch32_BFI_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: Rn=0, msb=0, Rd=0, cond=5, lsb=0
    let encoding: u32 = 0x57C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFI_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_bfi_a1_a_special_cond_6_condition_vs_16_67c00010() {
    // Encoding: 0x67C00010
    // Test aarch32_BFI_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: msb=0, lsb=0, Rn=0, cond=6, Rd=0
    let encoding: u32 = 0x67C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFI_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_bfi_a1_a_special_cond_7_condition_vc_16_77c00010() {
    // Encoding: 0x77C00010
    // Test aarch32_BFI_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: Rd=0, cond=7, Rn=0, msb=0, lsb=0
    let encoding: u32 = 0x77C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFI_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_bfi_a1_a_special_cond_8_condition_hi_16_87c00010() {
    // Encoding: 0x87C00010
    // Test aarch32_BFI_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: Rn=0, cond=8, Rd=0, msb=0, lsb=0
    let encoding: u32 = 0x87C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFI_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_bfi_a1_a_special_cond_9_condition_ls_16_97c00010() {
    // Encoding: 0x97C00010
    // Test aarch32_BFI_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: Rd=0, lsb=0, msb=0, cond=9, Rn=0
    let encoding: u32 = 0x97C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFI_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_bfi_a1_a_special_cond_10_condition_ge_16_a7c00010() {
    // Encoding: 0xA7C00010
    // Test aarch32_BFI_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: msb=0, cond=10, lsb=0, Rn=0, Rd=0
    let encoding: u32 = 0xA7C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFI_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_bfi_a1_a_special_cond_11_condition_lt_16_b7c00010() {
    // Encoding: 0xB7C00010
    // Test aarch32_BFI_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: msb=0, cond=11, lsb=0, Rd=0, Rn=0
    let encoding: u32 = 0xB7C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFI_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_bfi_a1_a_special_cond_12_condition_gt_16_c7c00010() {
    // Encoding: 0xC7C00010
    // Test aarch32_BFI_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: Rn=0, Rd=0, cond=12, msb=0, lsb=0
    let encoding: u32 = 0xC7C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFI_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_bfi_a1_a_special_cond_13_condition_le_16_d7c00010() {
    // Encoding: 0xD7C00010
    // Test aarch32_BFI_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: msb=0, Rn=0, lsb=0, cond=13, Rd=0
    let encoding: u32 = 0xD7C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFI_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_bfi_a1_a_special_cond_14_condition_al_16_e7c00010() {
    // Encoding: 0xE7C00010
    // Test aarch32_BFI_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: Rn=0, cond=14, lsb=0, msb=0, Rd=0
    let encoding: u32 = 0xE7C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFI_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_bfi_a1_a_special_cond_15_condition_nv_16_f7c00010() {
    // Encoding: 0xF7C00010
    // Test aarch32_BFI_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: msb=0, lsb=0, Rn=0, cond=15, Rd=0
    let encoding: u32 = 0xF7C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFI_A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_bfi_a1_a_invalid_0_10_07c00010() {
    // Encoding: 0x07C00010
    // Test aarch32_BFI_A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: LitInt(15) }
    // ISET: A32
    // Fields: msb=0, cond=0, Rn=0, lsb=0, Rd=0
    let encoding: u32 = 0x07C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_BFI_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_bfi_a1_a_invalid_1_10_07c00010() {
    // Encoding: 0x07C00010
    // Test aarch32_BFI_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: msb=0, cond=0, Rd=0, lsb=0, Rn=0
    let encoding: u32 = 0x07C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_BFI_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_bfi_t1_a_field_rn_0_min_0_f3600000() {
    // Thumb encoding (32): 0xF3600000
    // Test aarch32_BFI_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rd=0, Rn=0, imm3=0, msb=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3600000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_BFI_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_bfi_t1_a_field_rn_1_poweroftwo_0_f3610000() {
    // Thumb encoding (32): 0xF3610000
    // Test aarch32_BFI_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm3=0, imm2=0, Rn=1, Rd=0, msb=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3610000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_BFI_T1_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_bfi_t1_a_field_imm3_0_zero_0_f3600000() {
    // Thumb encoding (32): 0xF3600000
    // Test aarch32_BFI_T1_A field imm3 = 0 (Zero)
    // ISET: T32
    // Fields: msb=0, Rn=0, imm3=0, imm2=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3600000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_BFI_T1_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_bfi_t1_a_field_imm3_1_poweroftwo_0_f3601000() {
    // Thumb encoding (32): 0xF3601000
    // Test aarch32_BFI_T1_A field imm3 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rd=0, imm2=0, msb=0, Rn=0, imm3=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3601000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_BFI_T1_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 3, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (3)
#[test]
fn test_aarch32_bfi_t1_a_field_imm3_3_poweroftwominusone_0_f3603000() {
    // Thumb encoding (32): 0xF3603000
    // Test aarch32_BFI_T1_A field imm3 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm2=0, Rn=0, msb=0, Rd=0, imm3=3
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3603000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_BFI_T1_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 7, boundary: Max }
/// maximum immediate (7)
#[test]
fn test_aarch32_bfi_t1_a_field_imm3_7_max_0_f3607000() {
    // Thumb encoding (32): 0xF3607000
    // Test aarch32_BFI_T1_A field imm3 = 7 (Max)
    // ISET: T32
    // Fields: imm2=0, msb=0, Rn=0, Rd=0, imm3=7
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3607000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_BFI_T1_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_bfi_t1_a_field_rd_0_min_0_f3600000() {
    // Thumb encoding (32): 0xF3600000
    // Test aarch32_BFI_T1_A field Rd = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, msb=0, imm3=0, imm2=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3600000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_BFI_T1_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_bfi_t1_a_field_rd_1_poweroftwo_0_f3600100() {
    // Thumb encoding (32): 0xF3600100
    // Test aarch32_BFI_T1_A field Rd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm2=0, msb=0, Rd=1, Rn=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3600100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_BFI_T1_A
/// ASL: `field imm2 6 +: 2`
/// Requirement: FieldBoundary { field: "imm2", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_bfi_t1_a_field_imm2_0_zero_0_f3600000() {
    // Thumb encoding (32): 0xF3600000
    // Test aarch32_BFI_T1_A field imm2 = 0 (Zero)
    // ISET: T32
    // Fields: Rn=0, imm3=0, imm2=0, msb=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3600000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_BFI_T1_A
/// ASL: `field imm2 6 +: 2`
/// Requirement: FieldBoundary { field: "imm2", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_bfi_t1_a_field_imm2_1_poweroftwo_0_f3600040() {
    // Thumb encoding (32): 0xF3600040
    // Test aarch32_BFI_T1_A field imm2 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm3=0, msb=0, imm2=1, Rn=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3600040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_BFI_T1_A
/// ASL: `field imm2 6 +: 2`
/// Requirement: FieldBoundary { field: "imm2", value: 3, boundary: Max }
/// maximum immediate (3)
#[test]
fn test_aarch32_bfi_t1_a_field_imm2_3_max_0_f36000c0() {
    // Thumb encoding (32): 0xF36000C0
    // Test aarch32_BFI_T1_A field imm2 = 3 (Max)
    // ISET: T32
    // Fields: msb=0, Rd=0, Rn=0, imm3=0, imm2=3
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF36000C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_BFI_T1_A
/// ASL: `field msb 0 +: 5`
/// Requirement: FieldBoundary { field: "msb", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_bfi_t1_a_field_msb_0_min_0_f3600000() {
    // Thumb encoding (32): 0xF3600000
    // Test aarch32_BFI_T1_A field msb = 0 (Min)
    // ISET: T32
    // Fields: imm3=0, Rn=0, Rd=0, imm2=0, msb=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3600000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_BFI_T1_A
/// ASL: `field msb 0 +: 5`
/// Requirement: FieldBoundary { field: "msb", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_bfi_t1_a_field_msb_1_poweroftwo_0_f3600001() {
    // Thumb encoding (32): 0xF3600001
    // Test aarch32_BFI_T1_A field msb = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rd=0, Rn=0, imm2=0, msb=1, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3600001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_BFI_T1_A
/// ASL: `field msb 0 +: 5`
/// Requirement: FieldBoundary { field: "msb", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_aarch32_bfi_t1_a_field_msb_15_poweroftwominusone_0_f360000f() {
    // Thumb encoding (32): 0xF360000F
    // Test aarch32_BFI_T1_A field msb = 15 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: msb=15, imm3=0, Rn=0, imm2=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF360000F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_BFI_T1_A
/// ASL: `field msb 0 +: 5`
/// Requirement: FieldBoundary { field: "msb", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_aarch32_bfi_t1_a_field_msb_31_max_0_f360001f() {
    // Thumb encoding (32): 0xF360001F
    // Test aarch32_BFI_T1_A field msb = 31 (Max)
    // ISET: T32
    // Fields: msb=31, Rd=0, Rn=0, imm3=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF360001F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_BFI_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_bfi_t1_a_combo_0_0_f3600000() {
    // Thumb encoding (32): 0xF3600000
    // Test aarch32_BFI_T1_A field combination: Rn=0, imm3=0, Rd=0, imm2=0, msb=0
    // ISET: T32
    // Fields: msb=0, Rn=0, imm2=0, Rd=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3600000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_BFI_T1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_bfi_t1_a_combo_1_0_f3610000() {
    // Thumb encoding (32): 0xF3610000
    // Test aarch32_BFI_T1_A field combination: Rn=1, imm3=0, Rd=0, imm2=0, msb=0
    // ISET: T32
    // Fields: Rn=1, imm3=0, imm2=0, msb=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3610000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_BFI_T1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm3=0 (immediate value 0)
#[test]
fn test_aarch32_bfi_t1_a_combo_2_0_f3600000() {
    // Thumb encoding (32): 0xF3600000
    // Test aarch32_BFI_T1_A field combination: Rn=0, imm3=0, Rd=0, imm2=0, msb=0
    // ISET: T32
    // Fields: msb=0, Rd=0, imm2=0, imm3=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3600000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_BFI_T1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm3=1 (immediate value 1)
#[test]
fn test_aarch32_bfi_t1_a_combo_3_0_f3601000() {
    // Thumb encoding (32): 0xF3601000
    // Test aarch32_BFI_T1_A field combination: Rn=0, imm3=1, Rd=0, imm2=0, msb=0
    // ISET: T32
    // Fields: imm2=0, Rn=0, imm3=1, msb=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3601000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_BFI_T1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm3=3 (immediate midpoint (3))
#[test]
fn test_aarch32_bfi_t1_a_combo_4_0_f3603000() {
    // Thumb encoding (32): 0xF3603000
    // Test aarch32_BFI_T1_A field combination: Rn=0, imm3=3, Rd=0, imm2=0, msb=0
    // ISET: T32
    // Fields: Rn=0, msb=0, imm3=3, imm2=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3603000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_BFI_T1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm3=7 (maximum immediate (7))
#[test]
fn test_aarch32_bfi_t1_a_combo_5_0_f3607000() {
    // Thumb encoding (32): 0xF3607000
    // Test aarch32_BFI_T1_A field combination: Rn=0, imm3=7, Rd=0, imm2=0, msb=0
    // ISET: T32
    // Fields: Rn=0, Rd=0, imm2=0, imm3=7, msb=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3607000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_BFI_T1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch32_bfi_t1_a_combo_6_0_f3600000() {
    // Thumb encoding (32): 0xF3600000
    // Test aarch32_BFI_T1_A field combination: Rn=0, imm3=0, Rd=0, imm2=0, msb=0
    // ISET: T32
    // Fields: imm3=0, Rd=0, imm2=0, Rn=0, msb=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3600000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_BFI_T1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch32_bfi_t1_a_combo_7_0_f3600100() {
    // Thumb encoding (32): 0xF3600100
    // Test aarch32_BFI_T1_A field combination: Rn=0, imm3=0, Rd=1, imm2=0, msb=0
    // ISET: T32
    // Fields: Rd=1, imm2=0, Rn=0, imm3=0, msb=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3600100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_BFI_T1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm2=0 (immediate value 0)
#[test]
fn test_aarch32_bfi_t1_a_combo_8_0_f3600000() {
    // Thumb encoding (32): 0xF3600000
    // Test aarch32_BFI_T1_A field combination: Rn=0, imm3=0, Rd=0, imm2=0, msb=0
    // ISET: T32
    // Fields: imm2=0, msb=0, Rd=0, imm3=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3600000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_BFI_T1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm2=1 (immediate value 1)
#[test]
fn test_aarch32_bfi_t1_a_combo_9_0_f3600040() {
    // Thumb encoding (32): 0xF3600040
    // Test aarch32_BFI_T1_A field combination: Rn=0, imm3=0, Rd=0, imm2=1, msb=0
    // ISET: T32
    // Fields: imm3=0, imm2=1, Rn=0, Rd=0, msb=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3600040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_BFI_T1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm2=3 (maximum immediate (3))
#[test]
fn test_aarch32_bfi_t1_a_combo_10_0_f36000c0() {
    // Thumb encoding (32): 0xF36000C0
    // Test aarch32_BFI_T1_A field combination: Rn=0, imm3=0, Rd=0, imm2=3, msb=0
    // ISET: T32
    // Fields: imm2=3, Rd=0, imm3=0, Rn=0, msb=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF36000C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_BFI_T1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// msb=0 (minimum value)
#[test]
fn test_aarch32_bfi_t1_a_combo_11_0_f3600000() {
    // Thumb encoding (32): 0xF3600000
    // Test aarch32_BFI_T1_A field combination: Rn=0, imm3=0, Rd=0, imm2=0, msb=0
    // ISET: T32
    // Fields: msb=0, Rd=0, imm3=0, Rn=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3600000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_BFI_T1_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// msb=1 (value 1)
#[test]
fn test_aarch32_bfi_t1_a_combo_12_0_f3600001() {
    // Thumb encoding (32): 0xF3600001
    // Test aarch32_BFI_T1_A field combination: Rn=0, imm3=0, Rd=0, imm2=0, msb=1
    // ISET: T32
    // Fields: imm3=0, imm2=0, msb=1, Rn=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3600001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_BFI_T1_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// msb=15 (midpoint (15))
#[test]
fn test_aarch32_bfi_t1_a_combo_13_0_f360000f() {
    // Thumb encoding (32): 0xF360000F
    // Test aarch32_BFI_T1_A field combination: Rn=0, imm3=0, Rd=0, imm2=0, msb=15
    // ISET: T32
    // Fields: Rn=0, msb=15, imm3=0, imm2=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF360000F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_BFI_T1_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// msb=31 (maximum value (31))
#[test]
fn test_aarch32_bfi_t1_a_combo_14_0_f360001f() {
    // Thumb encoding (32): 0xF360001F
    // Test aarch32_BFI_T1_A field combination: Rn=0, imm3=0, Rd=0, imm2=0, msb=31
    // ISET: T32
    // Fields: imm2=0, msb=31, imm3=0, Rd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF360001F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_BFI_T1_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch32_bfi_t1_a_combo_15_0_f3610100() {
    // Thumb encoding (32): 0xF3610100
    // Test aarch32_BFI_T1_A field combination: Rn=1, imm3=0, Rd=1, imm2=0, msb=0
    // ISET: T32
    // Fields: imm3=0, msb=0, Rn=1, Rd=1, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3610100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_BFI_T1_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch32_bfi_t1_a_combo_16_0_f36f0f00() {
    // Thumb encoding (32): 0xF36F0F00
    // Test aarch32_BFI_T1_A field combination: Rn=31, imm3=0, Rd=31, imm2=0, msb=0
    // ISET: T32
    // Fields: imm3=0, Rn=31, msb=0, Rd=31, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF36F0F00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_BFI_T1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_bfi_t1_a_invalid_0_0_f3600000() {
    // Thumb encoding (32): 0xF3600000
    // Test aarch32_BFI_T1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: LitInt(15) }
    // ISET: T32
    // Fields: imm3=0, Rd=0, Rn=0, imm2=0, msb=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3600000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_BFI_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_bfi_t1_a_invalid_1_0_f3600000() {
    // Thumb encoding (32): 0xF3600000
    // Test aarch32_BFI_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rd=0, Rn=0, imm3=0, msb=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3600000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_BFI_A1_A
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Unpredictable
#[test]
fn test_aarch32_bfi_a1_a_exception_0_07c00010() {
    // Test aarch32_BFI_A1_A exception: Unpredictable
    // Encoding: 0x07C00010
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x07C00010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_BFI_T1_A
/// ASL: `SUB X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_bfi_t1_a_sub_oracle_32_0_f3602820() {
    // Test SUB 32-bit: simple addition/subtraction (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF3602820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF7F6064, "X0 should be 0xFFFFFFFFFF7F6064");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_BFI_T1_A
/// ASL: `SUB X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_bfi_t1_a_sub_oracle_64_0_f3602820() {
    // Test SUB 64-bit: simple addition/subtraction (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF3602820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF7F6064, "X0 should be 0xFFFFFFFFFF7F6064");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_BFI_T1_A
/// ASL: `SUB X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero operands (32)
#[test]
fn test_aarch32_bfi_t1_a_sub_oracle_32_1_f3600020() {
    // Test SUB 32-bit: zero operands (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF3600020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF800000, "X0 should be 0xFFFFFFFFFF800000");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_BFI_T1_A
/// ASL: `SUB X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero operands (64)
#[test]
fn test_aarch32_bfi_t1_a_sub_oracle_64_1_f3600020() {
    // Test SUB 64-bit: zero operands (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF3600020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF800000, "X0 should be 0xFFFFFFFFFF800000");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_BFI_T1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small values (32)
#[test]
fn test_aarch32_bfi_t1_a_sub_oracle_32_2_f3600420() {
    // Test SUB 32-bit: small values (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF3600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF7FF001, "X0 should be 0xFFFFFFFFFF7FF001");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_BFI_T1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// small values (64)
#[test]
fn test_aarch32_bfi_t1_a_sub_oracle_64_2_f3600420() {
    // Test SUB 64-bit: small values (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF3600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF7FF001, "X0 should be 0xFFFFFFFFFF7FF001");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_BFI_T1_A
/// ASL: `SUB X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_bfi_t1_a_sub_oracle_32_3_f37ffc20() {
    // Test SUB 32-bit: max imm12 unshifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF37FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF001000, "X0 should be 0xFFFFFFFFFF001000");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_BFI_T1_A
/// ASL: `SUB X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_bfi_t1_a_sub_oracle_64_3_f37ffc20() {
    // Test SUB 64-bit: max imm12 unshifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF37FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF001000, "X0 should be 0xFFFFFFFFFF001000");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_BFI_T1_A
/// ASL: `SUB X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_bfi_t1_a_sub_oracle_32_4_f37ffc20() {
    // Test SUB 32-bit: max imm12 shifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF37FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF001000, "X0 should be 0xFFFFFFFFFF001000");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_BFI_T1_A
/// ASL: `SUB X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_bfi_t1_a_sub_oracle_64_4_f37ffc20() {
    // Test SUB 64-bit: max imm12 shifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF37FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF001000, "X0 should be 0xFFFFFFFFFF001000");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_BFI_T1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max u64 operand (32)
#[test]
fn test_aarch32_bfi_t1_a_sub_oracle_32_5_f3600420() {
    // Test SUB 32-bit: max u64 operand (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF3600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF7FEFFF, "X0 should be 0x00000000FF7FEFFF");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_BFI_T1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max u64 operand (64)
#[test]
fn test_aarch32_bfi_t1_a_sub_oracle_64_5_f3600420() {
    // Test SUB 64-bit: max u64 operand (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF3600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF7FEFFF, "X0 should be 0xFFFFFFFFFF7FEFFF");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_BFI_T1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_bfi_t1_a_sub_oracle_32_6_f3600420() {
    // Test SUB 32-bit: zero result (for sub 1-1) (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF3600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF7FF000, "X0 should be 0xFFFFFFFFFF7FF000");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_BFI_T1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_bfi_t1_a_sub_oracle_64_6_f3600420() {
    // Test SUB 64-bit: zero result (for sub 1-1) (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF3600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF7FF000, "X0 should be 0xFFFFFFFFFF7FF000");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_BFI_T1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_bfi_t1_a_sub_oracle_32_7_f3600420() {
    // Test SUB 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF3600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF7FEFFF, "X0 should be 0x00000000FF7FEFFF");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_BFI_T1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_bfi_t1_a_sub_oracle_64_7_f3600420() {
    // Test SUB 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF3600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF7FEFFF, "X0 should be 0x7FFFFFFFFF7FEFFF");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_BFI_T1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_bfi_t1_a_sub_oracle_32_8_f3600420() {
    // Test SUB 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF3600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7F7FEFFF, "X0 should be 0x000000007F7FEFFF");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_BFI_T1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_bfi_t1_a_sub_oracle_64_8_f3600420() {
    // Test SUB 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF3600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7F7FEFFF, "X0 should be 0x000000007F7FEFFF");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_BFI_T1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_bfi_t1_a_sub_oracle_32_9_f3600420() {
    // Test SUB 32-bit: unsigned overflow 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF3600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF7FEFFF, "X0 should be 0x00000000FF7FEFFF");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_BFI_T1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_bfi_t1_a_sub_oracle_64_9_f3600420() {
    // Test SUB 64-bit: unsigned overflow 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF3600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF7FEFFF, "X0 should be 0xFFFFFFFFFF7FEFFF");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_BFI_T1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_bfi_t1_a_sub_oracle_32_10_f3600420() {
    // Test SUB 32-bit: unsigned overflow 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF3600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF7FEFFF, "X0 should be 0x00000000FF7FEFFF");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_BFI_T1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_bfi_t1_a_sub_oracle_64_10_f3600420() {
    // Test SUB 64-bit: unsigned overflow 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF3600420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF7FEFFF, "X0 should be 0x00000000FF7FEFFF");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_BFI_T1_A
/// ASL: `SUB SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (32)
#[test]
fn test_aarch32_bfi_t1_a_sub_oracle_32_rd31_sp_f360283f() {
    // Test SUB 32-bit with Rd=31 (SP)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF360283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_BFI_T1_A
/// ASL: `SUB SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (64)
#[test]
fn test_aarch32_bfi_t1_a_sub_oracle_64_rd31_sp_f360283f() {
    // Test SUB 64-bit with Rd=31 (SP)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF360283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_BFI_T1_A
/// ASL: `SUB.W R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple values
#[test]
fn test_aarch32_bfi_t1_a_t32_oracle_0_f3610000() {
    // Test T32 SUB: simple values (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x32);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF3610000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x32, "R0 should be 0x00000032");
}

/// Provenance: aarch32_BFI_T1_A
/// ASL: `SUB.W R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero values
#[test]
fn test_aarch32_bfi_t1_a_t32_oracle_1_f3610000() {
    // Test T32 SUB: zero values (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF3610000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_BFI_T1_A
/// ASL: `SUB.W R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max value
#[test]
fn test_aarch32_bfi_t1_a_t32_oracle_2_f3610000() {
    // Test T32 SUB: max value (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0xF3610000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFE, "R0 should be 0xFFFFFFFE");
}

/// Provenance: aarch32_BFI_T1_A
/// ASL: `SUB.W R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// mixed pattern
#[test]
fn test_aarch32_bfi_t1_a_t32_oracle_3_f3610000() {
    // Test T32 SUB: mixed pattern (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xABCDEF01);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u32 = 0xF3610000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x66666777, "R0 should be 0x66666777");
}

/// Provenance: aarch32_BFI_T1_A
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Unpredictable
#[test]
fn test_aarch32_bfi_t1_a_exception_0_f3600000() {
    // Test aarch32_BFI_T1_A exception: Unpredictable
    // ISET: T32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3600000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// aarch32_SSAT_A Tests
// ============================================================================

/// Provenance: aarch32_SSAT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_ssat_a1_a_field_cond_0_min_10_06a00010() {
    // Encoding: 0x06A00010
    // Test aarch32_SSAT_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: imm5=0, sh=0, Rn=0, cond=0, Rd=0, sat_imm=0
    let encoding: u32 = 0x06A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_ssat_a1_a_field_cond_1_poweroftwo_10_16a00010() {
    // Encoding: 0x16A00010
    // Test aarch32_SSAT_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: sat_imm=0, sh=0, cond=1, Rn=0, Rd=0, imm5=0
    let encoding: u32 = 0x16A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_ssat_a1_a_field_cond_2_poweroftwo_10_26a00010() {
    // Encoding: 0x26A00010
    // Test aarch32_SSAT_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: sat_imm=0, sh=0, cond=2, Rn=0, Rd=0, imm5=0
    let encoding: u32 = 0x26A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_ssat_a1_a_field_cond_3_poweroftwo_10_36a00010() {
    // Encoding: 0x36A00010
    // Test aarch32_SSAT_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: sat_imm=0, imm5=0, sh=0, Rn=0, cond=3, Rd=0
    let encoding: u32 = 0x36A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_ssat_a1_a_field_cond_4_poweroftwo_10_46a00010() {
    // Encoding: 0x46A00010
    // Test aarch32_SSAT_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rd=0, imm5=0, sat_imm=0, cond=4, sh=0
    let encoding: u32 = 0x46A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_ssat_a1_a_field_cond_5_poweroftwo_10_56a00010() {
    // Encoding: 0x56A00010
    // Test aarch32_SSAT_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, sh=0, cond=5, sat_imm=0, Rd=0, imm5=0
    let encoding: u32 = 0x56A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_ssat_a1_a_field_cond_6_poweroftwo_10_66a00010() {
    // Encoding: 0x66A00010
    // Test aarch32_SSAT_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: sat_imm=0, imm5=0, Rd=0, sh=0, cond=6, Rn=0
    let encoding: u32 = 0x66A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_ssat_a1_a_field_cond_7_poweroftwo_10_76a00010() {
    // Encoding: 0x76A00010
    // Test aarch32_SSAT_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: sat_imm=0, Rn=0, Rd=0, cond=7, imm5=0, sh=0
    let encoding: u32 = 0x76A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_ssat_a1_a_field_cond_8_poweroftwo_10_86a00010() {
    // Encoding: 0x86A00010
    // Test aarch32_SSAT_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=8, Rd=0, sh=0, Rn=0, imm5=0, sat_imm=0
    let encoding: u32 = 0x86A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_ssat_a1_a_field_cond_9_poweroftwo_10_96a00010() {
    // Encoding: 0x96A00010
    // Test aarch32_SSAT_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, sat_imm=0, sh=0, Rn=0, imm5=0, cond=9
    let encoding: u32 = 0x96A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_ssat_a1_a_field_cond_10_poweroftwo_10_a6a00010() {
    // Encoding: 0xA6A00010
    // Test aarch32_SSAT_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=10, sh=0, imm5=0, Rd=0, Rn=0, sat_imm=0
    let encoding: u32 = 0xA6A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_ssat_a1_a_field_cond_11_poweroftwo_10_b6a00010() {
    // Encoding: 0xB6A00010
    // Test aarch32_SSAT_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: sat_imm=0, imm5=0, Rd=0, cond=11, sh=0, Rn=0
    let encoding: u32 = 0xB6A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_ssat_a1_a_field_cond_12_poweroftwo_10_c6a00010() {
    // Encoding: 0xC6A00010
    // Test aarch32_SSAT_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: sat_imm=0, imm5=0, sh=0, Rn=0, cond=12, Rd=0
    let encoding: u32 = 0xC6A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_ssat_a1_a_field_cond_13_poweroftwo_10_d6a00010() {
    // Encoding: 0xD6A00010
    // Test aarch32_SSAT_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, sat_imm=0, Rd=0, cond=13, imm5=0, sh=0
    let encoding: u32 = 0xD6A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_ssat_a1_a_field_cond_14_poweroftwo_10_e6a00010() {
    // Encoding: 0xE6A00010
    // Test aarch32_SSAT_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: sat_imm=0, cond=14, imm5=0, Rd=0, sh=0, Rn=0
    let encoding: u32 = 0xE6A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_ssat_a1_a_field_cond_15_max_10_f6a00010() {
    // Encoding: 0xF6A00010
    // Test aarch32_SSAT_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: cond=15, imm5=0, Rd=0, sat_imm=0, sh=0, Rn=0
    let encoding: u32 = 0xF6A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT_A1_A
/// ASL: `field sat_imm 16 +: 5`
/// Requirement: FieldBoundary { field: "sat_imm", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ssat_a1_a_field_sat_imm_0_min_10_06a00010() {
    // Encoding: 0x06A00010
    // Test aarch32_SSAT_A1_A field sat_imm = 0 (Min)
    // ISET: A32
    // Fields: cond=0, imm5=0, sat_imm=0, sh=0, Rd=0, Rn=0
    let encoding: u32 = 0x06A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT_A1_A
/// ASL: `field sat_imm 16 +: 5`
/// Requirement: FieldBoundary { field: "sat_imm", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_ssat_a1_a_field_sat_imm_1_poweroftwo_10_06a10010() {
    // Encoding: 0x06A10010
    // Test aarch32_SSAT_A1_A field sat_imm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, sat_imm=1, sh=0, Rn=0, imm5=0, Rd=0
    let encoding: u32 = 0x06A10010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT_A1_A
/// ASL: `field sat_imm 16 +: 5`
/// Requirement: FieldBoundary { field: "sat_imm", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_aarch32_ssat_a1_a_field_sat_imm_15_poweroftwominusone_10_06af0010() {
    // Encoding: 0x06AF0010
    // Test aarch32_SSAT_A1_A field sat_imm = 15 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, imm5=0, sh=0, sat_imm=15, Rn=0, Rd=0
    let encoding: u32 = 0x06AF0010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT_A1_A
/// ASL: `field sat_imm 16 +: 5`
/// Requirement: FieldBoundary { field: "sat_imm", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_aarch32_ssat_a1_a_field_sat_imm_31_max_10_06bf0010() {
    // Encoding: 0x06BF0010
    // Test aarch32_SSAT_A1_A field sat_imm = 31 (Max)
    // ISET: A32
    // Fields: Rd=0, imm5=0, Rn=0, sat_imm=31, cond=0, sh=0
    let encoding: u32 = 0x06BF0010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ssat_a1_a_field_rd_0_min_10_06a00010() {
    // Encoding: 0x06A00010
    // Test aarch32_SSAT_A1_A field Rd = 0 (Min)
    // ISET: A32
    // Fields: imm5=0, Rd=0, sh=0, Rn=0, sat_imm=0, cond=0
    let encoding: u32 = 0x06A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ssat_a1_a_field_rd_1_poweroftwo_10_06a01010() {
    // Encoding: 0x06A01010
    // Test aarch32_SSAT_A1_A field Rd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, sat_imm=0, sh=0, imm5=0, Rn=0, Rd=1
    let encoding: u32 = 0x06A01010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_ssat_a1_a_field_imm5_0_zero_10_06a00010() {
    // Encoding: 0x06A00010
    // Test aarch32_SSAT_A1_A field imm5 = 0 (Zero)
    // ISET: A32
    // Fields: sh=0, Rn=0, cond=0, Rd=0, sat_imm=0, imm5=0
    let encoding: u32 = 0x06A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_ssat_a1_a_field_imm5_1_poweroftwo_10_06a00090() {
    // Encoding: 0x06A00090
    // Test aarch32_SSAT_A1_A field imm5 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, sh=0, Rn=0, sat_imm=0, Rd=0, imm5=1
    let encoding: u32 = 0x06A00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_ssat_a1_a_field_imm5_3_poweroftwominusone_10_06a00190() {
    // Encoding: 0x06A00190
    // Test aarch32_SSAT_A1_A field imm5 = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, imm5=3, sh=0, Rn=0, Rd=0, sat_imm=0
    let encoding: u32 = 0x06A00190;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_ssat_a1_a_field_imm5_4_poweroftwo_10_06a00210() {
    // Encoding: 0x06A00210
    // Test aarch32_SSAT_A1_A field imm5 = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, cond=0, imm5=4, sat_imm=0, sh=0, Rn=0
    let encoding: u32 = 0x06A00210;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_ssat_a1_a_field_imm5_7_poweroftwominusone_10_06a00390() {
    // Encoding: 0x06A00390
    // Test aarch32_SSAT_A1_A field imm5 = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rn=0, cond=0, sat_imm=0, imm5=7, Rd=0, sh=0
    let encoding: u32 = 0x06A00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_ssat_a1_a_field_imm5_8_poweroftwo_10_06a00410() {
    // Encoding: 0x06A00410
    // Test aarch32_SSAT_A1_A field imm5 = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, sat_imm=0, imm5=8, sh=0, cond=0, Rd=0
    let encoding: u32 = 0x06A00410;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 15, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (15)
#[test]
fn test_aarch32_ssat_a1_a_field_imm5_15_poweroftwominusone_10_06a00790() {
    // Encoding: 0x06A00790
    // Test aarch32_SSAT_A1_A field imm5 = 15 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rn=0, sh=0, Rd=0, cond=0, sat_imm=0, imm5=15
    let encoding: u32 = 0x06A00790;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_ssat_a1_a_field_imm5_16_poweroftwo_10_06a00810() {
    // Encoding: 0x06A00810
    // Test aarch32_SSAT_A1_A field imm5 = 16 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, sh=0, Rd=0, cond=0, sat_imm=0, imm5=16
    let encoding: u32 = 0x06A00810;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 31, boundary: Max }
/// maximum immediate (31)
#[test]
fn test_aarch32_ssat_a1_a_field_imm5_31_max_10_06a00f90() {
    // Encoding: 0x06A00F90
    // Test aarch32_SSAT_A1_A field imm5 = 31 (Max)
    // ISET: A32
    // Fields: Rn=0, sh=0, cond=0, imm5=31, sat_imm=0, Rd=0
    let encoding: u32 = 0x06A00F90;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT_A1_A
/// ASL: `field sh 6 +: 1`
/// Requirement: FieldBoundary { field: "sh", value: 0, boundary: Min }
/// shift type LSL (logical shift left)
#[test]
fn test_aarch32_ssat_a1_a_field_sh_0_min_10_06a00010() {
    // Encoding: 0x06A00010
    // Test aarch32_SSAT_A1_A field sh = 0 (Min)
    // ISET: A32
    // Fields: sat_imm=0, imm5=0, sh=0, Rd=0, Rn=0, cond=0
    let encoding: u32 = 0x06A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT_A1_A
/// ASL: `field sh 6 +: 1`
/// Requirement: FieldBoundary { field: "sh", value: 1, boundary: Max }
/// shift type LSR (logical shift right)
#[test]
fn test_aarch32_ssat_a1_a_field_sh_1_max_10_06a00050() {
    // Encoding: 0x06A00050
    // Test aarch32_SSAT_A1_A field sh = 1 (Max)
    // ISET: A32
    // Fields: sat_imm=0, cond=0, sh=1, imm5=0, Rn=0, Rd=0
    let encoding: u32 = 0x06A00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT_A1_A
/// ASL: `field Rn 0 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ssat_a1_a_field_rn_0_min_10_06a00010() {
    // Encoding: 0x06A00010
    // Test aarch32_SSAT_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: Rd=0, imm5=0, sat_imm=0, cond=0, sh=0, Rn=0
    let encoding: u32 = 0x06A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT_A1_A
/// ASL: `field Rn 0 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ssat_a1_a_field_rn_1_poweroftwo_10_06a00011() {
    // Encoding: 0x06A00011
    // Test aarch32_SSAT_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=1, Rd=0, sh=0, imm5=0, cond=0, sat_imm=0
    let encoding: u32 = 0x06A00011;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_ssat_a1_a_combo_0_10_06a00010() {
    // Encoding: 0x06A00010
    // Test aarch32_SSAT_A1_A field combination: cond=0, sat_imm=0, Rd=0, imm5=0, sh=0, Rn=0
    // ISET: A32
    // Fields: Rd=0, imm5=0, cond=0, sat_imm=0, sh=0, Rn=0
    let encoding: u32 = 0x06A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT_A1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=1 (condition NE (not equal))
#[test]
fn test_aarch32_ssat_a1_a_combo_1_10_16a00010() {
    // Encoding: 0x16A00010
    // Test aarch32_SSAT_A1_A field combination: cond=1, sat_imm=0, Rd=0, imm5=0, sh=0, Rn=0
    // ISET: A32
    // Fields: sat_imm=0, sh=0, Rn=0, imm5=0, Rd=0, cond=1
    let encoding: u32 = 0x16A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT_A1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=2 (condition CS/HS (carry set))
#[test]
fn test_aarch32_ssat_a1_a_combo_2_10_26a00010() {
    // Encoding: 0x26A00010
    // Test aarch32_SSAT_A1_A field combination: cond=2, sat_imm=0, Rd=0, imm5=0, sh=0, Rn=0
    // ISET: A32
    // Fields: Rn=0, sat_imm=0, Rd=0, cond=2, imm5=0, sh=0
    let encoding: u32 = 0x26A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT_A1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=3 (condition CC/LO (carry clear))
#[test]
fn test_aarch32_ssat_a1_a_combo_3_10_36a00010() {
    // Encoding: 0x36A00010
    // Test aarch32_SSAT_A1_A field combination: cond=3, sat_imm=0, Rd=0, imm5=0, sh=0, Rn=0
    // ISET: A32
    // Fields: sh=0, sat_imm=0, Rd=0, cond=3, Rn=0, imm5=0
    let encoding: u32 = 0x36A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT_A1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=4 (condition MI (minus/negative))
#[test]
fn test_aarch32_ssat_a1_a_combo_4_10_46a00010() {
    // Encoding: 0x46A00010
    // Test aarch32_SSAT_A1_A field combination: cond=4, sat_imm=0, Rd=0, imm5=0, sh=0, Rn=0
    // ISET: A32
    // Fields: sat_imm=0, Rn=0, sh=0, cond=4, imm5=0, Rd=0
    let encoding: u32 = 0x46A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT_A1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=5 (condition PL (plus/positive))
#[test]
fn test_aarch32_ssat_a1_a_combo_5_10_56a00010() {
    // Encoding: 0x56A00010
    // Test aarch32_SSAT_A1_A field combination: cond=5, sat_imm=0, Rd=0, imm5=0, sh=0, Rn=0
    // ISET: A32
    // Fields: Rn=0, cond=5, imm5=0, sh=0, sat_imm=0, Rd=0
    let encoding: u32 = 0x56A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT_A1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=6 (condition VS (overflow set))
#[test]
fn test_aarch32_ssat_a1_a_combo_6_10_66a00010() {
    // Encoding: 0x66A00010
    // Test aarch32_SSAT_A1_A field combination: cond=6, sat_imm=0, Rd=0, imm5=0, sh=0, Rn=0
    // ISET: A32
    // Fields: cond=6, imm5=0, sat_imm=0, Rd=0, Rn=0, sh=0
    let encoding: u32 = 0x66A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT_A1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=7 (condition VC (overflow clear))
#[test]
fn test_aarch32_ssat_a1_a_combo_7_10_76a00010() {
    // Encoding: 0x76A00010
    // Test aarch32_SSAT_A1_A field combination: cond=7, sat_imm=0, Rd=0, imm5=0, sh=0, Rn=0
    // ISET: A32
    // Fields: sh=0, sat_imm=0, cond=7, imm5=0, Rn=0, Rd=0
    let encoding: u32 = 0x76A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT_A1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=8 (condition HI (unsigned higher))
#[test]
fn test_aarch32_ssat_a1_a_combo_8_10_86a00010() {
    // Encoding: 0x86A00010
    // Test aarch32_SSAT_A1_A field combination: cond=8, sat_imm=0, Rd=0, imm5=0, sh=0, Rn=0
    // ISET: A32
    // Fields: cond=8, sat_imm=0, sh=0, imm5=0, Rd=0, Rn=0
    let encoding: u32 = 0x86A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT_A1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=9 (condition LS (unsigned lower or same))
#[test]
fn test_aarch32_ssat_a1_a_combo_9_10_96a00010() {
    // Encoding: 0x96A00010
    // Test aarch32_SSAT_A1_A field combination: cond=9, sat_imm=0, Rd=0, imm5=0, sh=0, Rn=0
    // ISET: A32
    // Fields: sat_imm=0, sh=0, imm5=0, Rn=0, Rd=0, cond=9
    let encoding: u32 = 0x96A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT_A1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=10 (condition GE (signed >=))
#[test]
fn test_aarch32_ssat_a1_a_combo_10_10_a6a00010() {
    // Encoding: 0xA6A00010
    // Test aarch32_SSAT_A1_A field combination: cond=10, sat_imm=0, Rd=0, imm5=0, sh=0, Rn=0
    // ISET: A32
    // Fields: sat_imm=0, imm5=0, Rn=0, Rd=0, sh=0, cond=10
    let encoding: u32 = 0xA6A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT_A1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=11 (condition LT (signed <))
#[test]
fn test_aarch32_ssat_a1_a_combo_11_10_b6a00010() {
    // Encoding: 0xB6A00010
    // Test aarch32_SSAT_A1_A field combination: cond=11, sat_imm=0, Rd=0, imm5=0, sh=0, Rn=0
    // ISET: A32
    // Fields: Rd=0, cond=11, imm5=0, sh=0, Rn=0, sat_imm=0
    let encoding: u32 = 0xB6A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT_A1_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=12 (condition GT (signed >))
#[test]
fn test_aarch32_ssat_a1_a_combo_12_10_c6a00010() {
    // Encoding: 0xC6A00010
    // Test aarch32_SSAT_A1_A field combination: cond=12, sat_imm=0, Rd=0, imm5=0, sh=0, Rn=0
    // ISET: A32
    // Fields: sh=0, Rn=0, Rd=0, imm5=0, cond=12, sat_imm=0
    let encoding: u32 = 0xC6A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT_A1_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=13 (condition LE (signed <=))
#[test]
fn test_aarch32_ssat_a1_a_combo_13_10_d6a00010() {
    // Encoding: 0xD6A00010
    // Test aarch32_SSAT_A1_A field combination: cond=13, sat_imm=0, Rd=0, imm5=0, sh=0, Rn=0
    // ISET: A32
    // Fields: cond=13, Rd=0, sat_imm=0, imm5=0, sh=0, Rn=0
    let encoding: u32 = 0xD6A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT_A1_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=14 (condition AL (always))
#[test]
fn test_aarch32_ssat_a1_a_combo_14_10_e6a00010() {
    // Encoding: 0xE6A00010
    // Test aarch32_SSAT_A1_A field combination: cond=14, sat_imm=0, Rd=0, imm5=0, sh=0, Rn=0
    // ISET: A32
    // Fields: sat_imm=0, imm5=0, cond=14, Rd=0, sh=0, Rn=0
    let encoding: u32 = 0xE6A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT_A1_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=15 (condition NV (never, reserved))
#[test]
fn test_aarch32_ssat_a1_a_combo_15_10_f6a00010() {
    // Encoding: 0xF6A00010
    // Test aarch32_SSAT_A1_A field combination: cond=15, sat_imm=0, Rd=0, imm5=0, sh=0, Rn=0
    // ISET: A32
    // Fields: Rd=0, cond=15, imm5=0, sh=0, Rn=0, sat_imm=0
    let encoding: u32 = 0xF6A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT_A1_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sat_imm=0 (minimum value)
#[test]
fn test_aarch32_ssat_a1_a_combo_16_10_06a00010() {
    // Encoding: 0x06A00010
    // Test aarch32_SSAT_A1_A field combination: cond=0, sat_imm=0, Rd=0, imm5=0, sh=0, Rn=0
    // ISET: A32
    // Fields: imm5=0, sat_imm=0, Rn=0, sh=0, Rd=0, cond=0
    let encoding: u32 = 0x06A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT_A1_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sat_imm=1 (value 1)
#[test]
fn test_aarch32_ssat_a1_a_combo_17_10_06a10010() {
    // Encoding: 0x06A10010
    // Test aarch32_SSAT_A1_A field combination: cond=0, sat_imm=1, Rd=0, imm5=0, sh=0, Rn=0
    // ISET: A32
    // Fields: cond=0, Rd=0, Rn=0, sat_imm=1, sh=0, imm5=0
    let encoding: u32 = 0x06A10010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT_A1_A
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sat_imm=15 (midpoint (15))
#[test]
fn test_aarch32_ssat_a1_a_combo_18_10_06af0010() {
    // Encoding: 0x06AF0010
    // Test aarch32_SSAT_A1_A field combination: cond=0, sat_imm=15, Rd=0, imm5=0, sh=0, Rn=0
    // ISET: A32
    // Fields: Rn=0, cond=0, sh=0, Rd=0, sat_imm=15, imm5=0
    let encoding: u32 = 0x06AF0010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT_A1_A
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sat_imm=31 (maximum value (31))
#[test]
fn test_aarch32_ssat_a1_a_combo_19_10_06bf0010() {
    // Encoding: 0x06BF0010
    // Test aarch32_SSAT_A1_A field combination: cond=0, sat_imm=31, Rd=0, imm5=0, sh=0, Rn=0
    // ISET: A32
    // Fields: imm5=0, cond=0, Rn=0, Rd=0, sat_imm=31, sh=0
    let encoding: u32 = 0x06BF0010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_ssat_a1_a_special_cond_0_condition_eq_16_06a00010() {
    // Encoding: 0x06A00010
    // Test aarch32_SSAT_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: sh=0, Rn=0, imm5=0, sat_imm=0, Rd=0, cond=0
    let encoding: u32 = 0x06A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_ssat_a1_a_special_cond_1_condition_ne_16_16a00010() {
    // Encoding: 0x16A00010
    // Test aarch32_SSAT_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: sh=0, cond=1, Rn=0, sat_imm=0, Rd=0, imm5=0
    let encoding: u32 = 0x16A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_ssat_a1_a_special_cond_2_condition_cs_hs_16_26a00010() {
    // Encoding: 0x26A00010
    // Test aarch32_SSAT_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: cond=2, Rd=0, Rn=0, sat_imm=0, imm5=0, sh=0
    let encoding: u32 = 0x26A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_ssat_a1_a_special_cond_3_condition_cc_lo_16_36a00010() {
    // Encoding: 0x36A00010
    // Test aarch32_SSAT_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: sat_imm=0, Rd=0, Rn=0, imm5=0, sh=0, cond=3
    let encoding: u32 = 0x36A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_ssat_a1_a_special_cond_4_condition_mi_16_46a00010() {
    // Encoding: 0x46A00010
    // Test aarch32_SSAT_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: sh=0, imm5=0, Rn=0, cond=4, sat_imm=0, Rd=0
    let encoding: u32 = 0x46A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_ssat_a1_a_special_cond_5_condition_pl_16_56a00010() {
    // Encoding: 0x56A00010
    // Test aarch32_SSAT_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: Rn=0, sat_imm=0, Rd=0, cond=5, sh=0, imm5=0
    let encoding: u32 = 0x56A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_ssat_a1_a_special_cond_6_condition_vs_16_66a00010() {
    // Encoding: 0x66A00010
    // Test aarch32_SSAT_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: Rd=0, sat_imm=0, Rn=0, cond=6, imm5=0, sh=0
    let encoding: u32 = 0x66A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_ssat_a1_a_special_cond_7_condition_vc_16_76a00010() {
    // Encoding: 0x76A00010
    // Test aarch32_SSAT_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: Rn=0, sat_imm=0, Rd=0, cond=7, imm5=0, sh=0
    let encoding: u32 = 0x76A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_ssat_a1_a_special_cond_8_condition_hi_16_86a00010() {
    // Encoding: 0x86A00010
    // Test aarch32_SSAT_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: sat_imm=0, imm5=0, sh=0, Rn=0, cond=8, Rd=0
    let encoding: u32 = 0x86A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_ssat_a1_a_special_cond_9_condition_ls_16_96a00010() {
    // Encoding: 0x96A00010
    // Test aarch32_SSAT_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: Rd=0, sh=0, sat_imm=0, Rn=0, cond=9, imm5=0
    let encoding: u32 = 0x96A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_ssat_a1_a_special_cond_10_condition_ge_16_a6a00010() {
    // Encoding: 0xA6A00010
    // Test aarch32_SSAT_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: sat_imm=0, imm5=0, Rn=0, sh=0, Rd=0, cond=10
    let encoding: u32 = 0xA6A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_ssat_a1_a_special_cond_11_condition_lt_16_b6a00010() {
    // Encoding: 0xB6A00010
    // Test aarch32_SSAT_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: sh=0, Rd=0, Rn=0, cond=11, imm5=0, sat_imm=0
    let encoding: u32 = 0xB6A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_ssat_a1_a_special_cond_12_condition_gt_16_c6a00010() {
    // Encoding: 0xC6A00010
    // Test aarch32_SSAT_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: imm5=0, Rd=0, cond=12, Rn=0, sat_imm=0, sh=0
    let encoding: u32 = 0xC6A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_ssat_a1_a_special_cond_13_condition_le_16_d6a00010() {
    // Encoding: 0xD6A00010
    // Test aarch32_SSAT_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: imm5=0, Rn=0, sh=0, sat_imm=0, Rd=0, cond=13
    let encoding: u32 = 0xD6A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_ssat_a1_a_special_cond_14_condition_al_16_e6a00010() {
    // Encoding: 0xE6A00010
    // Test aarch32_SSAT_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: sat_imm=0, Rd=0, cond=14, sh=0, Rn=0, imm5=0
    let encoding: u32 = 0xE6A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_ssat_a1_a_special_cond_15_condition_nv_16_f6a00010() {
    // Encoding: 0xF6A00010
    // Test aarch32_SSAT_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: sh=0, Rd=0, imm5=0, Rn=0, cond=15, sat_imm=0
    let encoding: u32 = 0xF6A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT_A1_A
/// ASL: `field sh = 0 (Shift type LSL)`
/// Requirement: FieldSpecial { field: "sh", value: 0, meaning: "Shift type LSL" }
/// Shift type LSL
#[test]
fn test_aarch32_ssat_a1_a_special_sh_0_shift_type_lsl_16_06a00010() {
    // Encoding: 0x06A00010
    // Test aarch32_SSAT_A1_A special value sh = 0 (Shift type LSL)
    // ISET: A32
    // Fields: sat_imm=0, imm5=0, Rd=0, sh=0, cond=0, Rn=0
    let encoding: u32 = 0x06A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT_A1_A
/// ASL: `field sh = 1 (Shift type LSR)`
/// Requirement: FieldSpecial { field: "sh", value: 1, meaning: "Shift type LSR" }
/// Shift type LSR
#[test]
fn test_aarch32_ssat_a1_a_special_sh_1_shift_type_lsr_16_06a00050() {
    // Encoding: 0x06A00050
    // Test aarch32_SSAT_A1_A special value sh = 1 (Shift type LSR)
    // ISET: A32
    // Fields: Rn=0, sat_imm=0, imm5=0, sh=1, Rd=0, cond=0
    let encoding: u32 = 0x06A00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT_A1_A
/// ASL: `field sh = 2 (Shift type ASR)`
/// Requirement: FieldSpecial { field: "sh", value: 2, meaning: "Shift type ASR" }
/// Shift type ASR
#[test]
fn test_aarch32_ssat_a1_a_special_sh_2_shift_type_asr_16_06a00010() {
    // Encoding: 0x06A00010
    // Test aarch32_SSAT_A1_A special value sh = 2 (Shift type ASR)
    // ISET: A32
    // Fields: cond=0, imm5=0, sat_imm=0, sh=2, Rn=0, Rd=0
    let encoding: u32 = 0x06A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT_A1_A
/// ASL: `field sh = 3 (Shift type ROR)`
/// Requirement: FieldSpecial { field: "sh", value: 3, meaning: "Shift type ROR" }
/// Shift type ROR
#[test]
fn test_aarch32_ssat_a1_a_special_sh_3_shift_type_ror_16_06a00050() {
    // Encoding: 0x06A00050
    // Test aarch32_SSAT_A1_A special value sh = 3 (Shift type ROR)
    // ISET: A32
    // Fields: sh=3, cond=0, imm5=0, sat_imm=0, Rd=0, Rn=0
    let encoding: u32 = 0x06A00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SSAT_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ssat_a1_a_invalid_0_10_06a00010() {
    // Encoding: 0x06A00010
    // Test aarch32_SSAT_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }
    // ISET: A32
    // Fields: sat_imm=0, Rn=0, cond=0, Rd=0, imm5=0, sh=0
    let encoding: u32 = 0x06A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_SSAT_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ssat_a1_a_invalid_1_10_06a00010() {
    // Encoding: 0x06A00010
    // Test aarch32_SSAT_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Rn=0, imm5=0, sh=0, sat_imm=0, Rd=0, cond=0
    let encoding: u32 = 0x06A00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_SSAT_T1_A
/// ASL: `field sh 21 +: 1`
/// Requirement: FieldBoundary { field: "sh", value: 0, boundary: Min }
/// shift type LSL (logical shift left)
#[test]
fn test_aarch32_ssat_t1_a_field_sh_0_min_0_f3000000() {
    // Thumb encoding (32): 0xF3000000
    // Test aarch32_SSAT_T1_A field sh = 0 (Min)
    // ISET: T32
    // Fields: sh=0, Rd=0, Rn=0, imm3=0, imm2=0, sat_imm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_SSAT_T1_A
/// ASL: `field sh 21 +: 1`
/// Requirement: FieldBoundary { field: "sh", value: 1, boundary: Max }
/// shift type LSR (logical shift right)
#[test]
fn test_aarch32_ssat_t1_a_field_sh_1_max_0_f3200000() {
    // Thumb encoding (32): 0xF3200000
    // Test aarch32_SSAT_T1_A field sh = 1 (Max)
    // ISET: T32
    // Fields: sh=1, imm3=0, Rd=0, imm2=0, sat_imm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_SSAT_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ssat_t1_a_field_rn_0_min_0_f3000000() {
    // Thumb encoding (32): 0xF3000000
    // Test aarch32_SSAT_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, imm2=0, sat_imm=0, imm3=0, Rd=0, sh=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_SSAT_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ssat_t1_a_field_rn_1_poweroftwo_0_f3010000() {
    // Thumb encoding (32): 0xF3010000
    // Test aarch32_SSAT_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: sat_imm=0, imm3=0, sh=0, imm2=0, Rd=0, Rn=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_SSAT_T1_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_ssat_t1_a_field_imm3_0_zero_0_f3000000() {
    // Thumb encoding (32): 0xF3000000
    // Test aarch32_SSAT_T1_A field imm3 = 0 (Zero)
    // ISET: T32
    // Fields: imm2=0, sat_imm=0, sh=0, Rn=0, imm3=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_SSAT_T1_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_ssat_t1_a_field_imm3_1_poweroftwo_0_f3001000() {
    // Thumb encoding (32): 0xF3001000
    // Test aarch32_SSAT_T1_A field imm3 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, sh=0, imm3=1, Rd=0, imm2=0, sat_imm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3001000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_SSAT_T1_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 3, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (3)
#[test]
fn test_aarch32_ssat_t1_a_field_imm3_3_poweroftwominusone_0_f3003000() {
    // Thumb encoding (32): 0xF3003000
    // Test aarch32_SSAT_T1_A field imm3 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rd=0, Rn=0, sat_imm=0, sh=0, imm3=3, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3003000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_SSAT_T1_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 7, boundary: Max }
/// maximum immediate (7)
#[test]
fn test_aarch32_ssat_t1_a_field_imm3_7_max_0_f3007000() {
    // Thumb encoding (32): 0xF3007000
    // Test aarch32_SSAT_T1_A field imm3 = 7 (Max)
    // ISET: T32
    // Fields: Rd=0, imm3=7, imm2=0, sat_imm=0, sh=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3007000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_SSAT_T1_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ssat_t1_a_field_rd_0_min_0_f3000000() {
    // Thumb encoding (32): 0xF3000000
    // Test aarch32_SSAT_T1_A field Rd = 0 (Min)
    // ISET: T32
    // Fields: Rd=0, imm2=0, sh=0, Rn=0, imm3=0, sat_imm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_SSAT_T1_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ssat_t1_a_field_rd_1_poweroftwo_0_f3000100() {
    // Thumb encoding (32): 0xF3000100
    // Test aarch32_SSAT_T1_A field Rd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: sh=0, Rn=0, Rd=1, imm2=0, sat_imm=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3000100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_SSAT_T1_A
/// ASL: `field imm2 6 +: 2`
/// Requirement: FieldBoundary { field: "imm2", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_ssat_t1_a_field_imm2_0_zero_0_f3000000() {
    // Thumb encoding (32): 0xF3000000
    // Test aarch32_SSAT_T1_A field imm2 = 0 (Zero)
    // ISET: T32
    // Fields: sh=0, imm3=0, sat_imm=0, imm2=0, Rn=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_SSAT_T1_A
/// ASL: `field imm2 6 +: 2`
/// Requirement: FieldBoundary { field: "imm2", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_ssat_t1_a_field_imm2_1_poweroftwo_0_f3000040() {
    // Thumb encoding (32): 0xF3000040
    // Test aarch32_SSAT_T1_A field imm2 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm2=1, Rd=0, imm3=0, sat_imm=0, sh=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3000040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_SSAT_T1_A
/// ASL: `field imm2 6 +: 2`
/// Requirement: FieldBoundary { field: "imm2", value: 3, boundary: Max }
/// maximum immediate (3)
#[test]
fn test_aarch32_ssat_t1_a_field_imm2_3_max_0_f30000c0() {
    // Thumb encoding (32): 0xF30000C0
    // Test aarch32_SSAT_T1_A field imm2 = 3 (Max)
    // ISET: T32
    // Fields: sat_imm=0, Rn=0, imm3=0, sh=0, Rd=0, imm2=3
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF30000C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_SSAT_T1_A
/// ASL: `field sat_imm 0 +: 5`
/// Requirement: FieldBoundary { field: "sat_imm", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ssat_t1_a_field_sat_imm_0_min_0_f3000000() {
    // Thumb encoding (32): 0xF3000000
    // Test aarch32_SSAT_T1_A field sat_imm = 0 (Min)
    // ISET: T32
    // Fields: imm3=0, sh=0, Rd=0, imm2=0, sat_imm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_SSAT_T1_A
/// ASL: `field sat_imm 0 +: 5`
/// Requirement: FieldBoundary { field: "sat_imm", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_ssat_t1_a_field_sat_imm_1_poweroftwo_0_f3000001() {
    // Thumb encoding (32): 0xF3000001
    // Test aarch32_SSAT_T1_A field sat_imm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: sat_imm=1, Rn=0, imm3=0, Rd=0, sh=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3000001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_SSAT_T1_A
/// ASL: `field sat_imm 0 +: 5`
/// Requirement: FieldBoundary { field: "sat_imm", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_aarch32_ssat_t1_a_field_sat_imm_15_poweroftwominusone_0_f300000f() {
    // Thumb encoding (32): 0xF300000F
    // Test aarch32_SSAT_T1_A field sat_imm = 15 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm2=0, sat_imm=15, imm3=0, sh=0, Rn=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF300000F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_SSAT_T1_A
/// ASL: `field sat_imm 0 +: 5`
/// Requirement: FieldBoundary { field: "sat_imm", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_aarch32_ssat_t1_a_field_sat_imm_31_max_0_f300001f() {
    // Thumb encoding (32): 0xF300001F
    // Test aarch32_SSAT_T1_A field sat_imm = 31 (Max)
    // ISET: T32
    // Fields: Rd=0, sat_imm=31, Rn=0, sh=0, imm3=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF300001F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_SSAT_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sh=0 (shift type LSL (logical shift left))
#[test]
fn test_aarch32_ssat_t1_a_combo_0_0_f3000000() {
    // Thumb encoding (32): 0xF3000000
    // Test aarch32_SSAT_T1_A field combination: sh=0, Rn=0, imm3=0, Rd=0, imm2=0, sat_imm=0
    // ISET: T32
    // Fields: sh=0, Rd=0, Rn=0, imm3=0, imm2=0, sat_imm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_SSAT_T1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sh=1 (shift type LSR (logical shift right))
#[test]
fn test_aarch32_ssat_t1_a_combo_1_0_f3200000() {
    // Thumb encoding (32): 0xF3200000
    // Test aarch32_SSAT_T1_A field combination: sh=1, Rn=0, imm3=0, Rd=0, imm2=0, sat_imm=0
    // ISET: T32
    // Fields: Rn=0, imm3=0, Rd=0, sh=1, imm2=0, sat_imm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_SSAT_T1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_ssat_t1_a_combo_2_0_f3000000() {
    // Thumb encoding (32): 0xF3000000
    // Test aarch32_SSAT_T1_A field combination: sh=0, Rn=0, imm3=0, Rd=0, imm2=0, sat_imm=0
    // ISET: T32
    // Fields: sat_imm=0, imm2=0, Rn=0, Rd=0, sh=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_SSAT_T1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_ssat_t1_a_combo_3_0_f3010000() {
    // Thumb encoding (32): 0xF3010000
    // Test aarch32_SSAT_T1_A field combination: sh=0, Rn=1, imm3=0, Rd=0, imm2=0, sat_imm=0
    // ISET: T32
    // Fields: sh=0, Rd=0, imm2=0, imm3=0, Rn=1, sat_imm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_SSAT_T1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm3=0 (immediate value 0)
#[test]
fn test_aarch32_ssat_t1_a_combo_4_0_f3000000() {
    // Thumb encoding (32): 0xF3000000
    // Test aarch32_SSAT_T1_A field combination: sh=0, Rn=0, imm3=0, Rd=0, imm2=0, sat_imm=0
    // ISET: T32
    // Fields: Rd=0, sh=0, Rn=0, imm3=0, imm2=0, sat_imm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_SSAT_T1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm3=1 (immediate value 1)
#[test]
fn test_aarch32_ssat_t1_a_combo_5_0_f3001000() {
    // Thumb encoding (32): 0xF3001000
    // Test aarch32_SSAT_T1_A field combination: sh=0, Rn=0, imm3=1, Rd=0, imm2=0, sat_imm=0
    // ISET: T32
    // Fields: imm2=0, sat_imm=0, Rd=0, sh=0, imm3=1, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3001000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_SSAT_T1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm3=3 (immediate midpoint (3))
#[test]
fn test_aarch32_ssat_t1_a_combo_6_0_f3003000() {
    // Thumb encoding (32): 0xF3003000
    // Test aarch32_SSAT_T1_A field combination: sh=0, Rn=0, imm3=3, Rd=0, imm2=0, sat_imm=0
    // ISET: T32
    // Fields: Rn=0, imm2=0, sat_imm=0, imm3=3, sh=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3003000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_SSAT_T1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm3=7 (maximum immediate (7))
#[test]
fn test_aarch32_ssat_t1_a_combo_7_0_f3007000() {
    // Thumb encoding (32): 0xF3007000
    // Test aarch32_SSAT_T1_A field combination: sh=0, Rn=0, imm3=7, Rd=0, imm2=0, sat_imm=0
    // ISET: T32
    // Fields: sh=0, Rn=0, Rd=0, imm2=0, sat_imm=0, imm3=7
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3007000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_SSAT_T1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch32_ssat_t1_a_combo_8_0_f3000000() {
    // Thumb encoding (32): 0xF3000000
    // Test aarch32_SSAT_T1_A field combination: sh=0, Rn=0, imm3=0, Rd=0, imm2=0, sat_imm=0
    // ISET: T32
    // Fields: sh=0, imm2=0, Rn=0, Rd=0, imm3=0, sat_imm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_SSAT_T1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch32_ssat_t1_a_combo_9_0_f3000100() {
    // Thumb encoding (32): 0xF3000100
    // Test aarch32_SSAT_T1_A field combination: sh=0, Rn=0, imm3=0, Rd=1, imm2=0, sat_imm=0
    // ISET: T32
    // Fields: sat_imm=0, Rn=0, imm3=0, Rd=1, imm2=0, sh=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3000100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_SSAT_T1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm2=0 (immediate value 0)
#[test]
fn test_aarch32_ssat_t1_a_combo_10_0_f3000000() {
    // Thumb encoding (32): 0xF3000000
    // Test aarch32_SSAT_T1_A field combination: sh=0, Rn=0, imm3=0, Rd=0, imm2=0, sat_imm=0
    // ISET: T32
    // Fields: sat_imm=0, imm3=0, Rn=0, sh=0, imm2=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_SSAT_T1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm2=1 (immediate value 1)
#[test]
fn test_aarch32_ssat_t1_a_combo_11_0_f3000040() {
    // Thumb encoding (32): 0xF3000040
    // Test aarch32_SSAT_T1_A field combination: sh=0, Rn=0, imm3=0, Rd=0, imm2=1, sat_imm=0
    // ISET: T32
    // Fields: sh=0, imm3=0, Rn=0, Rd=0, imm2=1, sat_imm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3000040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_SSAT_T1_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm2=3 (maximum immediate (3))
#[test]
fn test_aarch32_ssat_t1_a_combo_12_0_f30000c0() {
    // Thumb encoding (32): 0xF30000C0
    // Test aarch32_SSAT_T1_A field combination: sh=0, Rn=0, imm3=0, Rd=0, imm2=3, sat_imm=0
    // ISET: T32
    // Fields: Rn=0, imm3=0, Rd=0, imm2=3, sh=0, sat_imm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF30000C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_SSAT_T1_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sat_imm=0 (minimum value)
#[test]
fn test_aarch32_ssat_t1_a_combo_13_0_f3000000() {
    // Thumb encoding (32): 0xF3000000
    // Test aarch32_SSAT_T1_A field combination: sh=0, Rn=0, imm3=0, Rd=0, imm2=0, sat_imm=0
    // ISET: T32
    // Fields: Rn=0, Rd=0, imm2=0, sat_imm=0, imm3=0, sh=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_SSAT_T1_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sat_imm=1 (value 1)
#[test]
fn test_aarch32_ssat_t1_a_combo_14_0_f3000001() {
    // Thumb encoding (32): 0xF3000001
    // Test aarch32_SSAT_T1_A field combination: sh=0, Rn=0, imm3=0, Rd=0, imm2=0, sat_imm=1
    // ISET: T32
    // Fields: imm2=0, imm3=0, Rd=0, Rn=0, sh=0, sat_imm=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3000001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_SSAT_T1_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sat_imm=15 (midpoint (15))
#[test]
fn test_aarch32_ssat_t1_a_combo_15_0_f300000f() {
    // Thumb encoding (32): 0xF300000F
    // Test aarch32_SSAT_T1_A field combination: sh=0, Rn=0, imm3=0, Rd=0, imm2=0, sat_imm=15
    // ISET: T32
    // Fields: Rd=0, sat_imm=15, imm2=0, sh=0, imm3=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF300000F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_SSAT_T1_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sat_imm=31 (maximum value (31))
#[test]
fn test_aarch32_ssat_t1_a_combo_16_0_f300001f() {
    // Thumb encoding (32): 0xF300001F
    // Test aarch32_SSAT_T1_A field combination: sh=0, Rn=0, imm3=0, Rd=0, imm2=0, sat_imm=31
    // ISET: T32
    // Fields: sh=0, Rn=0, Rd=0, imm3=0, imm2=0, sat_imm=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF300001F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_SSAT_T1_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch32_ssat_t1_a_combo_17_0_f3010100() {
    // Thumb encoding (32): 0xF3010100
    // Test aarch32_SSAT_T1_A field combination: sh=0, Rn=1, imm3=0, Rd=1, imm2=0, sat_imm=0
    // ISET: T32
    // Fields: imm3=0, Rd=1, Rn=1, sh=0, imm2=0, sat_imm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3010100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_SSAT_T1_A
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch32_ssat_t1_a_combo_18_0_f30f0f00() {
    // Thumb encoding (32): 0xF30F0F00
    // Test aarch32_SSAT_T1_A field combination: sh=0, Rn=31, imm3=0, Rd=31, imm2=0, sat_imm=0
    // ISET: T32
    // Fields: imm3=0, Rn=31, sh=0, Rd=31, imm2=0, sat_imm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF30F0F00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_SSAT_T1_A
/// ASL: `field sh = 0 (Shift type LSL)`
/// Requirement: FieldSpecial { field: "sh", value: 0, meaning: "Shift type LSL" }
/// Shift type LSL
#[test]
fn test_aarch32_ssat_t1_a_special_sh_0_shift_type_lsl_0_f3000000() {
    // Thumb encoding (32): 0xF3000000
    // Test aarch32_SSAT_T1_A special value sh = 0 (Shift type LSL)
    // ISET: T32
    // Fields: sh=0, Rn=0, imm3=0, Rd=0, imm2=0, sat_imm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_SSAT_T1_A
/// ASL: `field sh = 1 (Shift type LSR)`
/// Requirement: FieldSpecial { field: "sh", value: 1, meaning: "Shift type LSR" }
/// Shift type LSR
#[test]
fn test_aarch32_ssat_t1_a_special_sh_1_shift_type_lsr_0_f3200000() {
    // Thumb encoding (32): 0xF3200000
    // Test aarch32_SSAT_T1_A special value sh = 1 (Shift type LSR)
    // ISET: T32
    // Fields: sh=1, Rd=0, imm2=0, sat_imm=0, imm3=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_SSAT_T1_A
/// ASL: `field sh = 2 (Shift type ASR)`
/// Requirement: FieldSpecial { field: "sh", value: 2, meaning: "Shift type ASR" }
/// Shift type ASR
#[test]
fn test_aarch32_ssat_t1_a_special_sh_2_shift_type_asr_0_f3000000() {
    // Thumb encoding (32): 0xF3000000
    // Test aarch32_SSAT_T1_A special value sh = 2 (Shift type ASR)
    // ISET: T32
    // Fields: sh=2, Rn=0, sat_imm=0, imm3=0, Rd=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_SSAT_T1_A
/// ASL: `field sh = 3 (Shift type ROR)`
/// Requirement: FieldSpecial { field: "sh", value: 3, meaning: "Shift type ROR" }
/// Shift type ROR
#[test]
fn test_aarch32_ssat_t1_a_special_sh_3_shift_type_ror_0_f3200000() {
    // Thumb encoding (32): 0xF3200000
    // Test aarch32_SSAT_T1_A special value sh = 3 (Shift type ROR)
    // ISET: T32
    // Fields: Rd=0, imm3=0, sh=3, Rn=0, imm2=0, sat_imm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_SSAT_T1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ssat_t1_a_invalid_0_0_f3000000() {
    // Thumb encoding (32): 0xF3000000
    // Test aarch32_SSAT_T1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }
    // ISET: T32
    // Fields: Rd=0, imm3=0, Rn=0, imm2=0, sat_imm=0, sh=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3000000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_SSAT_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ssat_t1_a_invalid_1_0_f3000000() {
    // Thumb encoding (32): 0xF3000000
    // Test aarch32_SSAT_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rn=0, Rd=0, imm2=0, imm3=0, sat_imm=0, sh=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3000000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_SSAT_T1_A
/// ASL: `ADD X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_ssat_t1_a_add_oracle_32_0_f3002820() {
    // Test ADD 32-bit: simple addition/subtraction (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF3002820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x5A, "X0 should be 0x000000000000005A");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SSAT_T1_A
/// ASL: `ADD X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_ssat_t1_a_add_oracle_64_0_f3002820() {
    // Test ADD 64-bit: simple addition/subtraction (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF3002820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x5A, "X0 should be 0x000000000000005A");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SSAT_T1_A
/// ASL: `ADD X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero operands (32)
#[test]
fn test_aarch32_ssat_t1_a_add_oracle_32_1_f3000020() {
    // Test ADD 32-bit: zero operands (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF3000020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SSAT_T1_A
/// ASL: `ADD X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero operands (64)
#[test]
fn test_aarch32_ssat_t1_a_add_oracle_64_1_f3000020() {
    // Test ADD 64-bit: zero operands (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF3000020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SSAT_T1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small values (32)
#[test]
fn test_aarch32_ssat_t1_a_add_oracle_32_2_f3000420() {
    // Test ADD 32-bit: small values (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF3000420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SSAT_T1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// small values (64)
#[test]
fn test_aarch32_ssat_t1_a_add_oracle_64_2_f3000420() {
    // Test ADD 64-bit: small values (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF3000420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SSAT_T1_A
/// ASL: `ADD X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_ssat_t1_a_add_oracle_32_3_f33ffc20() {
    // Test ADD 32-bit: max imm12 unshifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF33FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFF001, "X0 should be 0xFFFFFFFFFFFFF001");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SSAT_T1_A
/// ASL: `ADD X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_ssat_t1_a_add_oracle_64_3_f33ffc20() {
    // Test ADD 64-bit: max imm12 unshifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF33FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFF001, "X0 should be 0xFFFFFFFFFFFFF001");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SSAT_T1_A
/// ASL: `ADD X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_ssat_t1_a_add_oracle_32_4_f37ffc20() {
    // Test ADD 32-bit: max imm12 shifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF37FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF001000, "X0 should be 0xFFFFFFFFFF001000");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SSAT_T1_A
/// ASL: `ADD X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_ssat_t1_a_add_oracle_64_4_f37ffc20() {
    // Test ADD 64-bit: max imm12 shifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF37FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF001000, "X0 should be 0xFFFFFFFFFF001000");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SSAT_T1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max u64 operand (32)
#[test]
fn test_aarch32_ssat_t1_a_add_oracle_32_5_f3000420() {
    // Test ADD 32-bit: max u64 operand (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF3000420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFE, "X0 should be 0x00000000FFFFFFFE");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SSAT_T1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max u64 operand (64)
#[test]
fn test_aarch32_ssat_t1_a_add_oracle_64_5_f3000420() {
    // Test ADD 64-bit: max u64 operand (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF3000420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFE, "X0 should be 0xFFFFFFFFFFFFFFFE");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SSAT_T1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_ssat_t1_a_add_oracle_32_6_f3000420() {
    // Test ADD 32-bit: zero result (for sub 1-1) (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF3000420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "X0 should be 0xFFFFFFFFFFFFFFFF");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SSAT_T1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_ssat_t1_a_add_oracle_64_6_f3000420() {
    // Test ADD 64-bit: zero result (for sub 1-1) (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF3000420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "X0 should be 0xFFFFFFFFFFFFFFFF");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SSAT_T1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_ssat_t1_a_add_oracle_32_7_f3000420() {
    // Test ADD 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF3000420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFE, "X0 should be 0x00000000FFFFFFFE");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SSAT_T1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_ssat_t1_a_add_oracle_64_7_f3000420() {
    // Test ADD 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF3000420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFE, "X0 should be 0x7FFFFFFFFFFFFFFE");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SSAT_T1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_ssat_t1_a_add_oracle_32_8_f3000420() {
    // Test ADD 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF3000420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FFFFFFE, "X0 should be 0x000000007FFFFFFE");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SSAT_T1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_ssat_t1_a_add_oracle_64_8_f3000420() {
    // Test ADD 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF3000420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FFFFFFE, "X0 should be 0x000000007FFFFFFE");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SSAT_T1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_ssat_t1_a_add_oracle_32_9_f3000420() {
    // Test ADD 32-bit: unsigned overflow 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF3000420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFE, "X0 should be 0x00000000FFFFFFFE");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SSAT_T1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_ssat_t1_a_add_oracle_64_9_f3000420() {
    // Test ADD 64-bit: unsigned overflow 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF3000420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFE, "X0 should be 0xFFFFFFFFFFFFFFFE");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SSAT_T1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_ssat_t1_a_add_oracle_32_10_f3000420() {
    // Test ADD 32-bit: unsigned overflow 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF3000420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFE, "X0 should be 0x00000000FFFFFFFE");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SSAT_T1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_ssat_t1_a_add_oracle_64_10_f3000420() {
    // Test ADD 64-bit: unsigned overflow 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF3000420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFE, "X0 should be 0x00000000FFFFFFFE");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SSAT_T1_A
/// ASL: `ADD SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (32)
#[test]
fn test_aarch32_ssat_t1_a_add_oracle_32_rd31_sp_f300283f() {
    // Test ADD 32-bit with Rd=31 (SP)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF300283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SSAT_T1_A
/// ASL: `ADD SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (64)
#[test]
fn test_aarch32_ssat_t1_a_add_oracle_64_rd31_sp_f300283f() {
    // Test ADD 64-bit with Rd=31 (SP)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF300283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SSAT_T1_A
/// ASL: `ADD.W R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple values
#[test]
fn test_aarch32_ssat_t1_a_t32_oracle_0_f3010000() {
    // Test T32 ADD: simple values (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x32);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF3010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x96, "R0 should be 0x00000096");
}

/// Provenance: aarch32_SSAT_T1_A
/// ASL: `ADD.W R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero values
#[test]
fn test_aarch32_ssat_t1_a_t32_oracle_1_f3010000() {
    // Test T32 ADD: zero values (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xF3010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_SSAT_T1_A
/// ASL: `ADD.W R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max value
#[test]
fn test_aarch32_ssat_t1_a_t32_oracle_2_f3010000() {
    // Test T32 ADD: max value (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0xF3010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_SSAT_T1_A
/// ASL: `ADD.W R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// mixed pattern
#[test]
fn test_aarch32_ssat_t1_a_t32_oracle_3_f3010000() {
    // Test T32 ADD: mixed pattern (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0xABCDEF01);
    let encoding: u32 = 0xF3010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xBE024579, "R0 should be 0xBE024579");
}

// ============================================================================
// aarch32_UBFX_A Tests
// ============================================================================

/// Provenance: aarch32_UBFX_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_ubfx_a1_a_field_cond_0_min_50_07e00050() {
    // Encoding: 0x07E00050
    // Test aarch32_UBFX_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: lsb=0, cond=0, Rn=0, Rd=0, widthm1=0
    let encoding: u32 = 0x07E00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_UBFX_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_ubfx_a1_a_field_cond_1_poweroftwo_50_17e00050() {
    // Encoding: 0x17E00050
    // Test aarch32_UBFX_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: widthm1=0, lsb=0, Rn=0, cond=1, Rd=0
    let encoding: u32 = 0x17E00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_UBFX_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_ubfx_a1_a_field_cond_2_poweroftwo_50_27e00050() {
    // Encoding: 0x27E00050
    // Test aarch32_UBFX_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=2, lsb=0, widthm1=0, Rd=0, Rn=0
    let encoding: u32 = 0x27E00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_UBFX_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_ubfx_a1_a_field_cond_3_poweroftwo_50_37e00050() {
    // Encoding: 0x37E00050
    // Test aarch32_UBFX_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: lsb=0, widthm1=0, cond=3, Rd=0, Rn=0
    let encoding: u32 = 0x37E00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_UBFX_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_ubfx_a1_a_field_cond_4_poweroftwo_50_47e00050() {
    // Encoding: 0x47E00050
    // Test aarch32_UBFX_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, widthm1=0, Rn=0, cond=4, lsb=0
    let encoding: u32 = 0x47E00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_UBFX_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_ubfx_a1_a_field_cond_5_poweroftwo_50_57e00050() {
    // Encoding: 0x57E00050
    // Test aarch32_UBFX_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, cond=5, Rn=0, widthm1=0, lsb=0
    let encoding: u32 = 0x57E00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_UBFX_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_ubfx_a1_a_field_cond_6_poweroftwo_50_67e00050() {
    // Encoding: 0x67E00050
    // Test aarch32_UBFX_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rd=0, cond=6, widthm1=0, lsb=0
    let encoding: u32 = 0x67E00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_UBFX_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_ubfx_a1_a_field_cond_7_poweroftwo_50_77e00050() {
    // Encoding: 0x77E00050
    // Test aarch32_UBFX_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=7, lsb=0, Rd=0, widthm1=0
    let encoding: u32 = 0x77E00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_UBFX_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_ubfx_a1_a_field_cond_8_poweroftwo_50_87e00050() {
    // Encoding: 0x87E00050
    // Test aarch32_UBFX_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: widthm1=0, Rn=0, cond=8, Rd=0, lsb=0
    let encoding: u32 = 0x87E00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_UBFX_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_ubfx_a1_a_field_cond_9_poweroftwo_50_97e00050() {
    // Encoding: 0x97E00050
    // Test aarch32_UBFX_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rd=0, cond=9, lsb=0, widthm1=0
    let encoding: u32 = 0x97E00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_UBFX_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_ubfx_a1_a_field_cond_10_poweroftwo_50_a7e00050() {
    // Encoding: 0xA7E00050
    // Test aarch32_UBFX_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, lsb=0, cond=10, widthm1=0, Rn=0
    let encoding: u32 = 0xA7E00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_UBFX_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_ubfx_a1_a_field_cond_11_poweroftwo_50_b7e00050() {
    // Encoding: 0xB7E00050
    // Test aarch32_UBFX_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, widthm1=0, cond=11, Rd=0, lsb=0
    let encoding: u32 = 0xB7E00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_UBFX_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_ubfx_a1_a_field_cond_12_poweroftwo_50_c7e00050() {
    // Encoding: 0xC7E00050
    // Test aarch32_UBFX_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=12, lsb=0, widthm1=0, Rd=0, Rn=0
    let encoding: u32 = 0xC7E00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_UBFX_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_ubfx_a1_a_field_cond_13_poweroftwo_50_d7e00050() {
    // Encoding: 0xD7E00050
    // Test aarch32_UBFX_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=13, widthm1=0, Rn=0, Rd=0, lsb=0
    let encoding: u32 = 0xD7E00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_UBFX_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_ubfx_a1_a_field_cond_14_poweroftwo_50_e7e00050() {
    // Encoding: 0xE7E00050
    // Test aarch32_UBFX_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, widthm1=0, cond=14, lsb=0, Rn=0
    let encoding: u32 = 0xE7E00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_UBFX_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_ubfx_a1_a_field_cond_15_max_50_f7e00050() {
    // Encoding: 0xF7E00050
    // Test aarch32_UBFX_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: cond=15, lsb=0, Rn=0, widthm1=0, Rd=0
    let encoding: u32 = 0xF7E00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_UBFX_A1_A
/// ASL: `field widthm1 16 +: 5`
/// Requirement: FieldBoundary { field: "widthm1", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ubfx_a1_a_field_widthm1_0_min_50_07e00050() {
    // Encoding: 0x07E00050
    // Test aarch32_UBFX_A1_A field widthm1 = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rn=0, lsb=0, widthm1=0, Rd=0
    let encoding: u32 = 0x07E00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_UBFX_A1_A
/// ASL: `field widthm1 16 +: 5`
/// Requirement: FieldBoundary { field: "widthm1", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_ubfx_a1_a_field_widthm1_1_poweroftwo_50_07e10050() {
    // Encoding: 0x07E10050
    // Test aarch32_UBFX_A1_A field widthm1 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, lsb=0, Rd=0, Rn=0, widthm1=1
    let encoding: u32 = 0x07E10050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_UBFX_A1_A
/// ASL: `field widthm1 16 +: 5`
/// Requirement: FieldBoundary { field: "widthm1", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_aarch32_ubfx_a1_a_field_widthm1_15_poweroftwominusone_50_07ef0050() {
    // Encoding: 0x07EF0050
    // Test aarch32_UBFX_A1_A field widthm1 = 15 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: widthm1=15, lsb=0, Rd=0, Rn=0, cond=0
    let encoding: u32 = 0x07EF0050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_UBFX_A1_A
/// ASL: `field widthm1 16 +: 5`
/// Requirement: FieldBoundary { field: "widthm1", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_aarch32_ubfx_a1_a_field_widthm1_31_max_50_07ff0050() {
    // Encoding: 0x07FF0050
    // Test aarch32_UBFX_A1_A field widthm1 = 31 (Max)
    // ISET: A32
    // Fields: lsb=0, Rn=0, Rd=0, cond=0, widthm1=31
    let encoding: u32 = 0x07FF0050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_UBFX_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ubfx_a1_a_field_rd_0_min_50_07e00050() {
    // Encoding: 0x07E00050
    // Test aarch32_UBFX_A1_A field Rd = 0 (Min)
    // ISET: A32
    // Fields: widthm1=0, Rn=0, Rd=0, cond=0, lsb=0
    let encoding: u32 = 0x07E00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_UBFX_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ubfx_a1_a_field_rd_1_poweroftwo_50_07e01050() {
    // Encoding: 0x07E01050
    // Test aarch32_UBFX_A1_A field Rd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Rd=1, widthm1=0, lsb=0, Rn=0
    let encoding: u32 = 0x07E01050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_UBFX_A1_A
/// ASL: `field lsb 7 +: 5`
/// Requirement: FieldBoundary { field: "lsb", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ubfx_a1_a_field_lsb_0_min_50_07e00050() {
    // Encoding: 0x07E00050
    // Test aarch32_UBFX_A1_A field lsb = 0 (Min)
    // ISET: A32
    // Fields: Rd=0, lsb=0, Rn=0, widthm1=0, cond=0
    let encoding: u32 = 0x07E00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_UBFX_A1_A
/// ASL: `field lsb 7 +: 5`
/// Requirement: FieldBoundary { field: "lsb", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_ubfx_a1_a_field_lsb_1_poweroftwo_50_07e000d0() {
    // Encoding: 0x07E000D0
    // Test aarch32_UBFX_A1_A field lsb = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, widthm1=0, Rd=0, lsb=1, cond=0
    let encoding: u32 = 0x07E000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_UBFX_A1_A
/// ASL: `field lsb 7 +: 5`
/// Requirement: FieldBoundary { field: "lsb", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_aarch32_ubfx_a1_a_field_lsb_15_poweroftwominusone_50_07e007d0() {
    // Encoding: 0x07E007D0
    // Test aarch32_UBFX_A1_A field lsb = 15 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, lsb=15, Rn=0, widthm1=0, Rd=0
    let encoding: u32 = 0x07E007D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_UBFX_A1_A
/// ASL: `field lsb 7 +: 5`
/// Requirement: FieldBoundary { field: "lsb", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_aarch32_ubfx_a1_a_field_lsb_31_max_50_07e00fd0() {
    // Encoding: 0x07E00FD0
    // Test aarch32_UBFX_A1_A field lsb = 31 (Max)
    // ISET: A32
    // Fields: Rd=0, widthm1=0, Rn=0, cond=0, lsb=31
    let encoding: u32 = 0x07E00FD0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_UBFX_A1_A
/// ASL: `field Rn 0 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ubfx_a1_a_field_rn_0_min_50_07e00050() {
    // Encoding: 0x07E00050
    // Test aarch32_UBFX_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: lsb=0, cond=0, Rn=0, widthm1=0, Rd=0
    let encoding: u32 = 0x07E00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_UBFX_A1_A
/// ASL: `field Rn 0 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ubfx_a1_a_field_rn_1_poweroftwo_50_07e00051() {
    // Encoding: 0x07E00051
    // Test aarch32_UBFX_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, cond=0, widthm1=0, lsb=0, Rn=1
    let encoding: u32 = 0x07E00051;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_UBFX_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_ubfx_a1_a_combo_0_50_07e00050() {
    // Encoding: 0x07E00050
    // Test aarch32_UBFX_A1_A field combination: cond=0, widthm1=0, Rd=0, lsb=0, Rn=0
    // ISET: A32
    // Fields: lsb=0, Rn=0, Rd=0, cond=0, widthm1=0
    let encoding: u32 = 0x07E00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_UBFX_A1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=1 (condition NE (not equal))
#[test]
fn test_aarch32_ubfx_a1_a_combo_1_50_17e00050() {
    // Encoding: 0x17E00050
    // Test aarch32_UBFX_A1_A field combination: cond=1, widthm1=0, Rd=0, lsb=0, Rn=0
    // ISET: A32
    // Fields: cond=1, widthm1=0, lsb=0, Rd=0, Rn=0
    let encoding: u32 = 0x17E00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_UBFX_A1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=2 (condition CS/HS (carry set))
#[test]
fn test_aarch32_ubfx_a1_a_combo_2_50_27e00050() {
    // Encoding: 0x27E00050
    // Test aarch32_UBFX_A1_A field combination: cond=2, widthm1=0, Rd=0, lsb=0, Rn=0
    // ISET: A32
    // Fields: Rd=0, widthm1=0, Rn=0, cond=2, lsb=0
    let encoding: u32 = 0x27E00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_UBFX_A1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=3 (condition CC/LO (carry clear))
#[test]
fn test_aarch32_ubfx_a1_a_combo_3_50_37e00050() {
    // Encoding: 0x37E00050
    // Test aarch32_UBFX_A1_A field combination: cond=3, widthm1=0, Rd=0, lsb=0, Rn=0
    // ISET: A32
    // Fields: widthm1=0, lsb=0, Rd=0, cond=3, Rn=0
    let encoding: u32 = 0x37E00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_UBFX_A1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=4 (condition MI (minus/negative))
#[test]
fn test_aarch32_ubfx_a1_a_combo_4_50_47e00050() {
    // Encoding: 0x47E00050
    // Test aarch32_UBFX_A1_A field combination: cond=4, widthm1=0, Rd=0, lsb=0, Rn=0
    // ISET: A32
    // Fields: Rn=0, Rd=0, cond=4, lsb=0, widthm1=0
    let encoding: u32 = 0x47E00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_UBFX_A1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=5 (condition PL (plus/positive))
#[test]
fn test_aarch32_ubfx_a1_a_combo_5_50_57e00050() {
    // Encoding: 0x57E00050
    // Test aarch32_UBFX_A1_A field combination: cond=5, widthm1=0, Rd=0, lsb=0, Rn=0
    // ISET: A32
    // Fields: lsb=0, Rn=0, widthm1=0, cond=5, Rd=0
    let encoding: u32 = 0x57E00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_UBFX_A1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=6 (condition VS (overflow set))
#[test]
fn test_aarch32_ubfx_a1_a_combo_6_50_67e00050() {
    // Encoding: 0x67E00050
    // Test aarch32_UBFX_A1_A field combination: cond=6, widthm1=0, Rd=0, lsb=0, Rn=0
    // ISET: A32
    // Fields: cond=6, widthm1=0, lsb=0, Rn=0, Rd=0
    let encoding: u32 = 0x67E00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_UBFX_A1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=7 (condition VC (overflow clear))
#[test]
fn test_aarch32_ubfx_a1_a_combo_7_50_77e00050() {
    // Encoding: 0x77E00050
    // Test aarch32_UBFX_A1_A field combination: cond=7, widthm1=0, Rd=0, lsb=0, Rn=0
    // ISET: A32
    // Fields: widthm1=0, lsb=0, cond=7, Rn=0, Rd=0
    let encoding: u32 = 0x77E00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_UBFX_A1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=8 (condition HI (unsigned higher))
#[test]
fn test_aarch32_ubfx_a1_a_combo_8_50_87e00050() {
    // Encoding: 0x87E00050
    // Test aarch32_UBFX_A1_A field combination: cond=8, widthm1=0, Rd=0, lsb=0, Rn=0
    // ISET: A32
    // Fields: lsb=0, widthm1=0, Rd=0, cond=8, Rn=0
    let encoding: u32 = 0x87E00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_UBFX_A1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=9 (condition LS (unsigned lower or same))
#[test]
fn test_aarch32_ubfx_a1_a_combo_9_50_97e00050() {
    // Encoding: 0x97E00050
    // Test aarch32_UBFX_A1_A field combination: cond=9, widthm1=0, Rd=0, lsb=0, Rn=0
    // ISET: A32
    // Fields: lsb=0, Rn=0, cond=9, Rd=0, widthm1=0
    let encoding: u32 = 0x97E00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_UBFX_A1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=10 (condition GE (signed >=))
#[test]
fn test_aarch32_ubfx_a1_a_combo_10_50_a7e00050() {
    // Encoding: 0xA7E00050
    // Test aarch32_UBFX_A1_A field combination: cond=10, widthm1=0, Rd=0, lsb=0, Rn=0
    // ISET: A32
    // Fields: Rn=0, cond=10, widthm1=0, Rd=0, lsb=0
    let encoding: u32 = 0xA7E00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_UBFX_A1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=11 (condition LT (signed <))
#[test]
fn test_aarch32_ubfx_a1_a_combo_11_50_b7e00050() {
    // Encoding: 0xB7E00050
    // Test aarch32_UBFX_A1_A field combination: cond=11, widthm1=0, Rd=0, lsb=0, Rn=0
    // ISET: A32
    // Fields: widthm1=0, Rd=0, lsb=0, cond=11, Rn=0
    let encoding: u32 = 0xB7E00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_UBFX_A1_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=12 (condition GT (signed >))
#[test]
fn test_aarch32_ubfx_a1_a_combo_12_50_c7e00050() {
    // Encoding: 0xC7E00050
    // Test aarch32_UBFX_A1_A field combination: cond=12, widthm1=0, Rd=0, lsb=0, Rn=0
    // ISET: A32
    // Fields: widthm1=0, cond=12, lsb=0, Rn=0, Rd=0
    let encoding: u32 = 0xC7E00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_UBFX_A1_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=13 (condition LE (signed <=))
#[test]
fn test_aarch32_ubfx_a1_a_combo_13_50_d7e00050() {
    // Encoding: 0xD7E00050
    // Test aarch32_UBFX_A1_A field combination: cond=13, widthm1=0, Rd=0, lsb=0, Rn=0
    // ISET: A32
    // Fields: cond=13, widthm1=0, lsb=0, Rd=0, Rn=0
    let encoding: u32 = 0xD7E00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_UBFX_A1_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=14 (condition AL (always))
#[test]
fn test_aarch32_ubfx_a1_a_combo_14_50_e7e00050() {
    // Encoding: 0xE7E00050
    // Test aarch32_UBFX_A1_A field combination: cond=14, widthm1=0, Rd=0, lsb=0, Rn=0
    // ISET: A32
    // Fields: cond=14, lsb=0, Rn=0, widthm1=0, Rd=0
    let encoding: u32 = 0xE7E00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_UBFX_A1_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=15 (condition NV (never, reserved))
#[test]
fn test_aarch32_ubfx_a1_a_combo_15_50_f7e00050() {
    // Encoding: 0xF7E00050
    // Test aarch32_UBFX_A1_A field combination: cond=15, widthm1=0, Rd=0, lsb=0, Rn=0
    // ISET: A32
    // Fields: cond=15, widthm1=0, Rn=0, Rd=0, lsb=0
    let encoding: u32 = 0xF7E00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_UBFX_A1_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// widthm1=0 (minimum value)
#[test]
fn test_aarch32_ubfx_a1_a_combo_16_50_07e00050() {
    // Encoding: 0x07E00050
    // Test aarch32_UBFX_A1_A field combination: cond=0, widthm1=0, Rd=0, lsb=0, Rn=0
    // ISET: A32
    // Fields: Rd=0, widthm1=0, cond=0, lsb=0, Rn=0
    let encoding: u32 = 0x07E00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_UBFX_A1_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// widthm1=1 (value 1)
#[test]
fn test_aarch32_ubfx_a1_a_combo_17_50_07e10050() {
    // Encoding: 0x07E10050
    // Test aarch32_UBFX_A1_A field combination: cond=0, widthm1=1, Rd=0, lsb=0, Rn=0
    // ISET: A32
    // Fields: cond=0, Rd=0, lsb=0, widthm1=1, Rn=0
    let encoding: u32 = 0x07E10050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_UBFX_A1_A
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// widthm1=15 (midpoint (15))
#[test]
fn test_aarch32_ubfx_a1_a_combo_18_50_07ef0050() {
    // Encoding: 0x07EF0050
    // Test aarch32_UBFX_A1_A field combination: cond=0, widthm1=15, Rd=0, lsb=0, Rn=0
    // ISET: A32
    // Fields: lsb=0, cond=0, Rn=0, Rd=0, widthm1=15
    let encoding: u32 = 0x07EF0050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_UBFX_A1_A
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// widthm1=31 (maximum value (31))
#[test]
fn test_aarch32_ubfx_a1_a_combo_19_50_07ff0050() {
    // Encoding: 0x07FF0050
    // Test aarch32_UBFX_A1_A field combination: cond=0, widthm1=31, Rd=0, lsb=0, Rn=0
    // ISET: A32
    // Fields: Rn=0, Rd=0, lsb=0, cond=0, widthm1=31
    let encoding: u32 = 0x07FF0050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_UBFX_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_ubfx_a1_a_special_cond_0_condition_eq_80_07e00050() {
    // Encoding: 0x07E00050
    // Test aarch32_UBFX_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: widthm1=0, lsb=0, cond=0, Rn=0, Rd=0
    let encoding: u32 = 0x07E00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_UBFX_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_ubfx_a1_a_special_cond_1_condition_ne_80_17e00050() {
    // Encoding: 0x17E00050
    // Test aarch32_UBFX_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: cond=1, widthm1=0, lsb=0, Rd=0, Rn=0
    let encoding: u32 = 0x17E00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_UBFX_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_ubfx_a1_a_special_cond_2_condition_cs_hs_80_27e00050() {
    // Encoding: 0x27E00050
    // Test aarch32_UBFX_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: widthm1=0, lsb=0, Rn=0, cond=2, Rd=0
    let encoding: u32 = 0x27E00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_UBFX_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_ubfx_a1_a_special_cond_3_condition_cc_lo_80_37e00050() {
    // Encoding: 0x37E00050
    // Test aarch32_UBFX_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: lsb=0, cond=3, Rn=0, widthm1=0, Rd=0
    let encoding: u32 = 0x37E00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_UBFX_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_ubfx_a1_a_special_cond_4_condition_mi_80_47e00050() {
    // Encoding: 0x47E00050
    // Test aarch32_UBFX_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: widthm1=0, Rd=0, Rn=0, cond=4, lsb=0
    let encoding: u32 = 0x47E00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_UBFX_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_ubfx_a1_a_special_cond_5_condition_pl_80_57e00050() {
    // Encoding: 0x57E00050
    // Test aarch32_UBFX_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: cond=5, widthm1=0, lsb=0, Rn=0, Rd=0
    let encoding: u32 = 0x57E00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_UBFX_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_ubfx_a1_a_special_cond_6_condition_vs_80_67e00050() {
    // Encoding: 0x67E00050
    // Test aarch32_UBFX_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: Rn=0, widthm1=0, Rd=0, cond=6, lsb=0
    let encoding: u32 = 0x67E00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_UBFX_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_ubfx_a1_a_special_cond_7_condition_vc_80_77e00050() {
    // Encoding: 0x77E00050
    // Test aarch32_UBFX_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: Rd=0, cond=7, lsb=0, Rn=0, widthm1=0
    let encoding: u32 = 0x77E00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_UBFX_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_ubfx_a1_a_special_cond_8_condition_hi_80_87e00050() {
    // Encoding: 0x87E00050
    // Test aarch32_UBFX_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: Rd=0, cond=8, widthm1=0, lsb=0, Rn=0
    let encoding: u32 = 0x87E00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_UBFX_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_ubfx_a1_a_special_cond_9_condition_ls_80_97e00050() {
    // Encoding: 0x97E00050
    // Test aarch32_UBFX_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: Rd=0, widthm1=0, lsb=0, Rn=0, cond=9
    let encoding: u32 = 0x97E00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_UBFX_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_ubfx_a1_a_special_cond_10_condition_ge_80_a7e00050() {
    // Encoding: 0xA7E00050
    // Test aarch32_UBFX_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: lsb=0, cond=10, Rd=0, Rn=0, widthm1=0
    let encoding: u32 = 0xA7E00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_UBFX_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_ubfx_a1_a_special_cond_11_condition_lt_80_b7e00050() {
    // Encoding: 0xB7E00050
    // Test aarch32_UBFX_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: cond=11, Rn=0, Rd=0, lsb=0, widthm1=0
    let encoding: u32 = 0xB7E00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_UBFX_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_ubfx_a1_a_special_cond_12_condition_gt_80_c7e00050() {
    // Encoding: 0xC7E00050
    // Test aarch32_UBFX_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: widthm1=0, lsb=0, Rn=0, cond=12, Rd=0
    let encoding: u32 = 0xC7E00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_UBFX_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_ubfx_a1_a_special_cond_13_condition_le_80_d7e00050() {
    // Encoding: 0xD7E00050
    // Test aarch32_UBFX_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: Rd=0, lsb=0, widthm1=0, cond=13, Rn=0
    let encoding: u32 = 0xD7E00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_UBFX_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_ubfx_a1_a_special_cond_14_condition_al_80_e7e00050() {
    // Encoding: 0xE7E00050
    // Test aarch32_UBFX_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: Rn=0, widthm1=0, lsb=0, cond=14, Rd=0
    let encoding: u32 = 0xE7E00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_UBFX_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_ubfx_a1_a_special_cond_15_condition_nv_80_f7e00050() {
    // Encoding: 0xF7E00050
    // Test aarch32_UBFX_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: widthm1=0, Rn=0, lsb=0, cond=15, Rd=0
    let encoding: u32 = 0xF7E00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_UBFX_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ubfx_a1_a_invalid_0_50_07e00050() {
    // Encoding: 0x07E00050
    // Test aarch32_UBFX_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }
    // ISET: A32
    // Fields: Rd=0, widthm1=0, Rn=0, cond=0, lsb=0
    let encoding: u32 = 0x07E00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_UBFX_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ubfx_a1_a_invalid_1_50_07e00050() {
    // Encoding: 0x07E00050
    // Test aarch32_UBFX_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Rn=0, widthm1=0, lsb=0, cond=0, Rd=0
    let encoding: u32 = 0x07E00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_UBFX_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ubfx_t1_a_field_rn_0_min_0_f3c00000() {
    // Thumb encoding (32): 0xF3C00000
    // Test aarch32_UBFX_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: widthm1=0, imm3=0, Rn=0, Rd=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3C00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_UBFX_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ubfx_t1_a_field_rn_1_poweroftwo_0_f3c10000() {
    // Thumb encoding (32): 0xF3C10000
    // Test aarch32_UBFX_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=1, Rd=0, imm3=0, widthm1=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3C10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_UBFX_T1_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_ubfx_t1_a_field_imm3_0_zero_0_f3c00000() {
    // Thumb encoding (32): 0xF3C00000
    // Test aarch32_UBFX_T1_A field imm3 = 0 (Zero)
    // ISET: T32
    // Fields: Rn=0, imm3=0, Rd=0, imm2=0, widthm1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3C00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_UBFX_T1_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_ubfx_t1_a_field_imm3_1_poweroftwo_0_f3c01000() {
    // Thumb encoding (32): 0xF3C01000
    // Test aarch32_UBFX_T1_A field imm3 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm3=1, Rd=0, imm2=0, Rn=0, widthm1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3C01000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_UBFX_T1_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 3, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (3)
#[test]
fn test_aarch32_ubfx_t1_a_field_imm3_3_poweroftwominusone_0_f3c03000() {
    // Thumb encoding (32): 0xF3C03000
    // Test aarch32_UBFX_T1_A field imm3 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, Rd=0, imm3=3, widthm1=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3C03000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_UBFX_T1_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 7, boundary: Max }
/// maximum immediate (7)
#[test]
fn test_aarch32_ubfx_t1_a_field_imm3_7_max_0_f3c07000() {
    // Thumb encoding (32): 0xF3C07000
    // Test aarch32_UBFX_T1_A field imm3 = 7 (Max)
    // ISET: T32
    // Fields: widthm1=0, imm3=7, Rd=0, imm2=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3C07000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_UBFX_T1_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_ubfx_t1_a_field_rd_0_min_0_f3c00000() {
    // Thumb encoding (32): 0xF3C00000
    // Test aarch32_UBFX_T1_A field Rd = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, widthm1=0, imm3=0, Rd=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3C00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_UBFX_T1_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_ubfx_t1_a_field_rd_1_poweroftwo_0_f3c00100() {
    // Thumb encoding (32): 0xF3C00100
    // Test aarch32_UBFX_T1_A field Rd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm3=0, imm2=0, Rd=1, widthm1=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3C00100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_UBFX_T1_A
/// ASL: `field imm2 6 +: 2`
/// Requirement: FieldBoundary { field: "imm2", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_ubfx_t1_a_field_imm2_0_zero_0_f3c00000() {
    // Thumb encoding (32): 0xF3C00000
    // Test aarch32_UBFX_T1_A field imm2 = 0 (Zero)
    // ISET: T32
    // Fields: imm3=0, imm2=0, widthm1=0, Rn=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3C00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_UBFX_T1_A
/// ASL: `field imm2 6 +: 2`
/// Requirement: FieldBoundary { field: "imm2", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_ubfx_t1_a_field_imm2_1_poweroftwo_0_f3c00040() {
    // Thumb encoding (32): 0xF3C00040
    // Test aarch32_UBFX_T1_A field imm2 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm3=0, widthm1=0, Rn=0, Rd=0, imm2=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3C00040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_UBFX_T1_A
/// ASL: `field imm2 6 +: 2`
/// Requirement: FieldBoundary { field: "imm2", value: 3, boundary: Max }
/// maximum immediate (3)
#[test]
fn test_aarch32_ubfx_t1_a_field_imm2_3_max_0_f3c000c0() {
    // Thumb encoding (32): 0xF3C000C0
    // Test aarch32_UBFX_T1_A field imm2 = 3 (Max)
    // ISET: T32
    // Fields: Rn=0, imm3=0, imm2=3, widthm1=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3C000C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_UBFX_T1_A
/// ASL: `field widthm1 0 +: 5`
/// Requirement: FieldBoundary { field: "widthm1", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_ubfx_t1_a_field_widthm1_0_min_0_f3c00000() {
    // Thumb encoding (32): 0xF3C00000
    // Test aarch32_UBFX_T1_A field widthm1 = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, widthm1=0, Rd=0, imm2=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3C00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_UBFX_T1_A
/// ASL: `field widthm1 0 +: 5`
/// Requirement: FieldBoundary { field: "widthm1", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_ubfx_t1_a_field_widthm1_1_poweroftwo_0_f3c00001() {
    // Thumb encoding (32): 0xF3C00001
    // Test aarch32_UBFX_T1_A field widthm1 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm2=0, Rn=0, widthm1=1, Rd=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3C00001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_UBFX_T1_A
/// ASL: `field widthm1 0 +: 5`
/// Requirement: FieldBoundary { field: "widthm1", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_aarch32_ubfx_t1_a_field_widthm1_15_poweroftwominusone_0_f3c0000f() {
    // Thumb encoding (32): 0xF3C0000F
    // Test aarch32_UBFX_T1_A field widthm1 = 15 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: widthm1=15, Rd=0, imm3=0, Rn=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3C0000F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_UBFX_T1_A
/// ASL: `field widthm1 0 +: 5`
/// Requirement: FieldBoundary { field: "widthm1", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_aarch32_ubfx_t1_a_field_widthm1_31_max_0_f3c0001f() {
    // Thumb encoding (32): 0xF3C0001F
    // Test aarch32_UBFX_T1_A field widthm1 = 31 (Max)
    // ISET: T32
    // Fields: imm2=0, Rn=0, widthm1=31, imm3=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3C0001F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_UBFX_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_ubfx_t1_a_combo_0_0_f3c00000() {
    // Thumb encoding (32): 0xF3C00000
    // Test aarch32_UBFX_T1_A field combination: Rn=0, imm3=0, Rd=0, imm2=0, widthm1=0
    // ISET: T32
    // Fields: imm2=0, Rn=0, imm3=0, Rd=0, widthm1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3C00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_UBFX_T1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_ubfx_t1_a_combo_1_0_f3c10000() {
    // Thumb encoding (32): 0xF3C10000
    // Test aarch32_UBFX_T1_A field combination: Rn=1, imm3=0, Rd=0, imm2=0, widthm1=0
    // ISET: T32
    // Fields: imm3=0, widthm1=0, Rn=1, Rd=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3C10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_UBFX_T1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm3=0 (immediate value 0)
#[test]
fn test_aarch32_ubfx_t1_a_combo_2_0_f3c00000() {
    // Thumb encoding (32): 0xF3C00000
    // Test aarch32_UBFX_T1_A field combination: Rn=0, imm3=0, Rd=0, imm2=0, widthm1=0
    // ISET: T32
    // Fields: widthm1=0, Rd=0, imm3=0, Rn=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3C00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_UBFX_T1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm3=1 (immediate value 1)
#[test]
fn test_aarch32_ubfx_t1_a_combo_3_0_f3c01000() {
    // Thumb encoding (32): 0xF3C01000
    // Test aarch32_UBFX_T1_A field combination: Rn=0, imm3=1, Rd=0, imm2=0, widthm1=0
    // ISET: T32
    // Fields: Rn=0, imm2=0, imm3=1, widthm1=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3C01000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_UBFX_T1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm3=3 (immediate midpoint (3))
#[test]
fn test_aarch32_ubfx_t1_a_combo_4_0_f3c03000() {
    // Thumb encoding (32): 0xF3C03000
    // Test aarch32_UBFX_T1_A field combination: Rn=0, imm3=3, Rd=0, imm2=0, widthm1=0
    // ISET: T32
    // Fields: imm3=3, Rd=0, imm2=0, Rn=0, widthm1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3C03000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_UBFX_T1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm3=7 (maximum immediate (7))
#[test]
fn test_aarch32_ubfx_t1_a_combo_5_0_f3c07000() {
    // Thumb encoding (32): 0xF3C07000
    // Test aarch32_UBFX_T1_A field combination: Rn=0, imm3=7, Rd=0, imm2=0, widthm1=0
    // ISET: T32
    // Fields: Rd=0, imm2=0, imm3=7, widthm1=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3C07000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_UBFX_T1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch32_ubfx_t1_a_combo_6_0_f3c00000() {
    // Thumb encoding (32): 0xF3C00000
    // Test aarch32_UBFX_T1_A field combination: Rn=0, imm3=0, Rd=0, imm2=0, widthm1=0
    // ISET: T32
    // Fields: imm3=0, Rd=0, imm2=0, Rn=0, widthm1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3C00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_UBFX_T1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch32_ubfx_t1_a_combo_7_0_f3c00100() {
    // Thumb encoding (32): 0xF3C00100
    // Test aarch32_UBFX_T1_A field combination: Rn=0, imm3=0, Rd=1, imm2=0, widthm1=0
    // ISET: T32
    // Fields: Rn=0, imm2=0, imm3=0, Rd=1, widthm1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3C00100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_UBFX_T1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm2=0 (immediate value 0)
#[test]
fn test_aarch32_ubfx_t1_a_combo_8_0_f3c00000() {
    // Thumb encoding (32): 0xF3C00000
    // Test aarch32_UBFX_T1_A field combination: Rn=0, imm3=0, Rd=0, imm2=0, widthm1=0
    // ISET: T32
    // Fields: imm2=0, widthm1=0, Rn=0, imm3=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3C00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_UBFX_T1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm2=1 (immediate value 1)
#[test]
fn test_aarch32_ubfx_t1_a_combo_9_0_f3c00040() {
    // Thumb encoding (32): 0xF3C00040
    // Test aarch32_UBFX_T1_A field combination: Rn=0, imm3=0, Rd=0, imm2=1, widthm1=0
    // ISET: T32
    // Fields: imm3=0, Rn=0, widthm1=0, imm2=1, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3C00040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_UBFX_T1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm2=3 (maximum immediate (3))
#[test]
fn test_aarch32_ubfx_t1_a_combo_10_0_f3c000c0() {
    // Thumb encoding (32): 0xF3C000C0
    // Test aarch32_UBFX_T1_A field combination: Rn=0, imm3=0, Rd=0, imm2=3, widthm1=0
    // ISET: T32
    // Fields: widthm1=0, imm2=3, imm3=0, Rn=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3C000C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_UBFX_T1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// widthm1=0 (minimum value)
#[test]
fn test_aarch32_ubfx_t1_a_combo_11_0_f3c00000() {
    // Thumb encoding (32): 0xF3C00000
    // Test aarch32_UBFX_T1_A field combination: Rn=0, imm3=0, Rd=0, imm2=0, widthm1=0
    // ISET: T32
    // Fields: Rd=0, imm2=0, widthm1=0, Rn=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3C00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_UBFX_T1_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// widthm1=1 (value 1)
#[test]
fn test_aarch32_ubfx_t1_a_combo_12_0_f3c00001() {
    // Thumb encoding (32): 0xF3C00001
    // Test aarch32_UBFX_T1_A field combination: Rn=0, imm3=0, Rd=0, imm2=0, widthm1=1
    // ISET: T32
    // Fields: imm3=0, Rd=0, widthm1=1, imm2=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3C00001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_UBFX_T1_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// widthm1=15 (midpoint (15))
#[test]
fn test_aarch32_ubfx_t1_a_combo_13_0_f3c0000f() {
    // Thumb encoding (32): 0xF3C0000F
    // Test aarch32_UBFX_T1_A field combination: Rn=0, imm3=0, Rd=0, imm2=0, widthm1=15
    // ISET: T32
    // Fields: imm2=0, widthm1=15, imm3=0, Rd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3C0000F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_UBFX_T1_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// widthm1=31 (maximum value (31))
#[test]
fn test_aarch32_ubfx_t1_a_combo_14_0_f3c0001f() {
    // Thumb encoding (32): 0xF3C0001F
    // Test aarch32_UBFX_T1_A field combination: Rn=0, imm3=0, Rd=0, imm2=0, widthm1=31
    // ISET: T32
    // Fields: widthm1=31, imm3=0, Rd=0, Rn=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3C0001F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_UBFX_T1_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch32_ubfx_t1_a_combo_15_0_f3c10100() {
    // Thumb encoding (32): 0xF3C10100
    // Test aarch32_UBFX_T1_A field combination: Rn=1, imm3=0, Rd=1, imm2=0, widthm1=0
    // ISET: T32
    // Fields: imm2=0, widthm1=0, imm3=0, Rn=1, Rd=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3C10100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_UBFX_T1_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch32_ubfx_t1_a_combo_16_0_f3cf0f00() {
    // Thumb encoding (32): 0xF3CF0F00
    // Test aarch32_UBFX_T1_A field combination: Rn=31, imm3=0, Rd=31, imm2=0, widthm1=0
    // ISET: T32
    // Fields: imm3=0, widthm1=0, imm2=0, Rn=31, Rd=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3CF0F00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_UBFX_T1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ubfx_t1_a_invalid_0_0_f3c00000() {
    // Thumb encoding (32): 0xF3C00000
    // Test aarch32_UBFX_T1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }
    // ISET: T32
    // Fields: widthm1=0, Rn=0, Rd=0, imm3=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3C00000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_UBFX_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ubfx_t1_a_invalid_1_0_f3c00000() {
    // Thumb encoding (32): 0xF3C00000
    // Test aarch32_UBFX_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: imm3=0, Rd=0, Rn=0, imm2=0, widthm1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3C00000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_UBFX_A1_A
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ubfx_a1_a_exception_0_07e00050() {
    // Test aarch32_UBFX_A1_A exception: Unpredictable
    // Encoding: 0x07E00050
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x07E00050;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_UBFX_T1_A
/// ASL: `SUB X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_ubfx_t1_a_sub_oracle_32_0_f3c02820() {
    // Test SUB 32-bit: simple addition/subtraction (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF3C02820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFF6064, "X0 should be 0xFFFFFFFFFFFF6064");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_UBFX_T1_A
/// ASL: `SUB X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_ubfx_t1_a_sub_oracle_64_0_f3c02820() {
    // Test SUB 64-bit: simple addition/subtraction (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF3C02820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFF6064, "X0 should be 0xFFFFFFFFFFFF6064");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_UBFX_T1_A
/// ASL: `SUB X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero operands (32)
#[test]
fn test_aarch32_ubfx_t1_a_sub_oracle_32_1_f3c00020() {
    // Test SUB 32-bit: zero operands (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF3C00020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_UBFX_T1_A
/// ASL: `SUB X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero operands (64)
#[test]
fn test_aarch32_ubfx_t1_a_sub_oracle_64_1_f3c00020() {
    // Test SUB 64-bit: zero operands (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF3C00020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_UBFX_T1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small values (32)
#[test]
fn test_aarch32_ubfx_t1_a_sub_oracle_32_2_f3c00420() {
    // Test SUB 32-bit: small values (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF3C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFF001, "X0 should be 0xFFFFFFFFFFFFF001");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_UBFX_T1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// small values (64)
#[test]
fn test_aarch32_ubfx_t1_a_sub_oracle_64_2_f3c00420() {
    // Test SUB 64-bit: small values (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF3C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFF001, "X0 should be 0xFFFFFFFFFFFFF001");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_UBFX_T1_A
/// ASL: `SUB X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_ubfx_t1_a_sub_oracle_32_3_f3fffc20() {
    // Test SUB 32-bit: max imm12 unshifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF3FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF001000, "X0 should be 0xFFFFFFFFFF001000");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_UBFX_T1_A
/// ASL: `SUB X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_ubfx_t1_a_sub_oracle_64_3_f3fffc20() {
    // Test SUB 64-bit: max imm12 unshifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF3FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF001000, "X0 should be 0xFFFFFFFFFF001000");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_UBFX_T1_A
/// ASL: `SUB X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_ubfx_t1_a_sub_oracle_32_4_f3fffc20() {
    // Test SUB 32-bit: max imm12 shifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF3FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF001000, "X0 should be 0xFFFFFFFFFF001000");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_UBFX_T1_A
/// ASL: `SUB X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_ubfx_t1_a_sub_oracle_64_4_f3fffc20() {
    // Test SUB 64-bit: max imm12 shifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF3FFFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF001000, "X0 should be 0xFFFFFFFFFF001000");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_UBFX_T1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max u64 operand (32)
#[test]
fn test_aarch32_ubfx_t1_a_sub_oracle_32_5_f3c00420() {
    // Test SUB 32-bit: max u64 operand (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF3C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFEFFF, "X0 should be 0x00000000FFFFEFFF");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_UBFX_T1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max u64 operand (64)
#[test]
fn test_aarch32_ubfx_t1_a_sub_oracle_64_5_f3c00420() {
    // Test SUB 64-bit: max u64 operand (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF3C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFEFFF, "X0 should be 0xFFFFFFFFFFFFEFFF");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_UBFX_T1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_ubfx_t1_a_sub_oracle_32_6_f3c00420() {
    // Test SUB 32-bit: zero result (for sub 1-1) (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF3C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFF000, "X0 should be 0xFFFFFFFFFFFFF000");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_UBFX_T1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_ubfx_t1_a_sub_oracle_64_6_f3c00420() {
    // Test SUB 64-bit: zero result (for sub 1-1) (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF3C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFF000, "X0 should be 0xFFFFFFFFFFFFF000");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_UBFX_T1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_ubfx_t1_a_sub_oracle_32_7_f3c00420() {
    // Test SUB 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF3C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFEFFF, "X0 should be 0x00000000FFFFEFFF");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_UBFX_T1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_ubfx_t1_a_sub_oracle_64_7_f3c00420() {
    // Test SUB 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF3C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFEFFF, "X0 should be 0x7FFFFFFFFFFFEFFF");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_UBFX_T1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_ubfx_t1_a_sub_oracle_32_8_f3c00420() {
    // Test SUB 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF3C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FFFEFFF, "X0 should be 0x000000007FFFEFFF");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_UBFX_T1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_ubfx_t1_a_sub_oracle_64_8_f3c00420() {
    // Test SUB 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF3C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FFFEFFF, "X0 should be 0x000000007FFFEFFF");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_UBFX_T1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_ubfx_t1_a_sub_oracle_32_9_f3c00420() {
    // Test SUB 32-bit: unsigned overflow 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF3C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFEFFF, "X0 should be 0x00000000FFFFEFFF");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_UBFX_T1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_ubfx_t1_a_sub_oracle_64_9_f3c00420() {
    // Test SUB 64-bit: unsigned overflow 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF3C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFEFFF, "X0 should be 0xFFFFFFFFFFFFEFFF");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_UBFX_T1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_ubfx_t1_a_sub_oracle_32_10_f3c00420() {
    // Test SUB 32-bit: unsigned overflow 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF3C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFEFFF, "X0 should be 0x00000000FFFFEFFF");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_UBFX_T1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_ubfx_t1_a_sub_oracle_64_10_f3c00420() {
    // Test SUB 64-bit: unsigned overflow 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF3C00420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFEFFF, "X0 should be 0x00000000FFFFEFFF");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_UBFX_T1_A
/// ASL: `SUB SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (32)
#[test]
fn test_aarch32_ubfx_t1_a_sub_oracle_32_rd31_sp_f3c0283f() {
    // Test SUB 32-bit with Rd=31 (SP)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF3C0283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_UBFX_T1_A
/// ASL: `SUB SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (64)
#[test]
fn test_aarch32_ubfx_t1_a_sub_oracle_64_rd31_sp_f3c0283f() {
    // Test SUB 64-bit with Rd=31 (SP)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF3C0283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_UBFX_T1_A
/// ASL: `SUB.W R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple values
#[test]
fn test_aarch32_ubfx_t1_a_t32_oracle_0_f3c10000() {
    // Test T32 SUB: simple values (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x32);
    let encoding: u32 = 0xF3C10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x32, "R0 should be 0x00000032");
}

/// Provenance: aarch32_UBFX_T1_A
/// ASL: `SUB.W R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero values
#[test]
fn test_aarch32_ubfx_t1_a_t32_oracle_1_f3c10000() {
    // Test T32 SUB: zero values (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xF3C10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_UBFX_T1_A
/// ASL: `SUB.W R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max value
#[test]
fn test_aarch32_ubfx_t1_a_t32_oracle_2_f3c10000() {
    // Test T32 SUB: max value (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF3C10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFE, "R0 should be 0xFFFFFFFE");
}

/// Provenance: aarch32_UBFX_T1_A
/// ASL: `SUB.W R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// mixed pattern
#[test]
fn test_aarch32_ubfx_t1_a_t32_oracle_3_f3c10000() {
    // Test T32 SUB: mixed pattern (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0xABCDEF01);
    let encoding: u32 = 0xF3C10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x66666777, "R0 should be 0x66666777");
}

/// Provenance: aarch32_UBFX_T1_A
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Unpredictable
#[test]
fn test_aarch32_ubfx_t1_a_exception_0_f3c00000() {
    // Test aarch32_UBFX_T1_A exception: Unpredictable
    // ISET: T32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3C00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// aarch32_BFC_A Tests
// ============================================================================

/// Provenance: aarch32_BFC_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_bfc_a1_a_field_cond_0_min_1f_07c0001f() {
    // Encoding: 0x07C0001F
    // Test aarch32_BFC_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rd=0, msb=0, lsb=0
    let encoding: u32 = 0x07C0001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFC_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_bfc_a1_a_field_cond_1_poweroftwo_1f_17c0001f() {
    // Encoding: 0x17C0001F
    // Test aarch32_BFC_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: msb=0, cond=1, lsb=0, Rd=0
    let encoding: u32 = 0x17C0001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFC_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_bfc_a1_a_field_cond_2_poweroftwo_1f_27c0001f() {
    // Encoding: 0x27C0001F
    // Test aarch32_BFC_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: msb=0, cond=2, Rd=0, lsb=0
    let encoding: u32 = 0x27C0001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFC_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_bfc_a1_a_field_cond_3_poweroftwo_1f_37c0001f() {
    // Encoding: 0x37C0001F
    // Test aarch32_BFC_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: lsb=0, msb=0, Rd=0, cond=3
    let encoding: u32 = 0x37C0001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFC_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_bfc_a1_a_field_cond_4_poweroftwo_1f_47c0001f() {
    // Encoding: 0x47C0001F
    // Test aarch32_BFC_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: msb=0, cond=4, Rd=0, lsb=0
    let encoding: u32 = 0x47C0001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFC_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_bfc_a1_a_field_cond_5_poweroftwo_1f_57c0001f() {
    // Encoding: 0x57C0001F
    // Test aarch32_BFC_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=5, Rd=0, msb=0, lsb=0
    let encoding: u32 = 0x57C0001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFC_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_bfc_a1_a_field_cond_6_poweroftwo_1f_67c0001f() {
    // Encoding: 0x67C0001F
    // Test aarch32_BFC_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: lsb=0, Rd=0, msb=0, cond=6
    let encoding: u32 = 0x67C0001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFC_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_bfc_a1_a_field_cond_7_poweroftwo_1f_77c0001f() {
    // Encoding: 0x77C0001F
    // Test aarch32_BFC_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: msb=0, cond=7, lsb=0, Rd=0
    let encoding: u32 = 0x77C0001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFC_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_bfc_a1_a_field_cond_8_poweroftwo_1f_87c0001f() {
    // Encoding: 0x87C0001F
    // Test aarch32_BFC_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, cond=8, msb=0, lsb=0
    let encoding: u32 = 0x87C0001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFC_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_bfc_a1_a_field_cond_9_poweroftwo_1f_97c0001f() {
    // Encoding: 0x97C0001F
    // Test aarch32_BFC_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, lsb=0, msb=0, cond=9
    let encoding: u32 = 0x97C0001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFC_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_bfc_a1_a_field_cond_10_poweroftwo_1f_a7c0001f() {
    // Encoding: 0xA7C0001F
    // Test aarch32_BFC_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=10, Rd=0, msb=0, lsb=0
    let encoding: u32 = 0xA7C0001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFC_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_bfc_a1_a_field_cond_11_poweroftwo_1f_b7c0001f() {
    // Encoding: 0xB7C0001F
    // Test aarch32_BFC_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=11, msb=0, Rd=0, lsb=0
    let encoding: u32 = 0xB7C0001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFC_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_bfc_a1_a_field_cond_12_poweroftwo_1f_c7c0001f() {
    // Encoding: 0xC7C0001F
    // Test aarch32_BFC_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, lsb=0, cond=12, msb=0
    let encoding: u32 = 0xC7C0001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFC_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_bfc_a1_a_field_cond_13_poweroftwo_1f_d7c0001f() {
    // Encoding: 0xD7C0001F
    // Test aarch32_BFC_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: msb=0, Rd=0, cond=13, lsb=0
    let encoding: u32 = 0xD7C0001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFC_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_bfc_a1_a_field_cond_14_poweroftwo_1f_e7c0001f() {
    // Encoding: 0xE7C0001F
    // Test aarch32_BFC_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: lsb=0, cond=14, msb=0, Rd=0
    let encoding: u32 = 0xE7C0001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFC_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_bfc_a1_a_field_cond_15_max_1f_f7c0001f() {
    // Encoding: 0xF7C0001F
    // Test aarch32_BFC_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: cond=15, msb=0, lsb=0, Rd=0
    let encoding: u32 = 0xF7C0001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFC_A1_A
/// ASL: `field msb 16 +: 5`
/// Requirement: FieldBoundary { field: "msb", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_bfc_a1_a_field_msb_0_min_1f_07c0001f() {
    // Encoding: 0x07C0001F
    // Test aarch32_BFC_A1_A field msb = 0 (Min)
    // ISET: A32
    // Fields: msb=0, lsb=0, cond=0, Rd=0
    let encoding: u32 = 0x07C0001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFC_A1_A
/// ASL: `field msb 16 +: 5`
/// Requirement: FieldBoundary { field: "msb", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_bfc_a1_a_field_msb_1_poweroftwo_1f_07c1001f() {
    // Encoding: 0x07C1001F
    // Test aarch32_BFC_A1_A field msb = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, lsb=0, Rd=0, msb=1
    let encoding: u32 = 0x07C1001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFC_A1_A
/// ASL: `field msb 16 +: 5`
/// Requirement: FieldBoundary { field: "msb", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_aarch32_bfc_a1_a_field_msb_15_poweroftwominusone_1f_07cf001f() {
    // Encoding: 0x07CF001F
    // Test aarch32_BFC_A1_A field msb = 15 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rd=0, cond=0, msb=15, lsb=0
    let encoding: u32 = 0x07CF001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFC_A1_A
/// ASL: `field msb 16 +: 5`
/// Requirement: FieldBoundary { field: "msb", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_aarch32_bfc_a1_a_field_msb_31_max_1f_07df001f() {
    // Encoding: 0x07DF001F
    // Test aarch32_BFC_A1_A field msb = 31 (Max)
    // ISET: A32
    // Fields: msb=31, lsb=0, cond=0, Rd=0
    let encoding: u32 = 0x07DF001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFC_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_bfc_a1_a_field_rd_0_min_1f_07c0001f() {
    // Encoding: 0x07C0001F
    // Test aarch32_BFC_A1_A field Rd = 0 (Min)
    // ISET: A32
    // Fields: cond=0, msb=0, Rd=0, lsb=0
    let encoding: u32 = 0x07C0001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFC_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_bfc_a1_a_field_rd_1_poweroftwo_1f_07c0101f() {
    // Encoding: 0x07C0101F
    // Test aarch32_BFC_A1_A field Rd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=1, cond=0, msb=0, lsb=0
    let encoding: u32 = 0x07C0101F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFC_A1_A
/// ASL: `field lsb 7 +: 5`
/// Requirement: FieldBoundary { field: "lsb", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_bfc_a1_a_field_lsb_0_min_1f_07c0001f() {
    // Encoding: 0x07C0001F
    // Test aarch32_BFC_A1_A field lsb = 0 (Min)
    // ISET: A32
    // Fields: msb=0, lsb=0, cond=0, Rd=0
    let encoding: u32 = 0x07C0001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFC_A1_A
/// ASL: `field lsb 7 +: 5`
/// Requirement: FieldBoundary { field: "lsb", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_bfc_a1_a_field_lsb_1_poweroftwo_1f_07c0009f() {
    // Encoding: 0x07C0009F
    // Test aarch32_BFC_A1_A field lsb = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Rd=0, lsb=1, msb=0
    let encoding: u32 = 0x07C0009F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFC_A1_A
/// ASL: `field lsb 7 +: 5`
/// Requirement: FieldBoundary { field: "lsb", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_aarch32_bfc_a1_a_field_lsb_15_poweroftwominusone_1f_07c0079f() {
    // Encoding: 0x07C0079F
    // Test aarch32_BFC_A1_A field lsb = 15 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, lsb=15, msb=0, Rd=0
    let encoding: u32 = 0x07C0079F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFC_A1_A
/// ASL: `field lsb 7 +: 5`
/// Requirement: FieldBoundary { field: "lsb", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_aarch32_bfc_a1_a_field_lsb_31_max_1f_07c00f9f() {
    // Encoding: 0x07C00F9F
    // Test aarch32_BFC_A1_A field lsb = 31 (Max)
    // ISET: A32
    // Fields: Rd=0, cond=0, msb=0, lsb=31
    let encoding: u32 = 0x07C00F9F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFC_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_bfc_a1_a_combo_0_1f_07c0001f() {
    // Encoding: 0x07C0001F
    // Test aarch32_BFC_A1_A field combination: cond=0, msb=0, Rd=0, lsb=0
    // ISET: A32
    // Fields: msb=0, lsb=0, Rd=0, cond=0
    let encoding: u32 = 0x07C0001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFC_A1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=1 (condition NE (not equal))
#[test]
fn test_aarch32_bfc_a1_a_combo_1_1f_17c0001f() {
    // Encoding: 0x17C0001F
    // Test aarch32_BFC_A1_A field combination: cond=1, msb=0, Rd=0, lsb=0
    // ISET: A32
    // Fields: lsb=0, msb=0, cond=1, Rd=0
    let encoding: u32 = 0x17C0001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFC_A1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=2 (condition CS/HS (carry set))
#[test]
fn test_aarch32_bfc_a1_a_combo_2_1f_27c0001f() {
    // Encoding: 0x27C0001F
    // Test aarch32_BFC_A1_A field combination: cond=2, msb=0, Rd=0, lsb=0
    // ISET: A32
    // Fields: lsb=0, cond=2, msb=0, Rd=0
    let encoding: u32 = 0x27C0001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFC_A1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=3 (condition CC/LO (carry clear))
#[test]
fn test_aarch32_bfc_a1_a_combo_3_1f_37c0001f() {
    // Encoding: 0x37C0001F
    // Test aarch32_BFC_A1_A field combination: cond=3, msb=0, Rd=0, lsb=0
    // ISET: A32
    // Fields: cond=3, msb=0, lsb=0, Rd=0
    let encoding: u32 = 0x37C0001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFC_A1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=4 (condition MI (minus/negative))
#[test]
fn test_aarch32_bfc_a1_a_combo_4_1f_47c0001f() {
    // Encoding: 0x47C0001F
    // Test aarch32_BFC_A1_A field combination: cond=4, msb=0, Rd=0, lsb=0
    // ISET: A32
    // Fields: lsb=0, cond=4, Rd=0, msb=0
    let encoding: u32 = 0x47C0001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFC_A1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=5 (condition PL (plus/positive))
#[test]
fn test_aarch32_bfc_a1_a_combo_5_1f_57c0001f() {
    // Encoding: 0x57C0001F
    // Test aarch32_BFC_A1_A field combination: cond=5, msb=0, Rd=0, lsb=0
    // ISET: A32
    // Fields: lsb=0, cond=5, Rd=0, msb=0
    let encoding: u32 = 0x57C0001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFC_A1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=6 (condition VS (overflow set))
#[test]
fn test_aarch32_bfc_a1_a_combo_6_1f_67c0001f() {
    // Encoding: 0x67C0001F
    // Test aarch32_BFC_A1_A field combination: cond=6, msb=0, Rd=0, lsb=0
    // ISET: A32
    // Fields: Rd=0, lsb=0, msb=0, cond=6
    let encoding: u32 = 0x67C0001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFC_A1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=7 (condition VC (overflow clear))
#[test]
fn test_aarch32_bfc_a1_a_combo_7_1f_77c0001f() {
    // Encoding: 0x77C0001F
    // Test aarch32_BFC_A1_A field combination: cond=7, msb=0, Rd=0, lsb=0
    // ISET: A32
    // Fields: cond=7, msb=0, Rd=0, lsb=0
    let encoding: u32 = 0x77C0001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFC_A1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=8 (condition HI (unsigned higher))
#[test]
fn test_aarch32_bfc_a1_a_combo_8_1f_87c0001f() {
    // Encoding: 0x87C0001F
    // Test aarch32_BFC_A1_A field combination: cond=8, msb=0, Rd=0, lsb=0
    // ISET: A32
    // Fields: msb=0, cond=8, Rd=0, lsb=0
    let encoding: u32 = 0x87C0001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFC_A1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=9 (condition LS (unsigned lower or same))
#[test]
fn test_aarch32_bfc_a1_a_combo_9_1f_97c0001f() {
    // Encoding: 0x97C0001F
    // Test aarch32_BFC_A1_A field combination: cond=9, msb=0, Rd=0, lsb=0
    // ISET: A32
    // Fields: msb=0, lsb=0, cond=9, Rd=0
    let encoding: u32 = 0x97C0001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFC_A1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=10 (condition GE (signed >=))
#[test]
fn test_aarch32_bfc_a1_a_combo_10_1f_a7c0001f() {
    // Encoding: 0xA7C0001F
    // Test aarch32_BFC_A1_A field combination: cond=10, msb=0, Rd=0, lsb=0
    // ISET: A32
    // Fields: cond=10, msb=0, Rd=0, lsb=0
    let encoding: u32 = 0xA7C0001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFC_A1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=11 (condition LT (signed <))
#[test]
fn test_aarch32_bfc_a1_a_combo_11_1f_b7c0001f() {
    // Encoding: 0xB7C0001F
    // Test aarch32_BFC_A1_A field combination: cond=11, msb=0, Rd=0, lsb=0
    // ISET: A32
    // Fields: Rd=0, cond=11, lsb=0, msb=0
    let encoding: u32 = 0xB7C0001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFC_A1_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=12 (condition GT (signed >))
#[test]
fn test_aarch32_bfc_a1_a_combo_12_1f_c7c0001f() {
    // Encoding: 0xC7C0001F
    // Test aarch32_BFC_A1_A field combination: cond=12, msb=0, Rd=0, lsb=0
    // ISET: A32
    // Fields: Rd=0, lsb=0, cond=12, msb=0
    let encoding: u32 = 0xC7C0001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFC_A1_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=13 (condition LE (signed <=))
#[test]
fn test_aarch32_bfc_a1_a_combo_13_1f_d7c0001f() {
    // Encoding: 0xD7C0001F
    // Test aarch32_BFC_A1_A field combination: cond=13, msb=0, Rd=0, lsb=0
    // ISET: A32
    // Fields: Rd=0, msb=0, cond=13, lsb=0
    let encoding: u32 = 0xD7C0001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFC_A1_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=14 (condition AL (always))
#[test]
fn test_aarch32_bfc_a1_a_combo_14_1f_e7c0001f() {
    // Encoding: 0xE7C0001F
    // Test aarch32_BFC_A1_A field combination: cond=14, msb=0, Rd=0, lsb=0
    // ISET: A32
    // Fields: cond=14, Rd=0, lsb=0, msb=0
    let encoding: u32 = 0xE7C0001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFC_A1_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=15 (condition NV (never, reserved))
#[test]
fn test_aarch32_bfc_a1_a_combo_15_1f_f7c0001f() {
    // Encoding: 0xF7C0001F
    // Test aarch32_BFC_A1_A field combination: cond=15, msb=0, Rd=0, lsb=0
    // ISET: A32
    // Fields: cond=15, lsb=0, msb=0, Rd=0
    let encoding: u32 = 0xF7C0001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFC_A1_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// msb=0 (minimum value)
#[test]
fn test_aarch32_bfc_a1_a_combo_16_1f_07c0001f() {
    // Encoding: 0x07C0001F
    // Test aarch32_BFC_A1_A field combination: cond=0, msb=0, Rd=0, lsb=0
    // ISET: A32
    // Fields: Rd=0, lsb=0, msb=0, cond=0
    let encoding: u32 = 0x07C0001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFC_A1_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// msb=1 (value 1)
#[test]
fn test_aarch32_bfc_a1_a_combo_17_1f_07c1001f() {
    // Encoding: 0x07C1001F
    // Test aarch32_BFC_A1_A field combination: cond=0, msb=1, Rd=0, lsb=0
    // ISET: A32
    // Fields: cond=0, Rd=0, msb=1, lsb=0
    let encoding: u32 = 0x07C1001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFC_A1_A
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// msb=15 (midpoint (15))
#[test]
fn test_aarch32_bfc_a1_a_combo_18_1f_07cf001f() {
    // Encoding: 0x07CF001F
    // Test aarch32_BFC_A1_A field combination: cond=0, msb=15, Rd=0, lsb=0
    // ISET: A32
    // Fields: Rd=0, lsb=0, msb=15, cond=0
    let encoding: u32 = 0x07CF001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFC_A1_A
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// msb=31 (maximum value (31))
#[test]
fn test_aarch32_bfc_a1_a_combo_19_1f_07df001f() {
    // Encoding: 0x07DF001F
    // Test aarch32_BFC_A1_A field combination: cond=0, msb=31, Rd=0, lsb=0
    // ISET: A32
    // Fields: cond=0, lsb=0, Rd=0, msb=31
    let encoding: u32 = 0x07DF001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFC_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_bfc_a1_a_special_cond_0_condition_eq_31_07c0001f() {
    // Encoding: 0x07C0001F
    // Test aarch32_BFC_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: cond=0, msb=0, lsb=0, Rd=0
    let encoding: u32 = 0x07C0001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFC_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_bfc_a1_a_special_cond_1_condition_ne_31_17c0001f() {
    // Encoding: 0x17C0001F
    // Test aarch32_BFC_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: Rd=0, lsb=0, msb=0, cond=1
    let encoding: u32 = 0x17C0001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFC_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_bfc_a1_a_special_cond_2_condition_cs_hs_31_27c0001f() {
    // Encoding: 0x27C0001F
    // Test aarch32_BFC_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: lsb=0, msb=0, Rd=0, cond=2
    let encoding: u32 = 0x27C0001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFC_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_bfc_a1_a_special_cond_3_condition_cc_lo_31_37c0001f() {
    // Encoding: 0x37C0001F
    // Test aarch32_BFC_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: Rd=0, cond=3, msb=0, lsb=0
    let encoding: u32 = 0x37C0001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFC_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_bfc_a1_a_special_cond_4_condition_mi_31_47c0001f() {
    // Encoding: 0x47C0001F
    // Test aarch32_BFC_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: msb=0, lsb=0, cond=4, Rd=0
    let encoding: u32 = 0x47C0001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFC_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_bfc_a1_a_special_cond_5_condition_pl_31_57c0001f() {
    // Encoding: 0x57C0001F
    // Test aarch32_BFC_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: lsb=0, cond=5, msb=0, Rd=0
    let encoding: u32 = 0x57C0001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFC_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_bfc_a1_a_special_cond_6_condition_vs_31_67c0001f() {
    // Encoding: 0x67C0001F
    // Test aarch32_BFC_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: lsb=0, msb=0, cond=6, Rd=0
    let encoding: u32 = 0x67C0001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFC_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_bfc_a1_a_special_cond_7_condition_vc_31_77c0001f() {
    // Encoding: 0x77C0001F
    // Test aarch32_BFC_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: Rd=0, cond=7, lsb=0, msb=0
    let encoding: u32 = 0x77C0001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFC_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_bfc_a1_a_special_cond_8_condition_hi_31_87c0001f() {
    // Encoding: 0x87C0001F
    // Test aarch32_BFC_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: cond=8, msb=0, Rd=0, lsb=0
    let encoding: u32 = 0x87C0001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFC_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_bfc_a1_a_special_cond_9_condition_ls_31_97c0001f() {
    // Encoding: 0x97C0001F
    // Test aarch32_BFC_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: cond=9, lsb=0, msb=0, Rd=0
    let encoding: u32 = 0x97C0001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFC_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_bfc_a1_a_special_cond_10_condition_ge_31_a7c0001f() {
    // Encoding: 0xA7C0001F
    // Test aarch32_BFC_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: cond=10, lsb=0, msb=0, Rd=0
    let encoding: u32 = 0xA7C0001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFC_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_bfc_a1_a_special_cond_11_condition_lt_31_b7c0001f() {
    // Encoding: 0xB7C0001F
    // Test aarch32_BFC_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: cond=11, Rd=0, lsb=0, msb=0
    let encoding: u32 = 0xB7C0001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFC_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_bfc_a1_a_special_cond_12_condition_gt_31_c7c0001f() {
    // Encoding: 0xC7C0001F
    // Test aarch32_BFC_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: msb=0, Rd=0, cond=12, lsb=0
    let encoding: u32 = 0xC7C0001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFC_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_bfc_a1_a_special_cond_13_condition_le_31_d7c0001f() {
    // Encoding: 0xD7C0001F
    // Test aarch32_BFC_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: cond=13, msb=0, Rd=0, lsb=0
    let encoding: u32 = 0xD7C0001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFC_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_bfc_a1_a_special_cond_14_condition_al_31_e7c0001f() {
    // Encoding: 0xE7C0001F
    // Test aarch32_BFC_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: lsb=0, Rd=0, msb=0, cond=14
    let encoding: u32 = 0xE7C0001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFC_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_bfc_a1_a_special_cond_15_condition_nv_31_f7c0001f() {
    // Encoding: 0xF7C0001F
    // Test aarch32_BFC_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: msb=0, Rd=0, lsb=0, cond=15
    let encoding: u32 = 0xF7C0001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_BFC_A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_bfc_a1_a_invalid_0_1f_07c0001f() {
    // Encoding: 0x07C0001F
    // Test aarch32_BFC_A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: LitInt(15) }
    // ISET: A32
    // Fields: lsb=0, msb=0, cond=0, Rd=0
    let encoding: u32 = 0x07C0001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_BFC_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_bfc_a1_a_invalid_1_1f_07c0001f() {
    // Encoding: 0x07C0001F
    // Test aarch32_BFC_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Rd=0, cond=0, lsb=0, msb=0
    let encoding: u32 = 0x07C0001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_BFC_T1_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_bfc_t1_a_field_imm3_0_zero_0_f36f0000() {
    // Thumb encoding (32): 0xF36F0000
    // Test aarch32_BFC_T1_A field imm3 = 0 (Zero)
    // ISET: T32
    // Fields: msb=0, imm3=0, Rd=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF36F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_BFC_T1_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_bfc_t1_a_field_imm3_1_poweroftwo_0_f36f1000() {
    // Thumb encoding (32): 0xF36F1000
    // Test aarch32_BFC_T1_A field imm3 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: msb=0, imm2=0, Rd=0, imm3=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF36F1000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_BFC_T1_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 3, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (3)
#[test]
fn test_aarch32_bfc_t1_a_field_imm3_3_poweroftwominusone_0_f36f3000() {
    // Thumb encoding (32): 0xF36F3000
    // Test aarch32_BFC_T1_A field imm3 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rd=0, msb=0, imm2=0, imm3=3
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF36F3000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_BFC_T1_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 7, boundary: Max }
/// maximum immediate (7)
#[test]
fn test_aarch32_bfc_t1_a_field_imm3_7_max_0_f36f7000() {
    // Thumb encoding (32): 0xF36F7000
    // Test aarch32_BFC_T1_A field imm3 = 7 (Max)
    // ISET: T32
    // Fields: Rd=0, imm3=7, imm2=0, msb=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF36F7000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_BFC_T1_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_bfc_t1_a_field_rd_0_min_0_f36f0000() {
    // Thumb encoding (32): 0xF36F0000
    // Test aarch32_BFC_T1_A field Rd = 0 (Min)
    // ISET: T32
    // Fields: imm3=0, msb=0, Rd=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF36F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_BFC_T1_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_bfc_t1_a_field_rd_1_poweroftwo_0_f36f0100() {
    // Thumb encoding (32): 0xF36F0100
    // Test aarch32_BFC_T1_A field Rd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm3=0, msb=0, Rd=1, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF36F0100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_BFC_T1_A
/// ASL: `field imm2 6 +: 2`
/// Requirement: FieldBoundary { field: "imm2", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_bfc_t1_a_field_imm2_0_zero_0_f36f0000() {
    // Thumb encoding (32): 0xF36F0000
    // Test aarch32_BFC_T1_A field imm2 = 0 (Zero)
    // ISET: T32
    // Fields: imm2=0, Rd=0, imm3=0, msb=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF36F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_BFC_T1_A
/// ASL: `field imm2 6 +: 2`
/// Requirement: FieldBoundary { field: "imm2", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_bfc_t1_a_field_imm2_1_poweroftwo_0_f36f0040() {
    // Thumb encoding (32): 0xF36F0040
    // Test aarch32_BFC_T1_A field imm2 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rd=0, imm3=0, msb=0, imm2=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF36F0040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_BFC_T1_A
/// ASL: `field imm2 6 +: 2`
/// Requirement: FieldBoundary { field: "imm2", value: 3, boundary: Max }
/// maximum immediate (3)
#[test]
fn test_aarch32_bfc_t1_a_field_imm2_3_max_0_f36f00c0() {
    // Thumb encoding (32): 0xF36F00C0
    // Test aarch32_BFC_T1_A field imm2 = 3 (Max)
    // ISET: T32
    // Fields: Rd=0, imm2=3, imm3=0, msb=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF36F00C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_BFC_T1_A
/// ASL: `field msb 0 +: 5`
/// Requirement: FieldBoundary { field: "msb", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_bfc_t1_a_field_msb_0_min_0_f36f0000() {
    // Thumb encoding (32): 0xF36F0000
    // Test aarch32_BFC_T1_A field msb = 0 (Min)
    // ISET: T32
    // Fields: Rd=0, imm2=0, msb=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF36F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_BFC_T1_A
/// ASL: `field msb 0 +: 5`
/// Requirement: FieldBoundary { field: "msb", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_bfc_t1_a_field_msb_1_poweroftwo_0_f36f0001() {
    // Thumb encoding (32): 0xF36F0001
    // Test aarch32_BFC_T1_A field msb = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: msb=1, imm2=0, Rd=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF36F0001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_BFC_T1_A
/// ASL: `field msb 0 +: 5`
/// Requirement: FieldBoundary { field: "msb", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_aarch32_bfc_t1_a_field_msb_15_poweroftwominusone_0_f36f000f() {
    // Thumb encoding (32): 0xF36F000F
    // Test aarch32_BFC_T1_A field msb = 15 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: msb=15, imm2=0, imm3=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF36F000F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_BFC_T1_A
/// ASL: `field msb 0 +: 5`
/// Requirement: FieldBoundary { field: "msb", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_aarch32_bfc_t1_a_field_msb_31_max_0_f36f001f() {
    // Thumb encoding (32): 0xF36F001F
    // Test aarch32_BFC_T1_A field msb = 31 (Max)
    // ISET: T32
    // Fields: imm3=0, imm2=0, Rd=0, msb=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF36F001F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_BFC_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm3=0 (immediate value 0)
#[test]
fn test_aarch32_bfc_t1_a_combo_0_0_f36f0000() {
    // Thumb encoding (32): 0xF36F0000
    // Test aarch32_BFC_T1_A field combination: imm3=0, Rd=0, imm2=0, msb=0
    // ISET: T32
    // Fields: msb=0, imm2=0, imm3=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF36F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_BFC_T1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm3=1 (immediate value 1)
#[test]
fn test_aarch32_bfc_t1_a_combo_1_0_f36f1000() {
    // Thumb encoding (32): 0xF36F1000
    // Test aarch32_BFC_T1_A field combination: imm3=1, Rd=0, imm2=0, msb=0
    // ISET: T32
    // Fields: imm2=0, msb=0, imm3=1, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF36F1000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_BFC_T1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm3=3 (immediate midpoint (3))
#[test]
fn test_aarch32_bfc_t1_a_combo_2_0_f36f3000() {
    // Thumb encoding (32): 0xF36F3000
    // Test aarch32_BFC_T1_A field combination: imm3=3, Rd=0, imm2=0, msb=0
    // ISET: T32
    // Fields: imm2=0, imm3=3, msb=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF36F3000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_BFC_T1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm3=7 (maximum immediate (7))
#[test]
fn test_aarch32_bfc_t1_a_combo_3_0_f36f7000() {
    // Thumb encoding (32): 0xF36F7000
    // Test aarch32_BFC_T1_A field combination: imm3=7, Rd=0, imm2=0, msb=0
    // ISET: T32
    // Fields: imm2=0, msb=0, imm3=7, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF36F7000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_BFC_T1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch32_bfc_t1_a_combo_4_0_f36f0000() {
    // Thumb encoding (32): 0xF36F0000
    // Test aarch32_BFC_T1_A field combination: imm3=0, Rd=0, imm2=0, msb=0
    // ISET: T32
    // Fields: msb=0, imm3=0, Rd=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF36F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_BFC_T1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch32_bfc_t1_a_combo_5_0_f36f0100() {
    // Thumb encoding (32): 0xF36F0100
    // Test aarch32_BFC_T1_A field combination: imm3=0, Rd=1, imm2=0, msb=0
    // ISET: T32
    // Fields: imm3=0, imm2=0, Rd=1, msb=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF36F0100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_BFC_T1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm2=0 (immediate value 0)
#[test]
fn test_aarch32_bfc_t1_a_combo_6_0_f36f0000() {
    // Thumb encoding (32): 0xF36F0000
    // Test aarch32_BFC_T1_A field combination: imm3=0, Rd=0, imm2=0, msb=0
    // ISET: T32
    // Fields: imm2=0, msb=0, imm3=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF36F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_BFC_T1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm2=1 (immediate value 1)
#[test]
fn test_aarch32_bfc_t1_a_combo_7_0_f36f0040() {
    // Thumb encoding (32): 0xF36F0040
    // Test aarch32_BFC_T1_A field combination: imm3=0, Rd=0, imm2=1, msb=0
    // ISET: T32
    // Fields: imm3=0, msb=0, Rd=0, imm2=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF36F0040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_BFC_T1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm2=3 (maximum immediate (3))
#[test]
fn test_aarch32_bfc_t1_a_combo_8_0_f36f00c0() {
    // Thumb encoding (32): 0xF36F00C0
    // Test aarch32_BFC_T1_A field combination: imm3=0, Rd=0, imm2=3, msb=0
    // ISET: T32
    // Fields: imm2=3, imm3=0, Rd=0, msb=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF36F00C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_BFC_T1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// msb=0 (minimum value)
#[test]
fn test_aarch32_bfc_t1_a_combo_9_0_f36f0000() {
    // Thumb encoding (32): 0xF36F0000
    // Test aarch32_BFC_T1_A field combination: imm3=0, Rd=0, imm2=0, msb=0
    // ISET: T32
    // Fields: Rd=0, imm3=0, msb=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF36F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_BFC_T1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// msb=1 (value 1)
#[test]
fn test_aarch32_bfc_t1_a_combo_10_0_f36f0001() {
    // Thumb encoding (32): 0xF36F0001
    // Test aarch32_BFC_T1_A field combination: imm3=0, Rd=0, imm2=0, msb=1
    // ISET: T32
    // Fields: imm2=0, imm3=0, msb=1, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF36F0001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_BFC_T1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// msb=15 (midpoint (15))
#[test]
fn test_aarch32_bfc_t1_a_combo_11_0_f36f000f() {
    // Thumb encoding (32): 0xF36F000F
    // Test aarch32_BFC_T1_A field combination: imm3=0, Rd=0, imm2=0, msb=15
    // ISET: T32
    // Fields: imm3=0, msb=15, Rd=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF36F000F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_BFC_T1_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// msb=31 (maximum value (31))
#[test]
fn test_aarch32_bfc_t1_a_combo_12_0_f36f001f() {
    // Thumb encoding (32): 0xF36F001F
    // Test aarch32_BFC_T1_A field combination: imm3=0, Rd=0, imm2=0, msb=31
    // ISET: T32
    // Fields: imm3=0, Rd=0, imm2=0, msb=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF36F001F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_BFC_T1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_bfc_t1_a_invalid_0_0_f36f0000() {
    // Thumb encoding (32): 0xF36F0000
    // Test aarch32_BFC_T1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: LitInt(15) }
    // ISET: T32
    // Fields: Rd=0, msb=0, imm2=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF36F0000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_BFC_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_bfc_t1_a_invalid_1_0_f36f0000() {
    // Thumb encoding (32): 0xF36F0000
    // Test aarch32_BFC_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: imm2=0, Rd=0, imm3=0, msb=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF36F0000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_BFC_A1_A
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Unpredictable
#[test]
fn test_aarch32_bfc_a1_a_exception_0_07c0001f() {
    // Test aarch32_BFC_A1_A exception: Unpredictable
    // Encoding: 0x07C0001F
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x07C0001F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_BFC_T1_A
/// ASL: `SUB X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_bfc_t1_a_sub_oracle_32_0_f36f2820() {
    // Test SUB 32-bit: simple addition/subtraction (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF36F2820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF436064, "X0 should be 0xFFFFFFFFFF436064");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_BFC_T1_A
/// ASL: `SUB X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_bfc_t1_a_sub_oracle_64_0_f36f2820() {
    // Test SUB 64-bit: simple addition/subtraction (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF36F2820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF436064, "X0 should be 0xFFFFFFFFFF436064");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_BFC_T1_A
/// ASL: `SUB X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero operands (32)
#[test]
fn test_aarch32_bfc_t1_a_sub_oracle_32_1_f36f0020() {
    // Test SUB 32-bit: zero operands (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF36F0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF440000, "X0 should be 0xFFFFFFFFFF440000");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_BFC_T1_A
/// ASL: `SUB X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero operands (64)
#[test]
fn test_aarch32_bfc_t1_a_sub_oracle_64_1_f36f0020() {
    // Test SUB 64-bit: zero operands (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF36F0020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF440000, "X0 should be 0xFFFFFFFFFF440000");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_BFC_T1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small values (32)
#[test]
fn test_aarch32_bfc_t1_a_sub_oracle_32_2_f36f0420() {
    // Test SUB 32-bit: small values (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF36F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF43F001, "X0 should be 0xFFFFFFFFFF43F001");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_BFC_T1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// small values (64)
#[test]
fn test_aarch32_bfc_t1_a_sub_oracle_64_2_f36f0420() {
    // Test SUB 64-bit: small values (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF36F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF43F001, "X0 should be 0xFFFFFFFFFF43F001");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_BFC_T1_A
/// ASL: `SUB X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_bfc_t1_a_sub_oracle_32_3_f37ffc20() {
    // Test SUB 32-bit: max imm12 unshifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF37FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF001000, "X0 should be 0xFFFFFFFFFF001000");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_BFC_T1_A
/// ASL: `SUB X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_bfc_t1_a_sub_oracle_64_3_f37ffc20() {
    // Test SUB 64-bit: max imm12 unshifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF37FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF001000, "X0 should be 0xFFFFFFFFFF001000");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_BFC_T1_A
/// ASL: `SUB X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_bfc_t1_a_sub_oracle_32_4_f37ffc20() {
    // Test SUB 32-bit: max imm12 shifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF37FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF001000, "X0 should be 0xFFFFFFFFFF001000");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_BFC_T1_A
/// ASL: `SUB X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_bfc_t1_a_sub_oracle_64_4_f37ffc20() {
    // Test SUB 64-bit: max imm12 shifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF37FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF001000, "X0 should be 0xFFFFFFFFFF001000");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_BFC_T1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max u64 operand (32)
#[test]
fn test_aarch32_bfc_t1_a_sub_oracle_32_5_f36f0420() {
    // Test SUB 32-bit: max u64 operand (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF36F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF43EFFF, "X0 should be 0x00000000FF43EFFF");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_BFC_T1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max u64 operand (64)
#[test]
fn test_aarch32_bfc_t1_a_sub_oracle_64_5_f36f0420() {
    // Test SUB 64-bit: max u64 operand (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF36F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF43EFFF, "X0 should be 0xFFFFFFFFFF43EFFF");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_BFC_T1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_bfc_t1_a_sub_oracle_32_6_f36f0420() {
    // Test SUB 32-bit: zero result (for sub 1-1) (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF36F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF43F000, "X0 should be 0xFFFFFFFFFF43F000");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_BFC_T1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_bfc_t1_a_sub_oracle_64_6_f36f0420() {
    // Test SUB 64-bit: zero result (for sub 1-1) (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF36F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF43F000, "X0 should be 0xFFFFFFFFFF43F000");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_BFC_T1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_bfc_t1_a_sub_oracle_32_7_f36f0420() {
    // Test SUB 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF36F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF43EFFF, "X0 should be 0x00000000FF43EFFF");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_BFC_T1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_bfc_t1_a_sub_oracle_64_7_f36f0420() {
    // Test SUB 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF36F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF43EFFF, "X0 should be 0x7FFFFFFFFF43EFFF");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_BFC_T1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_bfc_t1_a_sub_oracle_32_8_f36f0420() {
    // Test SUB 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF36F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7F43EFFF, "X0 should be 0x000000007F43EFFF");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_BFC_T1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_bfc_t1_a_sub_oracle_64_8_f36f0420() {
    // Test SUB 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF36F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7F43EFFF, "X0 should be 0x000000007F43EFFF");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_BFC_T1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_bfc_t1_a_sub_oracle_32_9_f36f0420() {
    // Test SUB 32-bit: unsigned overflow 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF36F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF43EFFF, "X0 should be 0x00000000FF43EFFF");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_BFC_T1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_bfc_t1_a_sub_oracle_64_9_f36f0420() {
    // Test SUB 64-bit: unsigned overflow 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF36F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF43EFFF, "X0 should be 0xFFFFFFFFFF43EFFF");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_BFC_T1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_bfc_t1_a_sub_oracle_32_10_f36f0420() {
    // Test SUB 32-bit: unsigned overflow 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF36F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF43EFFF, "X0 should be 0x00000000FF43EFFF");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_BFC_T1_A
/// ASL: `SUB X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_bfc_t1_a_sub_oracle_64_10_f36f0420() {
    // Test SUB 64-bit: unsigned overflow 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF36F0420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF43EFFF, "X0 should be 0x00000000FF43EFFF");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_BFC_T1_A
/// ASL: `SUB SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (32)
#[test]
fn test_aarch32_bfc_t1_a_sub_oracle_32_rd31_sp_f36f283f() {
    // Test SUB 32-bit with Rd=31 (SP)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF36F283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_BFC_T1_A
/// ASL: `SUB SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (64)
#[test]
fn test_aarch32_bfc_t1_a_sub_oracle_64_rd31_sp_f36f283f() {
    // Test SUB 64-bit with Rd=31 (SP)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF36F283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_BFC_T1_A
/// ASL: `SUB.W R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple values
#[test]
fn test_aarch32_bfc_t1_a_t32_oracle_0_f36f0000() {
    // Test T32 SUB: simple values (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x32);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF36F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x32, "R0 should be 0x00000032");
}

/// Provenance: aarch32_BFC_T1_A
/// ASL: `SUB.W R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero values
#[test]
fn test_aarch32_bfc_t1_a_t32_oracle_1_f36f0000() {
    // Test T32 SUB: zero values (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xF36F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_BFC_T1_A
/// ASL: `SUB.W R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max value
#[test]
fn test_aarch32_bfc_t1_a_t32_oracle_2_f36f0000() {
    // Test T32 SUB: max value (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0xF36F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFE, "R0 should be 0xFFFFFFFE");
}

/// Provenance: aarch32_BFC_T1_A
/// ASL: `SUB.W R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// mixed pattern
#[test]
fn test_aarch32_bfc_t1_a_t32_oracle_3_f36f0000() {
    // Test T32 SUB: mixed pattern (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0xABCDEF01);
    let encoding: u32 = 0xF36F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x66666777, "R0 should be 0x66666777");
}

/// Provenance: aarch32_BFC_T1_A
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Unpredictable
#[test]
fn test_aarch32_bfc_t1_a_exception_0_f36f0000() {
    // Test aarch32_BFC_T1_A exception: Unpredictable
    // ISET: T32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF36F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// aarch32_SBFX_A Tests
// ============================================================================

/// Provenance: aarch32_SBFX_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_sbfx_a1_a_field_cond_0_min_50_07a00050() {
    // Encoding: 0x07A00050
    // Test aarch32_SBFX_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: widthm1=0, lsb=0, Rn=0, cond=0, Rd=0
    let encoding: u32 = 0x07A00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SBFX_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_sbfx_a1_a_field_cond_1_poweroftwo_50_17a00050() {
    // Encoding: 0x17A00050
    // Test aarch32_SBFX_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=1, Rd=0, widthm1=0, lsb=0, Rn=0
    let encoding: u32 = 0x17A00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SBFX_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_sbfx_a1_a_field_cond_2_poweroftwo_50_27a00050() {
    // Encoding: 0x27A00050
    // Test aarch32_SBFX_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: widthm1=0, Rn=0, Rd=0, cond=2, lsb=0
    let encoding: u32 = 0x27A00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SBFX_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_sbfx_a1_a_field_cond_3_poweroftwo_50_37a00050() {
    // Encoding: 0x37A00050
    // Test aarch32_SBFX_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=3, Rd=0, lsb=0, widthm1=0
    let encoding: u32 = 0x37A00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SBFX_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_sbfx_a1_a_field_cond_4_poweroftwo_50_47a00050() {
    // Encoding: 0x47A00050
    // Test aarch32_SBFX_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: widthm1=0, Rd=0, Rn=0, cond=4, lsb=0
    let encoding: u32 = 0x47A00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SBFX_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_sbfx_a1_a_field_cond_5_poweroftwo_50_57a00050() {
    // Encoding: 0x57A00050
    // Test aarch32_SBFX_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: lsb=0, Rn=0, cond=5, Rd=0, widthm1=0
    let encoding: u32 = 0x57A00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SBFX_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_sbfx_a1_a_field_cond_6_poweroftwo_50_67a00050() {
    // Encoding: 0x67A00050
    // Test aarch32_SBFX_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, widthm1=0, Rn=0, cond=6, lsb=0
    let encoding: u32 = 0x67A00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SBFX_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_sbfx_a1_a_field_cond_7_poweroftwo_50_77a00050() {
    // Encoding: 0x77A00050
    // Test aarch32_SBFX_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, lsb=0, Rn=0, widthm1=0, cond=7
    let encoding: u32 = 0x77A00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SBFX_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_sbfx_a1_a_field_cond_8_poweroftwo_50_87a00050() {
    // Encoding: 0x87A00050
    // Test aarch32_SBFX_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: lsb=0, Rn=0, cond=8, widthm1=0, Rd=0
    let encoding: u32 = 0x87A00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SBFX_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_sbfx_a1_a_field_cond_9_poweroftwo_50_97a00050() {
    // Encoding: 0x97A00050
    // Test aarch32_SBFX_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: lsb=0, cond=9, Rd=0, widthm1=0, Rn=0
    let encoding: u32 = 0x97A00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SBFX_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_sbfx_a1_a_field_cond_10_poweroftwo_50_a7a00050() {
    // Encoding: 0xA7A00050
    // Test aarch32_SBFX_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=10, widthm1=0, Rn=0, Rd=0, lsb=0
    let encoding: u32 = 0xA7A00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SBFX_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_sbfx_a1_a_field_cond_11_poweroftwo_50_b7a00050() {
    // Encoding: 0xB7A00050
    // Test aarch32_SBFX_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=11, widthm1=0, Rn=0, Rd=0, lsb=0
    let encoding: u32 = 0xB7A00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SBFX_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_sbfx_a1_a_field_cond_12_poweroftwo_50_c7a00050() {
    // Encoding: 0xC7A00050
    // Test aarch32_SBFX_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: widthm1=0, Rn=0, Rd=0, cond=12, lsb=0
    let encoding: u32 = 0xC7A00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SBFX_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_sbfx_a1_a_field_cond_13_poweroftwo_50_d7a00050() {
    // Encoding: 0xD7A00050
    // Test aarch32_SBFX_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=13, Rd=0, widthm1=0, Rn=0, lsb=0
    let encoding: u32 = 0xD7A00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SBFX_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_sbfx_a1_a_field_cond_14_poweroftwo_50_e7a00050() {
    // Encoding: 0xE7A00050
    // Test aarch32_SBFX_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: lsb=0, cond=14, Rd=0, widthm1=0, Rn=0
    let encoding: u32 = 0xE7A00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SBFX_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_sbfx_a1_a_field_cond_15_max_50_f7a00050() {
    // Encoding: 0xF7A00050
    // Test aarch32_SBFX_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: Rn=0, lsb=0, cond=15, widthm1=0, Rd=0
    let encoding: u32 = 0xF7A00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SBFX_A1_A
/// ASL: `field widthm1 16 +: 5`
/// Requirement: FieldBoundary { field: "widthm1", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_sbfx_a1_a_field_widthm1_0_min_50_07a00050() {
    // Encoding: 0x07A00050
    // Test aarch32_SBFX_A1_A field widthm1 = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, cond=0, widthm1=0, Rd=0, lsb=0
    let encoding: u32 = 0x07A00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SBFX_A1_A
/// ASL: `field widthm1 16 +: 5`
/// Requirement: FieldBoundary { field: "widthm1", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_sbfx_a1_a_field_widthm1_1_poweroftwo_50_07a10050() {
    // Encoding: 0x07A10050
    // Test aarch32_SBFX_A1_A field widthm1 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: lsb=0, widthm1=1, Rn=0, Rd=0, cond=0
    let encoding: u32 = 0x07A10050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SBFX_A1_A
/// ASL: `field widthm1 16 +: 5`
/// Requirement: FieldBoundary { field: "widthm1", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_aarch32_sbfx_a1_a_field_widthm1_15_poweroftwominusone_50_07af0050() {
    // Encoding: 0x07AF0050
    // Test aarch32_SBFX_A1_A field widthm1 = 15 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: widthm1=15, Rn=0, Rd=0, cond=0, lsb=0
    let encoding: u32 = 0x07AF0050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SBFX_A1_A
/// ASL: `field widthm1 16 +: 5`
/// Requirement: FieldBoundary { field: "widthm1", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_aarch32_sbfx_a1_a_field_widthm1_31_max_50_07bf0050() {
    // Encoding: 0x07BF0050
    // Test aarch32_SBFX_A1_A field widthm1 = 31 (Max)
    // ISET: A32
    // Fields: cond=0, widthm1=31, Rn=0, lsb=0, Rd=0
    let encoding: u32 = 0x07BF0050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SBFX_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_sbfx_a1_a_field_rd_0_min_50_07a00050() {
    // Encoding: 0x07A00050
    // Test aarch32_SBFX_A1_A field Rd = 0 (Min)
    // ISET: A32
    // Fields: widthm1=0, cond=0, Rn=0, Rd=0, lsb=0
    let encoding: u32 = 0x07A00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SBFX_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_sbfx_a1_a_field_rd_1_poweroftwo_50_07a01050() {
    // Encoding: 0x07A01050
    // Test aarch32_SBFX_A1_A field Rd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: lsb=0, widthm1=0, Rd=1, cond=0, Rn=0
    let encoding: u32 = 0x07A01050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SBFX_A1_A
/// ASL: `field lsb 7 +: 5`
/// Requirement: FieldBoundary { field: "lsb", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_sbfx_a1_a_field_lsb_0_min_50_07a00050() {
    // Encoding: 0x07A00050
    // Test aarch32_SBFX_A1_A field lsb = 0 (Min)
    // ISET: A32
    // Fields: widthm1=0, Rn=0, Rd=0, cond=0, lsb=0
    let encoding: u32 = 0x07A00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SBFX_A1_A
/// ASL: `field lsb 7 +: 5`
/// Requirement: FieldBoundary { field: "lsb", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_sbfx_a1_a_field_lsb_1_poweroftwo_50_07a000d0() {
    // Encoding: 0x07A000D0
    // Test aarch32_SBFX_A1_A field lsb = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: widthm1=0, cond=0, Rd=0, lsb=1, Rn=0
    let encoding: u32 = 0x07A000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SBFX_A1_A
/// ASL: `field lsb 7 +: 5`
/// Requirement: FieldBoundary { field: "lsb", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_aarch32_sbfx_a1_a_field_lsb_15_poweroftwominusone_50_07a007d0() {
    // Encoding: 0x07A007D0
    // Test aarch32_SBFX_A1_A field lsb = 15 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rd=0, cond=0, widthm1=0, lsb=15, Rn=0
    let encoding: u32 = 0x07A007D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SBFX_A1_A
/// ASL: `field lsb 7 +: 5`
/// Requirement: FieldBoundary { field: "lsb", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_aarch32_sbfx_a1_a_field_lsb_31_max_50_07a00fd0() {
    // Encoding: 0x07A00FD0
    // Test aarch32_SBFX_A1_A field lsb = 31 (Max)
    // ISET: A32
    // Fields: widthm1=0, Rd=0, Rn=0, cond=0, lsb=31
    let encoding: u32 = 0x07A00FD0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SBFX_A1_A
/// ASL: `field Rn 0 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_sbfx_a1_a_field_rn_0_min_50_07a00050() {
    // Encoding: 0x07A00050
    // Test aarch32_SBFX_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: widthm1=0, lsb=0, Rn=0, Rd=0, cond=0
    let encoding: u32 = 0x07A00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SBFX_A1_A
/// ASL: `field Rn 0 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_sbfx_a1_a_field_rn_1_poweroftwo_50_07a00051() {
    // Encoding: 0x07A00051
    // Test aarch32_SBFX_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, widthm1=0, Rd=0, lsb=0, Rn=1
    let encoding: u32 = 0x07A00051;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SBFX_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_sbfx_a1_a_combo_0_50_07a00050() {
    // Encoding: 0x07A00050
    // Test aarch32_SBFX_A1_A field combination: cond=0, widthm1=0, Rd=0, lsb=0, Rn=0
    // ISET: A32
    // Fields: Rd=0, Rn=0, widthm1=0, lsb=0, cond=0
    let encoding: u32 = 0x07A00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SBFX_A1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=1 (condition NE (not equal))
#[test]
fn test_aarch32_sbfx_a1_a_combo_1_50_17a00050() {
    // Encoding: 0x17A00050
    // Test aarch32_SBFX_A1_A field combination: cond=1, widthm1=0, Rd=0, lsb=0, Rn=0
    // ISET: A32
    // Fields: cond=1, widthm1=0, Rd=0, lsb=0, Rn=0
    let encoding: u32 = 0x17A00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SBFX_A1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=2 (condition CS/HS (carry set))
#[test]
fn test_aarch32_sbfx_a1_a_combo_2_50_27a00050() {
    // Encoding: 0x27A00050
    // Test aarch32_SBFX_A1_A field combination: cond=2, widthm1=0, Rd=0, lsb=0, Rn=0
    // ISET: A32
    // Fields: widthm1=0, cond=2, Rd=0, lsb=0, Rn=0
    let encoding: u32 = 0x27A00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SBFX_A1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=3 (condition CC/LO (carry clear))
#[test]
fn test_aarch32_sbfx_a1_a_combo_3_50_37a00050() {
    // Encoding: 0x37A00050
    // Test aarch32_SBFX_A1_A field combination: cond=3, widthm1=0, Rd=0, lsb=0, Rn=0
    // ISET: A32
    // Fields: widthm1=0, Rd=0, lsb=0, cond=3, Rn=0
    let encoding: u32 = 0x37A00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SBFX_A1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=4 (condition MI (minus/negative))
#[test]
fn test_aarch32_sbfx_a1_a_combo_4_50_47a00050() {
    // Encoding: 0x47A00050
    // Test aarch32_SBFX_A1_A field combination: cond=4, widthm1=0, Rd=0, lsb=0, Rn=0
    // ISET: A32
    // Fields: Rd=0, cond=4, widthm1=0, lsb=0, Rn=0
    let encoding: u32 = 0x47A00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SBFX_A1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=5 (condition PL (plus/positive))
#[test]
fn test_aarch32_sbfx_a1_a_combo_5_50_57a00050() {
    // Encoding: 0x57A00050
    // Test aarch32_SBFX_A1_A field combination: cond=5, widthm1=0, Rd=0, lsb=0, Rn=0
    // ISET: A32
    // Fields: lsb=0, cond=5, widthm1=0, Rd=0, Rn=0
    let encoding: u32 = 0x57A00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SBFX_A1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=6 (condition VS (overflow set))
#[test]
fn test_aarch32_sbfx_a1_a_combo_6_50_67a00050() {
    // Encoding: 0x67A00050
    // Test aarch32_SBFX_A1_A field combination: cond=6, widthm1=0, Rd=0, lsb=0, Rn=0
    // ISET: A32
    // Fields: Rn=0, lsb=0, widthm1=0, cond=6, Rd=0
    let encoding: u32 = 0x67A00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SBFX_A1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=7 (condition VC (overflow clear))
#[test]
fn test_aarch32_sbfx_a1_a_combo_7_50_77a00050() {
    // Encoding: 0x77A00050
    // Test aarch32_SBFX_A1_A field combination: cond=7, widthm1=0, Rd=0, lsb=0, Rn=0
    // ISET: A32
    // Fields: widthm1=0, Rd=0, cond=7, lsb=0, Rn=0
    let encoding: u32 = 0x77A00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SBFX_A1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=8 (condition HI (unsigned higher))
#[test]
fn test_aarch32_sbfx_a1_a_combo_8_50_87a00050() {
    // Encoding: 0x87A00050
    // Test aarch32_SBFX_A1_A field combination: cond=8, widthm1=0, Rd=0, lsb=0, Rn=0
    // ISET: A32
    // Fields: widthm1=0, Rn=0, cond=8, Rd=0, lsb=0
    let encoding: u32 = 0x87A00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SBFX_A1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=9 (condition LS (unsigned lower or same))
#[test]
fn test_aarch32_sbfx_a1_a_combo_9_50_97a00050() {
    // Encoding: 0x97A00050
    // Test aarch32_SBFX_A1_A field combination: cond=9, widthm1=0, Rd=0, lsb=0, Rn=0
    // ISET: A32
    // Fields: Rd=0, lsb=0, Rn=0, cond=9, widthm1=0
    let encoding: u32 = 0x97A00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SBFX_A1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=10 (condition GE (signed >=))
#[test]
fn test_aarch32_sbfx_a1_a_combo_10_50_a7a00050() {
    // Encoding: 0xA7A00050
    // Test aarch32_SBFX_A1_A field combination: cond=10, widthm1=0, Rd=0, lsb=0, Rn=0
    // ISET: A32
    // Fields: cond=10, widthm1=0, lsb=0, Rd=0, Rn=0
    let encoding: u32 = 0xA7A00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SBFX_A1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=11 (condition LT (signed <))
#[test]
fn test_aarch32_sbfx_a1_a_combo_11_50_b7a00050() {
    // Encoding: 0xB7A00050
    // Test aarch32_SBFX_A1_A field combination: cond=11, widthm1=0, Rd=0, lsb=0, Rn=0
    // ISET: A32
    // Fields: cond=11, Rd=0, widthm1=0, lsb=0, Rn=0
    let encoding: u32 = 0xB7A00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SBFX_A1_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=12 (condition GT (signed >))
#[test]
fn test_aarch32_sbfx_a1_a_combo_12_50_c7a00050() {
    // Encoding: 0xC7A00050
    // Test aarch32_SBFX_A1_A field combination: cond=12, widthm1=0, Rd=0, lsb=0, Rn=0
    // ISET: A32
    // Fields: cond=12, Rd=0, widthm1=0, lsb=0, Rn=0
    let encoding: u32 = 0xC7A00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SBFX_A1_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=13 (condition LE (signed <=))
#[test]
fn test_aarch32_sbfx_a1_a_combo_13_50_d7a00050() {
    // Encoding: 0xD7A00050
    // Test aarch32_SBFX_A1_A field combination: cond=13, widthm1=0, Rd=0, lsb=0, Rn=0
    // ISET: A32
    // Fields: widthm1=0, cond=13, Rd=0, lsb=0, Rn=0
    let encoding: u32 = 0xD7A00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SBFX_A1_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=14 (condition AL (always))
#[test]
fn test_aarch32_sbfx_a1_a_combo_14_50_e7a00050() {
    // Encoding: 0xE7A00050
    // Test aarch32_SBFX_A1_A field combination: cond=14, widthm1=0, Rd=0, lsb=0, Rn=0
    // ISET: A32
    // Fields: widthm1=0, Rd=0, lsb=0, cond=14, Rn=0
    let encoding: u32 = 0xE7A00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SBFX_A1_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=15 (condition NV (never, reserved))
#[test]
fn test_aarch32_sbfx_a1_a_combo_15_50_f7a00050() {
    // Encoding: 0xF7A00050
    // Test aarch32_SBFX_A1_A field combination: cond=15, widthm1=0, Rd=0, lsb=0, Rn=0
    // ISET: A32
    // Fields: cond=15, widthm1=0, lsb=0, Rn=0, Rd=0
    let encoding: u32 = 0xF7A00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SBFX_A1_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// widthm1=0 (minimum value)
#[test]
fn test_aarch32_sbfx_a1_a_combo_16_50_07a00050() {
    // Encoding: 0x07A00050
    // Test aarch32_SBFX_A1_A field combination: cond=0, widthm1=0, Rd=0, lsb=0, Rn=0
    // ISET: A32
    // Fields: Rd=0, cond=0, Rn=0, widthm1=0, lsb=0
    let encoding: u32 = 0x07A00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SBFX_A1_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// widthm1=1 (value 1)
#[test]
fn test_aarch32_sbfx_a1_a_combo_17_50_07a10050() {
    // Encoding: 0x07A10050
    // Test aarch32_SBFX_A1_A field combination: cond=0, widthm1=1, Rd=0, lsb=0, Rn=0
    // ISET: A32
    // Fields: Rn=0, cond=0, widthm1=1, Rd=0, lsb=0
    let encoding: u32 = 0x07A10050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SBFX_A1_A
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// widthm1=15 (midpoint (15))
#[test]
fn test_aarch32_sbfx_a1_a_combo_18_50_07af0050() {
    // Encoding: 0x07AF0050
    // Test aarch32_SBFX_A1_A field combination: cond=0, widthm1=15, Rd=0, lsb=0, Rn=0
    // ISET: A32
    // Fields: cond=0, Rd=0, lsb=0, widthm1=15, Rn=0
    let encoding: u32 = 0x07AF0050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SBFX_A1_A
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// widthm1=31 (maximum value (31))
#[test]
fn test_aarch32_sbfx_a1_a_combo_19_50_07bf0050() {
    // Encoding: 0x07BF0050
    // Test aarch32_SBFX_A1_A field combination: cond=0, widthm1=31, Rd=0, lsb=0, Rn=0
    // ISET: A32
    // Fields: cond=0, widthm1=31, lsb=0, Rn=0, Rd=0
    let encoding: u32 = 0x07BF0050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SBFX_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_sbfx_a1_a_special_cond_0_condition_eq_80_07a00050() {
    // Encoding: 0x07A00050
    // Test aarch32_SBFX_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: widthm1=0, cond=0, Rd=0, lsb=0, Rn=0
    let encoding: u32 = 0x07A00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SBFX_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_sbfx_a1_a_special_cond_1_condition_ne_80_17a00050() {
    // Encoding: 0x17A00050
    // Test aarch32_SBFX_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: widthm1=0, Rd=0, lsb=0, cond=1, Rn=0
    let encoding: u32 = 0x17A00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SBFX_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_sbfx_a1_a_special_cond_2_condition_cs_hs_80_27a00050() {
    // Encoding: 0x27A00050
    // Test aarch32_SBFX_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: Rd=0, Rn=0, lsb=0, widthm1=0, cond=2
    let encoding: u32 = 0x27A00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SBFX_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_sbfx_a1_a_special_cond_3_condition_cc_lo_80_37a00050() {
    // Encoding: 0x37A00050
    // Test aarch32_SBFX_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: cond=3, widthm1=0, lsb=0, Rn=0, Rd=0
    let encoding: u32 = 0x37A00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SBFX_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_sbfx_a1_a_special_cond_4_condition_mi_80_47a00050() {
    // Encoding: 0x47A00050
    // Test aarch32_SBFX_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: lsb=0, Rn=0, widthm1=0, Rd=0, cond=4
    let encoding: u32 = 0x47A00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SBFX_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_sbfx_a1_a_special_cond_5_condition_pl_80_57a00050() {
    // Encoding: 0x57A00050
    // Test aarch32_SBFX_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: Rn=0, widthm1=0, cond=5, lsb=0, Rd=0
    let encoding: u32 = 0x57A00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SBFX_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_sbfx_a1_a_special_cond_6_condition_vs_80_67a00050() {
    // Encoding: 0x67A00050
    // Test aarch32_SBFX_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: cond=6, widthm1=0, Rd=0, Rn=0, lsb=0
    let encoding: u32 = 0x67A00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SBFX_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_sbfx_a1_a_special_cond_7_condition_vc_80_77a00050() {
    // Encoding: 0x77A00050
    // Test aarch32_SBFX_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: widthm1=0, lsb=0, Rn=0, Rd=0, cond=7
    let encoding: u32 = 0x77A00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SBFX_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_sbfx_a1_a_special_cond_8_condition_hi_80_87a00050() {
    // Encoding: 0x87A00050
    // Test aarch32_SBFX_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: cond=8, Rn=0, lsb=0, widthm1=0, Rd=0
    let encoding: u32 = 0x87A00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SBFX_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_sbfx_a1_a_special_cond_9_condition_ls_80_97a00050() {
    // Encoding: 0x97A00050
    // Test aarch32_SBFX_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: widthm1=0, Rd=0, lsb=0, Rn=0, cond=9
    let encoding: u32 = 0x97A00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SBFX_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_sbfx_a1_a_special_cond_10_condition_ge_80_a7a00050() {
    // Encoding: 0xA7A00050
    // Test aarch32_SBFX_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: Rd=0, Rn=0, widthm1=0, cond=10, lsb=0
    let encoding: u32 = 0xA7A00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SBFX_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_sbfx_a1_a_special_cond_11_condition_lt_80_b7a00050() {
    // Encoding: 0xB7A00050
    // Test aarch32_SBFX_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: cond=11, widthm1=0, lsb=0, Rd=0, Rn=0
    let encoding: u32 = 0xB7A00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SBFX_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_sbfx_a1_a_special_cond_12_condition_gt_80_c7a00050() {
    // Encoding: 0xC7A00050
    // Test aarch32_SBFX_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: Rn=0, cond=12, widthm1=0, Rd=0, lsb=0
    let encoding: u32 = 0xC7A00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SBFX_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_sbfx_a1_a_special_cond_13_condition_le_80_d7a00050() {
    // Encoding: 0xD7A00050
    // Test aarch32_SBFX_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: Rn=0, Rd=0, lsb=0, cond=13, widthm1=0
    let encoding: u32 = 0xD7A00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SBFX_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_sbfx_a1_a_special_cond_14_condition_al_80_e7a00050() {
    // Encoding: 0xE7A00050
    // Test aarch32_SBFX_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: widthm1=0, Rd=0, lsb=0, cond=14, Rn=0
    let encoding: u32 = 0xE7A00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SBFX_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_sbfx_a1_a_special_cond_15_condition_nv_80_f7a00050() {
    // Encoding: 0xF7A00050
    // Test aarch32_SBFX_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: cond=15, Rd=0, lsb=0, widthm1=0, Rn=0
    let encoding: u32 = 0xF7A00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_SBFX_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_sbfx_a1_a_invalid_0_50_07a00050() {
    // Encoding: 0x07A00050
    // Test aarch32_SBFX_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }
    // ISET: A32
    // Fields: lsb=0, Rd=0, widthm1=0, Rn=0, cond=0
    let encoding: u32 = 0x07A00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_SBFX_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_sbfx_a1_a_invalid_1_50_07a00050() {
    // Encoding: 0x07A00050
    // Test aarch32_SBFX_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Rn=0, Rd=0, cond=0, lsb=0, widthm1=0
    let encoding: u32 = 0x07A00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_SBFX_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_sbfx_t1_a_field_rn_0_min_0_f3400000() {
    // Thumb encoding (32): 0xF3400000
    // Test aarch32_SBFX_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, imm2=0, Rd=0, widthm1=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_SBFX_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_sbfx_t1_a_field_rn_1_poweroftwo_0_f3410000() {
    // Thumb encoding (32): 0xF3410000
    // Test aarch32_SBFX_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm2=0, Rn=1, Rd=0, widthm1=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3410000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_SBFX_T1_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_sbfx_t1_a_field_imm3_0_zero_0_f3400000() {
    // Thumb encoding (32): 0xF3400000
    // Test aarch32_SBFX_T1_A field imm3 = 0 (Zero)
    // ISET: T32
    // Fields: imm3=0, Rn=0, imm2=0, Rd=0, widthm1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_SBFX_T1_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_sbfx_t1_a_field_imm3_1_poweroftwo_0_f3401000() {
    // Thumb encoding (32): 0xF3401000
    // Test aarch32_SBFX_T1_A field imm3 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm2=0, imm3=1, widthm1=0, Rn=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3401000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_SBFX_T1_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 3, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (3)
#[test]
fn test_aarch32_sbfx_t1_a_field_imm3_3_poweroftwominusone_0_f3403000() {
    // Thumb encoding (32): 0xF3403000
    // Test aarch32_SBFX_T1_A field imm3 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, imm2=0, widthm1=0, imm3=3, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3403000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_SBFX_T1_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 7, boundary: Max }
/// maximum immediate (7)
#[test]
fn test_aarch32_sbfx_t1_a_field_imm3_7_max_0_f3407000() {
    // Thumb encoding (32): 0xF3407000
    // Test aarch32_SBFX_T1_A field imm3 = 7 (Max)
    // ISET: T32
    // Fields: widthm1=0, Rd=0, imm3=7, Rn=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3407000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_SBFX_T1_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_sbfx_t1_a_field_rd_0_min_0_f3400000() {
    // Thumb encoding (32): 0xF3400000
    // Test aarch32_SBFX_T1_A field Rd = 0 (Min)
    // ISET: T32
    // Fields: Rd=0, imm2=0, imm3=0, Rn=0, widthm1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_SBFX_T1_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_sbfx_t1_a_field_rd_1_poweroftwo_0_f3400100() {
    // Thumb encoding (32): 0xF3400100
    // Test aarch32_SBFX_T1_A field Rd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rd=1, imm2=0, imm3=0, widthm1=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3400100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_SBFX_T1_A
/// ASL: `field imm2 6 +: 2`
/// Requirement: FieldBoundary { field: "imm2", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_sbfx_t1_a_field_imm2_0_zero_0_f3400000() {
    // Thumb encoding (32): 0xF3400000
    // Test aarch32_SBFX_T1_A field imm2 = 0 (Zero)
    // ISET: T32
    // Fields: Rn=0, imm3=0, Rd=0, imm2=0, widthm1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_SBFX_T1_A
/// ASL: `field imm2 6 +: 2`
/// Requirement: FieldBoundary { field: "imm2", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_sbfx_t1_a_field_imm2_1_poweroftwo_0_f3400040() {
    // Thumb encoding (32): 0xF3400040
    // Test aarch32_SBFX_T1_A field imm2 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, imm2=1, widthm1=0, imm3=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3400040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_SBFX_T1_A
/// ASL: `field imm2 6 +: 2`
/// Requirement: FieldBoundary { field: "imm2", value: 3, boundary: Max }
/// maximum immediate (3)
#[test]
fn test_aarch32_sbfx_t1_a_field_imm2_3_max_0_f34000c0() {
    // Thumb encoding (32): 0xF34000C0
    // Test aarch32_SBFX_T1_A field imm2 = 3 (Max)
    // ISET: T32
    // Fields: widthm1=0, imm3=0, Rd=0, imm2=3, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF34000C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_SBFX_T1_A
/// ASL: `field widthm1 0 +: 5`
/// Requirement: FieldBoundary { field: "widthm1", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_sbfx_t1_a_field_widthm1_0_min_0_f3400000() {
    // Thumb encoding (32): 0xF3400000
    // Test aarch32_SBFX_T1_A field widthm1 = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, imm2=0, Rd=0, imm3=0, widthm1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_SBFX_T1_A
/// ASL: `field widthm1 0 +: 5`
/// Requirement: FieldBoundary { field: "widthm1", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_sbfx_t1_a_field_widthm1_1_poweroftwo_0_f3400001() {
    // Thumb encoding (32): 0xF3400001
    // Test aarch32_SBFX_T1_A field widthm1 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, imm3=0, widthm1=1, imm2=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3400001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_SBFX_T1_A
/// ASL: `field widthm1 0 +: 5`
/// Requirement: FieldBoundary { field: "widthm1", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_aarch32_sbfx_t1_a_field_widthm1_15_poweroftwominusone_0_f340000f() {
    // Thumb encoding (32): 0xF340000F
    // Test aarch32_SBFX_T1_A field widthm1 = 15 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, imm3=0, Rd=0, imm2=0, widthm1=15
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF340000F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_SBFX_T1_A
/// ASL: `field widthm1 0 +: 5`
/// Requirement: FieldBoundary { field: "widthm1", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_aarch32_sbfx_t1_a_field_widthm1_31_max_0_f340001f() {
    // Thumb encoding (32): 0xF340001F
    // Test aarch32_SBFX_T1_A field widthm1 = 31 (Max)
    // ISET: T32
    // Fields: widthm1=31, imm3=0, Rn=0, Rd=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF340001F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_SBFX_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_sbfx_t1_a_combo_0_0_f3400000() {
    // Thumb encoding (32): 0xF3400000
    // Test aarch32_SBFX_T1_A field combination: Rn=0, imm3=0, Rd=0, imm2=0, widthm1=0
    // ISET: T32
    // Fields: imm3=0, widthm1=0, Rd=0, Rn=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_SBFX_T1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_sbfx_t1_a_combo_1_0_f3410000() {
    // Thumb encoding (32): 0xF3410000
    // Test aarch32_SBFX_T1_A field combination: Rn=1, imm3=0, Rd=0, imm2=0, widthm1=0
    // ISET: T32
    // Fields: imm2=0, widthm1=0, Rd=0, imm3=0, Rn=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3410000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_SBFX_T1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm3=0 (immediate value 0)
#[test]
fn test_aarch32_sbfx_t1_a_combo_2_0_f3400000() {
    // Thumb encoding (32): 0xF3400000
    // Test aarch32_SBFX_T1_A field combination: Rn=0, imm3=0, Rd=0, imm2=0, widthm1=0
    // ISET: T32
    // Fields: imm2=0, widthm1=0, Rn=0, imm3=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_SBFX_T1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm3=1 (immediate value 1)
#[test]
fn test_aarch32_sbfx_t1_a_combo_3_0_f3401000() {
    // Thumb encoding (32): 0xF3401000
    // Test aarch32_SBFX_T1_A field combination: Rn=0, imm3=1, Rd=0, imm2=0, widthm1=0
    // ISET: T32
    // Fields: Rd=0, Rn=0, widthm1=0, imm3=1, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3401000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_SBFX_T1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm3=3 (immediate midpoint (3))
#[test]
fn test_aarch32_sbfx_t1_a_combo_4_0_f3403000() {
    // Thumb encoding (32): 0xF3403000
    // Test aarch32_SBFX_T1_A field combination: Rn=0, imm3=3, Rd=0, imm2=0, widthm1=0
    // ISET: T32
    // Fields: Rd=0, Rn=0, imm2=0, widthm1=0, imm3=3
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3403000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_SBFX_T1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm3=7 (maximum immediate (7))
#[test]
fn test_aarch32_sbfx_t1_a_combo_5_0_f3407000() {
    // Thumb encoding (32): 0xF3407000
    // Test aarch32_SBFX_T1_A field combination: Rn=0, imm3=7, Rd=0, imm2=0, widthm1=0
    // ISET: T32
    // Fields: Rd=0, Rn=0, imm2=0, widthm1=0, imm3=7
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3407000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_SBFX_T1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch32_sbfx_t1_a_combo_6_0_f3400000() {
    // Thumb encoding (32): 0xF3400000
    // Test aarch32_SBFX_T1_A field combination: Rn=0, imm3=0, Rd=0, imm2=0, widthm1=0
    // ISET: T32
    // Fields: imm2=0, Rn=0, widthm1=0, Rd=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_SBFX_T1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch32_sbfx_t1_a_combo_7_0_f3400100() {
    // Thumb encoding (32): 0xF3400100
    // Test aarch32_SBFX_T1_A field combination: Rn=0, imm3=0, Rd=1, imm2=0, widthm1=0
    // ISET: T32
    // Fields: imm2=0, widthm1=0, imm3=0, Rd=1, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3400100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_SBFX_T1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm2=0 (immediate value 0)
#[test]
fn test_aarch32_sbfx_t1_a_combo_8_0_f3400000() {
    // Thumb encoding (32): 0xF3400000
    // Test aarch32_SBFX_T1_A field combination: Rn=0, imm3=0, Rd=0, imm2=0, widthm1=0
    // ISET: T32
    // Fields: widthm1=0, Rn=0, imm3=0, Rd=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_SBFX_T1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm2=1 (immediate value 1)
#[test]
fn test_aarch32_sbfx_t1_a_combo_9_0_f3400040() {
    // Thumb encoding (32): 0xF3400040
    // Test aarch32_SBFX_T1_A field combination: Rn=0, imm3=0, Rd=0, imm2=1, widthm1=0
    // ISET: T32
    // Fields: widthm1=0, Rd=0, Rn=0, imm2=1, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3400040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_SBFX_T1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm2=3 (maximum immediate (3))
#[test]
fn test_aarch32_sbfx_t1_a_combo_10_0_f34000c0() {
    // Thumb encoding (32): 0xF34000C0
    // Test aarch32_SBFX_T1_A field combination: Rn=0, imm3=0, Rd=0, imm2=3, widthm1=0
    // ISET: T32
    // Fields: imm3=0, Rd=0, imm2=3, widthm1=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF34000C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_SBFX_T1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// widthm1=0 (minimum value)
#[test]
fn test_aarch32_sbfx_t1_a_combo_11_0_f3400000() {
    // Thumb encoding (32): 0xF3400000
    // Test aarch32_SBFX_T1_A field combination: Rn=0, imm3=0, Rd=0, imm2=0, widthm1=0
    // ISET: T32
    // Fields: imm3=0, Rn=0, Rd=0, imm2=0, widthm1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_SBFX_T1_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// widthm1=1 (value 1)
#[test]
fn test_aarch32_sbfx_t1_a_combo_12_0_f3400001() {
    // Thumb encoding (32): 0xF3400001
    // Test aarch32_SBFX_T1_A field combination: Rn=0, imm3=0, Rd=0, imm2=0, widthm1=1
    // ISET: T32
    // Fields: imm2=0, Rn=0, Rd=0, imm3=0, widthm1=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3400001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_SBFX_T1_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// widthm1=15 (midpoint (15))
#[test]
fn test_aarch32_sbfx_t1_a_combo_13_0_f340000f() {
    // Thumb encoding (32): 0xF340000F
    // Test aarch32_SBFX_T1_A field combination: Rn=0, imm3=0, Rd=0, imm2=0, widthm1=15
    // ISET: T32
    // Fields: widthm1=15, Rn=0, Rd=0, imm2=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF340000F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_SBFX_T1_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// widthm1=31 (maximum value (31))
#[test]
fn test_aarch32_sbfx_t1_a_combo_14_0_f340001f() {
    // Thumb encoding (32): 0xF340001F
    // Test aarch32_SBFX_T1_A field combination: Rn=0, imm3=0, Rd=0, imm2=0, widthm1=31
    // ISET: T32
    // Fields: imm2=0, imm3=0, Rd=0, Rn=0, widthm1=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF340001F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_SBFX_T1_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch32_sbfx_t1_a_combo_15_0_f3410100() {
    // Thumb encoding (32): 0xF3410100
    // Test aarch32_SBFX_T1_A field combination: Rn=1, imm3=0, Rd=1, imm2=0, widthm1=0
    // ISET: T32
    // Fields: imm3=0, imm2=0, Rd=1, Rn=1, widthm1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3410100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_SBFX_T1_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch32_sbfx_t1_a_combo_16_0_f34f0f00() {
    // Thumb encoding (32): 0xF34F0F00
    // Test aarch32_SBFX_T1_A field combination: Rn=31, imm3=0, Rd=31, imm2=0, widthm1=0
    // ISET: T32
    // Fields: Rn=31, Rd=31, widthm1=0, imm2=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF34F0F00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_SBFX_T1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_sbfx_t1_a_invalid_0_0_f3400000() {
    // Thumb encoding (32): 0xF3400000
    // Test aarch32_SBFX_T1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }
    // ISET: T32
    // Fields: Rd=0, widthm1=0, imm3=0, imm2=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3400000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_SBFX_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_sbfx_t1_a_invalid_1_0_f3400000() {
    // Thumb encoding (32): 0xF3400000
    // Test aarch32_SBFX_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rn=0, Rd=0, widthm1=0, imm2=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3400000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_SBFX_A1_A
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Unpredictable
#[test]
fn test_aarch32_sbfx_a1_a_exception_0_07a00050() {
    // Test aarch32_SBFX_A1_A exception: Unpredictable
    // Encoding: 0x07A00050
    // ISET: A32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x07A00050;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch32_SBFX_T1_A
/// ASL: `ADD X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple addition/subtraction (32)
#[test]
fn test_aarch32_sbfx_t1_a_add_oracle_32_0_f3402820() {
    // Test ADD 32-bit: simple addition/subtraction (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF3402820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFF6064, "X0 should be 0xFFFFFFFFFFFF6064");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBFX_T1_A
/// ASL: `ADD X0, X1, #10`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple addition/subtraction (64)
#[test]
fn test_aarch32_sbfx_t1_a_add_oracle_64_0_f3402820() {
    // Test ADD 64-bit: simple addition/subtraction (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF3402820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFF6064, "X0 should be 0xFFFFFFFFFFFF6064");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBFX_T1_A
/// ASL: `ADD X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero operands (32)
#[test]
fn test_aarch32_sbfx_t1_a_add_oracle_32_1_f3400020() {
    // Test ADD 32-bit: zero operands (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF3400020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBFX_T1_A
/// ASL: `ADD X0, X1, #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero operands (64)
#[test]
fn test_aarch32_sbfx_t1_a_add_oracle_64_1_f3400020() {
    // Test ADD 64-bit: zero operands (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF3400020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z flag should be true");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBFX_T1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small values (32)
#[test]
fn test_aarch32_sbfx_t1_a_add_oracle_32_2_f3400420() {
    // Test ADD 32-bit: small values (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF3400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFF001, "X0 should be 0xFFFFFFFFFFFFF001");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBFX_T1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// small values (64)
#[test]
fn test_aarch32_sbfx_t1_a_add_oracle_64_2_f3400420() {
    // Test ADD 64-bit: small values (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF3400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFF001, "X0 should be 0xFFFFFFFFFFFFF001");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBFX_T1_A
/// ASL: `ADD X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 unshifted (32)
#[test]
fn test_aarch32_sbfx_t1_a_add_oracle_32_3_f37ffc20() {
    // Test ADD 32-bit: max imm12 unshifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF37FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF001000, "X0 should be 0xFFFFFFFFFF001000");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBFX_T1_A
/// ASL: `ADD X0, X1, #4095`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 unshifted (64)
#[test]
fn test_aarch32_sbfx_t1_a_add_oracle_64_3_f37ffc20() {
    // Test ADD 64-bit: max imm12 unshifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF37FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF001000, "X0 should be 0xFFFFFFFFFF001000");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBFX_T1_A
/// ASL: `ADD X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm12 shifted (32)
#[test]
fn test_aarch32_sbfx_t1_a_add_oracle_32_4_f37ffc20() {
    // Test ADD 32-bit: max imm12 shifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF37FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF001000, "X0 should be 0xFFFFFFFFFF001000");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBFX_T1_A
/// ASL: `ADD X0, X1, #4095, LSL #12`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max imm12 shifted (64)
#[test]
fn test_aarch32_sbfx_t1_a_add_oracle_64_4_f37ffc20() {
    // Test ADD 64-bit: max imm12 shifted (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF37FFC20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF001000, "X0 should be 0xFFFFFFFFFF001000");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBFX_T1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max u64 operand (32)
#[test]
fn test_aarch32_sbfx_t1_a_add_oracle_32_5_f3400420() {
    // Test ADD 32-bit: max u64 operand (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF3400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFEFFF, "X0 should be 0x00000000FFFFEFFF");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBFX_T1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max u64 operand (64)
#[test]
fn test_aarch32_sbfx_t1_a_add_oracle_64_5_f3400420() {
    // Test ADD 64-bit: max u64 operand (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF3400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFEFFF, "X0 should be 0xFFFFFFFFFFFFEFFF");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBFX_T1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero result (for sub 1-1) (32)
#[test]
fn test_aarch32_sbfx_t1_a_add_oracle_32_6_f3400420() {
    // Test ADD 32-bit: zero result (for sub 1-1) (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF3400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFF000, "X0 should be 0xFFFFFFFFFFFFF000");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBFX_T1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero result (for sub 1-1) (64)
#[test]
fn test_aarch32_sbfx_t1_a_add_oracle_64_6_f3400420() {
    // Test ADD 64-bit: zero result (for sub 1-1) (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF3400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFF000, "X0 should be 0xFFFFFFFFFFFFF000");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBFX_T1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 64-bit (32)
#[test]
fn test_aarch32_sbfx_t1_a_add_oracle_32_7_f3400420() {
    // Test ADD 32-bit: signed overflow boundary 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF3400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFEFFF, "X0 should be 0x00000000FFFFEFFF");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBFX_T1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 64-bit (64)
#[test]
fn test_aarch32_sbfx_t1_a_add_oracle_64_7_f3400420() {
    // Test ADD 64-bit: signed overflow boundary 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF3400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFEFFF, "X0 should be 0x7FFFFFFFFFFFEFFF");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBFX_T1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// signed overflow boundary 32-bit (32)
#[test]
fn test_aarch32_sbfx_t1_a_add_oracle_32_8_f3400420() {
    // Test ADD 32-bit: signed overflow boundary 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF3400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FFFEFFF, "X0 should be 0x000000007FFFEFFF");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBFX_T1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// signed overflow boundary 32-bit (64)
#[test]
fn test_aarch32_sbfx_t1_a_add_oracle_64_8_f3400420() {
    // Test ADD 64-bit: signed overflow boundary 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0xF3400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FFFEFFF, "X0 should be 0x000000007FFFEFFF");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBFX_T1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 64-bit (32)
#[test]
fn test_aarch32_sbfx_t1_a_add_oracle_32_9_f3400420() {
    // Test ADD 32-bit: unsigned overflow 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF3400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFEFFF, "X0 should be 0x00000000FFFFEFFF");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBFX_T1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 64-bit (64)
#[test]
fn test_aarch32_sbfx_t1_a_add_oracle_64_9_f3400420() {
    // Test ADD 64-bit: unsigned overflow 64-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF3400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFEFFF, "X0 should be 0xFFFFFFFFFFFFEFFF");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBFX_T1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// unsigned overflow 32-bit (32)
#[test]
fn test_aarch32_sbfx_t1_a_add_oracle_32_10_f3400420() {
    // Test ADD 32-bit: unsigned overflow 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF3400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFEFFF, "X0 should be 0x00000000FFFFEFFF");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBFX_T1_A
/// ASL: `ADD X0, X1, #1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// unsigned overflow 32-bit (64)
#[test]
fn test_aarch32_sbfx_t1_a_add_oracle_64_10_f3400420() {
    // Test ADD 64-bit: unsigned overflow 32-bit (with oracle verification)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF3400420;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFEFFF, "X0 should be 0x00000000FFFFEFFF");
    assert_eq!(cpu.get_pstate().n, false, "N flag should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, true, "C flag should be true");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBFX_T1_A
/// ASL: `ADD SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (32)
#[test]
fn test_aarch32_sbfx_t1_a_add_oracle_32_rd31_sp_f340283f() {
    // Test ADD 32-bit with Rd=31 (SP)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF340283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBFX_T1_A
/// ASL: `ADD SP, X1, #10`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "writes to stack pointer" }
/// SP destination (64)
#[test]
fn test_aarch32_sbfx_t1_a_add_oracle_64_rd31_sp_f340283f() {
    // Test ADD 64-bit with Rd=31 (SP)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF340283F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N flag should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z flag should be false");
    assert_eq!(cpu.get_pstate().c, false, "C flag should be false");
    assert_eq!(cpu.get_pstate().v, false, "V flag should be false");
}

/// Provenance: aarch32_SBFX_T1_A
/// ASL: `ADD.W R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple values
#[test]
fn test_aarch32_sbfx_t1_a_t32_oracle_0_f3410000() {
    // Test T32 ADD: simple values (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x32);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF3410000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x96, "R0 should be 0x00000096");
}

/// Provenance: aarch32_SBFX_T1_A
/// ASL: `ADD.W R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero values
#[test]
fn test_aarch32_sbfx_t1_a_t32_oracle_1_f3410000() {
    // Test T32 ADD: zero values (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xF3410000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_SBFX_T1_A
/// ASL: `ADD.W R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max value
#[test]
fn test_aarch32_sbfx_t1_a_t32_oracle_2_f3410000() {
    // Test T32 ADD: max value (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0xF3410000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_SBFX_T1_A
/// ASL: `ADD.W R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// mixed pattern
#[test]
fn test_aarch32_sbfx_t1_a_t32_oracle_3_f3410000() {
    // Test T32 ADD: mixed pattern (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xABCDEF01);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u32 = 0xF3410000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xBE024579, "R0 should be 0xBE024579");
}

/// Provenance: aarch32_SBFX_T1_A
/// ASL: `Unconditional`
/// Requirement: UndefinedEncoding { condition: "Unconditional" }
/// triggers Unpredictable
#[test]
fn test_aarch32_sbfx_t1_a_exception_0_f3400000() {
    // Test aarch32_SBFX_T1_A exception: Unpredictable
    // ISET: T32
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xF3400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// aarch32_REV_A Tests
// ============================================================================

/// Provenance: aarch32_REV_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_rev_a1_a_field_cond_0_min_30_06b00030() {
    // Encoding: 0x06B00030
    // Test aarch32_REV_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rd=0, Rm=0
    let encoding: u32 = 0x06B00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_rev_a1_a_field_cond_1_poweroftwo_30_16b00030() {
    // Encoding: 0x16B00030
    // Test aarch32_REV_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Rd=0, cond=1
    let encoding: u32 = 0x16B00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_rev_a1_a_field_cond_2_poweroftwo_30_26b00030() {
    // Encoding: 0x26B00030
    // Test aarch32_REV_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=2, Rm=0, Rd=0
    let encoding: u32 = 0x26B00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_rev_a1_a_field_cond_3_poweroftwo_30_36b00030() {
    // Encoding: 0x36B00030
    // Test aarch32_REV_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=3, Rd=0, Rm=0
    let encoding: u32 = 0x36B00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_rev_a1_a_field_cond_4_poweroftwo_30_46b00030() {
    // Encoding: 0x46B00030
    // Test aarch32_REV_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, cond=4, Rd=0
    let encoding: u32 = 0x46B00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_rev_a1_a_field_cond_5_poweroftwo_30_56b00030() {
    // Encoding: 0x56B00030
    // Test aarch32_REV_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=5, Rd=0, Rm=0
    let encoding: u32 = 0x56B00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_rev_a1_a_field_cond_6_poweroftwo_30_66b00030() {
    // Encoding: 0x66B00030
    // Test aarch32_REV_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=6, Rm=0, Rd=0
    let encoding: u32 = 0x66B00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_rev_a1_a_field_cond_7_poweroftwo_30_76b00030() {
    // Encoding: 0x76B00030
    // Test aarch32_REV_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=7, Rm=0, Rd=0
    let encoding: u32 = 0x76B00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_rev_a1_a_field_cond_8_poweroftwo_30_86b00030() {
    // Encoding: 0x86B00030
    // Test aarch32_REV_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=8, Rd=0, Rm=0
    let encoding: u32 = 0x86B00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_rev_a1_a_field_cond_9_poweroftwo_30_96b00030() {
    // Encoding: 0x96B00030
    // Test aarch32_REV_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=9, Rd=0, Rm=0
    let encoding: u32 = 0x96B00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_rev_a1_a_field_cond_10_poweroftwo_30_a6b00030() {
    // Encoding: 0xA6B00030
    // Test aarch32_REV_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rm=0, cond=10
    let encoding: u32 = 0xA6B00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_rev_a1_a_field_cond_11_poweroftwo_30_b6b00030() {
    // Encoding: 0xB6B00030
    // Test aarch32_REV_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, cond=11, Rd=0
    let encoding: u32 = 0xB6B00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_rev_a1_a_field_cond_12_poweroftwo_30_c6b00030() {
    // Encoding: 0xC6B00030
    // Test aarch32_REV_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rm=0, cond=12
    let encoding: u32 = 0xC6B00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_rev_a1_a_field_cond_13_poweroftwo_30_d6b00030() {
    // Encoding: 0xD6B00030
    // Test aarch32_REV_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=13, Rm=0, Rd=0
    let encoding: u32 = 0xD6B00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_rev_a1_a_field_cond_14_poweroftwo_30_e6b00030() {
    // Encoding: 0xE6B00030
    // Test aarch32_REV_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=14, Rm=0, Rd=0
    let encoding: u32 = 0xE6B00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_rev_a1_a_field_cond_15_max_30_f6b00030() {
    // Encoding: 0xF6B00030
    // Test aarch32_REV_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: Rd=0, cond=15, Rm=0
    let encoding: u32 = 0xF6B00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_rev_a1_a_field_rd_0_min_30_06b00030() {
    // Encoding: 0x06B00030
    // Test aarch32_REV_A1_A field Rd = 0 (Min)
    // ISET: A32
    // Fields: Rd=0, Rm=0, cond=0
    let encoding: u32 = 0x06B00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_rev_a1_a_field_rd_1_poweroftwo_30_06b01030() {
    // Encoding: 0x06B01030
    // Test aarch32_REV_A1_A field Rd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Rm=0, Rd=1
    let encoding: u32 = 0x06B01030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV_A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_rev_a1_a_field_rm_0_min_30_06b00030() {
    // Encoding: 0x06B00030
    // Test aarch32_REV_A1_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: Rd=0, Rm=0, cond=0
    let encoding: u32 = 0x06B00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV_A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_rev_a1_a_field_rm_1_poweroftwo_30_06b00031() {
    // Encoding: 0x06B00031
    // Test aarch32_REV_A1_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Rd=0, Rm=1
    let encoding: u32 = 0x06B00031;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_rev_a1_a_combo_0_30_06b00030() {
    // Encoding: 0x06B00030
    // Test aarch32_REV_A1_A field combination: cond=0, Rd=0, Rm=0
    // ISET: A32
    // Fields: Rm=0, cond=0, Rd=0
    let encoding: u32 = 0x06B00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV_A1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=1 (condition NE (not equal))
#[test]
fn test_aarch32_rev_a1_a_combo_1_30_16b00030() {
    // Encoding: 0x16B00030
    // Test aarch32_REV_A1_A field combination: cond=1, Rd=0, Rm=0
    // ISET: A32
    // Fields: Rd=0, cond=1, Rm=0
    let encoding: u32 = 0x16B00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV_A1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=2 (condition CS/HS (carry set))
#[test]
fn test_aarch32_rev_a1_a_combo_2_30_26b00030() {
    // Encoding: 0x26B00030
    // Test aarch32_REV_A1_A field combination: cond=2, Rd=0, Rm=0
    // ISET: A32
    // Fields: Rm=0, Rd=0, cond=2
    let encoding: u32 = 0x26B00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV_A1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=3 (condition CC/LO (carry clear))
#[test]
fn test_aarch32_rev_a1_a_combo_3_30_36b00030() {
    // Encoding: 0x36B00030
    // Test aarch32_REV_A1_A field combination: cond=3, Rd=0, Rm=0
    // ISET: A32
    // Fields: Rd=0, Rm=0, cond=3
    let encoding: u32 = 0x36B00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV_A1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=4 (condition MI (minus/negative))
#[test]
fn test_aarch32_rev_a1_a_combo_4_30_46b00030() {
    // Encoding: 0x46B00030
    // Test aarch32_REV_A1_A field combination: cond=4, Rd=0, Rm=0
    // ISET: A32
    // Fields: Rd=0, Rm=0, cond=4
    let encoding: u32 = 0x46B00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV_A1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=5 (condition PL (plus/positive))
#[test]
fn test_aarch32_rev_a1_a_combo_5_30_56b00030() {
    // Encoding: 0x56B00030
    // Test aarch32_REV_A1_A field combination: cond=5, Rd=0, Rm=0
    // ISET: A32
    // Fields: Rd=0, Rm=0, cond=5
    let encoding: u32 = 0x56B00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV_A1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=6 (condition VS (overflow set))
#[test]
fn test_aarch32_rev_a1_a_combo_6_30_66b00030() {
    // Encoding: 0x66B00030
    // Test aarch32_REV_A1_A field combination: cond=6, Rd=0, Rm=0
    // ISET: A32
    // Fields: Rm=0, cond=6, Rd=0
    let encoding: u32 = 0x66B00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV_A1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=7 (condition VC (overflow clear))
#[test]
fn test_aarch32_rev_a1_a_combo_7_30_76b00030() {
    // Encoding: 0x76B00030
    // Test aarch32_REV_A1_A field combination: cond=7, Rd=0, Rm=0
    // ISET: A32
    // Fields: Rm=0, cond=7, Rd=0
    let encoding: u32 = 0x76B00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV_A1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=8 (condition HI (unsigned higher))
#[test]
fn test_aarch32_rev_a1_a_combo_8_30_86b00030() {
    // Encoding: 0x86B00030
    // Test aarch32_REV_A1_A field combination: cond=8, Rd=0, Rm=0
    // ISET: A32
    // Fields: cond=8, Rd=0, Rm=0
    let encoding: u32 = 0x86B00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV_A1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=9 (condition LS (unsigned lower or same))
#[test]
fn test_aarch32_rev_a1_a_combo_9_30_96b00030() {
    // Encoding: 0x96B00030
    // Test aarch32_REV_A1_A field combination: cond=9, Rd=0, Rm=0
    // ISET: A32
    // Fields: Rm=0, cond=9, Rd=0
    let encoding: u32 = 0x96B00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV_A1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=10 (condition GE (signed >=))
#[test]
fn test_aarch32_rev_a1_a_combo_10_30_a6b00030() {
    // Encoding: 0xA6B00030
    // Test aarch32_REV_A1_A field combination: cond=10, Rd=0, Rm=0
    // ISET: A32
    // Fields: Rd=0, cond=10, Rm=0
    let encoding: u32 = 0xA6B00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV_A1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=11 (condition LT (signed <))
#[test]
fn test_aarch32_rev_a1_a_combo_11_30_b6b00030() {
    // Encoding: 0xB6B00030
    // Test aarch32_REV_A1_A field combination: cond=11, Rd=0, Rm=0
    // ISET: A32
    // Fields: cond=11, Rd=0, Rm=0
    let encoding: u32 = 0xB6B00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV_A1_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=12 (condition GT (signed >))
#[test]
fn test_aarch32_rev_a1_a_combo_12_30_c6b00030() {
    // Encoding: 0xC6B00030
    // Test aarch32_REV_A1_A field combination: cond=12, Rd=0, Rm=0
    // ISET: A32
    // Fields: Rd=0, Rm=0, cond=12
    let encoding: u32 = 0xC6B00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV_A1_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=13 (condition LE (signed <=))
#[test]
fn test_aarch32_rev_a1_a_combo_13_30_d6b00030() {
    // Encoding: 0xD6B00030
    // Test aarch32_REV_A1_A field combination: cond=13, Rd=0, Rm=0
    // ISET: A32
    // Fields: Rm=0, Rd=0, cond=13
    let encoding: u32 = 0xD6B00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV_A1_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=14 (condition AL (always))
#[test]
fn test_aarch32_rev_a1_a_combo_14_30_e6b00030() {
    // Encoding: 0xE6B00030
    // Test aarch32_REV_A1_A field combination: cond=14, Rd=0, Rm=0
    // ISET: A32
    // Fields: Rm=0, cond=14, Rd=0
    let encoding: u32 = 0xE6B00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV_A1_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=15 (condition NV (never, reserved))
#[test]
fn test_aarch32_rev_a1_a_combo_15_30_f6b00030() {
    // Encoding: 0xF6B00030
    // Test aarch32_REV_A1_A field combination: cond=15, Rd=0, Rm=0
    // ISET: A32
    // Fields: cond=15, Rm=0, Rd=0
    let encoding: u32 = 0xF6B00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV_A1_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch32_rev_a1_a_combo_16_30_06b00030() {
    // Encoding: 0x06B00030
    // Test aarch32_REV_A1_A field combination: cond=0, Rd=0, Rm=0
    // ISET: A32
    // Fields: cond=0, Rd=0, Rm=0
    let encoding: u32 = 0x06B00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV_A1_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch32_rev_a1_a_combo_17_30_06b01030() {
    // Encoding: 0x06B01030
    // Test aarch32_REV_A1_A field combination: cond=0, Rd=1, Rm=0
    // ISET: A32
    // Fields: Rd=1, Rm=0, cond=0
    let encoding: u32 = 0x06B01030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV_A1_A
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch32_rev_a1_a_combo_18_30_06b00030() {
    // Encoding: 0x06B00030
    // Test aarch32_REV_A1_A field combination: cond=0, Rd=0, Rm=0
    // ISET: A32
    // Fields: Rm=0, cond=0, Rd=0
    let encoding: u32 = 0x06B00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV_A1_A
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_aarch32_rev_a1_a_combo_19_30_06b00031() {
    // Encoding: 0x06B00031
    // Test aarch32_REV_A1_A field combination: cond=0, Rd=0, Rm=1
    // ISET: A32
    // Fields: cond=0, Rm=1, Rd=0
    let encoding: u32 = 0x06B00031;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_rev_a1_a_special_cond_0_condition_eq_48_06b00030() {
    // Encoding: 0x06B00030
    // Test aarch32_REV_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: cond=0, Rd=0, Rm=0
    let encoding: u32 = 0x06B00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_rev_a1_a_special_cond_1_condition_ne_48_16b00030() {
    // Encoding: 0x16B00030
    // Test aarch32_REV_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: cond=1, Rm=0, Rd=0
    let encoding: u32 = 0x16B00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_rev_a1_a_special_cond_2_condition_cs_hs_48_26b00030() {
    // Encoding: 0x26B00030
    // Test aarch32_REV_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: cond=2, Rm=0, Rd=0
    let encoding: u32 = 0x26B00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_rev_a1_a_special_cond_3_condition_cc_lo_48_36b00030() {
    // Encoding: 0x36B00030
    // Test aarch32_REV_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: Rd=0, Rm=0, cond=3
    let encoding: u32 = 0x36B00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_rev_a1_a_special_cond_4_condition_mi_48_46b00030() {
    // Encoding: 0x46B00030
    // Test aarch32_REV_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: cond=4, Rm=0, Rd=0
    let encoding: u32 = 0x46B00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_rev_a1_a_special_cond_5_condition_pl_48_56b00030() {
    // Encoding: 0x56B00030
    // Test aarch32_REV_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: cond=5, Rd=0, Rm=0
    let encoding: u32 = 0x56B00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_rev_a1_a_special_cond_6_condition_vs_48_66b00030() {
    // Encoding: 0x66B00030
    // Test aarch32_REV_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: Rm=0, cond=6, Rd=0
    let encoding: u32 = 0x66B00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_rev_a1_a_special_cond_7_condition_vc_48_76b00030() {
    // Encoding: 0x76B00030
    // Test aarch32_REV_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: Rm=0, cond=7, Rd=0
    let encoding: u32 = 0x76B00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_rev_a1_a_special_cond_8_condition_hi_48_86b00030() {
    // Encoding: 0x86B00030
    // Test aarch32_REV_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: cond=8, Rd=0, Rm=0
    let encoding: u32 = 0x86B00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_rev_a1_a_special_cond_9_condition_ls_48_96b00030() {
    // Encoding: 0x96B00030
    // Test aarch32_REV_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: Rd=0, Rm=0, cond=9
    let encoding: u32 = 0x96B00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_rev_a1_a_special_cond_10_condition_ge_48_a6b00030() {
    // Encoding: 0xA6B00030
    // Test aarch32_REV_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: Rd=0, cond=10, Rm=0
    let encoding: u32 = 0xA6B00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_rev_a1_a_special_cond_11_condition_lt_48_b6b00030() {
    // Encoding: 0xB6B00030
    // Test aarch32_REV_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: Rm=0, Rd=0, cond=11
    let encoding: u32 = 0xB6B00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_rev_a1_a_special_cond_12_condition_gt_48_c6b00030() {
    // Encoding: 0xC6B00030
    // Test aarch32_REV_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: cond=12, Rm=0, Rd=0
    let encoding: u32 = 0xC6B00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_rev_a1_a_special_cond_13_condition_le_48_d6b00030() {
    // Encoding: 0xD6B00030
    // Test aarch32_REV_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: cond=13, Rd=0, Rm=0
    let encoding: u32 = 0xD6B00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_rev_a1_a_special_cond_14_condition_al_48_e6b00030() {
    // Encoding: 0xE6B00030
    // Test aarch32_REV_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: Rm=0, Rd=0, cond=14
    let encoding: u32 = 0xE6B00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_rev_a1_a_special_cond_15_condition_nv_48_f6b00030() {
    // Encoding: 0xF6B00030
    // Test aarch32_REV_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: Rm=0, cond=15, Rd=0
    let encoding: u32 = 0xF6B00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_rev_a1_a_invalid_0_30_06b00030() {
    // Encoding: 0x06B00030
    // Test aarch32_REV_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }
    // ISET: A32
    // Fields: Rm=0, cond=0, Rd=0
    let encoding: u32 = 0x06B00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_REV_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_rev_a1_a_invalid_1_30_06b00030() {
    // Encoding: 0x06B00030
    // Test aarch32_REV_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Rm=0, cond=0, Rd=0
    let encoding: u32 = 0x06B00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_REV_T1_A
/// ASL: `field Rm 19 +: 3`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_rev_t1_a_field_rm_0_min_0_ba000000() {
    // Thumb encoding (32): 0xBA000000
    // Test aarch32_REV_T1_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: Rm=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xBA000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_REV_T1_A
/// ASL: `field Rm 19 +: 3`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_rev_t1_a_field_rm_1_poweroftwo_0_ba080000() {
    // Thumb encoding (32): 0xBA080000
    // Test aarch32_REV_T1_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rd=0, Rm=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xBA080000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_REV_T1_A
/// ASL: `field Rd 16 +: 3`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_rev_t1_a_field_rd_0_min_0_ba000000() {
    // Thumb encoding (32): 0xBA000000
    // Test aarch32_REV_T1_A field Rd = 0 (Min)
    // ISET: T32
    // Fields: Rd=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xBA000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_REV_T1_A
/// ASL: `field Rd 16 +: 3`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_rev_t1_a_field_rd_1_poweroftwo_0_ba010000() {
    // Thumb encoding (32): 0xBA010000
    // Test aarch32_REV_T1_A field Rd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=0, Rd=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xBA010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_REV_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch32_rev_t1_a_combo_0_0_ba000000() {
    // Thumb encoding (32): 0xBA000000
    // Test aarch32_REV_T1_A field combination: Rm=0, Rd=0
    // ISET: T32
    // Fields: Rd=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xBA000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_REV_T1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_aarch32_rev_t1_a_combo_1_0_ba080000() {
    // Thumb encoding (32): 0xBA080000
    // Test aarch32_REV_T1_A field combination: Rm=1, Rd=0
    // ISET: T32
    // Fields: Rm=1, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xBA080000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_REV_T1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch32_rev_t1_a_combo_2_0_ba000000() {
    // Thumb encoding (32): 0xBA000000
    // Test aarch32_REV_T1_A field combination: Rm=0, Rd=0
    // ISET: T32
    // Fields: Rm=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xBA000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_REV_T1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch32_rev_t1_a_combo_3_0_ba010000() {
    // Thumb encoding (32): 0xBA010000
    // Test aarch32_REV_T1_A field combination: Rm=0, Rd=1
    // ISET: T32
    // Fields: Rd=1, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xBA010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_REV_T1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch32_rev_t1_a_combo_4_0_ba090000() {
    // Thumb encoding (32): 0xBA090000
    // Test aarch32_REV_T1_A field combination: Rm=1, Rd=1
    // ISET: T32
    // Fields: Rm=1, Rd=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xBA090000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_REV_T1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch32_rev_t1_a_combo_5_0_ba3f0000() {
    // Thumb encoding (32): 0xBA3F0000
    // Test aarch32_REV_T1_A field combination: Rm=31, Rd=31
    // ISET: T32
    // Fields: Rm=31, Rd=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xBA3F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_REV_T2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_rev_t2_a_field_rn_0_min_f080_fa90f080() {
    // Thumb encoding (32): 0xFA90F080
    // Test aarch32_REV_T2_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rm=0, Rn=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFA90F080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_REV_T2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_rev_t2_a_field_rn_1_poweroftwo_f080_fa91f080() {
    // Thumb encoding (32): 0xFA91F080
    // Test aarch32_REV_T2_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rd=0, Rm=0, Rn=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFA91F080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_REV_T2_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_rev_t2_a_field_rd_0_min_f080_fa90f080() {
    // Thumb encoding (32): 0xFA90F080
    // Test aarch32_REV_T2_A field Rd = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rm=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFA90F080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_REV_T2_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_rev_t2_a_field_rd_1_poweroftwo_f080_fa90f180() {
    // Thumb encoding (32): 0xFA90F180
    // Test aarch32_REV_T2_A field Rd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=0, Rd=1, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFA90F180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_REV_T2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_rev_t2_a_field_rm_0_min_f080_fa90f080() {
    // Thumb encoding (32): 0xFA90F080
    // Test aarch32_REV_T2_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: Rm=0, Rd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFA90F080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_REV_T2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_rev_t2_a_field_rm_1_poweroftwo_f080_fa90f081() {
    // Thumb encoding (32): 0xFA90F081
    // Test aarch32_REV_T2_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=1, Rn=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFA90F081;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_REV_T2_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_rev_t2_a_combo_0_f080_fa90f080() {
    // Thumb encoding (32): 0xFA90F080
    // Test aarch32_REV_T2_A field combination: Rn=0, Rd=0, Rm=0
    // ISET: T32
    // Fields: Rd=0, Rm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFA90F080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_REV_T2_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_rev_t2_a_combo_1_f080_fa91f080() {
    // Thumb encoding (32): 0xFA91F080
    // Test aarch32_REV_T2_A field combination: Rn=1, Rd=0, Rm=0
    // ISET: T32
    // Fields: Rd=0, Rm=0, Rn=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFA91F080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_REV_T2_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch32_rev_t2_a_combo_2_f080_fa90f080() {
    // Thumb encoding (32): 0xFA90F080
    // Test aarch32_REV_T2_A field combination: Rn=0, Rd=0, Rm=0
    // ISET: T32
    // Fields: Rd=0, Rm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFA90F080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_REV_T2_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch32_rev_t2_a_combo_3_f080_fa90f180() {
    // Thumb encoding (32): 0xFA90F180
    // Test aarch32_REV_T2_A field combination: Rn=0, Rd=1, Rm=0
    // ISET: T32
    // Fields: Rn=0, Rm=0, Rd=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFA90F180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_REV_T2_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch32_rev_t2_a_combo_4_f080_fa90f080() {
    // Thumb encoding (32): 0xFA90F080
    // Test aarch32_REV_T2_A field combination: Rn=0, Rd=0, Rm=0
    // ISET: T32
    // Fields: Rd=0, Rn=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFA90F080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_REV_T2_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_aarch32_rev_t2_a_combo_5_f080_fa90f081() {
    // Thumb encoding (32): 0xFA90F081
    // Test aarch32_REV_T2_A field combination: Rn=0, Rd=0, Rm=1
    // ISET: T32
    // Fields: Rd=0, Rn=0, Rm=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFA90F081;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_REV_T2_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch32_rev_t2_a_combo_6_f080_fa91f180() {
    // Thumb encoding (32): 0xFA91F180
    // Test aarch32_REV_T2_A field combination: Rn=1, Rd=1, Rm=0
    // ISET: T32
    // Fields: Rn=1, Rd=1, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFA91F180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_REV_T2_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch32_rev_t2_a_combo_7_f080_fa9fff80() {
    // Thumb encoding (32): 0xFA9FFF80
    // Test aarch32_REV_T2_A field combination: Rn=31, Rd=31, Rm=0
    // ISET: T32
    // Fields: Rn=31, Rd=31, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFA9FFF80;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_REV_T2_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rm=1 (same register test (reg=1))
#[test]
fn test_aarch32_rev_t2_a_combo_8_f080_fa91f081() {
    // Thumb encoding (32): 0xFA91F081
    // Test aarch32_REV_T2_A field combination: Rn=1, Rd=0, Rm=1
    // ISET: T32
    // Fields: Rm=1, Rn=1, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFA91F081;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_REV_T2_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rm=31 (same register test (reg=31))
#[test]
fn test_aarch32_rev_t2_a_combo_9_f080_fa9ff08f() {
    // Thumb encoding (32): 0xFA9FF08F
    // Test aarch32_REV_T2_A field combination: Rn=31, Rd=0, Rm=31
    // ISET: T32
    // Fields: Rn=31, Rd=0, Rm=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFA9FF08F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_REV_T2_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (same register test (reg=1)), Rm=1 (same register test (reg=1))
#[test]
fn test_aarch32_rev_t2_a_combo_10_f080_fa90f181() {
    // Thumb encoding (32): 0xFA90F181
    // Test aarch32_REV_T2_A field combination: Rn=0, Rd=1, Rm=1
    // ISET: T32
    // Fields: Rd=1, Rn=0, Rm=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFA90F181;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_REV_T2_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=31 (same register test (reg=31)), Rm=31 (same register test (reg=31))
#[test]
fn test_aarch32_rev_t2_a_combo_11_f080_fa90ff8f() {
    // Thumb encoding (32): 0xFA90FF8F
    // Test aarch32_REV_T2_A field combination: Rn=0, Rd=31, Rm=31
    // ISET: T32
    // Fields: Rn=0, Rd=31, Rm=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFA90FF8F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_REV_T2_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }), rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }), rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_rev_t2_a_invalid_0_f080_fa90f080() {
    // Thumb encoding (32): 0xFA90F080
    // Test aarch32_REV_T2_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }), rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }
    // ISET: T32
    // Fields: Rn=0, Rd=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFA90F080;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_REV_T2_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_rev_t2_a_invalid_1_f080_fa90f080() {
    // Thumb encoding (32): 0xFA90F080
    // Test aarch32_REV_T2_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rn=0, Rm=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFA90F080;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_REV_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 0 (32)
#[test]
fn test_aarch32_rev_t1_a_lslv_oracle_32_0_ba020020() {
    // Test LSLV 32-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x12345678, "W0 should be 0x12345678");
}

/// Provenance: aarch32_REV_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 0 (64)
#[test]
fn test_aarch32_rev_t1_a_lslv_oracle_64_0_ba020020() {
    // Test LSLV 64-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x12345678, "X0 should be 0x0000000012345678");
}

/// Provenance: aarch32_REV_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4 (32)
#[test]
fn test_aarch32_rev_t1_a_lslv_oracle_32_1_ba020020() {
    // Test LSLV 32-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x4);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x23456780, "W0 should be 0x23456780");
}

/// Provenance: aarch32_REV_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 4 (64)
#[test]
fn test_aarch32_rev_t1_a_lslv_oracle_64_1_ba020020() {
    // Test LSLV 64-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x4);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x23456780, "X0 should be 0x0000000123456780");
}

/// Provenance: aarch32_REV_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 8 (32)
#[test]
fn test_aarch32_rev_t1_a_lslv_oracle_32_2_ba020020() {
    // Test LSLV 32-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x8);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x34567800, "W0 should be 0x34567800");
}

/// Provenance: aarch32_REV_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 8 (64)
#[test]
fn test_aarch32_rev_t1_a_lslv_oracle_64_2_ba020020() {
    // Test LSLV 64-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x8);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x34567800, "X0 should be 0x0000001234567800");
}

/// Provenance: aarch32_REV_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1 (32)
#[test]
fn test_aarch32_rev_t1_a_lslv_oracle_32_3_ba020020() {
    // Test LSLV 32-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_REV_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// MSB set, shift 1 (64)
#[test]
fn test_aarch32_rev_t1_a_lslv_oracle_64_3_ba020020() {
    // Test LSLV 64-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_REV_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// LSB set, max shift (32)
#[test]
fn test_aarch32_rev_t1_a_lslv_oracle_32_4_ba020020() {
    // Test LSLV 32-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x3F);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "W0 should be 0x80000000");
}

/// Provenance: aarch32_REV_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// LSB set, max shift (64)
#[test]
fn test_aarch32_rev_t1_a_lslv_oracle_64_4_ba020020() {
    // Test LSLV 64-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3F);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x8000000000000000");
}

/// Provenance: aarch32_REV_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// all ones, shift 32 (32)
#[test]
fn test_aarch32_rev_t1_a_lslv_oracle_32_5_ba020020() {
    // Test LSLV 32-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x20);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "W0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_REV_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// all ones, shift 32 (64)
#[test]
fn test_aarch32_rev_t1_a_lslv_oracle_64_5_ba020020() {
    // Test LSLV 64-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x20);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0xFFFFFFFF00000000");
}

/// Provenance: aarch32_REV_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// no shift
#[test]
fn test_aarch32_rev_t1_a_t16_oracle_0_ba100000() {
    // Test T16 LSLS: no shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_REV_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4
#[test]
fn test_aarch32_rev_t1_a_t16_oracle_1_ba100000() {
    // Test T16 LSLS: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    set_w(&mut cpu, 2, 0x4);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF0, "R0 should be 0x00000FF0");
}

/// Provenance: aarch32_REV_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1
#[test]
fn test_aarch32_rev_t1_a_t16_oracle_2_ba100000() {
    // Test T16 LSLS: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_REV_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift to MSB
#[test]
fn test_aarch32_rev_t1_a_t16_oracle_3_ba100000() {
    // Test T16 LSLS: shift to MSB (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x1F);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "R0 should be 0x80000000");
}

// ============================================================================
// aarch32_USAT_A Tests
// ============================================================================

/// Provenance: aarch32_USAT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_usat_a1_a_field_cond_0_min_10_06e00010() {
    // Encoding: 0x06E00010
    // Test aarch32_USAT_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: sh=0, Rn=0, cond=0, Rd=0, imm5=0, sat_imm=0
    let encoding: u32 = 0x06E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_usat_a1_a_field_cond_1_poweroftwo_10_16e00010() {
    // Encoding: 0x16E00010
    // Test aarch32_USAT_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, imm5=0, sat_imm=0, sh=0, Rn=0, cond=1
    let encoding: u32 = 0x16E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_usat_a1_a_field_cond_2_poweroftwo_10_26e00010() {
    // Encoding: 0x26E00010
    // Test aarch32_USAT_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, sat_imm=0, imm5=0, cond=2, Rn=0, sh=0
    let encoding: u32 = 0x26E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_usat_a1_a_field_cond_3_poweroftwo_10_36e00010() {
    // Encoding: 0x36E00010
    // Test aarch32_USAT_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, sat_imm=0, sh=0, Rn=0, imm5=0, cond=3
    let encoding: u32 = 0x36E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_usat_a1_a_field_cond_4_poweroftwo_10_46e00010() {
    // Encoding: 0x46E00010
    // Test aarch32_USAT_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: imm5=0, sh=0, Rn=0, sat_imm=0, Rd=0, cond=4
    let encoding: u32 = 0x46E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_usat_a1_a_field_cond_5_poweroftwo_10_56e00010() {
    // Encoding: 0x56E00010
    // Test aarch32_USAT_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=5, sat_imm=0, sh=0, Rn=0, imm5=0, Rd=0
    let encoding: u32 = 0x56E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_usat_a1_a_field_cond_6_poweroftwo_10_66e00010() {
    // Encoding: 0x66E00010
    // Test aarch32_USAT_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, sh=0, Rd=0, cond=6, sat_imm=0, imm5=0
    let encoding: u32 = 0x66E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_usat_a1_a_field_cond_7_poweroftwo_10_76e00010() {
    // Encoding: 0x76E00010
    // Test aarch32_USAT_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, sat_imm=0, Rd=0, imm5=0, cond=7, sh=0
    let encoding: u32 = 0x76E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_usat_a1_a_field_cond_8_poweroftwo_10_86e00010() {
    // Encoding: 0x86E00010
    // Test aarch32_USAT_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, imm5=0, cond=8, Rd=0, sat_imm=0, sh=0
    let encoding: u32 = 0x86E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_usat_a1_a_field_cond_9_poweroftwo_10_96e00010() {
    // Encoding: 0x96E00010
    // Test aarch32_USAT_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, imm5=0, sat_imm=0, Rd=0, sh=0, cond=9
    let encoding: u32 = 0x96E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_usat_a1_a_field_cond_10_poweroftwo_10_a6e00010() {
    // Encoding: 0xA6E00010
    // Test aarch32_USAT_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, imm5=0, sh=0, cond=10, sat_imm=0, Rn=0
    let encoding: u32 = 0xA6E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_usat_a1_a_field_cond_11_poweroftwo_10_b6e00010() {
    // Encoding: 0xB6E00010
    // Test aarch32_USAT_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=11, Rd=0, Rn=0, sat_imm=0, imm5=0, sh=0
    let encoding: u32 = 0xB6E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_usat_a1_a_field_cond_12_poweroftwo_10_c6e00010() {
    // Encoding: 0xC6E00010
    // Test aarch32_USAT_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=12, sh=0, Rn=0, Rd=0, imm5=0, sat_imm=0
    let encoding: u32 = 0xC6E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_usat_a1_a_field_cond_13_poweroftwo_10_d6e00010() {
    // Encoding: 0xD6E00010
    // Test aarch32_USAT_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, sat_imm=0, imm5=0, Rn=0, cond=13, sh=0
    let encoding: u32 = 0xD6E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_usat_a1_a_field_cond_14_poweroftwo_10_e6e00010() {
    // Encoding: 0xE6E00010
    // Test aarch32_USAT_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=14, imm5=0, Rn=0, sh=0, sat_imm=0, Rd=0
    let encoding: u32 = 0xE6E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_usat_a1_a_field_cond_15_max_10_f6e00010() {
    // Encoding: 0xF6E00010
    // Test aarch32_USAT_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: sat_imm=0, cond=15, Rd=0, imm5=0, sh=0, Rn=0
    let encoding: u32 = 0xF6E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT_A1_A
/// ASL: `field sat_imm 16 +: 5`
/// Requirement: FieldBoundary { field: "sat_imm", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_usat_a1_a_field_sat_imm_0_min_10_06e00010() {
    // Encoding: 0x06E00010
    // Test aarch32_USAT_A1_A field sat_imm = 0 (Min)
    // ISET: A32
    // Fields: sat_imm=0, imm5=0, sh=0, Rd=0, Rn=0, cond=0
    let encoding: u32 = 0x06E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT_A1_A
/// ASL: `field sat_imm 16 +: 5`
/// Requirement: FieldBoundary { field: "sat_imm", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_usat_a1_a_field_sat_imm_1_poweroftwo_10_06e10010() {
    // Encoding: 0x06E10010
    // Test aarch32_USAT_A1_A field sat_imm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: sat_imm=1, sh=0, Rd=0, Rn=0, imm5=0, cond=0
    let encoding: u32 = 0x06E10010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT_A1_A
/// ASL: `field sat_imm 16 +: 5`
/// Requirement: FieldBoundary { field: "sat_imm", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_aarch32_usat_a1_a_field_sat_imm_15_poweroftwominusone_10_06ef0010() {
    // Encoding: 0x06EF0010
    // Test aarch32_USAT_A1_A field sat_imm = 15 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm5=0, cond=0, Rd=0, sat_imm=15, sh=0, Rn=0
    let encoding: u32 = 0x06EF0010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT_A1_A
/// ASL: `field sat_imm 16 +: 5`
/// Requirement: FieldBoundary { field: "sat_imm", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_aarch32_usat_a1_a_field_sat_imm_31_max_10_06ff0010() {
    // Encoding: 0x06FF0010
    // Test aarch32_USAT_A1_A field sat_imm = 31 (Max)
    // ISET: A32
    // Fields: Rd=0, imm5=0, cond=0, sh=0, Rn=0, sat_imm=31
    let encoding: u32 = 0x06FF0010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_usat_a1_a_field_rd_0_min_10_06e00010() {
    // Encoding: 0x06E00010
    // Test aarch32_USAT_A1_A field Rd = 0 (Min)
    // ISET: A32
    // Fields: sat_imm=0, Rd=0, imm5=0, sh=0, Rn=0, cond=0
    let encoding: u32 = 0x06E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_usat_a1_a_field_rd_1_poweroftwo_10_06e01010() {
    // Encoding: 0x06E01010
    // Test aarch32_USAT_A1_A field Rd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: sh=0, sat_imm=0, Rn=0, cond=0, Rd=1, imm5=0
    let encoding: u32 = 0x06E01010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_usat_a1_a_field_imm5_0_zero_10_06e00010() {
    // Encoding: 0x06E00010
    // Test aarch32_USAT_A1_A field imm5 = 0 (Zero)
    // ISET: A32
    // Fields: sat_imm=0, sh=0, imm5=0, Rn=0, Rd=0, cond=0
    let encoding: u32 = 0x06E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_usat_a1_a_field_imm5_1_poweroftwo_10_06e00090() {
    // Encoding: 0x06E00090
    // Test aarch32_USAT_A1_A field imm5 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, sh=0, Rn=0, imm5=1, sat_imm=0, Rd=0
    let encoding: u32 = 0x06E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_usat_a1_a_field_imm5_3_poweroftwominusone_10_06e00190() {
    // Encoding: 0x06E00190
    // Test aarch32_USAT_A1_A field imm5 = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, sh=0, sat_imm=0, Rn=0, imm5=3, Rd=0
    let encoding: u32 = 0x06E00190;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_usat_a1_a_field_imm5_4_poweroftwo_10_06e00210() {
    // Encoding: 0x06E00210
    // Test aarch32_USAT_A1_A field imm5 = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, sat_imm=0, cond=0, imm5=4, sh=0, Rd=0
    let encoding: u32 = 0x06E00210;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_usat_a1_a_field_imm5_7_poweroftwominusone_10_06e00390() {
    // Encoding: 0x06E00390
    // Test aarch32_USAT_A1_A field imm5 = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: sh=0, imm5=7, Rn=0, Rd=0, sat_imm=0, cond=0
    let encoding: u32 = 0x06E00390;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_usat_a1_a_field_imm5_8_poweroftwo_10_06e00410() {
    // Encoding: 0x06E00410
    // Test aarch32_USAT_A1_A field imm5 = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: imm5=8, cond=0, sh=0, Rn=0, Rd=0, sat_imm=0
    let encoding: u32 = 0x06E00410;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 15, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (15)
#[test]
fn test_aarch32_usat_a1_a_field_imm5_15_poweroftwominusone_10_06e00790() {
    // Encoding: 0x06E00790
    // Test aarch32_USAT_A1_A field imm5 = 15 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: sh=0, cond=0, imm5=15, sat_imm=0, Rn=0, Rd=0
    let encoding: u32 = 0x06E00790;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_usat_a1_a_field_imm5_16_poweroftwo_10_06e00810() {
    // Encoding: 0x06E00810
    // Test aarch32_USAT_A1_A field imm5 = 16 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, sat_imm=0, imm5=16, sh=0, Rn=0, Rd=0
    let encoding: u32 = 0x06E00810;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 31, boundary: Max }
/// maximum immediate (31)
#[test]
fn test_aarch32_usat_a1_a_field_imm5_31_max_10_06e00f90() {
    // Encoding: 0x06E00F90
    // Test aarch32_USAT_A1_A field imm5 = 31 (Max)
    // ISET: A32
    // Fields: sat_imm=0, Rd=0, Rn=0, imm5=31, sh=0, cond=0
    let encoding: u32 = 0x06E00F90;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT_A1_A
/// ASL: `field sh 6 +: 1`
/// Requirement: FieldBoundary { field: "sh", value: 0, boundary: Min }
/// shift type LSL (logical shift left)
#[test]
fn test_aarch32_usat_a1_a_field_sh_0_min_10_06e00010() {
    // Encoding: 0x06E00010
    // Test aarch32_USAT_A1_A field sh = 0 (Min)
    // ISET: A32
    // Fields: sh=0, sat_imm=0, Rd=0, imm5=0, Rn=0, cond=0
    let encoding: u32 = 0x06E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT_A1_A
/// ASL: `field sh 6 +: 1`
/// Requirement: FieldBoundary { field: "sh", value: 1, boundary: Max }
/// shift type LSR (logical shift right)
#[test]
fn test_aarch32_usat_a1_a_field_sh_1_max_10_06e00050() {
    // Encoding: 0x06E00050
    // Test aarch32_USAT_A1_A field sh = 1 (Max)
    // ISET: A32
    // Fields: sh=1, cond=0, Rd=0, Rn=0, imm5=0, sat_imm=0
    let encoding: u32 = 0x06E00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT_A1_A
/// ASL: `field Rn 0 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_usat_a1_a_field_rn_0_min_10_06e00010() {
    // Encoding: 0x06E00010
    // Test aarch32_USAT_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: imm5=0, sat_imm=0, Rn=0, Rd=0, sh=0, cond=0
    let encoding: u32 = 0x06E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT_A1_A
/// ASL: `field Rn 0 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_usat_a1_a_field_rn_1_poweroftwo_10_06e00011() {
    // Encoding: 0x06E00011
    // Test aarch32_USAT_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, sat_imm=0, imm5=0, Rn=1, sh=0, cond=0
    let encoding: u32 = 0x06E00011;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_usat_a1_a_combo_0_10_06e00010() {
    // Encoding: 0x06E00010
    // Test aarch32_USAT_A1_A field combination: cond=0, sat_imm=0, Rd=0, imm5=0, sh=0, Rn=0
    // ISET: A32
    // Fields: cond=0, imm5=0, sh=0, Rd=0, Rn=0, sat_imm=0
    let encoding: u32 = 0x06E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT_A1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=1 (condition NE (not equal))
#[test]
fn test_aarch32_usat_a1_a_combo_1_10_16e00010() {
    // Encoding: 0x16E00010
    // Test aarch32_USAT_A1_A field combination: cond=1, sat_imm=0, Rd=0, imm5=0, sh=0, Rn=0
    // ISET: A32
    // Fields: imm5=0, cond=1, Rd=0, sh=0, Rn=0, sat_imm=0
    let encoding: u32 = 0x16E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT_A1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=2 (condition CS/HS (carry set))
#[test]
fn test_aarch32_usat_a1_a_combo_2_10_26e00010() {
    // Encoding: 0x26E00010
    // Test aarch32_USAT_A1_A field combination: cond=2, sat_imm=0, Rd=0, imm5=0, sh=0, Rn=0
    // ISET: A32
    // Fields: cond=2, sat_imm=0, sh=0, imm5=0, Rn=0, Rd=0
    let encoding: u32 = 0x26E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT_A1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=3 (condition CC/LO (carry clear))
#[test]
fn test_aarch32_usat_a1_a_combo_3_10_36e00010() {
    // Encoding: 0x36E00010
    // Test aarch32_USAT_A1_A field combination: cond=3, sat_imm=0, Rd=0, imm5=0, sh=0, Rn=0
    // ISET: A32
    // Fields: imm5=0, Rn=0, cond=3, sat_imm=0, sh=0, Rd=0
    let encoding: u32 = 0x36E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT_A1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=4 (condition MI (minus/negative))
#[test]
fn test_aarch32_usat_a1_a_combo_4_10_46e00010() {
    // Encoding: 0x46E00010
    // Test aarch32_USAT_A1_A field combination: cond=4, sat_imm=0, Rd=0, imm5=0, sh=0, Rn=0
    // ISET: A32
    // Fields: sh=0, cond=4, Rd=0, imm5=0, sat_imm=0, Rn=0
    let encoding: u32 = 0x46E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT_A1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=5 (condition PL (plus/positive))
#[test]
fn test_aarch32_usat_a1_a_combo_5_10_56e00010() {
    // Encoding: 0x56E00010
    // Test aarch32_USAT_A1_A field combination: cond=5, sat_imm=0, Rd=0, imm5=0, sh=0, Rn=0
    // ISET: A32
    // Fields: Rd=0, cond=5, imm5=0, Rn=0, sat_imm=0, sh=0
    let encoding: u32 = 0x56E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT_A1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=6 (condition VS (overflow set))
#[test]
fn test_aarch32_usat_a1_a_combo_6_10_66e00010() {
    // Encoding: 0x66E00010
    // Test aarch32_USAT_A1_A field combination: cond=6, sat_imm=0, Rd=0, imm5=0, sh=0, Rn=0
    // ISET: A32
    // Fields: Rn=0, sat_imm=0, imm5=0, Rd=0, cond=6, sh=0
    let encoding: u32 = 0x66E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT_A1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=7 (condition VC (overflow clear))
#[test]
fn test_aarch32_usat_a1_a_combo_7_10_76e00010() {
    // Encoding: 0x76E00010
    // Test aarch32_USAT_A1_A field combination: cond=7, sat_imm=0, Rd=0, imm5=0, sh=0, Rn=0
    // ISET: A32
    // Fields: cond=7, sat_imm=0, imm5=0, Rn=0, Rd=0, sh=0
    let encoding: u32 = 0x76E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT_A1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=8 (condition HI (unsigned higher))
#[test]
fn test_aarch32_usat_a1_a_combo_8_10_86e00010() {
    // Encoding: 0x86E00010
    // Test aarch32_USAT_A1_A field combination: cond=8, sat_imm=0, Rd=0, imm5=0, sh=0, Rn=0
    // ISET: A32
    // Fields: imm5=0, Rn=0, Rd=0, sh=0, cond=8, sat_imm=0
    let encoding: u32 = 0x86E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT_A1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=9 (condition LS (unsigned lower or same))
#[test]
fn test_aarch32_usat_a1_a_combo_9_10_96e00010() {
    // Encoding: 0x96E00010
    // Test aarch32_USAT_A1_A field combination: cond=9, sat_imm=0, Rd=0, imm5=0, sh=0, Rn=0
    // ISET: A32
    // Fields: sh=0, sat_imm=0, imm5=0, Rn=0, cond=9, Rd=0
    let encoding: u32 = 0x96E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT_A1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=10 (condition GE (signed >=))
#[test]
fn test_aarch32_usat_a1_a_combo_10_10_a6e00010() {
    // Encoding: 0xA6E00010
    // Test aarch32_USAT_A1_A field combination: cond=10, sat_imm=0, Rd=0, imm5=0, sh=0, Rn=0
    // ISET: A32
    // Fields: sat_imm=0, imm5=0, Rd=0, sh=0, Rn=0, cond=10
    let encoding: u32 = 0xA6E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT_A1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=11 (condition LT (signed <))
#[test]
fn test_aarch32_usat_a1_a_combo_11_10_b6e00010() {
    // Encoding: 0xB6E00010
    // Test aarch32_USAT_A1_A field combination: cond=11, sat_imm=0, Rd=0, imm5=0, sh=0, Rn=0
    // ISET: A32
    // Fields: imm5=0, sh=0, Rd=0, sat_imm=0, Rn=0, cond=11
    let encoding: u32 = 0xB6E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT_A1_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=12 (condition GT (signed >))
#[test]
fn test_aarch32_usat_a1_a_combo_12_10_c6e00010() {
    // Encoding: 0xC6E00010
    // Test aarch32_USAT_A1_A field combination: cond=12, sat_imm=0, Rd=0, imm5=0, sh=0, Rn=0
    // ISET: A32
    // Fields: Rd=0, imm5=0, sh=0, sat_imm=0, Rn=0, cond=12
    let encoding: u32 = 0xC6E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT_A1_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=13 (condition LE (signed <=))
#[test]
fn test_aarch32_usat_a1_a_combo_13_10_d6e00010() {
    // Encoding: 0xD6E00010
    // Test aarch32_USAT_A1_A field combination: cond=13, sat_imm=0, Rd=0, imm5=0, sh=0, Rn=0
    // ISET: A32
    // Fields: imm5=0, Rn=0, sat_imm=0, cond=13, Rd=0, sh=0
    let encoding: u32 = 0xD6E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT_A1_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=14 (condition AL (always))
#[test]
fn test_aarch32_usat_a1_a_combo_14_10_e6e00010() {
    // Encoding: 0xE6E00010
    // Test aarch32_USAT_A1_A field combination: cond=14, sat_imm=0, Rd=0, imm5=0, sh=0, Rn=0
    // ISET: A32
    // Fields: sh=0, imm5=0, sat_imm=0, Rd=0, Rn=0, cond=14
    let encoding: u32 = 0xE6E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT_A1_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=15 (condition NV (never, reserved))
#[test]
fn test_aarch32_usat_a1_a_combo_15_10_f6e00010() {
    // Encoding: 0xF6E00010
    // Test aarch32_USAT_A1_A field combination: cond=15, sat_imm=0, Rd=0, imm5=0, sh=0, Rn=0
    // ISET: A32
    // Fields: Rn=0, cond=15, sh=0, imm5=0, sat_imm=0, Rd=0
    let encoding: u32 = 0xF6E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT_A1_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sat_imm=0 (minimum value)
#[test]
fn test_aarch32_usat_a1_a_combo_16_10_06e00010() {
    // Encoding: 0x06E00010
    // Test aarch32_USAT_A1_A field combination: cond=0, sat_imm=0, Rd=0, imm5=0, sh=0, Rn=0
    // ISET: A32
    // Fields: sh=0, sat_imm=0, Rd=0, cond=0, imm5=0, Rn=0
    let encoding: u32 = 0x06E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT_A1_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sat_imm=1 (value 1)
#[test]
fn test_aarch32_usat_a1_a_combo_17_10_06e10010() {
    // Encoding: 0x06E10010
    // Test aarch32_USAT_A1_A field combination: cond=0, sat_imm=1, Rd=0, imm5=0, sh=0, Rn=0
    // ISET: A32
    // Fields: sat_imm=1, imm5=0, Rn=0, cond=0, Rd=0, sh=0
    let encoding: u32 = 0x06E10010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT_A1_A
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sat_imm=15 (midpoint (15))
#[test]
fn test_aarch32_usat_a1_a_combo_18_10_06ef0010() {
    // Encoding: 0x06EF0010
    // Test aarch32_USAT_A1_A field combination: cond=0, sat_imm=15, Rd=0, imm5=0, sh=0, Rn=0
    // ISET: A32
    // Fields: Rd=0, sh=0, cond=0, sat_imm=15, imm5=0, Rn=0
    let encoding: u32 = 0x06EF0010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT_A1_A
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sat_imm=31 (maximum value (31))
#[test]
fn test_aarch32_usat_a1_a_combo_19_10_06ff0010() {
    // Encoding: 0x06FF0010
    // Test aarch32_USAT_A1_A field combination: cond=0, sat_imm=31, Rd=0, imm5=0, sh=0, Rn=0
    // ISET: A32
    // Fields: Rd=0, imm5=0, sat_imm=31, Rn=0, sh=0, cond=0
    let encoding: u32 = 0x06FF0010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_usat_a1_a_special_cond_0_condition_eq_16_06e00010() {
    // Encoding: 0x06E00010
    // Test aarch32_USAT_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: sh=0, Rn=0, sat_imm=0, cond=0, Rd=0, imm5=0
    let encoding: u32 = 0x06E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_usat_a1_a_special_cond_1_condition_ne_16_16e00010() {
    // Encoding: 0x16E00010
    // Test aarch32_USAT_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: sat_imm=0, Rd=0, imm5=0, sh=0, Rn=0, cond=1
    let encoding: u32 = 0x16E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_usat_a1_a_special_cond_2_condition_cs_hs_16_26e00010() {
    // Encoding: 0x26E00010
    // Test aarch32_USAT_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: cond=2, sat_imm=0, Rd=0, imm5=0, sh=0, Rn=0
    let encoding: u32 = 0x26E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_usat_a1_a_special_cond_3_condition_cc_lo_16_36e00010() {
    // Encoding: 0x36E00010
    // Test aarch32_USAT_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: imm5=0, Rn=0, sat_imm=0, cond=3, sh=0, Rd=0
    let encoding: u32 = 0x36E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_usat_a1_a_special_cond_4_condition_mi_16_46e00010() {
    // Encoding: 0x46E00010
    // Test aarch32_USAT_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: Rd=0, cond=4, sh=0, Rn=0, imm5=0, sat_imm=0
    let encoding: u32 = 0x46E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_usat_a1_a_special_cond_5_condition_pl_16_56e00010() {
    // Encoding: 0x56E00010
    // Test aarch32_USAT_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: cond=5, Rd=0, Rn=0, sat_imm=0, imm5=0, sh=0
    let encoding: u32 = 0x56E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_usat_a1_a_special_cond_6_condition_vs_16_66e00010() {
    // Encoding: 0x66E00010
    // Test aarch32_USAT_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: cond=6, Rd=0, Rn=0, sat_imm=0, sh=0, imm5=0
    let encoding: u32 = 0x66E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_usat_a1_a_special_cond_7_condition_vc_16_76e00010() {
    // Encoding: 0x76E00010
    // Test aarch32_USAT_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: Rd=0, sat_imm=0, imm5=0, Rn=0, sh=0, cond=7
    let encoding: u32 = 0x76E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_usat_a1_a_special_cond_8_condition_hi_16_86e00010() {
    // Encoding: 0x86E00010
    // Test aarch32_USAT_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: sh=0, Rn=0, imm5=0, Rd=0, cond=8, sat_imm=0
    let encoding: u32 = 0x86E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_usat_a1_a_special_cond_9_condition_ls_16_96e00010() {
    // Encoding: 0x96E00010
    // Test aarch32_USAT_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: Rd=0, sat_imm=0, sh=0, Rn=0, cond=9, imm5=0
    let encoding: u32 = 0x96E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_usat_a1_a_special_cond_10_condition_ge_16_a6e00010() {
    // Encoding: 0xA6E00010
    // Test aarch32_USAT_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: imm5=0, Rd=0, cond=10, sh=0, sat_imm=0, Rn=0
    let encoding: u32 = 0xA6E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_usat_a1_a_special_cond_11_condition_lt_16_b6e00010() {
    // Encoding: 0xB6E00010
    // Test aarch32_USAT_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: Rd=0, sat_imm=0, sh=0, Rn=0, imm5=0, cond=11
    let encoding: u32 = 0xB6E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_usat_a1_a_special_cond_12_condition_gt_16_c6e00010() {
    // Encoding: 0xC6E00010
    // Test aarch32_USAT_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: sh=0, Rd=0, cond=12, Rn=0, sat_imm=0, imm5=0
    let encoding: u32 = 0xC6E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_usat_a1_a_special_cond_13_condition_le_16_d6e00010() {
    // Encoding: 0xD6E00010
    // Test aarch32_USAT_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: sat_imm=0, imm5=0, sh=0, cond=13, Rn=0, Rd=0
    let encoding: u32 = 0xD6E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_usat_a1_a_special_cond_14_condition_al_16_e6e00010() {
    // Encoding: 0xE6E00010
    // Test aarch32_USAT_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: imm5=0, cond=14, sat_imm=0, sh=0, Rd=0, Rn=0
    let encoding: u32 = 0xE6E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_usat_a1_a_special_cond_15_condition_nv_16_f6e00010() {
    // Encoding: 0xF6E00010
    // Test aarch32_USAT_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: sat_imm=0, sh=0, Rd=0, Rn=0, imm5=0, cond=15
    let encoding: u32 = 0xF6E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT_A1_A
/// ASL: `field sh = 0 (Shift type LSL)`
/// Requirement: FieldSpecial { field: "sh", value: 0, meaning: "Shift type LSL" }
/// Shift type LSL
#[test]
fn test_aarch32_usat_a1_a_special_sh_0_shift_type_lsl_16_06e00010() {
    // Encoding: 0x06E00010
    // Test aarch32_USAT_A1_A special value sh = 0 (Shift type LSL)
    // ISET: A32
    // Fields: sat_imm=0, Rn=0, sh=0, cond=0, imm5=0, Rd=0
    let encoding: u32 = 0x06E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT_A1_A
/// ASL: `field sh = 1 (Shift type LSR)`
/// Requirement: FieldSpecial { field: "sh", value: 1, meaning: "Shift type LSR" }
/// Shift type LSR
#[test]
fn test_aarch32_usat_a1_a_special_sh_1_shift_type_lsr_16_06e00050() {
    // Encoding: 0x06E00050
    // Test aarch32_USAT_A1_A special value sh = 1 (Shift type LSR)
    // ISET: A32
    // Fields: imm5=0, cond=0, Rd=0, Rn=0, sh=1, sat_imm=0
    let encoding: u32 = 0x06E00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT_A1_A
/// ASL: `field sh = 2 (Shift type ASR)`
/// Requirement: FieldSpecial { field: "sh", value: 2, meaning: "Shift type ASR" }
/// Shift type ASR
#[test]
fn test_aarch32_usat_a1_a_special_sh_2_shift_type_asr_16_06e00010() {
    // Encoding: 0x06E00010
    // Test aarch32_USAT_A1_A special value sh = 2 (Shift type ASR)
    // ISET: A32
    // Fields: Rn=0, sat_imm=0, Rd=0, imm5=0, cond=0, sh=2
    let encoding: u32 = 0x06E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT_A1_A
/// ASL: `field sh = 3 (Shift type ROR)`
/// Requirement: FieldSpecial { field: "sh", value: 3, meaning: "Shift type ROR" }
/// Shift type ROR
#[test]
fn test_aarch32_usat_a1_a_special_sh_3_shift_type_ror_16_06e00050() {
    // Encoding: 0x06E00050
    // Test aarch32_USAT_A1_A special value sh = 3 (Shift type ROR)
    // ISET: A32
    // Fields: Rn=0, imm5=0, cond=0, sat_imm=0, Rd=0, sh=3
    let encoding: u32 = 0x06E00050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_USAT_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_usat_a1_a_invalid_0_10_06e00010() {
    // Encoding: 0x06E00010
    // Test aarch32_USAT_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }
    // ISET: A32
    // Fields: Rn=0, Rd=0, imm5=0, cond=0, sh=0, sat_imm=0
    let encoding: u32 = 0x06E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_USAT_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_usat_a1_a_invalid_1_10_06e00010() {
    // Encoding: 0x06E00010
    // Test aarch32_USAT_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: sat_imm=0, Rd=0, sh=0, Rn=0, imm5=0, cond=0
    let encoding: u32 = 0x06E00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_USAT_T1_A
/// ASL: `field sh 21 +: 1`
/// Requirement: FieldBoundary { field: "sh", value: 0, boundary: Min }
/// shift type LSL (logical shift left)
#[test]
fn test_aarch32_usat_t1_a_field_sh_0_min_0_f3800000() {
    // Thumb encoding (32): 0xF3800000
    // Test aarch32_USAT_T1_A field sh = 0 (Min)
    // ISET: T32
    // Fields: imm3=0, Rn=0, imm2=0, Rd=0, sat_imm=0, sh=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_USAT_T1_A
/// ASL: `field sh 21 +: 1`
/// Requirement: FieldBoundary { field: "sh", value: 1, boundary: Max }
/// shift type LSR (logical shift right)
#[test]
fn test_aarch32_usat_t1_a_field_sh_1_max_0_f3a00000() {
    // Thumb encoding (32): 0xF3A00000
    // Test aarch32_USAT_T1_A field sh = 1 (Max)
    // ISET: T32
    // Fields: sat_imm=0, imm2=0, Rd=0, sh=1, Rn=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_USAT_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_usat_t1_a_field_rn_0_min_0_f3800000() {
    // Thumb encoding (32): 0xF3800000
    // Test aarch32_USAT_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rd=0, imm2=0, sat_imm=0, imm3=0, sh=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_USAT_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_usat_t1_a_field_rn_1_poweroftwo_0_f3810000() {
    // Thumb encoding (32): 0xF3810000
    // Test aarch32_USAT_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rd=0, Rn=1, sat_imm=0, imm2=0, sh=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_USAT_T1_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_usat_t1_a_field_imm3_0_zero_0_f3800000() {
    // Thumb encoding (32): 0xF3800000
    // Test aarch32_USAT_T1_A field imm3 = 0 (Zero)
    // ISET: T32
    // Fields: imm3=0, imm2=0, sh=0, sat_imm=0, Rn=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_USAT_T1_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_usat_t1_a_field_imm3_1_poweroftwo_0_f3801000() {
    // Thumb encoding (32): 0xF3801000
    // Test aarch32_USAT_T1_A field imm3 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: sh=0, imm2=0, sat_imm=0, Rn=0, Rd=0, imm3=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3801000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_USAT_T1_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 3, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (3)
#[test]
fn test_aarch32_usat_t1_a_field_imm3_3_poweroftwominusone_0_f3803000() {
    // Thumb encoding (32): 0xF3803000
    // Test aarch32_USAT_T1_A field imm3 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm2=0, sat_imm=0, imm3=3, sh=0, Rn=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3803000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_USAT_T1_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 7, boundary: Max }
/// maximum immediate (7)
#[test]
fn test_aarch32_usat_t1_a_field_imm3_7_max_0_f3807000() {
    // Thumb encoding (32): 0xF3807000
    // Test aarch32_USAT_T1_A field imm3 = 7 (Max)
    // ISET: T32
    // Fields: Rd=0, sat_imm=0, Rn=0, imm3=7, imm2=0, sh=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3807000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_USAT_T1_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_usat_t1_a_field_rd_0_min_0_f3800000() {
    // Thumb encoding (32): 0xF3800000
    // Test aarch32_USAT_T1_A field Rd = 0 (Min)
    // ISET: T32
    // Fields: sh=0, Rd=0, imm2=0, Rn=0, imm3=0, sat_imm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_USAT_T1_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_usat_t1_a_field_rd_1_poweroftwo_0_f3800100() {
    // Thumb encoding (32): 0xF3800100
    // Test aarch32_USAT_T1_A field Rd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm2=0, Rd=1, Rn=0, sh=0, sat_imm=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3800100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_USAT_T1_A
/// ASL: `field imm2 6 +: 2`
/// Requirement: FieldBoundary { field: "imm2", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_usat_t1_a_field_imm2_0_zero_0_f3800000() {
    // Thumb encoding (32): 0xF3800000
    // Test aarch32_USAT_T1_A field imm2 = 0 (Zero)
    // ISET: T32
    // Fields: imm2=0, imm3=0, sh=0, sat_imm=0, Rn=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_USAT_T1_A
/// ASL: `field imm2 6 +: 2`
/// Requirement: FieldBoundary { field: "imm2", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_usat_t1_a_field_imm2_1_poweroftwo_0_f3800040() {
    // Thumb encoding (32): 0xF3800040
    // Test aarch32_USAT_T1_A field imm2 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: sat_imm=0, Rn=0, Rd=0, imm2=1, imm3=0, sh=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3800040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_USAT_T1_A
/// ASL: `field imm2 6 +: 2`
/// Requirement: FieldBoundary { field: "imm2", value: 3, boundary: Max }
/// maximum immediate (3)
#[test]
fn test_aarch32_usat_t1_a_field_imm2_3_max_0_f38000c0() {
    // Thumb encoding (32): 0xF38000C0
    // Test aarch32_USAT_T1_A field imm2 = 3 (Max)
    // ISET: T32
    // Fields: Rd=0, sat_imm=0, sh=0, Rn=0, imm2=3, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF38000C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_USAT_T1_A
/// ASL: `field sat_imm 0 +: 5`
/// Requirement: FieldBoundary { field: "sat_imm", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_usat_t1_a_field_sat_imm_0_min_0_f3800000() {
    // Thumb encoding (32): 0xF3800000
    // Test aarch32_USAT_T1_A field sat_imm = 0 (Min)
    // ISET: T32
    // Fields: sat_imm=0, imm2=0, sh=0, Rn=0, Rd=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_USAT_T1_A
/// ASL: `field sat_imm 0 +: 5`
/// Requirement: FieldBoundary { field: "sat_imm", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_usat_t1_a_field_sat_imm_1_poweroftwo_0_f3800001() {
    // Thumb encoding (32): 0xF3800001
    // Test aarch32_USAT_T1_A field sat_imm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: sh=0, sat_imm=1, imm2=0, imm3=0, Rn=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3800001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_USAT_T1_A
/// ASL: `field sat_imm 0 +: 5`
/// Requirement: FieldBoundary { field: "sat_imm", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_aarch32_usat_t1_a_field_sat_imm_15_poweroftwominusone_0_f380000f() {
    // Thumb encoding (32): 0xF380000F
    // Test aarch32_USAT_T1_A field sat_imm = 15 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm2=0, Rn=0, Rd=0, sat_imm=15, imm3=0, sh=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF380000F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_USAT_T1_A
/// ASL: `field sat_imm 0 +: 5`
/// Requirement: FieldBoundary { field: "sat_imm", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_aarch32_usat_t1_a_field_sat_imm_31_max_0_f380001f() {
    // Thumb encoding (32): 0xF380001F
    // Test aarch32_USAT_T1_A field sat_imm = 31 (Max)
    // ISET: T32
    // Fields: sat_imm=31, imm3=0, sh=0, Rd=0, Rn=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF380001F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_USAT_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sh=0 (shift type LSL (logical shift left))
#[test]
fn test_aarch32_usat_t1_a_combo_0_0_f3800000() {
    // Thumb encoding (32): 0xF3800000
    // Test aarch32_USAT_T1_A field combination: sh=0, Rn=0, imm3=0, Rd=0, imm2=0, sat_imm=0
    // ISET: T32
    // Fields: Rn=0, sat_imm=0, sh=0, Rd=0, imm3=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_USAT_T1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sh=1 (shift type LSR (logical shift right))
#[test]
fn test_aarch32_usat_t1_a_combo_1_0_f3a00000() {
    // Thumb encoding (32): 0xF3A00000
    // Test aarch32_USAT_T1_A field combination: sh=1, Rn=0, imm3=0, Rd=0, imm2=0, sat_imm=0
    // ISET: T32
    // Fields: sat_imm=0, sh=1, Rn=0, imm3=0, Rd=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_USAT_T1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_usat_t1_a_combo_2_0_f3800000() {
    // Thumb encoding (32): 0xF3800000
    // Test aarch32_USAT_T1_A field combination: sh=0, Rn=0, imm3=0, Rd=0, imm2=0, sat_imm=0
    // ISET: T32
    // Fields: imm2=0, imm3=0, Rn=0, Rd=0, sat_imm=0, sh=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_USAT_T1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_usat_t1_a_combo_3_0_f3810000() {
    // Thumb encoding (32): 0xF3810000
    // Test aarch32_USAT_T1_A field combination: sh=0, Rn=1, imm3=0, Rd=0, imm2=0, sat_imm=0
    // ISET: T32
    // Fields: Rd=0, Rn=1, imm3=0, imm2=0, sh=0, sat_imm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_USAT_T1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm3=0 (immediate value 0)
#[test]
fn test_aarch32_usat_t1_a_combo_4_0_f3800000() {
    // Thumb encoding (32): 0xF3800000
    // Test aarch32_USAT_T1_A field combination: sh=0, Rn=0, imm3=0, Rd=0, imm2=0, sat_imm=0
    // ISET: T32
    // Fields: Rn=0, imm2=0, sat_imm=0, sh=0, imm3=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_USAT_T1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm3=1 (immediate value 1)
#[test]
fn test_aarch32_usat_t1_a_combo_5_0_f3801000() {
    // Thumb encoding (32): 0xF3801000
    // Test aarch32_USAT_T1_A field combination: sh=0, Rn=0, imm3=1, Rd=0, imm2=0, sat_imm=0
    // ISET: T32
    // Fields: imm3=1, sat_imm=0, Rn=0, sh=0, Rd=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3801000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_USAT_T1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm3=3 (immediate midpoint (3))
#[test]
fn test_aarch32_usat_t1_a_combo_6_0_f3803000() {
    // Thumb encoding (32): 0xF3803000
    // Test aarch32_USAT_T1_A field combination: sh=0, Rn=0, imm3=3, Rd=0, imm2=0, sat_imm=0
    // ISET: T32
    // Fields: imm3=3, sat_imm=0, imm2=0, Rn=0, Rd=0, sh=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3803000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_USAT_T1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm3=7 (maximum immediate (7))
#[test]
fn test_aarch32_usat_t1_a_combo_7_0_f3807000() {
    // Thumb encoding (32): 0xF3807000
    // Test aarch32_USAT_T1_A field combination: sh=0, Rn=0, imm3=7, Rd=0, imm2=0, sat_imm=0
    // ISET: T32
    // Fields: sh=0, imm3=7, Rn=0, Rd=0, imm2=0, sat_imm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3807000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_USAT_T1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch32_usat_t1_a_combo_8_0_f3800000() {
    // Thumb encoding (32): 0xF3800000
    // Test aarch32_USAT_T1_A field combination: sh=0, Rn=0, imm3=0, Rd=0, imm2=0, sat_imm=0
    // ISET: T32
    // Fields: Rd=0, sh=0, imm3=0, imm2=0, sat_imm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_USAT_T1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch32_usat_t1_a_combo_9_0_f3800100() {
    // Thumb encoding (32): 0xF3800100
    // Test aarch32_USAT_T1_A field combination: sh=0, Rn=0, imm3=0, Rd=1, imm2=0, sat_imm=0
    // ISET: T32
    // Fields: imm2=0, sat_imm=0, sh=0, Rn=0, Rd=1, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3800100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_USAT_T1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm2=0 (immediate value 0)
#[test]
fn test_aarch32_usat_t1_a_combo_10_0_f3800000() {
    // Thumb encoding (32): 0xF3800000
    // Test aarch32_USAT_T1_A field combination: sh=0, Rn=0, imm3=0, Rd=0, imm2=0, sat_imm=0
    // ISET: T32
    // Fields: sh=0, imm3=0, Rd=0, Rn=0, imm2=0, sat_imm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_USAT_T1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm2=1 (immediate value 1)
#[test]
fn test_aarch32_usat_t1_a_combo_11_0_f3800040() {
    // Thumb encoding (32): 0xF3800040
    // Test aarch32_USAT_T1_A field combination: sh=0, Rn=0, imm3=0, Rd=0, imm2=1, sat_imm=0
    // ISET: T32
    // Fields: imm3=0, Rd=0, sat_imm=0, Rn=0, imm2=1, sh=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3800040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_USAT_T1_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm2=3 (maximum immediate (3))
#[test]
fn test_aarch32_usat_t1_a_combo_12_0_f38000c0() {
    // Thumb encoding (32): 0xF38000C0
    // Test aarch32_USAT_T1_A field combination: sh=0, Rn=0, imm3=0, Rd=0, imm2=3, sat_imm=0
    // ISET: T32
    // Fields: sh=0, Rd=0, imm2=3, sat_imm=0, imm3=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF38000C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_USAT_T1_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sat_imm=0 (minimum value)
#[test]
fn test_aarch32_usat_t1_a_combo_13_0_f3800000() {
    // Thumb encoding (32): 0xF3800000
    // Test aarch32_USAT_T1_A field combination: sh=0, Rn=0, imm3=0, Rd=0, imm2=0, sat_imm=0
    // ISET: T32
    // Fields: Rd=0, sh=0, imm3=0, imm2=0, Rn=0, sat_imm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_USAT_T1_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sat_imm=1 (value 1)
#[test]
fn test_aarch32_usat_t1_a_combo_14_0_f3800001() {
    // Thumb encoding (32): 0xF3800001
    // Test aarch32_USAT_T1_A field combination: sh=0, Rn=0, imm3=0, Rd=0, imm2=0, sat_imm=1
    // ISET: T32
    // Fields: Rn=0, Rd=0, sat_imm=1, sh=0, imm3=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3800001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_USAT_T1_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sat_imm=15 (midpoint (15))
#[test]
fn test_aarch32_usat_t1_a_combo_15_0_f380000f() {
    // Thumb encoding (32): 0xF380000F
    // Test aarch32_USAT_T1_A field combination: sh=0, Rn=0, imm3=0, Rd=0, imm2=0, sat_imm=15
    // ISET: T32
    // Fields: imm2=0, Rd=0, imm3=0, Rn=0, sat_imm=15, sh=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF380000F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_USAT_T1_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sat_imm=31 (maximum value (31))
#[test]
fn test_aarch32_usat_t1_a_combo_16_0_f380001f() {
    // Thumb encoding (32): 0xF380001F
    // Test aarch32_USAT_T1_A field combination: sh=0, Rn=0, imm3=0, Rd=0, imm2=0, sat_imm=31
    // ISET: T32
    // Fields: imm2=0, sh=0, imm3=0, Rd=0, Rn=0, sat_imm=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF380001F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_USAT_T1_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch32_usat_t1_a_combo_17_0_f3810100() {
    // Thumb encoding (32): 0xF3810100
    // Test aarch32_USAT_T1_A field combination: sh=0, Rn=1, imm3=0, Rd=1, imm2=0, sat_imm=0
    // ISET: T32
    // Fields: sat_imm=0, Rd=1, sh=0, imm3=0, imm2=0, Rn=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3810100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_USAT_T1_A
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch32_usat_t1_a_combo_18_0_f38f0f00() {
    // Thumb encoding (32): 0xF38F0F00
    // Test aarch32_USAT_T1_A field combination: sh=0, Rn=31, imm3=0, Rd=31, imm2=0, sat_imm=0
    // ISET: T32
    // Fields: imm3=0, sh=0, Rn=31, imm2=0, sat_imm=0, Rd=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF38F0F00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_USAT_T1_A
/// ASL: `field sh = 0 (Shift type LSL)`
/// Requirement: FieldSpecial { field: "sh", value: 0, meaning: "Shift type LSL" }
/// Shift type LSL
#[test]
fn test_aarch32_usat_t1_a_special_sh_0_shift_type_lsl_0_f3800000() {
    // Thumb encoding (32): 0xF3800000
    // Test aarch32_USAT_T1_A special value sh = 0 (Shift type LSL)
    // ISET: T32
    // Fields: imm3=0, sat_imm=0, imm2=0, Rn=0, Rd=0, sh=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_USAT_T1_A
/// ASL: `field sh = 1 (Shift type LSR)`
/// Requirement: FieldSpecial { field: "sh", value: 1, meaning: "Shift type LSR" }
/// Shift type LSR
#[test]
fn test_aarch32_usat_t1_a_special_sh_1_shift_type_lsr_0_f3a00000() {
    // Thumb encoding (32): 0xF3A00000
    // Test aarch32_USAT_T1_A special value sh = 1 (Shift type LSR)
    // ISET: T32
    // Fields: imm2=0, imm3=0, sh=1, Rn=0, Rd=0, sat_imm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_USAT_T1_A
/// ASL: `field sh = 2 (Shift type ASR)`
/// Requirement: FieldSpecial { field: "sh", value: 2, meaning: "Shift type ASR" }
/// Shift type ASR
#[test]
fn test_aarch32_usat_t1_a_special_sh_2_shift_type_asr_0_f3800000() {
    // Thumb encoding (32): 0xF3800000
    // Test aarch32_USAT_T1_A special value sh = 2 (Shift type ASR)
    // ISET: T32
    // Fields: imm2=0, Rn=0, Rd=0, sh=2, sat_imm=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_USAT_T1_A
/// ASL: `field sh = 3 (Shift type ROR)`
/// Requirement: FieldSpecial { field: "sh", value: 3, meaning: "Shift type ROR" }
/// Shift type ROR
#[test]
fn test_aarch32_usat_t1_a_special_sh_3_shift_type_ror_0_f3a00000() {
    // Thumb encoding (32): 0xF3A00000
    // Test aarch32_USAT_T1_A special value sh = 3 (Shift type ROR)
    // ISET: T32
    // Fields: sh=3, Rd=0, sat_imm=0, Rn=0, imm3=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_USAT_T1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_usat_t1_a_invalid_0_0_f3800000() {
    // Thumb encoding (32): 0xF3800000
    // Test aarch32_USAT_T1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }
    // ISET: T32
    // Fields: imm3=0, sh=0, Rd=0, imm2=0, sat_imm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3800000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_USAT_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_usat_t1_a_invalid_1_0_f3800000() {
    // Thumb encoding (32): 0xF3800000
    // Test aarch32_USAT_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: sat_imm=0, sh=0, imm3=0, imm2=0, Rn=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF3800000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

// ============================================================================
// aarch32_REV16_A Tests
// ============================================================================

/// Provenance: aarch32_REV16_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_rev16_a1_a_field_cond_0_min_b0_06b000b0() {
    // Encoding: 0x06B000B0
    // Test aarch32_REV16_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, cond=0, Rd=0
    let encoding: u32 = 0x06B000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV16_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_rev16_a1_a_field_cond_1_poweroftwo_b0_16b000b0() {
    // Encoding: 0x16B000B0
    // Test aarch32_REV16_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rm=0, cond=1
    let encoding: u32 = 0x16B000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV16_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_rev16_a1_a_field_cond_2_poweroftwo_b0_26b000b0() {
    // Encoding: 0x26B000B0
    // Test aarch32_REV16_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, cond=2, Rd=0
    let encoding: u32 = 0x26B000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV16_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_rev16_a1_a_field_cond_3_poweroftwo_b0_36b000b0() {
    // Encoding: 0x36B000B0
    // Test aarch32_REV16_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, cond=3, Rd=0
    let encoding: u32 = 0x36B000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV16_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_rev16_a1_a_field_cond_4_poweroftwo_b0_46b000b0() {
    // Encoding: 0x46B000B0
    // Test aarch32_REV16_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=4, Rm=0, Rd=0
    let encoding: u32 = 0x46B000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV16_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_rev16_a1_a_field_cond_5_poweroftwo_b0_56b000b0() {
    // Encoding: 0x56B000B0
    // Test aarch32_REV16_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, cond=5, Rd=0
    let encoding: u32 = 0x56B000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV16_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_rev16_a1_a_field_cond_6_poweroftwo_b0_66b000b0() {
    // Encoding: 0x66B000B0
    // Test aarch32_REV16_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rm=0, cond=6
    let encoding: u32 = 0x66B000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV16_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_rev16_a1_a_field_cond_7_poweroftwo_b0_76b000b0() {
    // Encoding: 0x76B000B0
    // Test aarch32_REV16_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rm=0, cond=7
    let encoding: u32 = 0x76B000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV16_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_rev16_a1_a_field_cond_8_poweroftwo_b0_86b000b0() {
    // Encoding: 0x86B000B0
    // Test aarch32_REV16_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=8, Rm=0, Rd=0
    let encoding: u32 = 0x86B000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV16_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_rev16_a1_a_field_cond_9_poweroftwo_b0_96b000b0() {
    // Encoding: 0x96B000B0
    // Test aarch32_REV16_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rm=0, cond=9
    let encoding: u32 = 0x96B000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV16_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_rev16_a1_a_field_cond_10_poweroftwo_b0_a6b000b0() {
    // Encoding: 0xA6B000B0
    // Test aarch32_REV16_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=10, Rm=0, Rd=0
    let encoding: u32 = 0xA6B000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV16_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_rev16_a1_a_field_cond_11_poweroftwo_b0_b6b000b0() {
    // Encoding: 0xB6B000B0
    // Test aarch32_REV16_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=11, Rd=0, Rm=0
    let encoding: u32 = 0xB6B000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV16_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_rev16_a1_a_field_cond_12_poweroftwo_b0_c6b000b0() {
    // Encoding: 0xC6B000B0
    // Test aarch32_REV16_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, cond=12, Rd=0
    let encoding: u32 = 0xC6B000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV16_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_rev16_a1_a_field_cond_13_poweroftwo_b0_d6b000b0() {
    // Encoding: 0xD6B000B0
    // Test aarch32_REV16_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Rd=0, cond=13
    let encoding: u32 = 0xD6B000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV16_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_rev16_a1_a_field_cond_14_poweroftwo_b0_e6b000b0() {
    // Encoding: 0xE6B000B0
    // Test aarch32_REV16_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, cond=14, Rm=0
    let encoding: u32 = 0xE6B000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV16_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_rev16_a1_a_field_cond_15_max_b0_f6b000b0() {
    // Encoding: 0xF6B000B0
    // Test aarch32_REV16_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: Rd=0, Rm=0, cond=15
    let encoding: u32 = 0xF6B000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV16_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_rev16_a1_a_field_rd_0_min_b0_06b000b0() {
    // Encoding: 0x06B000B0
    // Test aarch32_REV16_A1_A field Rd = 0 (Min)
    // ISET: A32
    // Fields: Rd=0, Rm=0, cond=0
    let encoding: u32 = 0x06B000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV16_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_rev16_a1_a_field_rd_1_poweroftwo_b0_06b010b0() {
    // Encoding: 0x06B010B0
    // Test aarch32_REV16_A1_A field Rd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Rd=1, Rm=0
    let encoding: u32 = 0x06B010B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV16_A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_rev16_a1_a_field_rm_0_min_b0_06b000b0() {
    // Encoding: 0x06B000B0
    // Test aarch32_REV16_A1_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, cond=0, Rd=0
    let encoding: u32 = 0x06B000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV16_A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_rev16_a1_a_field_rm_1_poweroftwo_b0_06b000b1() {
    // Encoding: 0x06B000B1
    // Test aarch32_REV16_A1_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Rm=1, Rd=0
    let encoding: u32 = 0x06B000B1;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV16_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_rev16_a1_a_combo_0_b0_06b000b0() {
    // Encoding: 0x06B000B0
    // Test aarch32_REV16_A1_A field combination: cond=0, Rd=0, Rm=0
    // ISET: A32
    // Fields: Rd=0, cond=0, Rm=0
    let encoding: u32 = 0x06B000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV16_A1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=1 (condition NE (not equal))
#[test]
fn test_aarch32_rev16_a1_a_combo_1_b0_16b000b0() {
    // Encoding: 0x16B000B0
    // Test aarch32_REV16_A1_A field combination: cond=1, Rd=0, Rm=0
    // ISET: A32
    // Fields: Rd=0, Rm=0, cond=1
    let encoding: u32 = 0x16B000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV16_A1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=2 (condition CS/HS (carry set))
#[test]
fn test_aarch32_rev16_a1_a_combo_2_b0_26b000b0() {
    // Encoding: 0x26B000B0
    // Test aarch32_REV16_A1_A field combination: cond=2, Rd=0, Rm=0
    // ISET: A32
    // Fields: cond=2, Rd=0, Rm=0
    let encoding: u32 = 0x26B000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV16_A1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=3 (condition CC/LO (carry clear))
#[test]
fn test_aarch32_rev16_a1_a_combo_3_b0_36b000b0() {
    // Encoding: 0x36B000B0
    // Test aarch32_REV16_A1_A field combination: cond=3, Rd=0, Rm=0
    // ISET: A32
    // Fields: cond=3, Rd=0, Rm=0
    let encoding: u32 = 0x36B000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV16_A1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=4 (condition MI (minus/negative))
#[test]
fn test_aarch32_rev16_a1_a_combo_4_b0_46b000b0() {
    // Encoding: 0x46B000B0
    // Test aarch32_REV16_A1_A field combination: cond=4, Rd=0, Rm=0
    // ISET: A32
    // Fields: cond=4, Rm=0, Rd=0
    let encoding: u32 = 0x46B000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV16_A1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=5 (condition PL (plus/positive))
#[test]
fn test_aarch32_rev16_a1_a_combo_5_b0_56b000b0() {
    // Encoding: 0x56B000B0
    // Test aarch32_REV16_A1_A field combination: cond=5, Rd=0, Rm=0
    // ISET: A32
    // Fields: Rd=0, Rm=0, cond=5
    let encoding: u32 = 0x56B000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV16_A1_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=6 (condition VS (overflow set))
#[test]
fn test_aarch32_rev16_a1_a_combo_6_b0_66b000b0() {
    // Encoding: 0x66B000B0
    // Test aarch32_REV16_A1_A field combination: cond=6, Rd=0, Rm=0
    // ISET: A32
    // Fields: Rm=0, cond=6, Rd=0
    let encoding: u32 = 0x66B000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV16_A1_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=7 (condition VC (overflow clear))
#[test]
fn test_aarch32_rev16_a1_a_combo_7_b0_76b000b0() {
    // Encoding: 0x76B000B0
    // Test aarch32_REV16_A1_A field combination: cond=7, Rd=0, Rm=0
    // ISET: A32
    // Fields: Rd=0, Rm=0, cond=7
    let encoding: u32 = 0x76B000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV16_A1_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=8 (condition HI (unsigned higher))
#[test]
fn test_aarch32_rev16_a1_a_combo_8_b0_86b000b0() {
    // Encoding: 0x86B000B0
    // Test aarch32_REV16_A1_A field combination: cond=8, Rd=0, Rm=0
    // ISET: A32
    // Fields: cond=8, Rm=0, Rd=0
    let encoding: u32 = 0x86B000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV16_A1_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=9 (condition LS (unsigned lower or same))
#[test]
fn test_aarch32_rev16_a1_a_combo_9_b0_96b000b0() {
    // Encoding: 0x96B000B0
    // Test aarch32_REV16_A1_A field combination: cond=9, Rd=0, Rm=0
    // ISET: A32
    // Fields: cond=9, Rm=0, Rd=0
    let encoding: u32 = 0x96B000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV16_A1_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=10 (condition GE (signed >=))
#[test]
fn test_aarch32_rev16_a1_a_combo_10_b0_a6b000b0() {
    // Encoding: 0xA6B000B0
    // Test aarch32_REV16_A1_A field combination: cond=10, Rd=0, Rm=0
    // ISET: A32
    // Fields: Rd=0, cond=10, Rm=0
    let encoding: u32 = 0xA6B000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV16_A1_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=11 (condition LT (signed <))
#[test]
fn test_aarch32_rev16_a1_a_combo_11_b0_b6b000b0() {
    // Encoding: 0xB6B000B0
    // Test aarch32_REV16_A1_A field combination: cond=11, Rd=0, Rm=0
    // ISET: A32
    // Fields: Rm=0, Rd=0, cond=11
    let encoding: u32 = 0xB6B000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV16_A1_A
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=12 (condition GT (signed >))
#[test]
fn test_aarch32_rev16_a1_a_combo_12_b0_c6b000b0() {
    // Encoding: 0xC6B000B0
    // Test aarch32_REV16_A1_A field combination: cond=12, Rd=0, Rm=0
    // ISET: A32
    // Fields: Rm=0, cond=12, Rd=0
    let encoding: u32 = 0xC6B000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV16_A1_A
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=13 (condition LE (signed <=))
#[test]
fn test_aarch32_rev16_a1_a_combo_13_b0_d6b000b0() {
    // Encoding: 0xD6B000B0
    // Test aarch32_REV16_A1_A field combination: cond=13, Rd=0, Rm=0
    // ISET: A32
    // Fields: Rd=0, cond=13, Rm=0
    let encoding: u32 = 0xD6B000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV16_A1_A
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=14 (condition AL (always))
#[test]
fn test_aarch32_rev16_a1_a_combo_14_b0_e6b000b0() {
    // Encoding: 0xE6B000B0
    // Test aarch32_REV16_A1_A field combination: cond=14, Rd=0, Rm=0
    // ISET: A32
    // Fields: cond=14, Rd=0, Rm=0
    let encoding: u32 = 0xE6B000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV16_A1_A
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=15 (condition NV (never, reserved))
#[test]
fn test_aarch32_rev16_a1_a_combo_15_b0_f6b000b0() {
    // Encoding: 0xF6B000B0
    // Test aarch32_REV16_A1_A field combination: cond=15, Rd=0, Rm=0
    // ISET: A32
    // Fields: Rm=0, cond=15, Rd=0
    let encoding: u32 = 0xF6B000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV16_A1_A
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch32_rev16_a1_a_combo_16_b0_06b000b0() {
    // Encoding: 0x06B000B0
    // Test aarch32_REV16_A1_A field combination: cond=0, Rd=0, Rm=0
    // ISET: A32
    // Fields: cond=0, Rd=0, Rm=0
    let encoding: u32 = 0x06B000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV16_A1_A
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch32_rev16_a1_a_combo_17_b0_06b010b0() {
    // Encoding: 0x06B010B0
    // Test aarch32_REV16_A1_A field combination: cond=0, Rd=1, Rm=0
    // ISET: A32
    // Fields: cond=0, Rd=1, Rm=0
    let encoding: u32 = 0x06B010B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV16_A1_A
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch32_rev16_a1_a_combo_18_b0_06b000b0() {
    // Encoding: 0x06B000B0
    // Test aarch32_REV16_A1_A field combination: cond=0, Rd=0, Rm=0
    // ISET: A32
    // Fields: Rd=0, Rm=0, cond=0
    let encoding: u32 = 0x06B000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV16_A1_A
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_aarch32_rev16_a1_a_combo_19_b0_06b000b1() {
    // Encoding: 0x06B000B1
    // Test aarch32_REV16_A1_A field combination: cond=0, Rd=0, Rm=1
    // ISET: A32
    // Fields: cond=0, Rm=1, Rd=0
    let encoding: u32 = 0x06B000B1;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV16_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_rev16_a1_a_special_cond_0_condition_eq_176_06b000b0() {
    // Encoding: 0x06B000B0
    // Test aarch32_REV16_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: Rm=0, Rd=0, cond=0
    let encoding: u32 = 0x06B000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV16_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_rev16_a1_a_special_cond_1_condition_ne_176_16b000b0() {
    // Encoding: 0x16B000B0
    // Test aarch32_REV16_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: cond=1, Rd=0, Rm=0
    let encoding: u32 = 0x16B000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV16_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_rev16_a1_a_special_cond_2_condition_cs_hs_176_26b000b0() {
    // Encoding: 0x26B000B0
    // Test aarch32_REV16_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: cond=2, Rd=0, Rm=0
    let encoding: u32 = 0x26B000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV16_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_rev16_a1_a_special_cond_3_condition_cc_lo_176_36b000b0() {
    // Encoding: 0x36B000B0
    // Test aarch32_REV16_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: cond=3, Rd=0, Rm=0
    let encoding: u32 = 0x36B000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV16_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_rev16_a1_a_special_cond_4_condition_mi_176_46b000b0() {
    // Encoding: 0x46B000B0
    // Test aarch32_REV16_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: Rm=0, Rd=0, cond=4
    let encoding: u32 = 0x46B000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV16_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_rev16_a1_a_special_cond_5_condition_pl_176_56b000b0() {
    // Encoding: 0x56B000B0
    // Test aarch32_REV16_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: cond=5, Rd=0, Rm=0
    let encoding: u32 = 0x56B000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV16_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_rev16_a1_a_special_cond_6_condition_vs_176_66b000b0() {
    // Encoding: 0x66B000B0
    // Test aarch32_REV16_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: Rd=0, Rm=0, cond=6
    let encoding: u32 = 0x66B000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV16_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_rev16_a1_a_special_cond_7_condition_vc_176_76b000b0() {
    // Encoding: 0x76B000B0
    // Test aarch32_REV16_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: Rd=0, cond=7, Rm=0
    let encoding: u32 = 0x76B000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV16_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_rev16_a1_a_special_cond_8_condition_hi_176_86b000b0() {
    // Encoding: 0x86B000B0
    // Test aarch32_REV16_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: Rm=0, Rd=0, cond=8
    let encoding: u32 = 0x86B000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV16_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_rev16_a1_a_special_cond_9_condition_ls_176_96b000b0() {
    // Encoding: 0x96B000B0
    // Test aarch32_REV16_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: Rm=0, cond=9, Rd=0
    let encoding: u32 = 0x96B000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV16_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_rev16_a1_a_special_cond_10_condition_ge_176_a6b000b0() {
    // Encoding: 0xA6B000B0
    // Test aarch32_REV16_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: Rd=0, cond=10, Rm=0
    let encoding: u32 = 0xA6B000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV16_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_rev16_a1_a_special_cond_11_condition_lt_176_b6b000b0() {
    // Encoding: 0xB6B000B0
    // Test aarch32_REV16_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: Rm=0, cond=11, Rd=0
    let encoding: u32 = 0xB6B000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV16_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_rev16_a1_a_special_cond_12_condition_gt_176_c6b000b0() {
    // Encoding: 0xC6B000B0
    // Test aarch32_REV16_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: Rd=0, cond=12, Rm=0
    let encoding: u32 = 0xC6B000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV16_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_rev16_a1_a_special_cond_13_condition_le_176_d6b000b0() {
    // Encoding: 0xD6B000B0
    // Test aarch32_REV16_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: Rd=0, cond=13, Rm=0
    let encoding: u32 = 0xD6B000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV16_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_rev16_a1_a_special_cond_14_condition_al_176_e6b000b0() {
    // Encoding: 0xE6B000B0
    // Test aarch32_REV16_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: Rm=0, cond=14, Rd=0
    let encoding: u32 = 0xE6B000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV16_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_rev16_a1_a_special_cond_15_condition_nv_176_f6b000b0() {
    // Encoding: 0xF6B000B0
    // Test aarch32_REV16_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: Rm=0, cond=15, Rd=0
    let encoding: u32 = 0xF6B000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "A32 instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch32_REV16_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_rev16_a1_a_invalid_0_b0_06b000b0() {
    // Encoding: 0x06B000B0
    // Test aarch32_REV16_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }
    // ISET: A32
    // Fields: cond=0, Rd=0, Rm=0
    let encoding: u32 = 0x06B000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_REV16_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_rev16_a1_a_invalid_1_b0_06b000b0() {
    // Encoding: 0x06B000B0
    // Test aarch32_REV16_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Rd=0, Rm=0, cond=0
    let encoding: u32 = 0x06B000B0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_REV16_T1_A
/// ASL: `field Rm 19 +: 3`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_rev16_t1_a_field_rm_0_min_0_ba400000() {
    // Thumb encoding (32): 0xBA400000
    // Test aarch32_REV16_T1_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: Rm=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xBA400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_REV16_T1_A
/// ASL: `field Rm 19 +: 3`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_rev16_t1_a_field_rm_1_poweroftwo_0_ba480000() {
    // Thumb encoding (32): 0xBA480000
    // Test aarch32_REV16_T1_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rd=0, Rm=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xBA480000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_REV16_T1_A
/// ASL: `field Rd 16 +: 3`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_rev16_t1_a_field_rd_0_min_0_ba400000() {
    // Thumb encoding (32): 0xBA400000
    // Test aarch32_REV16_T1_A field Rd = 0 (Min)
    // ISET: T32
    // Fields: Rd=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xBA400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_REV16_T1_A
/// ASL: `field Rd 16 +: 3`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_rev16_t1_a_field_rd_1_poweroftwo_0_ba410000() {
    // Thumb encoding (32): 0xBA410000
    // Test aarch32_REV16_T1_A field Rd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=0, Rd=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xBA410000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_REV16_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch32_rev16_t1_a_combo_0_0_ba400000() {
    // Thumb encoding (32): 0xBA400000
    // Test aarch32_REV16_T1_A field combination: Rm=0, Rd=0
    // ISET: T32
    // Fields: Rd=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xBA400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_REV16_T1_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_aarch32_rev16_t1_a_combo_1_0_ba480000() {
    // Thumb encoding (32): 0xBA480000
    // Test aarch32_REV16_T1_A field combination: Rm=1, Rd=0
    // ISET: T32
    // Fields: Rm=1, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xBA480000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_REV16_T1_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch32_rev16_t1_a_combo_2_0_ba400000() {
    // Thumb encoding (32): 0xBA400000
    // Test aarch32_REV16_T1_A field combination: Rm=0, Rd=0
    // ISET: T32
    // Fields: Rd=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xBA400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_REV16_T1_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch32_rev16_t1_a_combo_3_0_ba410000() {
    // Thumb encoding (32): 0xBA410000
    // Test aarch32_REV16_T1_A field combination: Rm=0, Rd=1
    // ISET: T32
    // Fields: Rm=0, Rd=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xBA410000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_REV16_T1_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch32_rev16_t1_a_combo_4_0_ba490000() {
    // Thumb encoding (32): 0xBA490000
    // Test aarch32_REV16_T1_A field combination: Rm=1, Rd=1
    // ISET: T32
    // Fields: Rm=1, Rd=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xBA490000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_REV16_T1_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch32_rev16_t1_a_combo_5_0_ba7f0000() {
    // Thumb encoding (32): 0xBA7F0000
    // Test aarch32_REV16_T1_A field combination: Rm=31, Rd=31
    // ISET: T32
    // Fields: Rd=31, Rm=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xBA7F0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_REV16_T2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_rev16_t2_a_field_rn_0_min_f090_fa90f090() {
    // Thumb encoding (32): 0xFA90F090
    // Test aarch32_REV16_T2_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rm=0, Rd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFA90F090;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_REV16_T2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_rev16_t2_a_field_rn_1_poweroftwo_f090_fa91f090() {
    // Thumb encoding (32): 0xFA91F090
    // Test aarch32_REV16_T2_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=0, Rd=0, Rn=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFA91F090;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_REV16_T2_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_rev16_t2_a_field_rd_0_min_f090_fa90f090() {
    // Thumb encoding (32): 0xFA90F090
    // Test aarch32_REV16_T2_A field Rd = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rm=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFA90F090;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_REV16_T2_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_rev16_t2_a_field_rd_1_poweroftwo_f090_fa90f190() {
    // Thumb encoding (32): 0xFA90F190
    // Test aarch32_REV16_T2_A field Rd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Rm=0, Rd=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFA90F190;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_REV16_T2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_rev16_t2_a_field_rm_0_min_f090_fa90f090() {
    // Thumb encoding (32): 0xFA90F090
    // Test aarch32_REV16_T2_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: Rm=0, Rn=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFA90F090;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_REV16_T2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_rev16_t2_a_field_rm_1_poweroftwo_f090_fa90f091() {
    // Thumb encoding (32): 0xFA90F091
    // Test aarch32_REV16_T2_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rd=0, Rn=0, Rm=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFA90F091;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_REV16_T2_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_rev16_t2_a_combo_0_f090_fa90f090() {
    // Thumb encoding (32): 0xFA90F090
    // Test aarch32_REV16_T2_A field combination: Rn=0, Rd=0, Rm=0
    // ISET: T32
    // Fields: Rd=0, Rn=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFA90F090;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_REV16_T2_A
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch32_rev16_t2_a_combo_1_f090_fa91f090() {
    // Thumb encoding (32): 0xFA91F090
    // Test aarch32_REV16_T2_A field combination: Rn=1, Rd=0, Rm=0
    // ISET: T32
    // Fields: Rm=0, Rn=1, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFA91F090;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_REV16_T2_A
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch32_rev16_t2_a_combo_2_f090_fa90f090() {
    // Thumb encoding (32): 0xFA90F090
    // Test aarch32_REV16_T2_A field combination: Rn=0, Rd=0, Rm=0
    // ISET: T32
    // Fields: Rd=0, Rm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFA90F090;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_REV16_T2_A
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch32_rev16_t2_a_combo_3_f090_fa90f190() {
    // Thumb encoding (32): 0xFA90F190
    // Test aarch32_REV16_T2_A field combination: Rn=0, Rd=1, Rm=0
    // ISET: T32
    // Fields: Rn=0, Rd=1, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFA90F190;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_REV16_T2_A
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch32_rev16_t2_a_combo_4_f090_fa90f090() {
    // Thumb encoding (32): 0xFA90F090
    // Test aarch32_REV16_T2_A field combination: Rn=0, Rd=0, Rm=0
    // ISET: T32
    // Fields: Rn=0, Rd=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFA90F090;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_REV16_T2_A
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_aarch32_rev16_t2_a_combo_5_f090_fa90f091() {
    // Thumb encoding (32): 0xFA90F091
    // Test aarch32_REV16_T2_A field combination: Rn=0, Rd=0, Rm=1
    // ISET: T32
    // Fields: Rd=0, Rm=1, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFA90F091;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_REV16_T2_A
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch32_rev16_t2_a_combo_6_f090_fa91f190() {
    // Thumb encoding (32): 0xFA91F190
    // Test aarch32_REV16_T2_A field combination: Rn=1, Rd=1, Rm=0
    // ISET: T32
    // Fields: Rd=1, Rm=0, Rn=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFA91F190;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_REV16_T2_A
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch32_rev16_t2_a_combo_7_f090_fa9fff90() {
    // Thumb encoding (32): 0xFA9FFF90
    // Test aarch32_REV16_T2_A field combination: Rn=31, Rd=31, Rm=0
    // ISET: T32
    // Fields: Rd=31, Rm=0, Rn=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFA9FFF90;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_REV16_T2_A
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rm=1 (same register test (reg=1))
#[test]
fn test_aarch32_rev16_t2_a_combo_8_f090_fa91f091() {
    // Thumb encoding (32): 0xFA91F091
    // Test aarch32_REV16_T2_A field combination: Rn=1, Rd=0, Rm=1
    // ISET: T32
    // Fields: Rd=0, Rn=1, Rm=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFA91F091;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_REV16_T2_A
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rm=31 (same register test (reg=31))
#[test]
fn test_aarch32_rev16_t2_a_combo_9_f090_fa9ff09f() {
    // Thumb encoding (32): 0xFA9FF09F
    // Test aarch32_REV16_T2_A field combination: Rn=31, Rd=0, Rm=31
    // ISET: T32
    // Fields: Rd=0, Rn=31, Rm=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFA9FF09F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_REV16_T2_A
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (same register test (reg=1)), Rm=1 (same register test (reg=1))
#[test]
fn test_aarch32_rev16_t2_a_combo_10_f090_fa90f191() {
    // Thumb encoding (32): 0xFA90F191
    // Test aarch32_REV16_T2_A field combination: Rn=0, Rd=1, Rm=1
    // ISET: T32
    // Fields: Rn=0, Rd=1, Rm=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFA90F191;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_REV16_T2_A
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=31 (same register test (reg=31)), Rm=31 (same register test (reg=31))
#[test]
fn test_aarch32_rev16_t2_a_combo_11_f090_fa90ff9f() {
    // Thumb encoding (32): 0xFA90FF9F
    // Test aarch32_REV16_T2_A field combination: Rn=0, Rd=31, Rm=31
    // ISET: T32
    // Fields: Rm=31, Rn=0, Rd=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFA90FF9F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "T32 instruction should execute successfully");
}

/// Provenance: aarch32_REV16_T2_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }), rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }), rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_rev16_t2_a_invalid_0_f090_fa90f090() {
    // Thumb encoding (32): 0xFA90F090
    // Test aarch32_REV16_T2_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }), rhs: Binary { op: Or, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }
    // ISET: T32
    // Fields: Rm=0, Rn=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFA90F090;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_REV16_T2_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_rev16_t2_a_invalid_1_f090_fa90f090() {
    // Thumb encoding (32): 0xFA90F090
    // Test aarch32_REV16_T2_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rn=0, Rd=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFA90F090;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_REV16_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 0 (32)
#[test]
fn test_aarch32_rev16_t1_a_lslv_oracle_32_0_ba420020() {
    // Test LSLV 32-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x12345678, "W0 should be 0x12345678");
}

/// Provenance: aarch32_REV16_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 0 (64)
#[test]
fn test_aarch32_rev16_t1_a_lslv_oracle_64_0_ba420020() {
    // Test LSLV 64-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x12345678, "X0 should be 0x0000000012345678");
}

/// Provenance: aarch32_REV16_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4 (32)
#[test]
fn test_aarch32_rev16_t1_a_lslv_oracle_32_1_ba420020() {
    // Test LSLV 32-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x4);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x23456780, "W0 should be 0x23456780");
}

/// Provenance: aarch32_REV16_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 4 (64)
#[test]
fn test_aarch32_rev16_t1_a_lslv_oracle_64_1_ba420020() {
    // Test LSLV 64-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x4);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x23456780, "X0 should be 0x0000000123456780");
}

/// Provenance: aarch32_REV16_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 8 (32)
#[test]
fn test_aarch32_rev16_t1_a_lslv_oracle_32_2_ba420020() {
    // Test LSLV 32-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x8);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x34567800, "W0 should be 0x34567800");
}

/// Provenance: aarch32_REV16_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 8 (64)
#[test]
fn test_aarch32_rev16_t1_a_lslv_oracle_64_2_ba420020() {
    // Test LSLV 64-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x8);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x34567800, "X0 should be 0x0000001234567800");
}

/// Provenance: aarch32_REV16_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1 (32)
#[test]
fn test_aarch32_rev16_t1_a_lslv_oracle_32_3_ba420020() {
    // Test LSLV 32-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_REV16_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// MSB set, shift 1 (64)
#[test]
fn test_aarch32_rev16_t1_a_lslv_oracle_64_3_ba420020() {
    // Test LSLV 64-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_REV16_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// LSB set, max shift (32)
#[test]
fn test_aarch32_rev16_t1_a_lslv_oracle_32_4_ba420020() {
    // Test LSLV 32-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x3F);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "W0 should be 0x80000000");
}

/// Provenance: aarch32_REV16_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// LSB set, max shift (64)
#[test]
fn test_aarch32_rev16_t1_a_lslv_oracle_64_4_ba420020() {
    // Test LSLV 64-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x3F);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x8000000000000000");
}

/// Provenance: aarch32_REV16_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// all ones, shift 32 (32)
#[test]
fn test_aarch32_rev16_t1_a_lslv_oracle_32_5_ba420020() {
    // Test LSLV 32-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x20);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "W0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_REV16_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// all ones, shift 32 (64)
#[test]
fn test_aarch32_rev16_t1_a_lslv_oracle_64_5_ba420020() {
    // Test LSLV 64-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x20);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0xFFFFFFFF00000000");
}

/// Provenance: aarch32_REV16_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// no shift
#[test]
fn test_aarch32_rev16_t1_a_t16_oracle_0_ba500000() {
    // Test T16 LSLS: no shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_REV16_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4
#[test]
fn test_aarch32_rev16_t1_a_t16_oracle_1_ba500000() {
    // Test T16 LSLS: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x4);
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF0, "R0 should be 0x00000FF0");
}

/// Provenance: aarch32_REV16_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1
#[test]
fn test_aarch32_rev16_t1_a_t16_oracle_2_ba500000() {
    // Test T16 LSLS: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_REV16_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift to MSB
#[test]
fn test_aarch32_rev16_t1_a_t16_oracle_3_ba500000() {
    // Test T16 LSLS: shift to MSB (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1F);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "R0 should be 0x80000000");
}

